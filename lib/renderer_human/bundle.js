require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({"/actions.js":[function(require,module,exports){
(function (__dirname){
const path = require('path') //eslint-disable-line
const s2clientprotocol = require('s2clientprotocol') //eslint-disable-line
const Enum = require('python-enum') //eslint-disable-line
const point = require(path.resolve(__dirname, './point.js'))
const pythonUtils = require(path.resolve(__dirname, './pythonUtils.js'))
const numpy = require(path.resolve(__dirname, './numpy.js'))

const { spatial_pb, ui_pb, common_pb } = s2clientprotocol
const sc_spatial = spatial_pb
const sc_ui = ui_pb
const { len, isinstance, isObject, namedtuple, ValueError, zip } = pythonUtils

const ActionSpace = Enum.IntEnum('ActionSpace', {
  FEATURES: 1, // Act in feature layer pixel space with FUNCTIONS below.
  RGB: 2, //      Act in RGB pixel space with FUNCTIONS below.
  RAW: 3, //      Act with unit tags with RAW_FUNCTIONS below.
})

function spatial(action, action_space) {
  // Choose the action space for the action proto.//
  if (action_space == ActionSpace.FEATURES) {
    return action.getActionFeatureLayer()
  }
  if (action_space == ActionSpace.RGB) {
    return action.getActionRender()
  }
  throw new ValueError(`Unexpected value for action_space: ${action_space}`);
}
function no_op(action = {}, action_space) {
  delete action[action_space]
}
function move_camera(action, action_space, minimap) {
  // Move the camera.//
  minimap.assign_to(spatial(action, action_space).getCameraMove().getCenterMinimap());
}
function select_point(action, action_space, select_point_act, screen) {
  const select = spatial(action, action_space).getUnitSelectionPoint()
  screen.assign_to(select.getSelectionScreenCoord())
  select.setType(select_point_act)
}
function select_rect(action, action_space, select_add, screen, screen2) {
  // Select units within a rectangle.//
  const select = spatial(action, action_space).getUnitSelectionRect()
  const out_rect = select.addSelectionScreenCoord(new common_pb.RectangleI())
  out_rect.setP0(new common_pb.PointI())
  out_rect.setP1(new common_pb.PointI())
  const screen_rect = new point.Rect(screen, screen2)
  screen_rect.tl.assign_to(out_rect.getP0())
  screen_rect.br.assign_to(out_rect.getP1())
  select.setSelectionAdd(Boolean(select_add))
}
function select_idle_worker(action, action_space, select_worker) {
  // Select an idle worker.//
  /* delete action_space has no equivalent in js */
  action.getActionUi().getSelectIdleWorker().setType(select_worker)
}

function select_army(action, action_space, select_add) {
  // Select the entire army.//
  /* delete action_space has no equivalent in js */
  action.getActionUi().getSelectArmy().setSelectionAdd(select_add)
}

function select_warp_gates(action, action_space, select_add) {
  // Select all warp gates.//
  /* delete action_space has no equivalent in js */
  action.getActionUi().getSelectWarpGates().setSelectionAdd(select_add)
}

function select_larva(action, /*action_space*/) {
  // Select all larva.//
  /* delete action_space has no equivalent in js */
  action.getActionUi().setSelectLarva(new ui_pb.ActionSelectLarva()) // Adds the empty proto field.
}

function select_unit(action, action_space, select_unit_act, select_unit_id) {
  // Select a specific unit from the multi-unit selection.//
  /* delete action_space has no equivalent in js */
  const select = action.getActionUi().getMultiPanel()
  select.setType(select_unit_act)
  select.setUnitIndex(select_unit_id)
}

function control_group(action, action_space, control_group_act, control_group_id) {
  // Act on a control group, selecting, setting, etc.//
  /* delete action_space has no equivalent in js */
  const select = action.getActionUi().getControlGroup()
  select.setAction(control_group_act)
  select.setControlGroupIndex(control_group_id)
}

function unload(action, action_space, unload_id) {
  // Unload a unit from a transport/bunker/nydus/etc.//
  /* delete action_space has no equivalent in js */
  action.getActionUi().getCargoPanel().setUnitIndex(unload_id)
}

function build_queue(action, action_space, build_queue_id) {
  // Cancel a unit in the build queue.//
  /* delete action_space has no equivalent in js */
  action.getActionUi().getProductionPanel().setUnitIndex(build_queue_id)
}

function cmd_quick(action, action_space, ability_id, queued) {
  // Do a quick command like 'Stop' or 'Stim'.//
  const action_cmd = spatial(action, action_space).getUnitCommand()
  action_cmd.setAbilityId(ability_id)
  action_cmd.setQueueCommand(queued)
}

function cmd_screen(action, action_space, ability_id, queued, screen) {
  // Do a command that needs a point on the screen.//
  const action_cmd = spatial(action, action_space).getUnitCommand()
  action_cmd.setAbilityId(ability_id)
  action_cmd.setQueueCommand(queued)
  screen.assign_to(action_cmd.getTargetScreenCoord())
}

function cmd_minimap(action, action_space, ability_id, queued, minimap) {
  // Do a command that needs a point on the minimap.//
  const action_cmd = spatial(action, action_space).getUnitCommand()
  action_cmd.setAbilityId(ability_id)
  action_cmd.setQueueCommand(queued)
  minimap.assign_to(action_cmd.getTargetMinimapCoord())
}

function autocast(action, action_space, ability_id) {
  // Toggle autocast.//
  /* delete action_space has no equivalent in js */
  action.getActionUi().getToggleAutocast().setAbilityId(ability_id)
}

function raw_no_op(/*action*/) {
  /* delete action has no equivalent in js */
}

function raw_move_camera(action, world) {
  // Move the camera.//
  const action_cmd = action.getActionRaw().getCameraMove()
  world.assign_to(action_cmd.center_world_space)
}

function raw_cmd(action, ability_id, queued, unit_tags) {
  // Do a raw command to another unit.//
  const action_cmd = action.getActionRaw().getUnitCommand()
  action_cmd.setAbilityId(ability_id)
  action_cmd.setQueueCommand(queued)
  if (isinstance(unit_tags, [Array])) {
    unit_tags.forEach((unit_tag) => {
      action_cmd.addUnitTags(unit_tag)
    })
  } else {
    action_cmd.addUnitTags(unit_tags)
  }
}

function raw_cmd_pt(action, ability_id, queued, unit_tags, world) {
  // Do a raw command to another unit towards a point.//
  const action_cmd = action.getActionRaw().getUnitCommand()
  action_cmd.setAbilityId(ability_id)
  action_cmd.setQueueCommand(queued)
  if (isinstance(unit_tags, [Array])) {
    unit_tags.forEach((unit_tag) => {
      action_cmd.addUnitTags(unit_tag)
    })
  } else {
    action_cmd.addUnitTags(unit_tags)
  }
  world.assign_to(action_cmd.getTargetWorldSpacePos())
}

function raw_cmd_unit(action, ability_id, queued, unit_tags,
  target_unit_tag) {
  // Do a raw command to another unit towards a unit.//
  const action_cmd = action.getActionRaw().getUnitCommand()
  action_cmd.setAbilityId(ability_id)
  action_cmd.setQueueCommand(queued)
  if (isinstance(unit_tags, [Array])) {
    unit_tags.forEach((unit_tag) => {
      action_cmd.addUnitTags(unit_tag)
    })
  } else {
    action_cmd.addUnitTags(unit_tags)
  }
  action_cmd.setTargetUnitTag(target_unit_tag)
}

function raw_autocast(action, ability_id, unit_tags) {
  // Toggle autocast.//
  const action_cmd = action.getActionRaw().getToggleAutocast()
  action_cmd.setAbilityId(ability_id)
  if (isinstance(unit_tags, [Array])) {
    unit_tags.forEach((unit_tag) => {
      action_cmd.addUnitTags(unit_tag)
    })
  } else {
    action_cmd.addUnitTags(unit_tags)
  }
}

function numpy_to_python(val) {
  // Convert numpy types to their corresponding python types.//
  if (isinstance(val, [Number, String, Boolean])) {
    return val
  }
  if (isinstance(val, numpy.TensorMeta)) {
    return val.arraySync() // handles any rank tensor
  }
  const result = [];
  if (isinstance(val, Array)) {
    val.forEach((ele) => {
      result.push(numpy_to_python(ele))
    })
    return result
  }
  const isPointLikeObj = (val && val.hasOwnProperty('x') && val.hasOwnProperty('y'))
  if (isinstance(val, point.Point) || isPointLikeObj) {
    result.push(numpy_to_python(val.x))
    result.push(numpy_to_python(val.y))
    return result
  }
  throw new ValueError(`Unknown value. Type:${typeof (val)}, repr: ${val}`)
}

class ArgumentType extends namedtuple("ArgumentType", ["id", "name", "sizes", "fn", "values", "count"]) {
  /*Represents a single argument type.

  Attributes:
    id: The argument id. This is unique.
    name: The name of the argument, also unique.
    sizes: The max+1 of each of the dimensions this argument takes.
    fn: The function to convert the list of integers into something more
        meaningful to be set in the protos to send to the game.
    values: An enum representing the values this argument type could hold. None
        if this isn't an enum argument type.
    count: Number of valid values. Only useful for unit_tags.
  */
  // constructor(kwargs) {
  //   super(kwargs);
  // }

  toString() {
    return `${this.id} / ${this.name} ${JSON.stringify(this.sizes)}`
  }

  static enum(options, values) {
    // Create an ArgumentType where you choose one of a set of known values.//
    const [names, real] = zip(...options)
    const self = this
    function factory(i, name) {
      return new self.prototype.constructor({
        id: i,
        name,
        sizes: [real.length],
        fn: (a) => real[Number(a[0])],
        values,
        count: null,
      })
    }
    return factory
  }

  static scalar(value) {
    // Create an ArgumentType with a single scalar in range(value).//
    const self = this
    return (i, name) => new self.prototype.constructor({
      id: i,
      name,
      sizes: [value],
      fn: (a) => a[0],
      values: null,
      count: null,
    })
  }

  static point() {
    // Create an ArgumentType that is represented by a point.Point.//
    const self = this;
    function factory(i, name) {
      return new self.prototype.constructor({
        id: i,
        name,
        sizes: [0, 0],
        fn: (a) => new point.Point(...a).floor(),
        values: null,
        count: null,
      })
    }
    return factory
  }

  static spec(id_, name, sizes) {
    // Create an ArgumentType to be used in ValidActions.//
    return new this.prototype.constructor({
      id: id_,
      name,
      sizes,
      fn: null,
      values: null,
      count: null,
    })
  }

  static unit_tags(count, size) {
    // Create an ArgumentType with a list of unbounded ints.//
    function clean(arg) {
      arg = numpy_to_python(arg)
      if (isinstance(arg, Array) && len(arg) === 1 && isinstance(arg[0], Array)) {
        arg = arg[0] // Support [[list, of, tags]].
      }
      return arg.slice(0, count)
    }

    return (i, name) => new this.prototype.constructor({
      id: i,
      name,
      sizes: [size],
      fn: clean,
      values: null,
      count,
    })
  }
}

class Arguments extends namedtuple("Arguments", ["screen", "minimap", "screen2", "queued", "control_group_act", "control_group_id", "select_point_act", "select_add", "select_unit_act", "select_unit_id", "select_worker", "build_queue_id", "unload_id"]) {
  /*The full list of argument types.

   Take a look at TYPES and FUNCTION_TYPES for more details.

   Attributes:
   screen: A point on the screen.
   minimap: A point on the minimap.
   screen2: The second point for a rectangle. This is needed so that no
      function takes the same type twice.
   queued: Whether the action should be done immediately or after all other
      actions queued for this unit.
   control_group_act: What to do with the control group.
   control_group_id: Which control group to do it with.
   select_point_act: What to do with the unit at the point.
   select_add: Whether to add the unit to the selection or replace it.
   select_unit_act: What to do when selecting a unit by id.
   select_unit_id: Which unit to select by id.
   select_worker: What to do when selecting a worker.
   build_queue_id: Which build queue index to target.
   unload_id: Which unit to target in a transport/nydus/command center.
  */
  constructor(kwargs) {
    if (Array.isArray(kwargs)) {
      super(...kwargs)
    } else {
      super(...arguments) //eslint-disable-line
    }
  }

  keys() {
    return this.constructor._fields
  }

  static types(kwargs) {
    const named = {}
    Object.keys(kwargs).forEach((name) => {
      const factory = kwargs[name]
      named[name] = factory(this._fields.indexOf(name), name)
    })
    return new this.prototype.constructor(named)
  }
}

class RawArguments extends namedtuple("RawArguments", ["world", "queued", "unit_tags", "target_unit_tag"]) {
  /*The full list of argument types.

  Take a look at TYPES and FUNCTION_TYPES for more details.

  Attributes:
  world: A point in world coordinates
  queued: Whether the action should be done immediately or after all other actions queued for this unit.
  unit_tags: Which units should execute this action.
  target_unit_tag: The target unit of this action.
  */
  constructor(kwargs) {
    if (Array.isArray(kwargs)) {
      super(...kwargs)
    } else {
      super(...arguments) //eslint-disable-line
    }
  }

  keys() {
    return this.constructor._fields
  }

  static types(kwargs) {
    const named = {}
    Object.keys(kwargs).forEach((name) => {
      const factory = kwargs[name]
      named[name] = factory(this._fields.indexOf(name), name)
    })
    return new this.prototype.constructor(named)
  }
}

function _define_position_based_enum(name, options) {
  const dict = {}
  options.forEach(([opt_name], i) => {
    dict[opt_name] = i
  })
  return Enum(name, dict)
}

const QUEUED_OPTIONS = [
  ["now", false],
  ["queued", true],
]

const Queued = _define_position_based_enum("Queued", QUEUED_OPTIONS)

const CONTROL_GROUP_ACT_OPTIONS = [
  ["recall", sc_ui.ActionControlGroup.ControlGroupAction.RECALL],
  ["set", sc_ui.ActionControlGroup.ControlGroupAction.SET],
  ["append", sc_ui.ActionControlGroup.ControlGroupAction.APPEND],
  ["set_and_steal", sc_ui.ActionControlGroup.ControlGroupAction.SETANDSTEAL],
  ["append_and_steal", sc_ui.ActionControlGroup.ControlGroupAction.APPENDANDSTEAL],
]

const ControlGroupAct = _define_position_based_enum(
  "ControlGroupAct", CONTROL_GROUP_ACT_OPTIONS
)

const SELECT_POINT_ACT_OPTIONS = [
  ["select", sc_spatial.ActionSpatialUnitSelectionPoint.Type.SELECT],
  ["toggle", sc_spatial.ActionSpatialUnitSelectionPoint.Type.TOGGLE],
  ["select_all_type", sc_spatial.ActionSpatialUnitSelectionPoint.Type.ALLTYPE],
  ["add_all_type", sc_spatial.ActionSpatialUnitSelectionPoint.Type.ADDALLTYPE],
]
const SelectPointAct = _define_position_based_enum(
  "SelectPointAct", SELECT_POINT_ACT_OPTIONS
)

const SELECT_ADD_OPTIONS = [
  ["select", false],
  ["add", true],
]
const SelectAdd = _define_position_based_enum(
  "SelectAdd", SELECT_ADD_OPTIONS
)

const SELECT_UNIT_ACT_OPTIONS = [
  ["select", sc_ui.ActionMultiPanel.Type.SINGLESELECT],
  ["deselect", sc_ui.ActionMultiPanel.Type.DESELECTUNIT],
  ["select_all_type", sc_ui.ActionMultiPanel.Type.SELECTALLOFTYPE],
  ["deselect_all_type", sc_ui.ActionMultiPanel.Type.DESELECTALLOFTYPE],
]
const SelectUnitAct = _define_position_based_enum(
  "SelectUnitAct", SELECT_UNIT_ACT_OPTIONS
)

const SELECT_WORKER_OPTIONS = [
  ["select", sc_ui.ActionSelectIdleWorker.Type.SET],
  ["add", sc_ui.ActionSelectIdleWorker.Type.ADD],
  ["select_all", sc_ui.ActionSelectIdleWorker.Type.ALL],
  ["add_all", sc_ui.ActionSelectIdleWorker.Type.ADDALL],
]
const SelectWorker = _define_position_based_enum(
  "SelectWorker", SELECT_WORKER_OPTIONS
)

//The list of known types.
const TYPES = Arguments.types({
  screen: ArgumentType.point(),
  minimap: ArgumentType.point(),
  screen2: ArgumentType.point(),
  queued: ArgumentType.enum(QUEUED_OPTIONS, Queued),
  control_group_act: ArgumentType.enum(
    CONTROL_GROUP_ACT_OPTIONS, ControlGroupAct
  ),
  control_group_id: ArgumentType.scalar(10),
  select_point_act: ArgumentType.enum(
    SELECT_POINT_ACT_OPTIONS, SelectPointAct
  ),
  select_add: ArgumentType.enum(SELECT_ADD_OPTIONS, SelectAdd),
  select_unit_act: ArgumentType.enum(SELECT_UNIT_ACT_OPTIONS, SelectUnitAct),
  select_unit_id: ArgumentType.scalar(500), // Depends on current selection.
  select_worker: ArgumentType.enum(SELECT_WORKER_OPTIONS, SelectWorker),
  build_queue_id: ArgumentType.scalar(10), // Depends on current build queue.
  unload_id: ArgumentType.scalar(500), // Depends on the current loaded units.
})

const RAW_TYPES = RawArguments.types({
  world: ArgumentType.point(),
  queued: ArgumentType.enum(QUEUED_OPTIONS, Queued),
  unit_tags: ArgumentType.unit_tags(512, 512),
  target_unit_tag: ArgumentType.unit_tags(1, 512),
})

// Which argument types do each function need?
const FUNCTION_TYPES = {
  no_op: [],
  move_camera: [TYPES.minimap],
  select_point: [TYPES.select_point_act, TYPES.screen],
  select_rect: [TYPES.select_add, TYPES.screen, TYPES.screen2],
  select_unit: [TYPES.select_unit_act, TYPES.select_unit_id],
  control_group: [TYPES.control_group_act, TYPES.control_group_id],
  select_idle_worker: [TYPES.select_worker],
  select_army: [TYPES.select_add],
  select_warp_gates: [TYPES.select_add],
  select_larva: [],
  unload: [TYPES.unload_id],
  build_queue: [TYPES.build_queue_id],
  cmd_quick: [TYPES.queued],
  cmd_screen: [TYPES.queued, TYPES.screen],
  cmd_minimap: [TYPES.queued, TYPES.minimap],
  autocast: [],
  raw_no_op: [],
  raw_cmd: [RAW_TYPES.queued, RAW_TYPES.unit_tags],
  raw_cmd_pt: [RAW_TYPES.queued, RAW_TYPES.unit_tags, RAW_TYPES.world],
  raw_cmd_unit: [RAW_TYPES.queued, RAW_TYPES.unit_tags,
    RAW_TYPES.target_unit_tag],
  raw_move_camera: [RAW_TYPES.world],
  raw_autocast: [RAW_TYPES.unit_tags],
}

// Which ones need an ability?
const ABILITY_FUNCTIONS = { cmd_quick, cmd_screen, cmd_minimap, autocast }
const RAW_ABILITY_FUNCTIONS = { raw_cmd, raw_cmd_pt, raw_cmd_unit, raw_autocast }

// Which ones require a point?
const POINT_REQUIRED_FUNCS = new Map()
POINT_REQUIRED_FUNCS.set(false, { cmd_quick, autocast })
POINT_REQUIRED_FUNCS.set(true, { cmd_screen, cmd_minimap, autocast })

const always = () => true

class Function extends namedtuple("Function", ["id", "name", "ability_id", "general_id", "function_type", "args", "avail_fn", "raw"]) {
  /*Represents a function action.

  Attributes:
    id: The function id, which is what the agent will use.
    name: The name of the function. Should be unique.
    ability_id: The ability id to pass to sc2.
    general_id: 0 for normal abilities, and the ability_id of another ability if
        it can be represented by a more general action.
    function_type: One of the functions in FUNCTION_TYPES for how to construct
        the sc2 action proto out of python types.
    args: A list of the types of args passed to function_type.
    avail_fn: For non-abilities, this function returns whether the function is
        valid.
    raw: Whether the function is raw or not.
  */
  constructor() {
    super(...arguments) //eslint-disable-line
    const func = this.__call__.bind(this)
    return this._getProxy(func)
  }
  // constructor(kwargs) {
  //   super(kwargs)
  //   const func = this.__call__.bind(this)
  //   return this._getProxy(func)
  // }

  _getProxy(thing) {
    const self = this
    return new Proxy(thing, {
      //eslint-disable-next-line
      get: (target, name) => {
        return self[name]
      },
    })
  }

  static ui_func(id_, name, function_type, avail_fn = always) {
    //Define a function representing a ui action.//
    return new this.prototype.constructor({
      id: id_,
      name,
      ability_id: 0,
      general_id: 0,
      function_type,
      args: FUNCTION_TYPES[function_type.name],
      avail_fn: (obs) => {
        if (!obs) {
          return false
        }
        return avail_fn(obs)
      },
      raw: false,
    })
  }

  static ability(id_, name, function_type, ability_id, general_id = 0) {
    //Define a function represented as a game ability.//
    // assert function_type in ABILITY_FUNCTIONS
    if (!ABILITY_FUNCTIONS[function_type.name]) {
      console.warn('ability: Unknown function type: ', JSON.stringify(function_type))
    }
    return new this.prototype.constructor({
      id: id_,
      name,
      ability_id,
      general_id,
      function_type,
      args: FUNCTION_TYPES[function_type.name],
      avail_fn: null,
      raw: false,
    })
  }

  static raw_ability(id_, name, function_type, ability_id, general_id = 0,
    avail_fn = always) {
    //Define a function represented as a game ability.//
    if (!RAW_ABILITY_FUNCTIONS[function_type.name]) {
      console.warn('raw_ability: Unknown function type: ', JSON.stringify(function_type))
    }
    return new this.prototype.constructor({
      id: id_,
      name,
      ability_id,
      general_id,
      function_type,
      args: FUNCTION_TYPES[function_type.name],
      avail_fn,
      raw: true,
    })
  }

  static raw_ui_func(id_, name, function_type, avail_fn = always) {
    //Define a function representing a ui action.//
    return new this.prototype.constructor({
      id: id_,
      name,
      ability_id: 0,
      general_id: 0,
      function_type,
      args: FUNCTION_TYPES[function_type.name],
      avail_fn,
      raw: true,
    })
  }

  static spec(id_, name, args) {
    //Create a Function to be used in ValidActions.//
    return new this.prototype.constructor({
      id: id_,
      name,
      ability_id: null,
      general_id: null,
      function_type: null,
      args,
      avail_fn: null,
      raw: false,
    })
  }

  __hash__() { // So it can go in a set().
    return this.id
  }

  __call__() {
    //A convenient way to create a FunctionCall from this Function.//
    return FunctionCall.init_with_validation( //eslint-disable-line
      this.id,
      arguments, //eslint-disable-line
      this.raw,
    )
  }

  str(space = false) {
    //String version. Set space=True to line them all up nicely.//
    const val1 = (String(Math.floor(this.id))).rjust(space && 4)
    return `${val1} ${this.name.ljust(space && 50)} (${this.args.join('; ')})`
  }

  toString(space = false) {
    return this.str(space)
  }
}

class Functions {
  /*Represents the full set of functions.

  Can't use namedtuple since python3 has a limit of 255 function arguments, so
  build something similar.
  */
  constructor(functions) {
    this.__init__(functions)
    return this._getProxy(this)
  }

  /* @param functions Array */
  __init__(functions) {
    functions = functions.sort((fA, fB) => fA.id - fB.id)
    this._func_list = functions
    this._func_dict = {}
    functions.forEach((f) => {
      this._func_dict[f.name] = f
    })
    if (Object.keys(this._func_dict).length !== this._func_list.length) {
      throw new ValueError('Function names must be unique')
    }
  }

  __getstate__() {
    return this._func_list
  }

  __setstate__(functions) {
    this.__init__(functions)
  }

  __iter__() {
    return this._func_list
  }

  get length() {
    return this._func_list.length
  }

  __eq__(other) {
    for (let i = 0; i < this._func_list.length; i++) {
      if (this._func_list[i] !== other._func_list[i]) {
        return false;
      }
    }
    return true;
  }

  _getProxy(thing) {
    const self = this //eslint-disable-line
    return new Proxy(thing, {
      get: (target, name) => {
        if (name === Symbol.iterator) {
          return target._func_list[Symbol.iterator].bind(target._func_list)
        }
        if (name === '_func_list' || name === '_func_dict') {
          return target[name]
        }
        if (typeof name === 'number' || (typeof name === 'string' && Number.isInteger(Number(name)))) {
          return target._func_list[name]
        }
        if (name === 'forEach') {
          return target._func_list.forEach.bind(target._func_list)
        }
        if (name === 'map') {
          return target._func_list.map.bind(target._func_list)
        }
        if (name === 'length') {
          return target._func_list.length
        }
        return target._func_dict[name]
      },
      ownKeys: (target) => Object.keys(self._func_dict),
      getOwnPropertyDescriptor(k) {
        return {
          enumerable: true,
          configurable: true,
        }
      },
    })
  }
}

// The semantic meaning of these actions can mainly be found by searching:
// http://liquipedia.net/starcraft2/ or http://starcraft.wikia.com/ .
let _FUNCTIONS = [
  Function.ui_func(0, "no_op", no_op),
  Function.ui_func(1, "move_camera", move_camera),
  Function.ui_func(2, "select_point", select_point),
  Function.ui_func(3, "select_rect", select_rect),
  Function.ui_func(4, "select_control_group", control_group),
  Function.ui_func(5, "select_unit", select_unit,
    (obs) => obs.hasUiData() && obs.getUiData().hasMulti()),
  Function.ui_func(6, "select_idle_worker", select_idle_worker,
    (obs) => obs.hasPlayerCommon() && obs.getPlayerCommon().getIdleWorkerCount() > 0),
  Function.ui_func(7, "select_army", select_army,
    (obs) => obs.hasPlayerCommon() && obs.getPlayerCommon().getArmyCount() > 0),
  Function.ui_func(8, "select_warp_gates", select_warp_gates,
    (obs) => obs.hasPlayerCommon() && obs.getPlayerCommon().getWarpGateCount() > 0),
  Function.ui_func(9, "select_larva", select_larva,
    (obs) => obs.hasPlayerCommon() && obs.getPlayerCommon().getLarvaCount() > 0),
  Function.ui_func(10, "unload", unload,
    (obs) => obs.hasUiData() && obs.getUiData().hasCargo()),
  Function.ui_func(11, "build_queue", build_queue,
    (obs) => obs.hasUiData() && obs.getUiData().hasProduction()),
  // Everything below here is generated with gen_actions.py
  Function.ability(12, "Attack_screen", cmd_screen, 3674),
  Function.ability(13, "Attack_minimap", cmd_minimap, 3674),
  Function.ability(14, "Attack_Attack_screen", cmd_screen, 23, 3674),
  Function.ability(15, "Attack_Attack_minimap", cmd_minimap, 23, 3674),
  Function.ability(16, "Attack_AttackBuilding_screen", cmd_screen, 2048, 3674),
  Function.ability(17, "Attack_AttackBuilding_minimap", cmd_minimap, 2048, 3674),
  Function.ability(555, "Attack_Battlecruiser_screen", cmd_screen, 3771, 3674),
  Function.ability(556, "Attack_Battlecruiser_minimap", cmd_minimap, 3771, 3674),
  Function.ability(18, "Attack_Redirect_screen", cmd_screen, 1682, 3674),
  Function.ability(19, "Scan_Move_screen", cmd_screen, 19, 3674),
  Function.ability(20, "Scan_Move_minimap", cmd_minimap, 19, 3674),
  Function.ability(21, "Behavior_BuildingAttackOff_quick", cmd_quick, 2082),
  Function.ability(22, "Behavior_BuildingAttackOn_quick", cmd_quick, 2081),
  Function.ability(23, "Behavior_CloakOff_quick", cmd_quick, 3677),
  Function.ability(24, "Behavior_CloakOff_Banshee_quick", cmd_quick, 393, 3677),
  Function.ability(25, "Behavior_CloakOff_Ghost_quick", cmd_quick, 383, 3677),
  Function.ability(26, "Behavior_CloakOn_quick", cmd_quick, 3676),
  Function.ability(27, "Behavior_CloakOn_Banshee_quick", cmd_quick, 392, 3676),
  Function.ability(28, "Behavior_CloakOn_Ghost_quick", cmd_quick, 382, 3676),
  Function.ability(29, "Behavior_GenerateCreepOff_quick", cmd_quick, 1693),
  Function.ability(30, "Behavior_GenerateCreepOn_quick", cmd_quick, 1692),
  Function.ability(31, "Behavior_HoldFireOff_quick", cmd_quick, 3689),
  Function.ability(32, "Behavior_HoldFireOff_Ghost_quick", cmd_quick, 38, 3689),
  Function.ability(33, "Behavior_HoldFireOff_Lurker_quick", cmd_quick, 2552, 3689),
  Function.ability(34, "Behavior_HoldFireOn_quick", cmd_quick, 3688),
  Function.ability(35, "Behavior_HoldFireOn_Ghost_quick", cmd_quick, 36, 3688),
  Function.ability(36, "Behavior_HoldFireOn_Lurker_quick", cmd_quick, 2550, 3688),
  Function.ability(37, "Behavior_PulsarBeamOff_quick", cmd_quick, 2376),
  Function.ability(38, "Behavior_PulsarBeamOn_quick", cmd_quick, 2375),
  Function.ability(39, "Build_Armory_screen", cmd_screen, 331),
  Function.ability(40, "Build_Assimilator_screen", cmd_screen, 882),
  Function.ability(41, "Build_BanelingNest_screen", cmd_screen, 1162),
  Function.ability(42, "Build_Barracks_screen", cmd_screen, 321),
  Function.ability(43, "Build_Bunker_screen", cmd_screen, 324),
  Function.ability(44, "Build_CommandCenter_screen", cmd_screen, 318),
  Function.ability(45, "Build_CreepTumor_screen", cmd_screen, 3691),
  Function.ability(46, "Build_CreepTumor_Queen_screen", cmd_screen, 1694, 3691),
  Function.ability(47, "Build_CreepTumor_Tumor_screen", cmd_screen, 1733, 3691),
  Function.ability(48, "Build_CyberneticsCore_screen", cmd_screen, 894),
  Function.ability(49, "Build_DarkShrine_screen", cmd_screen, 891),
  Function.ability(50, "Build_EngineeringBay_screen", cmd_screen, 322),
  Function.ability(51, "Build_EvolutionChamber_screen", cmd_screen, 1156),
  Function.ability(52, "Build_Extractor_screen", cmd_screen, 1154),
  Function.ability(53, "Build_Factory_screen", cmd_screen, 328),
  Function.ability(54, "Build_FleetBeacon_screen", cmd_screen, 885),
  Function.ability(55, "Build_Forge_screen", cmd_screen, 884),
  Function.ability(56, "Build_FusionCore_screen", cmd_screen, 333),
  Function.ability(57, "Build_Gateway_screen", cmd_screen, 883),
  Function.ability(58, "Build_GhostAcademy_screen", cmd_screen, 327),
  Function.ability(59, "Build_Hatchery_screen", cmd_screen, 1152),
  Function.ability(60, "Build_HydraliskDen_screen", cmd_screen, 1157),
  Function.ability(61, "Build_InfestationPit_screen", cmd_screen, 1160),
  Function.ability(62, "Build_Interceptors_quick", cmd_quick, 1042),
  Function.ability(63, "Build_Interceptors_autocast", autocast, 1042),
  Function.ability(524, "Build_LurkerDen_screen", cmd_screen, 1163),
  Function.ability(64, "Build_MissileTurret_screen", cmd_screen, 323),
  Function.ability(65, "Build_Nexus_screen", cmd_screen, 880),
  Function.ability(66, "Build_Nuke_quick", cmd_quick, 710),
  Function.ability(67, "Build_NydusNetwork_screen", cmd_screen, 1161),
  Function.ability(68, "Build_NydusWorm_screen", cmd_screen, 1768),
  Function.ability(69, "Build_PhotonCannon_screen", cmd_screen, 887),
  Function.ability(70, "Build_Pylon_screen", cmd_screen, 881),
  Function.ability(71, "Build_Reactor_quick", cmd_quick, 3683),
  Function.ability(72, "Build_Reactor_screen", cmd_screen, 3683),
  Function.ability(73, "Build_Reactor_Barracks_quick", cmd_quick, 422, 3683),
  Function.ability(74, "Build_Reactor_Barracks_screen", cmd_screen, 422, 3683),
  Function.ability(75, "Build_Reactor_Factory_quick", cmd_quick, 455, 3683),
  Function.ability(76, "Build_Reactor_Factory_screen", cmd_screen, 455, 3683),
  Function.ability(77, "Build_Reactor_Starport_quick", cmd_quick, 488, 3683),
  Function.ability(78, "Build_Reactor_Starport_screen", cmd_screen, 488, 3683),
  Function.ability(79, "Build_Refinery_screen", cmd_screen, 320),
  Function.ability(80, "Build_RoachWarren_screen", cmd_screen, 1165),
  Function.ability(81, "Build_RoboticsBay_screen", cmd_screen, 892),
  Function.ability(82, "Build_RoboticsFacility_screen", cmd_screen, 893),
  Function.ability(83, "Build_SensorTower_screen", cmd_screen, 326),
  Function.ability(525, "Build_ShieldBattery_screen", cmd_screen, 895),
  Function.ability(84, "Build_SpawningPool_screen", cmd_screen, 1155),
  Function.ability(85, "Build_SpineCrawler_screen", cmd_screen, 1166),
  Function.ability(86, "Build_Spire_screen", cmd_screen, 1158),
  Function.ability(87, "Build_SporeCrawler_screen", cmd_screen, 1167),
  Function.ability(88, "Build_Stargate_screen", cmd_screen, 889),
  Function.ability(89, "Build_Starport_screen", cmd_screen, 329),
  Function.ability(90, "Build_StasisTrap_screen", cmd_screen, 2505),
  Function.ability(91, "Build_SupplyDepot_screen", cmd_screen, 319),
  Function.ability(92, "Build_TechLab_quick", cmd_quick, 3682),
  Function.ability(93, "Build_TechLab_screen", cmd_screen, 3682),
  Function.ability(94, "Build_TechLab_Barracks_quick", cmd_quick, 421, 3682),
  Function.ability(95, "Build_TechLab_Barracks_screen", cmd_screen, 421, 3682),
  Function.ability(96, "Build_TechLab_Factory_quick", cmd_quick, 454, 3682),
  Function.ability(97, "Build_TechLab_Factory_screen", cmd_screen, 454, 3682),
  Function.ability(98, "Build_TechLab_Starport_quick", cmd_quick, 487, 3682),
  Function.ability(99, "Build_TechLab_Starport_screen", cmd_screen, 487, 3682),
  Function.ability(100, "Build_TemplarArchive_screen", cmd_screen, 890),
  Function.ability(101, "Build_TwilightCouncil_screen", cmd_screen, 886),
  Function.ability(102, "Build_UltraliskCavern_screen", cmd_screen, 1159),
  Function.ability(103, "BurrowDown_quick", cmd_quick, 3661),
  Function.ability(104, "BurrowDown_Baneling_quick", cmd_quick, 1374, 3661),
  Function.ability(105, "BurrowDown_Drone_quick", cmd_quick, 1378, 3661),
  Function.ability(106, "BurrowDown_Hydralisk_quick", cmd_quick, 1382, 3661),
  Function.ability(107, "BurrowDown_Infestor_quick", cmd_quick, 1444, 3661),
  Function.ability(108, "BurrowDown_InfestorTerran_quick", cmd_quick, 1394, 3661),
  Function.ability(109, "BurrowDown_Lurker_quick", cmd_quick, 2108, 3661),
  Function.ability(110, "BurrowDown_Queen_quick", cmd_quick, 1433, 3661),
  Function.ability(111, "BurrowDown_Ravager_quick", cmd_quick, 2340, 3661),
  Function.ability(112, "BurrowDown_Roach_quick", cmd_quick, 1386, 3661),
  Function.ability(113, "BurrowDown_SwarmHost_quick", cmd_quick, 2014, 3661),
  Function.ability(114, "BurrowDown_Ultralisk_quick", cmd_quick, 1512, 3661),
  Function.ability(115, "BurrowDown_WidowMine_quick", cmd_quick, 2095, 3661),
  Function.ability(116, "BurrowDown_Zergling_quick", cmd_quick, 1390, 3661),
  Function.ability(117, "BurrowUp_quick", cmd_quick, 3662),
  Function.ability(118, "BurrowUp_autocast", autocast, 3662),
  Function.ability(119, "BurrowUp_Baneling_quick", cmd_quick, 1376, 3662),
  Function.ability(120, "BurrowUp_Baneling_autocast", autocast, 1376, 3662),
  Function.ability(121, "BurrowUp_Drone_quick", cmd_quick, 1380, 3662),
  Function.ability(122, "BurrowUp_Hydralisk_quick", cmd_quick, 1384, 3662),
  Function.ability(123, "BurrowUp_Hydralisk_autocast", autocast, 1384, 3662),
  Function.ability(124, "BurrowUp_Infestor_quick", cmd_quick, 1446, 3662),
  Function.ability(125, "BurrowUp_InfestorTerran_quick", cmd_quick, 1396, 3662),
  Function.ability(126, "BurrowUp_InfestorTerran_autocast", autocast, 1396, 3662),
  Function.ability(127, "BurrowUp_Lurker_quick", cmd_quick, 2110, 3662),
  Function.ability(128, "BurrowUp_Queen_quick", cmd_quick, 1435, 3662),
  Function.ability(129, "BurrowUp_Queen_autocast", autocast, 1435, 3662),
  Function.ability(130, "BurrowUp_Ravager_quick", cmd_quick, 2342, 3662),
  Function.ability(131, "BurrowUp_Ravager_autocast", autocast, 2342, 3662),
  Function.ability(132, "BurrowUp_Roach_quick", cmd_quick, 1388, 3662),
  Function.ability(133, "BurrowUp_Roach_autocast", autocast, 1388, 3662),
  Function.ability(134, "BurrowUp_SwarmHost_quick", cmd_quick, 2016, 3662),
  Function.ability(135, "BurrowUp_Ultralisk_quick", cmd_quick, 1514, 3662),
  Function.ability(136, "BurrowUp_Ultralisk_autocast", autocast, 1514, 3662),
  Function.ability(137, "BurrowUp_WidowMine_quick", cmd_quick, 2097, 3662),
  Function.ability(138, "BurrowUp_Zergling_quick", cmd_quick, 1392, 3662),
  Function.ability(139, "BurrowUp_Zergling_autocast", autocast, 1392, 3662),
  Function.ability(140, "Cancel_quick", cmd_quick, 3659),
  Function.ability(141, "Cancel_AdeptPhaseShift_quick", cmd_quick, 2594, 3659),
  Function.ability(142, "Cancel_AdeptShadePhaseShift_quick", cmd_quick, 2596, 3659),
  Function.ability(143, "Cancel_BarracksAddOn_quick", cmd_quick, 451, 3659),
  Function.ability(144, "Cancel_BuildInProgress_quick", cmd_quick, 314, 3659),
  Function.ability(145, "Cancel_CreepTumor_quick", cmd_quick, 1763, 3659),
  Function.ability(146, "Cancel_FactoryAddOn_quick", cmd_quick, 484, 3659),
  Function.ability(147, "Cancel_GravitonBeam_quick", cmd_quick, 174, 3659),
  Function.ability(148, "Cancel_LockOn_quick", cmd_quick, 2354, 3659),
  Function.ability(149, "Cancel_MorphBroodlord_quick", cmd_quick, 1373, 3659),
  Function.ability(150, "Cancel_MorphGreaterSpire_quick", cmd_quick, 1221, 3659),
  Function.ability(151, "Cancel_MorphHive_quick", cmd_quick, 1219, 3659),
  Function.ability(152, "Cancel_MorphLair_quick", cmd_quick, 1217, 3659),
  Function.ability(153, "Cancel_MorphLurker_quick", cmd_quick, 2333, 3659),
  Function.ability(154, "Cancel_MorphLurkerDen_quick", cmd_quick, 2113, 3659),
  Function.ability(155, "Cancel_MorphMothership_quick", cmd_quick, 1848, 3659),
  Function.ability(156, "Cancel_MorphOrbital_quick", cmd_quick, 1517, 3659),
  Function.ability(157, "Cancel_MorphOverlordTransport_quick", cmd_quick, 2709, 3659),
  Function.ability(158, "Cancel_MorphOverseer_quick", cmd_quick, 1449, 3659),
  Function.ability(159, "Cancel_MorphPlanetaryFortress_quick", cmd_quick, 1451, 3659),
  Function.ability(160, "Cancel_MorphRavager_quick", cmd_quick, 2331, 3659),
  Function.ability(161, "Cancel_MorphThorExplosiveMode_quick", cmd_quick, 2365, 3659),
  Function.ability(162, "Cancel_NeuralParasite_quick", cmd_quick, 250, 3659),
  Function.ability(163, "Cancel_Nuke_quick", cmd_quick, 1623, 3659),
  Function.ability(164, "Cancel_SpineCrawlerRoot_quick", cmd_quick, 1730, 3659),
  Function.ability(165, "Cancel_SporeCrawlerRoot_quick", cmd_quick, 1732, 3659),
  Function.ability(166, "Cancel_StarportAddOn_quick", cmd_quick, 517, 3659),
  Function.ability(167, "Cancel_StasisTrap_quick", cmd_quick, 2535, 3659),
  Function.ability(546, "Cancel_VoidRayPrismaticAlignment_quick", cmd_quick, 3707, 3659),
  Function.ability(168, "Cancel_Last_quick", cmd_quick, 3671),
  Function.ability(169, "Cancel_HangarQueue5_quick", cmd_quick, 1038, 3671),
  Function.ability(170, "Cancel_Queue1_quick", cmd_quick, 304, 3671),
  Function.ability(171, "Cancel_Queue5_quick", cmd_quick, 306, 3671),
  Function.ability(172, "Cancel_QueueAddOn_quick", cmd_quick, 312, 3671),
  Function.ability(173, "Cancel_QueueCancelToSelection_quick", cmd_quick, 308, 3671),
  Function.ability(174, "Cancel_QueuePassive_quick", cmd_quick, 1831, 3671),
  Function.ability(175, "Cancel_QueuePassiveCancelToSelection_quick", cmd_quick, 1833, 3671),
  Function.ability(176, "Effect_Abduct_screen", cmd_screen, 2067),
  Function.ability(177, "Effect_AdeptPhaseShift_screen", cmd_screen, 2544),
  Function.ability(547, "Effect_AdeptPhaseShift_minimap", cmd_minimap, 2544),
  Function.ability(526, "Effect_AntiArmorMissile_screen", cmd_screen, 3753),
  Function.ability(178, "Effect_AutoTurret_screen", cmd_screen, 1764),
  Function.ability(179, "Effect_BlindingCloud_screen", cmd_screen, 2063),
  Function.ability(180, "Effect_Blink_screen", cmd_screen, 3687),
  Function.ability(543, "Effect_Blink_minimap", cmd_minimap, 3687),
  Function.ability(181, "Effect_Blink_Stalker_screen", cmd_screen, 1442, 3687),
  Function.ability(544, "Effect_Blink_Stalker_minimap", cmd_minimap, 1442, 3687),
  Function.ability(182, "Effect_ShadowStride_screen", cmd_screen, 2700, 3687),
  Function.ability(545, "Effect_ShadowStride_minimap", cmd_minimap, 2700, 3687),
  Function.ability(183, "Effect_CalldownMULE_screen", cmd_screen, 171),
  Function.ability(184, "Effect_CausticSpray_screen", cmd_screen, 2324),
  Function.ability(185, "Effect_Charge_screen", cmd_screen, 1819),
  Function.ability(186, "Effect_Charge_autocast", autocast, 1819),
  Function.ability(187, "Effect_ChronoBoost_screen", cmd_screen, 261),
  Function.ability(527, "Effect_ChronoBoostEnergyCost_screen", cmd_screen, 3755),
  Function.ability(188, "Effect_Contaminate_screen", cmd_screen, 1825),
  Function.ability(189, "Effect_CorrosiveBile_screen", cmd_screen, 2338),
  Function.ability(190, "Effect_EMP_screen", cmd_screen, 1628),
  Function.ability(191, "Effect_Explode_quick", cmd_quick, 42),
  Function.ability(192, "Effect_Feedback_screen", cmd_screen, 140),
  Function.ability(193, "Effect_ForceField_screen", cmd_screen, 1526),
  Function.ability(194, "Effect_FungalGrowth_screen", cmd_screen, 74),
  Function.ability(195, "Effect_GhostSnipe_screen", cmd_screen, 2714),
  Function.ability(196, "Effect_GravitonBeam_screen", cmd_screen, 173),
  Function.ability(197, "Effect_GuardianShield_quick", cmd_quick, 76),
  Function.ability(198, "Effect_Heal_screen", cmd_screen, 386),
  Function.ability(199, "Effect_Heal_autocast", autocast, 386),
  Function.ability(200, "Effect_HunterSeekerMissile_screen", cmd_screen, 169),
  Function.ability(201, "Effect_ImmortalBarrier_quick", cmd_quick, 2328),
  Function.ability(202, "Effect_ImmortalBarrier_autocast", autocast, 2328),
  Function.ability(203, "Effect_InfestedTerrans_screen", cmd_screen, 247),
  Function.ability(204, "Effect_InjectLarva_screen", cmd_screen, 251),
  Function.ability(528, "Effect_InterferenceMatrix_screen", cmd_screen, 3747),
  Function.ability(205, "Effect_KD8Charge_screen", cmd_screen, 2588),
  Function.ability(206, "Effect_LockOn_screen", cmd_screen, 2350),
  Function.ability(557, "Effect_LockOn_autocast", autocast, 2350),
  Function.ability(207, "Effect_LocustSwoop_screen", cmd_screen, 2387),
  Function.ability(208, "Effect_MassRecall_screen", cmd_screen, 3686),
  Function.ability(209, "Effect_MassRecall_Mothership_screen", cmd_screen, 2368, 3686),
  Function.ability(210, "Effect_MassRecall_MothershipCore_screen", cmd_screen, 1974, 3686),
  Function.ability(529, "Effect_MassRecall_Nexus_screen", cmd_screen, 3757, 3686),
  Function.ability(548, "Effect_MassRecall_StrategicRecall_screen", cmd_screen, 142, 3686),
  Function.ability(211, "Effect_MedivacIgniteAfterburners_quick", cmd_quick, 2116),
  Function.ability(212, "Effect_NeuralParasite_screen", cmd_screen, 249),
  Function.ability(213, "Effect_NukeCalldown_screen", cmd_screen, 1622),
  Function.ability(214, "Effect_OracleRevelation_screen", cmd_screen, 2146),
  Function.ability(215, "Effect_ParasiticBomb_screen", cmd_screen, 2542),
  Function.ability(216, "Effect_PhotonOvercharge_screen", cmd_screen, 2162),
  Function.ability(217, "Effect_PointDefenseDrone_screen", cmd_screen, 144),
  Function.ability(218, "Effect_PsiStorm_screen", cmd_screen, 1036),
  Function.ability(219, "Effect_PurificationNova_screen", cmd_screen, 2346),
  Function.ability(220, "Effect_Repair_screen", cmd_screen, 3685),
  Function.ability(221, "Effect_Repair_autocast", autocast, 3685),
  Function.ability(222, "Effect_Repair_Mule_screen", cmd_screen, 78, 3685),
  Function.ability(223, "Effect_Repair_Mule_autocast", autocast, 78, 3685),
  Function.ability(530, "Effect_Repair_RepairDrone_screen", cmd_screen, 3751, 3685),
  Function.ability(531, "Effect_Repair_RepairDrone_autocast", autocast, 3751, 3685),
  Function.ability(224, "Effect_Repair_SCV_screen", cmd_screen, 316, 3685),
  Function.ability(225, "Effect_Repair_SCV_autocast", autocast, 316, 3685),
  Function.ability(532, "Effect_RepairDrone_screen", cmd_screen, 3749),
  Function.ability(533, "Effect_Restore_screen", cmd_screen, 3765),
  Function.ability(534, "Effect_Restore_autocast", autocast, 3765),
  Function.ability(226, "Effect_Salvage_quick", cmd_quick, 32),
  Function.ability(227, "Effect_Scan_screen", cmd_screen, 399),
  Function.ability(542, "Effect_Scan_minimap", cmd_minimap, 399),
  Function.ability(228, "Effect_SpawnChangeling_quick", cmd_quick, 181),
  Function.ability(229, "Effect_SpawnLocusts_screen", cmd_screen, 2704),
  Function.ability(230, "Effect_Spray_screen", cmd_screen, 3684),
  Function.ability(231, "Effect_Spray_Protoss_screen", cmd_screen, 30, 3684),
  Function.ability(232, "Effect_Spray_Terran_screen", cmd_screen, 26, 3684),
  Function.ability(233, "Effect_Spray_Zerg_screen", cmd_screen, 28, 3684),
  Function.ability(549, "Effect_Spray_minimap", cmd_minimap, 3684),
  Function.ability(550, "Effect_Spray_Protoss_minimap", cmd_minimap, 30, 3684),
  Function.ability(551, "Effect_Spray_Terran_minimap", cmd_minimap, 26, 3684),
  Function.ability(552, "Effect_Spray_Zerg_minimap", cmd_minimap, 28, 3684),
  Function.ability(234, "Effect_Stim_quick", cmd_quick, 3675),
  Function.ability(235, "Effect_Stim_Marauder_quick", cmd_quick, 253, 3675),
  Function.ability(236, "Effect_Stim_Marauder_Redirect_quick", cmd_quick, 1684, 3675),
  Function.ability(237, "Effect_Stim_Marine_quick", cmd_quick, 380, 3675),
  Function.ability(238, "Effect_Stim_Marine_Redirect_quick", cmd_quick, 1683, 3675),
  Function.ability(239, "Effect_SupplyDrop_screen", cmd_screen, 255),
  Function.ability(240, "Effect_TacticalJump_screen", cmd_screen, 2358),
  Function.ability(553, "Effect_TacticalJump_minimap", cmd_minimap, 2358),
  Function.ability(241, "Effect_TimeWarp_screen", cmd_screen, 2244),
  Function.ability(242, "Effect_Transfusion_screen", cmd_screen, 1664),
  Function.ability(243, "Effect_ViperConsume_screen", cmd_screen, 2073),
  Function.ability(244, "Effect_VoidRayPrismaticAlignment_quick", cmd_quick, 2393),
  Function.ability(245, "Effect_WidowMineAttack_screen", cmd_screen, 2099),
  Function.ability(246, "Effect_WidowMineAttack_autocast", autocast, 2099),
  Function.ability(247, "Effect_YamatoGun_screen", cmd_screen, 401),
  Function.ability(248, "Hallucination_Adept_quick", cmd_quick, 2391),
  Function.ability(249, "Hallucination_Archon_quick", cmd_quick, 146),
  Function.ability(250, "Hallucination_Colossus_quick", cmd_quick, 148),
  Function.ability(251, "Hallucination_Disruptor_quick", cmd_quick, 2389),
  Function.ability(252, "Hallucination_HighTemplar_quick", cmd_quick, 150),
  Function.ability(253, "Hallucination_Immortal_quick", cmd_quick, 152),
  Function.ability(254, "Hallucination_Oracle_quick", cmd_quick, 2114),
  Function.ability(255, "Hallucination_Phoenix_quick", cmd_quick, 154),
  Function.ability(256, "Hallucination_Probe_quick", cmd_quick, 156),
  Function.ability(257, "Hallucination_Stalker_quick", cmd_quick, 158),
  Function.ability(258, "Hallucination_VoidRay_quick", cmd_quick, 160),
  Function.ability(259, "Hallucination_WarpPrism_quick", cmd_quick, 162),
  Function.ability(260, "Hallucination_Zealot_quick", cmd_quick, 164),
  Function.ability(261, "Halt_quick", cmd_quick, 3660),
  Function.ability(262, "Halt_Building_quick", cmd_quick, 315, 3660),
  Function.ability(263, "Halt_TerranBuild_quick", cmd_quick, 348, 3660),
  Function.ability(264, "Harvest_Gather_screen", cmd_screen, 3666),
  Function.ability(265, "Harvest_Gather_Drone_screen", cmd_screen, 1183, 3666),
  Function.ability(266, "Harvest_Gather_Mule_screen", cmd_screen, 166, 3666),
  Function.ability(267, "Harvest_Gather_Probe_screen", cmd_screen, 298, 3666),
  Function.ability(268, "Harvest_Gather_SCV_screen", cmd_screen, 295, 3666),
  Function.ability(269, "Harvest_Return_quick", cmd_quick, 3667),
  Function.ability(270, "Harvest_Return_Drone_quick", cmd_quick, 1184, 3667),
  Function.ability(271, "Harvest_Return_Mule_quick", cmd_quick, 167, 3667),
  Function.ability(272, "Harvest_Return_Probe_quick", cmd_quick, 299, 3667),
  Function.ability(273, "Harvest_Return_SCV_quick", cmd_quick, 296, 3667),
  Function.ability(274, "HoldPosition_quick", cmd_quick, 3793),
  Function.ability(558, "HoldPosition_Battlecruiser_quick", cmd_quick, 3778, 3793),
  Function.ability(559, "HoldPosition_Hold_quick", cmd_quick, 18, 3793),
  Function.ability(275, "Land_screen", cmd_screen, 3678),
  Function.ability(276, "Land_Barracks_screen", cmd_screen, 554, 3678),
  Function.ability(277, "Land_CommandCenter_screen", cmd_screen, 419, 3678),
  Function.ability(278, "Land_Factory_screen", cmd_screen, 520, 3678),
  Function.ability(279, "Land_OrbitalCommand_screen", cmd_screen, 1524, 3678),
  Function.ability(280, "Land_Starport_screen", cmd_screen, 522, 3678),
  Function.ability(281, "Lift_quick", cmd_quick, 3679),
  Function.ability(282, "Lift_Barracks_quick", cmd_quick, 452, 3679),
  Function.ability(283, "Lift_CommandCenter_quick", cmd_quick, 417, 3679),
  Function.ability(284, "Lift_Factory_quick", cmd_quick, 485, 3679),
  Function.ability(285, "Lift_OrbitalCommand_quick", cmd_quick, 1522, 3679),
  Function.ability(286, "Lift_Starport_quick", cmd_quick, 518, 3679),
  Function.ability(287, "Load_screen", cmd_screen, 3668),
  Function.ability(288, "Load_Bunker_screen", cmd_screen, 407, 3668),
  Function.ability(289, "Load_Medivac_screen", cmd_screen, 394, 3668),
  Function.ability(290, "Load_NydusNetwork_screen", cmd_screen, 1437, 3668),
  Function.ability(291, "Load_NydusWorm_screen", cmd_screen, 2370, 3668),
  Function.ability(292, "Load_Overlord_screen", cmd_screen, 1406, 3668),
  Function.ability(293, "Load_WarpPrism_screen", cmd_screen, 911, 3668),
  Function.ability(294, "LoadAll_quick", cmd_quick, 3663),
  Function.ability(295, "LoadAll_CommandCenter_quick", cmd_quick, 416, 3663),
  Function.ability(296, "Morph_Archon_quick", cmd_quick, 1766),
  Function.ability(297, "Morph_BroodLord_quick", cmd_quick, 1372),
  Function.ability(298, "Morph_Gateway_quick", cmd_quick, 1520),
  Function.ability(299, "Morph_GreaterSpire_quick", cmd_quick, 1220),
  Function.ability(300, "Morph_Hellbat_quick", cmd_quick, 1998),
  Function.ability(301, "Morph_Hellion_quick", cmd_quick, 1978),
  Function.ability(302, "Morph_Hive_quick", cmd_quick, 1218),
  Function.ability(303, "Morph_Lair_quick", cmd_quick, 1216),
  Function.ability(304, "Morph_LiberatorAAMode_quick", cmd_quick, 2560),
  Function.ability(305, "Morph_LiberatorAGMode_screen", cmd_screen, 2558),
  Function.ability(554, "Morph_LiberatorAGMode_minimap", cmd_minimap, 2558),
  Function.ability(306, "Morph_Lurker_quick", cmd_quick, 2332),
  Function.ability(307, "Morph_LurkerDen_quick", cmd_quick, 2112),
  Function.ability(308, "Morph_Mothership_quick", cmd_quick, 1847),
  Function.ability(535, "Morph_ObserverMode_quick", cmd_quick, 3739),
  Function.ability(309, "Morph_OrbitalCommand_quick", cmd_quick, 1516),
  Function.ability(310, "Morph_OverlordTransport_quick", cmd_quick, 2708),
  Function.ability(311, "Morph_Overseer_quick", cmd_quick, 1448),
  Function.ability(536, "Morph_OverseerMode_quick", cmd_quick, 3745),
  Function.ability(537, "Morph_OversightMode_quick", cmd_quick, 3743),
  Function.ability(312, "Morph_PlanetaryFortress_quick", cmd_quick, 1450),
  Function.ability(313, "Morph_Ravager_quick", cmd_quick, 2330),
  Function.ability(314, "Morph_Root_screen", cmd_screen, 3680),
  Function.ability(315, "Morph_SpineCrawlerRoot_screen", cmd_screen, 1729, 3680),
  Function.ability(316, "Morph_SporeCrawlerRoot_screen", cmd_screen, 1731, 3680),
  Function.ability(317, "Morph_SiegeMode_quick", cmd_quick, 388),
  Function.ability(318, "Morph_SupplyDepot_Lower_quick", cmd_quick, 556),
  Function.ability(319, "Morph_SupplyDepot_Raise_quick", cmd_quick, 558),
  Function.ability(538, "Morph_SurveillanceMode_quick", cmd_quick, 3741),
  Function.ability(320, "Morph_ThorExplosiveMode_quick", cmd_quick, 2364),
  Function.ability(321, "Morph_ThorHighImpactMode_quick", cmd_quick, 2362),
  Function.ability(322, "Morph_Unsiege_quick", cmd_quick, 390),
  Function.ability(323, "Morph_Uproot_quick", cmd_quick, 3681),
  Function.ability(324, "Morph_SpineCrawlerUproot_quick", cmd_quick, 1725, 3681),
  Function.ability(325, "Morph_SporeCrawlerUproot_quick", cmd_quick, 1727, 3681),
  Function.ability(326, "Morph_VikingAssaultMode_quick", cmd_quick, 403),
  Function.ability(327, "Morph_VikingFighterMode_quick", cmd_quick, 405),
  Function.ability(328, "Morph_WarpGate_quick", cmd_quick, 1518),
  Function.ability(560, "Morph_WarpGate_autocast", autocast, 1518),
  Function.ability(329, "Morph_WarpPrismPhasingMode_quick", cmd_quick, 1528),
  Function.ability(330, "Morph_WarpPrismTransportMode_quick", cmd_quick, 1530),
  Function.ability(331, "Move_screen", cmd_screen, 3794),
  Function.ability(332, "Move_minimap", cmd_minimap, 3794),
  Function.ability(561, "Move_Battlecruiser_screen", cmd_screen, 3776, 3794),
  Function.ability(562, "Move_Battlecruiser_minimap", cmd_minimap, 3776, 3794),
  Function.ability(563, "Move_Move_screen", cmd_screen, 16, 3794),
  Function.ability(564, "Move_Move_minimap", cmd_minimap, 16, 3794),
  Function.ability(333, "Patrol_screen", cmd_screen, 3795),
  Function.ability(334, "Patrol_minimap", cmd_minimap, 3795),
  Function.ability(565, "Patrol_Battlecruiser_screen", cmd_screen, 3777, 3795),
  Function.ability(566, "Patrol_Battlecruiser_minimap", cmd_minimap, 3777, 3795),
  Function.ability(567, "Patrol_Patrol_screen", cmd_screen, 17, 3795),
  Function.ability(568, "Patrol_Patrol_minimap", cmd_minimap, 17, 3795),
  Function.ability(335, "Rally_Units_screen", cmd_screen, 3673),
  Function.ability(336, "Rally_Units_minimap", cmd_minimap, 3673),
  Function.ability(337, "Rally_Building_screen", cmd_screen, 195, 3673),
  Function.ability(338, "Rally_Building_minimap", cmd_minimap, 195, 3673),
  Function.ability(339, "Rally_Hatchery_Units_screen", cmd_screen, 211, 3673),
  Function.ability(340, "Rally_Hatchery_Units_minimap", cmd_minimap, 211, 3673),
  Function.ability(341, "Rally_Morphing_Unit_screen", cmd_screen, 199, 3673),
  Function.ability(342, "Rally_Morphing_Unit_minimap", cmd_minimap, 199, 3673),
  Function.ability(343, "Rally_Workers_screen", cmd_screen, 3690),
  Function.ability(344, "Rally_Workers_minimap", cmd_minimap, 3690),
  Function.ability(345, "Rally_CommandCenter_screen", cmd_screen, 203, 3690),
  Function.ability(346, "Rally_CommandCenter_minimap", cmd_minimap, 203, 3690),
  Function.ability(347, "Rally_Hatchery_Workers_screen", cmd_screen, 212, 3690),
  Function.ability(348, "Rally_Hatchery_Workers_minimap", cmd_minimap, 212, 3690),
  Function.ability(349, "Rally_Nexus_screen", cmd_screen, 207, 3690),
  Function.ability(350, "Rally_Nexus_minimap", cmd_minimap, 207, 3690),
  Function.ability(539, "Research_AdaptiveTalons_quick", cmd_quick, 3709),
  Function.ability(351, "Research_AdeptResonatingGlaives_quick", cmd_quick, 1594),
  Function.ability(352, "Research_AdvancedBallistics_quick", cmd_quick, 805),
  Function.ability(569, "Research_AnabolicSynthesis_quick", cmd_quick, 263),
  Function.ability(353, "Research_BansheeCloakingField_quick", cmd_quick, 790),
  Function.ability(354, "Research_BansheeHyperflightRotors_quick", cmd_quick, 799),
  Function.ability(355, "Research_BattlecruiserWeaponRefit_quick", cmd_quick, 1532),
  Function.ability(356, "Research_Blink_quick", cmd_quick, 1593),
  Function.ability(357, "Research_Burrow_quick", cmd_quick, 1225),
  Function.ability(358, "Research_CentrifugalHooks_quick", cmd_quick, 1482),
  Function.ability(359, "Research_Charge_quick", cmd_quick, 1592),
  Function.ability(360, "Research_ChitinousPlating_quick", cmd_quick, 265),
  Function.ability(361, "Research_CombatShield_quick", cmd_quick, 731),
  Function.ability(362, "Research_ConcussiveShells_quick", cmd_quick, 732),
  Function.ability(570, "Research_CycloneLockOnDamage_quick", cmd_quick, 769),
  Function.ability(540, "Research_CycloneRapidFireLaunchers_quick", cmd_quick, 768),
  Function.ability(363, "Research_DrillingClaws_quick", cmd_quick, 764),
  Function.ability(572, "Research_EnhancedShockwaves_quick", cmd_quick, 822),
  Function.ability(364, "Research_ExtendedThermalLance_quick", cmd_quick, 1097),
  Function.ability(365, "Research_GlialRegeneration_quick", cmd_quick, 216),
  Function.ability(366, "Research_GraviticBooster_quick", cmd_quick, 1093),
  Function.ability(367, "Research_GraviticDrive_quick", cmd_quick, 1094),
  Function.ability(368, "Research_GroovedSpines_quick", cmd_quick, 1282),
  Function.ability(369, "Research_HiSecAutoTracking_quick", cmd_quick, 650),
  Function.ability(370, "Research_HighCapacityFuelTanks_quick", cmd_quick, 804),
  Function.ability(371, "Research_InfernalPreigniter_quick", cmd_quick, 761),
  Function.ability(372, "Research_InterceptorGravitonCatapult_quick", cmd_quick, 44),
  Function.ability(374, "Research_MuscularAugments_quick", cmd_quick, 1283),
  Function.ability(375, "Research_NeosteelFrame_quick", cmd_quick, 655),
  Function.ability(376, "Research_NeuralParasite_quick", cmd_quick, 1455),
  Function.ability(377, "Research_PathogenGlands_quick", cmd_quick, 1454),
  Function.ability(378, "Research_PersonalCloaking_quick", cmd_quick, 820),
  Function.ability(379, "Research_PhoenixAnionPulseCrystals_quick", cmd_quick, 46),
  Function.ability(380, "Research_PneumatizedCarapace_quick", cmd_quick, 1223),
  Function.ability(381, "Research_ProtossAirArmor_quick", cmd_quick, 3692),
  Function.ability(382, "Research_ProtossAirArmorLevel1_quick", cmd_quick, 1565, 3692),
  Function.ability(383, "Research_ProtossAirArmorLevel2_quick", cmd_quick, 1566, 3692),
  Function.ability(384, "Research_ProtossAirArmorLevel3_quick", cmd_quick, 1567, 3692),
  Function.ability(385, "Research_ProtossAirWeapons_quick", cmd_quick, 3693),
  Function.ability(386, "Research_ProtossAirWeaponsLevel1_quick", cmd_quick, 1562, 3693),
  Function.ability(387, "Research_ProtossAirWeaponsLevel2_quick", cmd_quick, 1563, 3693),
  Function.ability(388, "Research_ProtossAirWeaponsLevel3_quick", cmd_quick, 1564, 3693),
  Function.ability(389, "Research_ProtossGroundArmor_quick", cmd_quick, 3694),
  Function.ability(390, "Research_ProtossGroundArmorLevel1_quick", cmd_quick, 1065, 3694),
  Function.ability(391, "Research_ProtossGroundArmorLevel2_quick", cmd_quick, 1066, 3694),
  Function.ability(392, "Research_ProtossGroundArmorLevel3_quick", cmd_quick, 1067, 3694),
  Function.ability(393, "Research_ProtossGroundWeapons_quick", cmd_quick, 3695),
  Function.ability(394, "Research_ProtossGroundWeaponsLevel1_quick", cmd_quick, 1062, 3695),
  Function.ability(395, "Research_ProtossGroundWeaponsLevel2_quick", cmd_quick, 1063, 3695),
  Function.ability(396, "Research_ProtossGroundWeaponsLevel3_quick", cmd_quick, 1064, 3695),
  Function.ability(397, "Research_ProtossShields_quick", cmd_quick, 3696),
  Function.ability(398, "Research_ProtossShieldsLevel1_quick", cmd_quick, 1068, 3696),
  Function.ability(399, "Research_ProtossShieldsLevel2_quick", cmd_quick, 1069, 3696),
  Function.ability(400, "Research_ProtossShieldsLevel3_quick", cmd_quick, 1070, 3696),
  Function.ability(401, "Research_PsiStorm_quick", cmd_quick, 1126),
  Function.ability(402, "Research_RavenCorvidReactor_quick", cmd_quick, 793),
  Function.ability(403, "Research_RavenRecalibratedExplosives_quick", cmd_quick, 803),
  Function.ability(404, "Research_ShadowStrike_quick", cmd_quick, 2720),
  Function.ability(373, "Research_SmartServos_quick", cmd_quick, 766),
  Function.ability(405, "Research_Stimpack_quick", cmd_quick, 730),
  Function.ability(406, "Research_TerranInfantryArmor_quick", cmd_quick, 3697),
  Function.ability(407, "Research_TerranInfantryArmorLevel1_quick", cmd_quick, 656, 3697),
  Function.ability(408, "Research_TerranInfantryArmorLevel2_quick", cmd_quick, 657, 3697),
  Function.ability(409, "Research_TerranInfantryArmorLevel3_quick", cmd_quick, 658, 3697),
  Function.ability(410, "Research_TerranInfantryWeapons_quick", cmd_quick, 3698),
  Function.ability(411, "Research_TerranInfantryWeaponsLevel1_quick", cmd_quick, 652, 3698),
  Function.ability(412, "Research_TerranInfantryWeaponsLevel2_quick", cmd_quick, 653, 3698),
  Function.ability(413, "Research_TerranInfantryWeaponsLevel3_quick", cmd_quick, 654, 3698),
  Function.ability(414, "Research_TerranShipWeapons_quick", cmd_quick, 3699),
  Function.ability(415, "Research_TerranShipWeaponsLevel1_quick", cmd_quick, 861, 3699),
  Function.ability(416, "Research_TerranShipWeaponsLevel2_quick", cmd_quick, 862, 3699),
  Function.ability(417, "Research_TerranShipWeaponsLevel3_quick", cmd_quick, 863, 3699),
  Function.ability(418, "Research_TerranStructureArmorUpgrade_quick", cmd_quick, 651),
  Function.ability(419, "Research_TerranVehicleAndShipPlating_quick", cmd_quick, 3700),
  Function.ability(420, "Research_TerranVehicleAndShipPlatingLevel1_quick", cmd_quick, 864, 3700),
  Function.ability(421, "Research_TerranVehicleAndShipPlatingLevel2_quick", cmd_quick, 865, 3700),
  Function.ability(422, "Research_TerranVehicleAndShipPlatingLevel3_quick", cmd_quick, 866, 3700),
  Function.ability(423, "Research_TerranVehicleWeapons_quick", cmd_quick, 3701),
  Function.ability(424, "Research_TerranVehicleWeaponsLevel1_quick", cmd_quick, 855, 3701),
  Function.ability(425, "Research_TerranVehicleWeaponsLevel2_quick", cmd_quick, 856, 3701),
  Function.ability(426, "Research_TerranVehicleWeaponsLevel3_quick", cmd_quick, 857, 3701),
  Function.ability(427, "Research_TunnelingClaws_quick", cmd_quick, 217),
  Function.ability(428, "Research_WarpGate_quick", cmd_quick, 1568),
  Function.ability(429, "Research_ZergFlyerArmor_quick", cmd_quick, 3702),
  Function.ability(430, "Research_ZergFlyerArmorLevel1_quick", cmd_quick, 1315, 3702),
  Function.ability(431, "Research_ZergFlyerArmorLevel2_quick", cmd_quick, 1316, 3702),
  Function.ability(432, "Research_ZergFlyerArmorLevel3_quick", cmd_quick, 1317, 3702),
  Function.ability(433, "Research_ZergFlyerAttack_quick", cmd_quick, 3703),
  Function.ability(434, "Research_ZergFlyerAttackLevel1_quick", cmd_quick, 1312, 3703),
  Function.ability(435, "Research_ZergFlyerAttackLevel2_quick", cmd_quick, 1313, 3703),
  Function.ability(436, "Research_ZergFlyerAttackLevel3_quick", cmd_quick, 1314, 3703),
  Function.ability(437, "Research_ZergGroundArmor_quick", cmd_quick, 3704),
  Function.ability(438, "Research_ZergGroundArmorLevel1_quick", cmd_quick, 1189, 3704),
  Function.ability(439, "Research_ZergGroundArmorLevel2_quick", cmd_quick, 1190, 3704),
  Function.ability(440, "Research_ZergGroundArmorLevel3_quick", cmd_quick, 1191, 3704),
  Function.ability(441, "Research_ZergMeleeWeapons_quick", cmd_quick, 3705),
  Function.ability(442, "Research_ZergMeleeWeaponsLevel1_quick", cmd_quick, 1186, 3705),
  Function.ability(443, "Research_ZergMeleeWeaponsLevel2_quick", cmd_quick, 1187, 3705),
  Function.ability(444, "Research_ZergMeleeWeaponsLevel3_quick", cmd_quick, 1188, 3705),
  Function.ability(445, "Research_ZergMissileWeapons_quick", cmd_quick, 3706),
  Function.ability(446, "Research_ZergMissileWeaponsLevel1_quick", cmd_quick, 1192, 3706),
  Function.ability(447, "Research_ZergMissileWeaponsLevel2_quick", cmd_quick, 1193, 3706),
  Function.ability(448, "Research_ZergMissileWeaponsLevel3_quick", cmd_quick, 1194, 3706),
  Function.ability(449, "Research_ZerglingAdrenalGlands_quick", cmd_quick, 1252),
  Function.ability(450, "Research_ZerglingMetabolicBoost_quick", cmd_quick, 1253),
  Function.ability(451, "Smart_screen", cmd_screen, 1),
  Function.ability(452, "Smart_minimap", cmd_minimap, 1),
  Function.ability(453, "Stop_quick", cmd_quick, 3665),
  Function.ability(571, "Stop_Battlecruiser_quick", cmd_quick, 3783, 3665),
  Function.ability(454, "Stop_Building_quick", cmd_quick, 2057, 3665),
  Function.ability(455, "Stop_Redirect_quick", cmd_quick, 1691, 3665),
  Function.ability(456, "Stop_Stop_quick", cmd_quick, 4, 3665),
  Function.ability(457, "Train_Adept_quick", cmd_quick, 922),
  Function.ability(458, "Train_Baneling_quick", cmd_quick, 80),
  Function.ability(459, "Train_Banshee_quick", cmd_quick, 621),
  Function.ability(460, "Train_Battlecruiser_quick", cmd_quick, 623),
  Function.ability(461, "Train_Carrier_quick", cmd_quick, 948),
  Function.ability(462, "Train_Colossus_quick", cmd_quick, 978),
  Function.ability(463, "Train_Corruptor_quick", cmd_quick, 1353),
  Function.ability(464, "Train_Cyclone_quick", cmd_quick, 597),
  Function.ability(465, "Train_DarkTemplar_quick", cmd_quick, 920),
  Function.ability(466, "Train_Disruptor_quick", cmd_quick, 994),
  Function.ability(467, "Train_Drone_quick", cmd_quick, 1342),
  Function.ability(468, "Train_Ghost_quick", cmd_quick, 562),
  Function.ability(469, "Train_Hellbat_quick", cmd_quick, 596),
  Function.ability(470, "Train_Hellion_quick", cmd_quick, 595),
  Function.ability(471, "Train_HighTemplar_quick", cmd_quick, 919),
  Function.ability(472, "Train_Hydralisk_quick", cmd_quick, 1345),
  Function.ability(473, "Train_Immortal_quick", cmd_quick, 979),
  Function.ability(474, "Train_Infestor_quick", cmd_quick, 1352),
  Function.ability(475, "Train_Liberator_quick", cmd_quick, 626),
  Function.ability(476, "Train_Marauder_quick", cmd_quick, 563),
  Function.ability(477, "Train_Marine_quick", cmd_quick, 560),
  Function.ability(478, "Train_Medivac_quick", cmd_quick, 620),
  Function.ability(541, "Train_Mothership_quick", cmd_quick, 110),
  Function.ability(479, "Train_MothershipCore_quick", cmd_quick, 1853),
  Function.ability(480, "Train_Mutalisk_quick", cmd_quick, 1346),
  Function.ability(481, "Train_Observer_quick", cmd_quick, 977),
  Function.ability(482, "Train_Oracle_quick", cmd_quick, 954),
  Function.ability(483, "Train_Overlord_quick", cmd_quick, 1344),
  Function.ability(484, "Train_Phoenix_quick", cmd_quick, 946),
  Function.ability(485, "Train_Probe_quick", cmd_quick, 1006),
  Function.ability(486, "Train_Queen_quick", cmd_quick, 1632),
  Function.ability(487, "Train_Raven_quick", cmd_quick, 622),
  Function.ability(488, "Train_Reaper_quick", cmd_quick, 561),
  Function.ability(489, "Train_Roach_quick", cmd_quick, 1351),
  Function.ability(490, "Train_SCV_quick", cmd_quick, 524),
  Function.ability(491, "Train_Sentry_quick", cmd_quick, 921),
  Function.ability(492, "Train_SiegeTank_quick", cmd_quick, 591),
  Function.ability(493, "Train_Stalker_quick", cmd_quick, 917),
  Function.ability(494, "Train_SwarmHost_quick", cmd_quick, 1356),
  Function.ability(495, "Train_Tempest_quick", cmd_quick, 955),
  Function.ability(496, "Train_Thor_quick", cmd_quick, 594),
  Function.ability(497, "Train_Ultralisk_quick", cmd_quick, 1348),
  Function.ability(498, "Train_VikingFighter_quick", cmd_quick, 624),
  Function.ability(499, "Train_Viper_quick", cmd_quick, 1354),
  Function.ability(500, "Train_VoidRay_quick", cmd_quick, 950),
  Function.ability(501, "Train_WarpPrism_quick", cmd_quick, 976),
  Function.ability(502, "Train_WidowMine_quick", cmd_quick, 614),
  Function.ability(503, "Train_Zealot_quick", cmd_quick, 916),
  Function.ability(504, "Train_Zergling_quick", cmd_quick, 1343),
  Function.ability(505, "TrainWarp_Adept_screen", cmd_screen, 1419),
  Function.ability(506, "TrainWarp_DarkTemplar_screen", cmd_screen, 1417),
  Function.ability(507, "TrainWarp_HighTemplar_screen", cmd_screen, 1416),
  Function.ability(508, "TrainWarp_Sentry_screen", cmd_screen, 1418),
  Function.ability(509, "TrainWarp_Stalker_screen", cmd_screen, 1414),
  Function.ability(510, "TrainWarp_Zealot_screen", cmd_screen, 1413),
  Function.ability(511, "UnloadAll_quick", cmd_quick, 3664),
  Function.ability(512, "UnloadAll_Bunker_quick", cmd_quick, 408, 3664),
  Function.ability(513, "UnloadAll_CommandCenter_quick", cmd_quick, 413, 3664),
  Function.ability(514, "UnloadAll_NydusNetwork_quick", cmd_quick, 1438, 3664),
  Function.ability(515, "UnloadAll_NydusWorm_quick", cmd_quick, 2371, 3664),
  Function.ability(516, "UnloadAllAt_screen", cmd_screen, 3669),
  Function.ability(517, "UnloadAllAt_minimap", cmd_minimap, 3669),
  Function.ability(518, "UnloadAllAt_Medivac_screen", cmd_screen, 396, 3669),
  Function.ability(519, "UnloadAllAt_Medivac_minimap", cmd_minimap, 396, 3669),
  Function.ability(520, "UnloadAllAt_Overlord_screen", cmd_screen, 1408, 3669),
  Function.ability(521, "UnloadAllAt_Overlord_minimap", cmd_minimap, 1408, 3669),
  Function.ability(522, "UnloadAllAt_WarpPrism_screen", cmd_screen, 913, 3669),
  Function.ability(523, "UnloadAllAt_WarpPrism_minimap", cmd_minimap, 913, 3669),
]

let tempDict = {}
// Create an IntEnum of the function names/ids so that printing the id will
// show something useful.
_FUNCTIONS.forEach((f) => {
  tempDict[f.name] = f.id
})
const _Functions = Enum.IntEnum('_Functions', tempDict)
_FUNCTIONS = _FUNCTIONS.map((f) => f._replace({ id: _Functions(f.id) }))
const FUNCTIONS = new Functions(_FUNCTIONS)
// Some indexes to support features.py and action conversion.
const ABILITY_IDS = {}
const ABILITY_IDS_seen = new Map()
for (let i = 0; i < FUNCTIONS.length; i++) {
  const _func = FUNCTIONS[i];
  ABILITY_IDS[_func.ability_id] = ABILITY_IDS[_func.ability_id] || []
  if (_func.ability_id >= 0 && !ABILITY_IDS_seen.has(_func)) {
    ABILITY_IDS[_func.ability_id].push(_func)
    ABILITY_IDS_seen.set(_func, true)
  }
}

Object.keys(ABILITY_IDS).forEach((key) => {
  Object.freeze(ABILITY_IDS[key])
})
const FUNCTIONS_AVAILABLE = {}
FUNCTIONS.forEach((f) => {
  if (f.avail_fn) {
    FUNCTIONS_AVAILABLE[f.id.key] = f
  }
})

let _RAW_FUNCTIONS = [
  Function.raw_ui_func(0, "no_op", raw_no_op),
  Function.raw_ui_func(168, "raw_move_camera", raw_move_camera),
  Function.raw_ability(2, "Attack_pt", raw_cmd_pt, 3674),
  Function.raw_ability(3, "Attack_unit", raw_cmd_unit, 3674),
  Function.raw_ability(4, "Attack_Attack_pt", raw_cmd_pt, 23, 3674),
  Function.raw_ability(6, "Attack_AttackBuilding_pt", raw_cmd_pt, 2048, 3674),
  Function.raw_ability(5, "Attack_Attack_unit", raw_cmd_unit, 23, 3674),
  Function.raw_ability(7, "Attack_AttackBuilding_unit", raw_cmd_unit, 2048, 3674),
  Function.raw_ability(539, "Attack_Battlecruiser_pt", raw_cmd_pt, 3771, 3674),
  Function.raw_ability(540, "Attack_Battlecruiser_unit", raw_cmd_unit, 3771, 3674),
  Function.raw_ability(8, "Attack_Redirect_pt", raw_cmd_pt, 1682, 3674),
  Function.raw_ability(9, "Attack_Redirect_unit", raw_cmd_unit, 1682, 3674),
  Function.raw_ability(88, "Behavior_BuildingAttackOff_quick", raw_cmd, 2082), // wrong / baneling
  Function.raw_ability(87, "Behavior_BuildingAttackOn_quick", raw_cmd, 2081), // wrong / baneling
  Function.raw_ability(169, "Behavior_CloakOff_quick", raw_cmd, 3677),
  Function.raw_ability(170, "Behavior_CloakOff_Banshee_quick", raw_cmd, 393, 3677),
  Function.raw_ability(171, "Behavior_CloakOff_Ghost_quick", raw_cmd, 383, 3677),
  Function.raw_ability(172, "Behavior_CloakOn_quick", raw_cmd, 3676),
  Function.raw_ability(173, "Behavior_CloakOn_Banshee_quick", raw_cmd, 392, 3676),
  Function.raw_ability(174, "Behavior_CloakOn_Ghost_quick", raw_cmd, 382, 3676),
  Function.raw_ability(175, "Behavior_GenerateCreepOff_quick", raw_cmd, 1693),
  Function.raw_ability(176, "Behavior_GenerateCreepOn_quick", raw_cmd, 1692),
  Function.raw_ability(178, "Behavior_HoldFireOff_Ghost_quick", raw_cmd, 38, 3689),
  Function.raw_ability(179, "Behavior_HoldFireOff_Lurker_quick", raw_cmd, 2552, 3689),
  Function.raw_ability(177, "Behavior_HoldFireOff_quick", raw_cmd, 3689),
  Function.raw_ability(181, "Behavior_HoldFireOn_Ghost_quick", raw_cmd, 36, 3688),
  Function.raw_ability(182, "Behavior_HoldFireOn_Lurker_quick", raw_cmd, 2550, 3688),
  Function.raw_ability(180, "Behavior_HoldFireOn_quick", raw_cmd, 3688),
  Function.raw_ability(158, "Behavior_PulsarBeamOff_quick", raw_cmd, 2376),
  Function.raw_ability(159, "Behavior_PulsarBeamOn_quick", raw_cmd, 2375),
  Function.raw_ability(183, "Build_Armory_pt", raw_cmd_pt, 331),
  Function.raw_ability(36, "Build_Assimilator_unit", raw_cmd_unit, 882),
  Function.raw_ability(184, "Build_BanelingNest_pt", raw_cmd_pt, 1162),
  Function.raw_ability(185, "Build_Barracks_pt", raw_cmd_pt, 321),
  Function.raw_ability(186, "Build_Bunker_pt", raw_cmd_pt, 324),
  Function.raw_ability(187, "Build_CommandCenter_pt", raw_cmd_pt, 318),
  Function.raw_ability(188, "Build_CreepTumor_pt", raw_cmd_pt, 3691),
  Function.raw_ability(189, "Build_CreepTumor_Queen_pt", raw_cmd_pt, 1694, 3691),
  Function.raw_ability(190, "Build_CreepTumor_Tumor_pt", raw_cmd_pt, 1733, 3691),
  Function.raw_ability(47, "Build_CyberneticsCore_pt", raw_cmd_pt, 894),
  Function.raw_ability(44, "Build_DarkShrine_pt", raw_cmd_pt, 891),
  Function.raw_ability(191, "Build_EngineeringBay_pt", raw_cmd_pt, 322),
  Function.raw_ability(192, "Build_EvolutionChamber_pt", raw_cmd_pt, 1156),
  Function.raw_ability(193, "Build_Extractor_unit", raw_cmd_unit, 1154),
  Function.raw_ability(194, "Build_Factory_pt", raw_cmd_pt, 328),
  Function.raw_ability(39, "Build_FleetBeacon_pt", raw_cmd_pt, 885),
  Function.raw_ability(38, "Build_Forge_pt", raw_cmd_pt, 884),
  Function.raw_ability(195, "Build_FusionCore_pt", raw_cmd_pt, 333),
  Function.raw_ability(37, "Build_Gateway_pt", raw_cmd_pt, 883),
  Function.raw_ability(196, "Build_GhostAcademy_pt", raw_cmd_pt, 327),
  Function.raw_ability(197, "Build_Hatchery_pt", raw_cmd_pt, 1152),
  Function.raw_ability(198, "Build_HydraliskDen_pt", raw_cmd_pt, 1157),
  Function.raw_ability(199, "Build_InfestationPit_pt", raw_cmd_pt, 1160),
  Function.raw_ability(200, "Build_Interceptors_autocast", raw_autocast, 1042),
  Function.raw_ability(66, "Build_Interceptors_quick", raw_cmd, 1042),
  Function.raw_ability(201, "Build_LurkerDen_pt", raw_cmd_pt, 1163),
  Function.raw_ability(202, "Build_MissileTurret_pt", raw_cmd_pt, 323),
  Function.raw_ability(34, "Build_Nexus_pt", raw_cmd_pt, 880),
  Function.raw_ability(203, "Build_Nuke_quick", raw_cmd, 710),
  Function.raw_ability(204, "Build_NydusNetwork_pt", raw_cmd_pt, 1161),
  Function.raw_ability(205, "Build_NydusWorm_pt", raw_cmd_pt, 1768),
  Function.raw_ability(41, "Build_PhotonCannon_pt", raw_cmd_pt, 887),
  Function.raw_ability(35, "Build_Pylon_pt", raw_cmd_pt, 881),
  Function.raw_ability(207, "Build_Reactor_pt", raw_cmd_pt, 3683),
  Function.raw_ability(206, "Build_Reactor_quick", raw_cmd, 3683),
  Function.raw_ability(209, "Build_Reactor_Barracks_pt", raw_cmd_pt, 422, 3683),
  Function.raw_ability(208, "Build_Reactor_Barracks_quick", raw_cmd, 422, 3683),
  Function.raw_ability(211, "Build_Reactor_Factory_pt", raw_cmd_pt, 455, 3683),
  Function.raw_ability(210, "Build_Reactor_Factory_quick", raw_cmd, 455, 3683),
  Function.raw_ability(213, "Build_Reactor_Starport_pt", raw_cmd_pt, 488, 3683),
  Function.raw_ability(212, "Build_Reactor_Starport_quick", raw_cmd, 488, 3683),
  Function.raw_ability(214, "Build_Refinery_pt", raw_cmd_unit, 320),
  Function.raw_ability(215, "Build_RoachWarren_pt", raw_cmd_pt, 1165),
  Function.raw_ability(45, "Build_RoboticsBay_pt", raw_cmd_pt, 892),
  Function.raw_ability(46, "Build_RoboticsFacility_pt", raw_cmd_pt, 893),
  Function.raw_ability(216, "Build_SensorTower_pt", raw_cmd_pt, 326),
  Function.raw_ability(48, "Build_ShieldBattery_pt", raw_cmd_pt, 895),
  Function.raw_ability(217, "Build_SpawningPool_pt", raw_cmd_pt, 1155),
  Function.raw_ability(218, "Build_SpineCrawler_pt", raw_cmd_pt, 1166),
  Function.raw_ability(219, "Build_Spire_pt", raw_cmd_pt, 1158),
  Function.raw_ability(220, "Build_SporeCrawler_pt", raw_cmd_pt, 1167),
  Function.raw_ability(42, "Build_Stargate_pt", raw_cmd_pt, 889),
  Function.raw_ability(221, "Build_Starport_pt", raw_cmd_pt, 329),
  Function.raw_ability(95, "Build_StasisTrap_pt", raw_cmd_pt, 2505),
  Function.raw_ability(222, "Build_SupplyDepot_pt", raw_cmd_pt, 319),
  Function.raw_ability(224, "Build_TechLab_pt", raw_cmd_pt, 3682),
  Function.raw_ability(223, "Build_TechLab_quick", raw_cmd, 3682),
  Function.raw_ability(226, "Build_TechLab_Barracks_pt", raw_cmd_pt, 421, 3682),
  Function.raw_ability(225, "Build_TechLab_Barracks_quick", raw_cmd, 421, 3682),
  Function.raw_ability(228, "Build_TechLab_Factory_pt", raw_cmd_pt, 454, 3682),
  Function.raw_ability(227, "Build_TechLab_Factory_quick", raw_cmd, 454, 3682),
  Function.raw_ability(230, "Build_TechLab_Starport_pt", raw_cmd_pt, 487, 3682),
  Function.raw_ability(229, "Build_TechLab_Starport_quick", raw_cmd, 487, 3682),
  Function.raw_ability(43, "Build_TemplarArchive_pt", raw_cmd_pt, 890),
  Function.raw_ability(40, "Build_TwilightCouncil_pt", raw_cmd_pt, 886),
  Function.raw_ability(231, "Build_UltraliskCavern_pt", raw_cmd_pt, 1159),
  Function.raw_ability(232, "BurrowDown_quick", raw_cmd, 3661),
  Function.raw_ability(233, "BurrowDown_Baneling_quick", raw_cmd, 1374, 3661),
  Function.raw_ability(234, "BurrowDown_Drone_quick", raw_cmd, 1378, 3661),
  Function.raw_ability(235, "BurrowDown_Hydralisk_quick", raw_cmd, 1382, 3661),
  Function.raw_ability(236, "BurrowDown_Infestor_quick", raw_cmd, 1444, 3661),
  Function.raw_ability(237, "BurrowDown_InfestorTerran_quick", raw_cmd, 1394, 3661),
  Function.raw_ability(238, "BurrowDown_Lurker_quick", raw_cmd, 2108, 3661),
  Function.raw_ability(239, "BurrowDown_Queen_quick", raw_cmd, 1433, 3661),
  Function.raw_ability(240, "BurrowDown_Ravager_quick", raw_cmd, 2340, 3661),
  Function.raw_ability(241, "BurrowDown_Roach_quick", raw_cmd, 1386, 3661),
  Function.raw_ability(242, "BurrowDown_SwarmHost_quick", raw_cmd, 2014, 3661),
  Function.raw_ability(243, "BurrowDown_Ultralisk_quick", raw_cmd, 1512, 3661),
  Function.raw_ability(244, "BurrowDown_WidowMine_quick", raw_cmd, 2095, 3661),
  Function.raw_ability(245, "BurrowDown_Zergling_quick", raw_cmd, 1390, 3661),
  Function.raw_ability(247, "BurrowUp_autocast", raw_autocast, 3662),
  Function.raw_ability(246, "BurrowUp_quick", raw_cmd, 3662),
  Function.raw_ability(249, "BurrowUp_Baneling_autocast", raw_autocast, 1376, 3662),
  Function.raw_ability(248, "BurrowUp_Baneling_quick", raw_cmd, 1376, 3662),
  Function.raw_ability(250, "BurrowUp_Drone_quick", raw_cmd, 1380, 3662),
  Function.raw_ability(252, "BurrowUp_Hydralisk_autocast", raw_autocast, 1384, 3662),
  Function.raw_ability(251, "BurrowUp_Hydralisk_quick", raw_cmd, 1384, 3662),
  Function.raw_ability(253, "BurrowUp_Infestor_quick", raw_cmd, 1446, 3662),
  Function.raw_ability(255, "BurrowUp_InfestorTerran_autocast", raw_autocast, 1396, 3662),
  Function.raw_ability(254, "BurrowUp_InfestorTerran_quick", raw_cmd, 1396, 3662),
  Function.raw_ability(256, "BurrowUp_Lurker_quick", raw_cmd, 2110, 3662),
  Function.raw_ability(258, "BurrowUp_Queen_autocast", raw_autocast, 1435, 3662),
  Function.raw_ability(257, "BurrowUp_Queen_quick", raw_cmd, 1435, 3662),
  Function.raw_ability(260, "BurrowUp_Ravager_autocast", raw_autocast, 2342, 3662),
  Function.raw_ability(259, "BurrowUp_Ravager_quick", raw_cmd, 2342, 3662),
  Function.raw_ability(262, "BurrowUp_Roach_autocast", raw_autocast, 1388, 3662),
  Function.raw_ability(261, "BurrowUp_Roach_quick", raw_cmd, 1388, 3662),
  Function.raw_ability(263, "BurrowUp_SwarmHost_quick", raw_cmd, 2016, 3662),
  Function.raw_ability(265, "BurrowUp_Ultralisk_autocast", raw_autocast, 1514, 3662),
  Function.raw_ability(264, "BurrowUp_Ultralisk_quick", raw_cmd, 1514, 3662),
  Function.raw_ability(266, "BurrowUp_WidowMine_quick", raw_cmd, 2097, 3662),
  Function.raw_ability(268, "BurrowUp_Zergling_autocast", raw_autocast, 1392, 3662),
  Function.raw_ability(267, "BurrowUp_Zergling_quick", raw_cmd, 1392, 3662),
  Function.raw_ability(98, "Cancel_quick", raw_cmd, 3659),
  Function.raw_ability(123, "Cancel_AdeptPhaseShift_quick", raw_cmd, 2594, 3659),
  Function.raw_ability(124, "Cancel_AdeptShadePhaseShift_quick", raw_cmd, 2596, 3659),
  Function.raw_ability(269, "Cancel_BarracksAddOn_quick", raw_cmd, 451, 3659),
  Function.raw_ability(125, "Cancel_BuildInProgress_quick", raw_cmd, 314, 3659),
  Function.raw_ability(270, "Cancel_CreepTumor_quick", raw_cmd, 1763, 3659),
  Function.raw_ability(271, "Cancel_FactoryAddOn_quick", raw_cmd, 484, 3659),
  Function.raw_ability(126, "Cancel_GravitonBeam_quick", raw_cmd, 174, 3659),
  Function.raw_ability(272, "Cancel_HangarQueue5_quick", raw_cmd, 1038, 3671),
  Function.raw_ability(129, "Cancel_Last_quick", raw_cmd, 3671),
  Function.raw_ability(273, "Cancel_LockOn_quick", raw_cmd, 2354, 3659),
  Function.raw_ability(274, "Cancel_MorphBroodlord_quick", raw_cmd, 1373, 3659),
  Function.raw_ability(275, "Cancel_MorphGreaterSpire_quick", raw_cmd, 1221, 3659),
  Function.raw_ability(276, "Cancel_MorphHive_quick", raw_cmd, 1219, 3659),
  Function.raw_ability(277, "Cancel_MorphLair_quick", raw_cmd, 1217, 3659),
  Function.raw_ability(279, "Cancel_MorphLurkerDen_quick", raw_cmd, 2113, 3659),
  Function.raw_ability(278, "Cancel_MorphLurker_quick", raw_cmd, 2333, 3659),
  Function.raw_ability(280, "Cancel_MorphMothership_quick", raw_cmd, 1848, 3659),
  Function.raw_ability(281, "Cancel_MorphOrbital_quick", raw_cmd, 1517, 3659),
  Function.raw_ability(282, "Cancel_MorphOverlordTransport_quick", raw_cmd, 2709, 3659),
  Function.raw_ability(283, "Cancel_MorphOverseer_quick", raw_cmd, 1449, 3659),
  Function.raw_ability(284, "Cancel_MorphPlanetaryFortress_quick", raw_cmd, 1451, 3659),
  Function.raw_ability(285, "Cancel_MorphRavager_quick", raw_cmd, 2331, 3659),
  Function.raw_ability(286, "Cancel_MorphThorExplosiveMode_quick", raw_cmd, 2365, 3659),
  Function.raw_ability(287, "Cancel_NeuralParasite_quick", raw_cmd, 250, 3659),
  Function.raw_ability(288, "Cancel_Nuke_quick", raw_cmd, 1623, 3659),
  Function.raw_ability(130, "Cancel_Queue1_quick", raw_cmd, 304, 3671),
  Function.raw_ability(131, "Cancel_Queue5_quick", raw_cmd, 306, 3671),
  Function.raw_ability(289, "Cancel_QueueAddOn_quick", raw_cmd, 312, 3671),
  Function.raw_ability(132, "Cancel_QueueCancelToSelection_quick", raw_cmd, 308, 3671),
  Function.raw_ability(134, "Cancel_QueuePassiveCancelToSelection_quick", raw_cmd, 1833, 3671),
  Function.raw_ability(133, "Cancel_QueuePassive_quick", raw_cmd, 1831, 3671),
  Function.raw_ability(290, "Cancel_SpineCrawlerRoot_quick", raw_cmd, 1730, 3659),
  Function.raw_ability(291, "Cancel_SporeCrawlerRoot_quick", raw_cmd, 1732, 3659),
  Function.raw_ability(292, "Cancel_StarportAddOn_quick", raw_cmd, 517, 3659),
  Function.raw_ability(127, "Cancel_StasisTrap_quick", raw_cmd, 2535, 3659),
  Function.raw_ability(128, "Cancel_VoidRayPrismaticAlignment_quick", raw_cmd, 3707, 3659),
  Function.raw_ability(293, "Effect_Abduct_unit", raw_cmd_unit, 2067),
  Function.raw_ability(96, "Effect_AdeptPhaseShift_pt", raw_cmd_pt, 2544),
  Function.raw_ability(294, "Effect_AntiArmorMissile_unit", raw_cmd_unit, 3753),
  Function.raw_ability(295, "Effect_AutoTurret_pt", raw_cmd_pt, 1764),
  Function.raw_ability(296, "Effect_BlindingCloud_pt", raw_cmd_pt, 2063),
  Function.raw_ability(111, "Effect_Blink_pt", raw_cmd_pt, 3687),
  Function.raw_ability(135, "Effect_Blink_Stalker_pt", raw_cmd_pt, 1442, 3687),
  Function.raw_ability(112, "Effect_Blink_unit", raw_cmd_unit, 3687), // wrong/unit
  Function.raw_ability(297, "Effect_CalldownMULE_pt", raw_cmd_pt, 171),
  Function.raw_ability(298, "Effect_CalldownMULE_unit", raw_cmd_unit, 171),
  Function.raw_ability(299, "Effect_CausticSpray_unit", raw_cmd_unit, 2324),
  Function.raw_ability(302, "Effect_Charge_autocast", raw_autocast, 1819),
  Function.raw_ability(300, "Effect_Charge_pt", raw_cmd_pt, 1819),
  Function.raw_ability(301, "Effect_Charge_unit", raw_cmd_unit, 1819),
  Function.raw_ability(122, "Effect_ChronoBoostEnergyCost_unit", raw_cmd_unit, 3755), // new 4.0?
  Function.raw_ability(33, "Effect_ChronoBoost_unit", raw_cmd_unit, 261), // wrong / old?
  Function.raw_ability(303, "Effect_Contaminate_unit", raw_cmd_unit, 1825),
  Function.raw_ability(304, "Effect_CorrosiveBile_pt", raw_cmd_pt, 2338),
  Function.raw_ability(305, "Effect_EMP_pt", raw_cmd_pt, 1628),
  Function.raw_ability(306, "Effect_EMP_unit", raw_cmd_unit, 1628),
  Function.raw_ability(307, "Effect_Explode_quick", raw_cmd, 42),
  Function.raw_ability(157, "Effect_Feedback_unit", raw_cmd_unit, 140),
  Function.raw_ability(79, "Effect_ForceField_pt", raw_cmd_pt, 1526),
  Function.raw_ability(308, "Effect_FungalGrowth_pt", raw_cmd_pt, 74),
  Function.raw_ability(309, "Effect_FungalGrowth_unit", raw_cmd_unit, 74),
  Function.raw_ability(310, "Effect_GhostSnipe_unit", raw_cmd_unit, 2714),
  Function.raw_ability(32, "Effect_GravitonBeam_unit", raw_cmd_unit, 173),
  Function.raw_ability(20, "Effect_GuardianShield_quick", raw_cmd, 76),
  Function.raw_ability(312, "Effect_Heal_autocast", raw_autocast, 386),
  Function.raw_ability(311, "Effect_Heal_unit", raw_cmd_unit, 386),
  Function.raw_ability(313, "Effect_ImmortalBarrier_autocast", raw_autocast, 2328),
  Function.raw_ability(91, "Effect_ImmortalBarrier_quick", raw_cmd, 2328),
  Function.raw_ability(314, "Effect_InfestedTerrans_pt", raw_cmd_pt, 247),
  Function.raw_ability(315, "Effect_InjectLarva_unit", raw_cmd_unit, 251),
  Function.raw_ability(316, "Effect_InterferenceMatrix_unit", raw_cmd_unit, 3747),
  Function.raw_ability(317, "Effect_KD8Charge_pt", raw_cmd_pt, 2588),
  Function.raw_ability(538, "Effect_KD8Charge_unit", raw_cmd_unit, 2588),
  Function.raw_ability(318, "Effect_LockOn_unit", raw_cmd_unit, 2350),
  Function.raw_ability(541, "Effect_LockOn_autocast", raw_autocast, 2350),
  Function.raw_ability(319, "Effect_LocustSwoop_pt", raw_cmd_pt, 2387),
  Function.raw_ability(110, "Effect_MassRecall_pt", raw_cmd_pt, 3686),
  Function.raw_ability(136, "Effect_MassRecall_Mothership_pt", raw_cmd_pt, 2368, 3686),
  Function.raw_ability(162, "Effect_MassRecall_Nexus_pt", raw_cmd_pt, 3757, 3686),
  Function.raw_ability(137, "Effect_MassRecall_StrategicRecall_pt", raw_cmd_pt, 142, 3686),
  Function.raw_ability(320, "Effect_MedivacIgniteAfterburners_quick", raw_cmd, 2116),
  Function.raw_ability(321, "Effect_NeuralParasite_unit", raw_cmd_unit, 249),
  Function.raw_ability(322, "Effect_NukeCalldown_pt", raw_cmd_pt, 1622),
  Function.raw_ability(90, "Effect_OracleRevelation_pt", raw_cmd_pt, 2146),
  Function.raw_ability(323, "Effect_ParasiticBomb_unit", raw_cmd_unit, 2542),
  Function.raw_ability(65, "Effect_PsiStorm_pt", raw_cmd_pt, 1036),
  Function.raw_ability(167, "Effect_PurificationNova_pt", raw_cmd_pt, 2346),
  Function.raw_ability(324, "Effect_Repair_autocast", raw_autocast, 3685),
  Function.raw_ability(108, "Effect_Repair_pt", raw_cmd_pt, 3685),
  Function.raw_ability(109, "Effect_Repair_unit", raw_cmd_unit, 3685),
  Function.raw_ability(326, "Effect_Repair_Mule_autocast", raw_autocast, 78, 3685),
  Function.raw_ability(325, "Effect_Repair_Mule_unit", raw_cmd_unit, 78, 3685),
  Function.raw_ability(328, "Effect_Repair_RepairDrone_autocast", raw_autocast, 3751, 3685),
  Function.raw_ability(327, "Effect_Repair_RepairDrone_unit", raw_cmd_unit, 3751, 3685),
  Function.raw_ability(330, "Effect_Repair_SCV_autocast", raw_autocast, 316, 3685),
  Function.raw_ability(329, "Effect_Repair_SCV_unit", raw_cmd_unit, 316, 3685),
  Function.raw_ability(331, "Effect_Restore_autocast", raw_autocast, 3765),
  Function.raw_ability(161, "Effect_Restore_unit", raw_cmd_unit, 3765),
  Function.raw_ability(332, "Effect_Salvage_quick", raw_cmd, 32),
  Function.raw_ability(333, "Effect_Scan_pt", raw_cmd_pt, 399),
  Function.raw_ability(113, "Effect_ShadowStride_pt", raw_cmd_pt, 2700, 3687),
  Function.raw_ability(334, "Effect_SpawnChangeling_quick", raw_cmd, 181),
  Function.raw_ability(335, "Effect_SpawnLocusts_pt", raw_cmd_pt, 2704),
  Function.raw_ability(336, "Effect_SpawnLocusts_unit", raw_cmd_unit, 2704),
  Function.raw_ability(337, "Effect_Spray_pt", raw_cmd_pt, 3684),
  Function.raw_ability(338, "Effect_Spray_Protoss_pt", raw_cmd_pt, 30, 3684),
  Function.raw_ability(339, "Effect_Spray_Terran_pt", raw_cmd_pt, 26, 3684),
  Function.raw_ability(340, "Effect_Spray_Zerg_pt", raw_cmd_pt, 28, 3684),
  Function.raw_ability(341, "Effect_Stim_quick", raw_cmd, 3675),
  Function.raw_ability(342, "Effect_Stim_Marauder_quick", raw_cmd, 253, 3675),
  Function.raw_ability(343, "Effect_Stim_Marauder_Redirect_quick", raw_cmd, 1684, 3675),
  Function.raw_ability(344, "Effect_Stim_Marine_quick", raw_cmd, 380, 3675),
  Function.raw_ability(345, "Effect_Stim_Marine_Redirect_quick", raw_cmd, 1683, 3675),
  Function.raw_ability(346, "Effect_SupplyDrop_unit", raw_cmd_unit, 255),
  Function.raw_ability(347, "Effect_TacticalJump_pt", raw_cmd_pt, 2358),
  Function.raw_ability(348, "Effect_TimeWarp_pt", raw_cmd_pt, 2244),
  Function.raw_ability(349, "Effect_Transfusion_unit", raw_cmd_unit, 1664),
  Function.raw_ability(350, "Effect_ViperConsume_unit", raw_cmd_unit, 2073),
  Function.raw_ability(94, "Effect_VoidRayPrismaticAlignment_quick", raw_cmd, 2393),
  Function.raw_ability(353, "Effect_WidowMineAttack_autocast", raw_autocast, 2099),
  Function.raw_ability(351, "Effect_WidowMineAttack_pt", raw_cmd_pt, 2099),
  Function.raw_ability(352, "Effect_WidowMineAttack_unit", raw_cmd_unit, 2099),
  Function.raw_ability(537, "Effect_YamatoGun_unit", raw_cmd_unit, 401),
  Function.raw_ability(93, "Hallucination_Adept_quick", raw_cmd, 2391),
  Function.raw_ability(22, "Hallucination_Archon_quick", raw_cmd, 146),
  Function.raw_ability(23, "Hallucination_Colossus_quick", raw_cmd, 148),
  Function.raw_ability(92, "Hallucination_Disruptor_quick", raw_cmd, 2389),
  Function.raw_ability(24, "Hallucination_HighTemplar_quick", raw_cmd, 150),
  Function.raw_ability(25, "Hallucination_Immortal_quick", raw_cmd, 152),
  Function.raw_ability(89, "Hallucination_Oracle_quick", raw_cmd, 2114),
  Function.raw_ability(26, "Hallucination_Phoenix_quick", raw_cmd, 154),
  Function.raw_ability(27, "Hallucination_Probe_quick", raw_cmd, 156),
  Function.raw_ability(28, "Hallucination_Stalker_quick", raw_cmd, 158),
  Function.raw_ability(29, "Hallucination_VoidRay_quick", raw_cmd, 160),
  Function.raw_ability(30, "Hallucination_WarpPrism_quick", raw_cmd, 162),
  Function.raw_ability(31, "Hallucination_Zealot_quick", raw_cmd, 164),
  Function.raw_ability(354, "Halt_Building_quick", raw_cmd, 315, 3660),
  Function.raw_ability(99, "Halt_quick", raw_cmd, 3660),
  Function.raw_ability(355, "Halt_TerranBuild_quick", raw_cmd, 348, 3660),
  Function.raw_ability(102, "Harvest_Gather_unit", raw_cmd_unit, 3666),
  Function.raw_ability(356, "Harvest_Gather_Drone_unit", raw_cmd_unit, 1183, 3666),
  Function.raw_ability(357, "Harvest_Gather_Mule_unit", raw_cmd_unit, 166, 3666),
  Function.raw_ability(358, "Harvest_Gather_Probe_unit", raw_cmd_unit, 298, 3666),
  Function.raw_ability(359, "Harvest_Gather_SCV_unit", raw_cmd_unit, 295, 3666),
  Function.raw_ability(103, "Harvest_Return_quick", raw_cmd, 3667),
  Function.raw_ability(360, "Harvest_Return_Drone_quick", raw_cmd, 1184, 3667),
  Function.raw_ability(361, "Harvest_Return_Mule_quick", raw_cmd, 167, 3667),
  Function.raw_ability(154, "Harvest_Return_Probe_quick", raw_cmd, 299, 3667),
  Function.raw_ability(362, "Harvest_Return_SCV_quick", raw_cmd, 296, 3667),
  Function.raw_ability(17, "HoldPosition_quick", raw_cmd, 3793),
  Function.raw_ability(542, "HoldPosition_Battlecruiser_quick", raw_cmd, 3778, 3793),
  Function.raw_ability(543, "HoldPosition_Hold_quick", raw_cmd, 18, 3793),
  Function.raw_ability(364, "Land_Barracks_pt", raw_cmd_pt, 554, 3678),
  Function.raw_ability(365, "Land_CommandCenter_pt", raw_cmd_pt, 419, 3678),
  Function.raw_ability(366, "Land_Factory_pt", raw_cmd_pt, 520, 3678),
  Function.raw_ability(367, "Land_OrbitalCommand_pt", raw_cmd_pt, 1524, 3678),
  Function.raw_ability(363, "Land_pt", raw_cmd_pt, 3678),
  Function.raw_ability(368, "Land_Starport_pt", raw_cmd_pt, 522, 3678),
  Function.raw_ability(370, "Lift_Barracks_quick", raw_cmd, 452, 3679),
  Function.raw_ability(371, "Lift_CommandCenter_quick", raw_cmd, 417, 3679),
  Function.raw_ability(372, "Lift_Factory_quick", raw_cmd, 485, 3679),
  Function.raw_ability(373, "Lift_OrbitalCommand_quick", raw_cmd, 1522, 3679),
  Function.raw_ability(369, "Lift_quick", raw_cmd, 3679),
  Function.raw_ability(374, "Lift_Starport_quick", raw_cmd, 518, 3679),
  Function.raw_ability(376, "LoadAll_CommandCenter_quick", raw_cmd, 416, 3663),
  Function.raw_ability(375, "LoadAll_quick", raw_cmd, 3663),
  Function.raw_ability(377, "Load_Bunker_unit", raw_cmd_unit, 407, 3668),
  Function.raw_ability(378, "Load_Medivac_unit", raw_cmd_unit, 394, 3668),
  Function.raw_ability(379, "Load_NydusNetwork_unit", raw_cmd_unit, 1437, 3668),
  Function.raw_ability(380, "Load_NydusWorm_unit", raw_cmd_unit, 2370, 3668),
  Function.raw_ability(381, "Load_Overlord_unit", raw_cmd_unit, 1406, 3668),
  Function.raw_ability(104, "Load_unit", raw_cmd_unit, 3668),
  Function.raw_ability(382, "Load_WarpPrism_unit", raw_cmd_unit, 911, 3668),
  Function.raw_ability(86, "Morph_Archon_quick", raw_cmd, 1766),
  Function.raw_ability(383, "Morph_BroodLord_quick", raw_cmd, 1372),
  Function.raw_ability(78, "Morph_Gateway_quick", raw_cmd, 1520),
  Function.raw_ability(384, "Morph_GreaterSpire_quick", raw_cmd, 1220),
  Function.raw_ability(385, "Morph_Hellbat_quick", raw_cmd, 1998),
  Function.raw_ability(386, "Morph_Hellion_quick", raw_cmd, 1978),
  Function.raw_ability(387, "Morph_Hive_quick", raw_cmd, 1218),
  Function.raw_ability(388, "Morph_Lair_quick", raw_cmd, 1216),
  Function.raw_ability(389, "Morph_LiberatorAAMode_quick", raw_cmd, 2560),
  Function.raw_ability(390, "Morph_LiberatorAGMode_pt", raw_cmd_pt, 2558),
  Function.raw_ability(392, "Morph_LurkerDen_quick", raw_cmd, 2112),
  Function.raw_ability(391, "Morph_Lurker_quick", raw_cmd, 2332),
  Function.raw_ability(393, "Morph_Mothership_quick", raw_cmd, 1847),
  Function.raw_ability(121, "Morph_ObserverMode_quick", raw_cmd, 3739),
  Function.raw_ability(394, "Morph_OrbitalCommand_quick", raw_cmd, 1516),
  Function.raw_ability(395, "Morph_OverlordTransport_quick", raw_cmd, 2708),
  Function.raw_ability(397, "Morph_OverseerMode_quick", raw_cmd, 3745),
  Function.raw_ability(396, "Morph_Overseer_quick", raw_cmd, 1448),
  Function.raw_ability(398, "Morph_OversightMode_quick", raw_cmd, 3743),
  Function.raw_ability(399, "Morph_PlanetaryFortress_quick", raw_cmd, 1450),
  Function.raw_ability(400, "Morph_Ravager_quick", raw_cmd, 2330),
  Function.raw_ability(401, "Morph_Root_pt", raw_cmd_pt, 3680),
  Function.raw_ability(402, "Morph_SiegeMode_quick", raw_cmd, 388),
  Function.raw_ability(403, "Morph_SpineCrawlerRoot_pt", raw_cmd_pt, 1729, 3680),
  Function.raw_ability(404, "Morph_SpineCrawlerUproot_quick", raw_cmd, 1725, 3681),
  Function.raw_ability(405, "Morph_SporeCrawlerRoot_pt", raw_cmd_pt, 1731, 3680),
  Function.raw_ability(406, "Morph_SporeCrawlerUproot_quick", raw_cmd, 1727, 3681),
  Function.raw_ability(407, "Morph_SupplyDepot_Lower_quick", raw_cmd, 556),
  Function.raw_ability(408, "Morph_SupplyDepot_Raise_quick", raw_cmd, 558),
  Function.raw_ability(160, "Morph_SurveillanceMode_quick", raw_cmd, 3741),
  Function.raw_ability(409, "Morph_ThorExplosiveMode_quick", raw_cmd, 2364),
  Function.raw_ability(410, "Morph_ThorHighImpactMode_quick", raw_cmd, 2362),
  Function.raw_ability(411, "Morph_Unsiege_quick", raw_cmd, 390),
  Function.raw_ability(412, "Morph_Uproot_quick", raw_cmd, 3681),
  Function.raw_ability(413, "Morph_VikingAssaultMode_quick", raw_cmd, 403),
  Function.raw_ability(414, "Morph_VikingFighterMode_quick", raw_cmd, 405),
  Function.raw_ability(77, "Morph_WarpGate_quick", raw_cmd, 1518),
  Function.raw_ability(544, "Morph_WarpGate_autocast", raw_autocast, 1518),
  Function.raw_ability(80, "Morph_WarpPrismPhasingMode_quick", raw_cmd, 1528),
  Function.raw_ability(81, "Morph_WarpPrismTransportMode_quick", raw_cmd, 1530),
  Function.raw_ability(13, "Move_pt", raw_cmd_pt, 3794),
  Function.raw_ability(14, "Move_unit", raw_cmd_unit, 3794),
  Function.raw_ability(545, "Move_Battlecruiser_pt", raw_cmd_pt, 3776, 3794),
  Function.raw_ability(546, "Move_Battlecruiser_unit", raw_cmd_unit, 3776, 3794),
  Function.raw_ability(547, "Move_Move_pt", raw_cmd_pt, 16, 3794),
  Function.raw_ability(548, "Move_Move_unit", raw_cmd_unit, 16, 3794),
  Function.raw_ability(15, "Patrol_pt", raw_cmd_pt, 3795),
  Function.raw_ability(16, "Patrol_unit", raw_cmd_unit, 3795),
  Function.raw_ability(549, "Patrol_Battlecruiser_pt", raw_cmd_pt, 3777, 3795),
  Function.raw_ability(550, "Patrol_Battlecruiser_unit", raw_cmd_unit, 3777, 3795),
  Function.raw_ability(551, "Patrol_Patrol_pt", raw_cmd_pt, 17, 3795),
  Function.raw_ability(552, "Patrol_Patrol_unit", raw_cmd_unit, 17, 3795),
  Function.raw_ability(415, "Rally_Building_pt", raw_cmd_pt, 195, 3673),
  Function.raw_ability(416, "Rally_Building_unit", raw_cmd_unit, 195, 3673),
  Function.raw_ability(417, "Rally_CommandCenter_pt", raw_cmd_pt, 203, 3690),
  Function.raw_ability(418, "Rally_CommandCenter_unit", raw_cmd_unit, 203, 3690),
  Function.raw_ability(419, "Rally_Hatchery_Units_pt", raw_cmd_pt, 211, 3673),
  Function.raw_ability(420, "Rally_Hatchery_Units_unit", raw_cmd_unit, 211, 3673),
  Function.raw_ability(421, "Rally_Hatchery_Workers_pt", raw_cmd_pt, 212, 3690),
  Function.raw_ability(422, "Rally_Hatchery_Workers_unit", raw_cmd_unit, 212, 3690),
  Function.raw_ability(423, "Rally_Morphing_Unit_pt", raw_cmd_pt, 199, 3673),
  Function.raw_ability(424, "Rally_Morphing_Unit_unit", raw_cmd_unit, 199, 3673),
  Function.raw_ability(138, "Rally_Nexus_pt", raw_cmd_pt, 207, 3690),
  Function.raw_ability(165, "Rally_Nexus_unit", raw_cmd_unit, 207, 3690),
  Function.raw_ability(106, "Rally_Units_pt", raw_cmd_pt, 3673),
  Function.raw_ability(107, "Rally_Units_unit", raw_cmd_unit, 3673),
  Function.raw_ability(114, "Rally_Workers_pt", raw_cmd_pt, 3690),
  Function.raw_ability(115, "Rally_Workers_unit", raw_cmd_unit, 3690),
  Function.raw_ability(425, "Research_AdaptiveTalons_quick", raw_cmd, 3709),
  Function.raw_ability(85, "Research_AdeptResonatingGlaives_quick", raw_cmd, 1594),
  Function.raw_ability(426, "Research_AdvancedBallistics_quick", raw_cmd, 805),
  Function.raw_ability(553, "Research_AnabolicSynthesis_quick", raw_cmd, 263),
  Function.raw_ability(427, "Research_BansheeCloakingField_quick", raw_cmd, 790),
  Function.raw_ability(428, "Research_BansheeHyperflightRotors_quick", raw_cmd, 799),
  Function.raw_ability(429, "Research_BattlecruiserWeaponRefit_quick", raw_cmd, 1532),
  Function.raw_ability(84, "Research_Blink_quick", raw_cmd, 1593),
  Function.raw_ability(430, "Research_Burrow_quick", raw_cmd, 1225),
  Function.raw_ability(431, "Research_CentrifugalHooks_quick", raw_cmd, 1482),
  Function.raw_ability(83, "Research_Charge_quick", raw_cmd, 1592),
  Function.raw_ability(432, "Research_ChitinousPlating_quick", raw_cmd, 265),
  Function.raw_ability(433, "Research_CombatShield_quick", raw_cmd, 731),
  Function.raw_ability(434, "Research_ConcussiveShells_quick", raw_cmd, 732),
  Function.raw_ability(554, "Research_CycloneLockOnDamage_quick", raw_cmd, 769),
  Function.raw_ability(435, "Research_CycloneRapidFireLaunchers_quick", raw_cmd, 768),
  Function.raw_ability(436, "Research_DrillingClaws_quick", raw_cmd, 764),
  Function.raw_ability(563, "Research_EnhancedShockwaves_quick", raw_cmd, 822),
  Function.raw_ability(69, "Research_ExtendedThermalLance_quick", raw_cmd, 1097),
  Function.raw_ability(437, "Research_GlialRegeneration_quick", raw_cmd, 216),
  Function.raw_ability(67, "Research_GraviticBooster_quick", raw_cmd, 1093),
  Function.raw_ability(68, "Research_GraviticDrive_quick", raw_cmd, 1094),
  Function.raw_ability(438, "Research_GroovedSpines_quick", raw_cmd, 1282),
  Function.raw_ability(440, "Research_HighCapacityFuelTanks_quick", raw_cmd, 804),
  Function.raw_ability(439, "Research_HiSecAutoTracking_quick", raw_cmd, 650),
  Function.raw_ability(441, "Research_InfernalPreigniter_quick", raw_cmd, 761),
  Function.raw_ability(18, "Research_InterceptorGravitonCatapult_quick", raw_cmd, 44),
  Function.raw_ability(442, "Research_MuscularAugments_quick", raw_cmd, 1283),
  Function.raw_ability(443, "Research_NeosteelFrame_quick", raw_cmd, 655),
  Function.raw_ability(444, "Research_NeuralParasite_quick", raw_cmd, 1455),
  Function.raw_ability(445, "Research_PathogenGlands_quick", raw_cmd, 1454),
  Function.raw_ability(446, "Research_PersonalCloaking_quick", raw_cmd, 820),
  Function.raw_ability(19, "Research_PhoenixAnionPulseCrystals_quick", raw_cmd, 46),
  Function.raw_ability(447, "Research_PneumatizedCarapace_quick", raw_cmd, 1223),
  Function.raw_ability(139, "Research_ProtossAirArmorLevel1_quick", raw_cmd, 1565, 3692),
  Function.raw_ability(140, "Research_ProtossAirArmorLevel2_quick", raw_cmd, 1566, 3692),
  Function.raw_ability(141, "Research_ProtossAirArmorLevel3_quick", raw_cmd, 1567, 3692),
  Function.raw_ability(116, "Research_ProtossAirArmor_quick", raw_cmd, 3692),
  Function.raw_ability(142, "Research_ProtossAirWeaponsLevel1_quick", raw_cmd, 1562, 3693),
  Function.raw_ability(143, "Research_ProtossAirWeaponsLevel2_quick", raw_cmd, 1563, 3693),
  Function.raw_ability(144, "Research_ProtossAirWeaponsLevel3_quick", raw_cmd, 1564, 3693),
  Function.raw_ability(117, "Research_ProtossAirWeapons_quick", raw_cmd, 3693),
  Function.raw_ability(145, "Research_ProtossGroundArmorLevel1_quick", raw_cmd, 1065, 3694),
  Function.raw_ability(146, "Research_ProtossGroundArmorLevel2_quick", raw_cmd, 1066, 3694),
  Function.raw_ability(147, "Research_ProtossGroundArmorLevel3_quick", raw_cmd, 1067, 3694),
  Function.raw_ability(118, "Research_ProtossGroundArmor_quick", raw_cmd, 3694),
  Function.raw_ability(148, "Research_ProtossGroundWeaponsLevel1_quick", raw_cmd, 1062, 3695),
  Function.raw_ability(149, "Research_ProtossGroundWeaponsLevel2_quick", raw_cmd, 1063, 3695),
  Function.raw_ability(150, "Research_ProtossGroundWeaponsLevel3_quick", raw_cmd, 1064, 3695),
  Function.raw_ability(119, "Research_ProtossGroundWeapons_quick", raw_cmd, 3695),
  Function.raw_ability(151, "Research_ProtossShieldsLevel1_quick", raw_cmd, 1068, 3696),
  Function.raw_ability(152, "Research_ProtossShieldsLevel2_quick", raw_cmd, 1069, 3696),
  Function.raw_ability(153, "Research_ProtossShieldsLevel3_quick", raw_cmd, 1070, 3696),
  Function.raw_ability(120, "Research_ProtossShields_quick", raw_cmd, 3696),
  Function.raw_ability(70, "Research_PsiStorm_quick", raw_cmd, 1126),
  Function.raw_ability(448, "Research_RavenCorvidReactor_quick", raw_cmd, 793),
  Function.raw_ability(449, "Research_RavenRecalibratedExplosives_quick", raw_cmd, 803),
  Function.raw_ability(97, "Research_ShadowStrike_quick", raw_cmd, 2720),
  Function.raw_ability(450, "Research_SmartServos_quick", raw_cmd, 766),
  Function.raw_ability(451, "Research_Stimpack_quick", raw_cmd, 730),
  Function.raw_ability(453, "Research_TerranInfantryArmorLevel1_quick", raw_cmd, 656, 3697),
  Function.raw_ability(454, "Research_TerranInfantryArmorLevel2_quick", raw_cmd, 657, 3697),
  Function.raw_ability(455, "Research_TerranInfantryArmorLevel3_quick", raw_cmd, 658, 3697),
  Function.raw_ability(452, "Research_TerranInfantryArmor_quick", raw_cmd, 3697),
  Function.raw_ability(457, "Research_TerranInfantryWeaponsLevel1_quick", raw_cmd, 652, 3698),
  Function.raw_ability(458, "Research_TerranInfantryWeaponsLevel2_quick", raw_cmd, 653, 3698),
  Function.raw_ability(459, "Research_TerranInfantryWeaponsLevel3_quick", raw_cmd, 654, 3698),
  Function.raw_ability(456, "Research_TerranInfantryWeapons_quick", raw_cmd, 3698),
  Function.raw_ability(461, "Research_TerranShipWeaponsLevel1_quick", raw_cmd, 861, 3699),
  Function.raw_ability(462, "Research_TerranShipWeaponsLevel2_quick", raw_cmd, 862, 3699),
  Function.raw_ability(463, "Research_TerranShipWeaponsLevel3_quick", raw_cmd, 863, 3699),
  Function.raw_ability(460, "Research_TerranShipWeapons_quick", raw_cmd, 3699),
  Function.raw_ability(464, "Research_TerranStructureArmorUpgrade_quick", raw_cmd, 651),
  Function.raw_ability(466, "Research_TerranVehicleAndShipPlatingLevel1_quick", raw_cmd, 864, 3700),
  Function.raw_ability(467, "Research_TerranVehicleAndShipPlatingLevel2_quick", raw_cmd, 865, 3700),
  Function.raw_ability(468, "Research_TerranVehicleAndShipPlatingLevel3_quick", raw_cmd, 866, 3700),
  Function.raw_ability(465, "Research_TerranVehicleAndShipPlating_quick", raw_cmd, 3700),
  Function.raw_ability(470, "Research_TerranVehicleWeaponsLevel1_quick", raw_cmd, 855, 3701),
  Function.raw_ability(471, "Research_TerranVehicleWeaponsLevel2_quick", raw_cmd, 856, 3701),
  Function.raw_ability(472, "Research_TerranVehicleWeaponsLevel3_quick", raw_cmd, 857, 3701),
  Function.raw_ability(469, "Research_TerranVehicleWeapons_quick", raw_cmd, 3701),
  Function.raw_ability(473, "Research_TunnelingClaws_quick", raw_cmd, 217),
  Function.raw_ability(82, "Research_WarpGate_quick", raw_cmd, 1568),
  Function.raw_ability(475, "Research_ZergFlyerArmorLevel1_quick", raw_cmd, 1315, 3702),
  Function.raw_ability(476, "Research_ZergFlyerArmorLevel2_quick", raw_cmd, 1316, 3702),
  Function.raw_ability(477, "Research_ZergFlyerArmorLevel3_quick", raw_cmd, 1317, 3702),
  Function.raw_ability(474, "Research_ZergFlyerArmor_quick", raw_cmd, 3702),
  Function.raw_ability(479, "Research_ZergFlyerAttackLevel1_quick", raw_cmd, 1312, 3703),
  Function.raw_ability(480, "Research_ZergFlyerAttackLevel2_quick", raw_cmd, 1313, 3703),
  Function.raw_ability(481, "Research_ZergFlyerAttackLevel3_quick", raw_cmd, 1314, 3703),
  Function.raw_ability(478, "Research_ZergFlyerAttack_quick", raw_cmd, 3703),
  Function.raw_ability(483, "Research_ZergGroundArmorLevel1_quick", raw_cmd, 1189, 3704),
  Function.raw_ability(484, "Research_ZergGroundArmorLevel2_quick", raw_cmd, 1190, 3704),
  Function.raw_ability(485, "Research_ZergGroundArmorLevel3_quick", raw_cmd, 1191, 3704),
  Function.raw_ability(482, "Research_ZergGroundArmor_quick", raw_cmd, 3704),
  Function.raw_ability(494, "Research_ZerglingAdrenalGlands_quick", raw_cmd, 1252),
  Function.raw_ability(495, "Research_ZerglingMetabolicBoost_quick", raw_cmd, 1253),
  Function.raw_ability(487, "Research_ZergMeleeWeaponsLevel1_quick", raw_cmd, 1186, 3705),
  Function.raw_ability(488, "Research_ZergMeleeWeaponsLevel2_quick", raw_cmd, 1187, 3705),
  Function.raw_ability(489, "Research_ZergMeleeWeaponsLevel3_quick", raw_cmd, 1188, 3705),
  Function.raw_ability(486, "Research_ZergMeleeWeapons_quick", raw_cmd, 3705),
  Function.raw_ability(491, "Research_ZergMissileWeaponsLevel1_quick", raw_cmd, 1192, 3706),
  Function.raw_ability(492, "Research_ZergMissileWeaponsLevel2_quick", raw_cmd, 1193, 3706),
  Function.raw_ability(493, "Research_ZergMissileWeaponsLevel3_quick", raw_cmd, 1194, 3706),
  Function.raw_ability(490, "Research_ZergMissileWeapons_quick", raw_cmd, 3706),
  Function.raw_ability(10, "Scan_Move_pt", raw_cmd_pt, 19, 3674),
  Function.raw_ability(11, "Scan_Move_unit", raw_cmd_unit, 19, 3674),
  Function.raw_ability(1, "Smart_pt", raw_cmd_pt, 1),
  Function.raw_ability(12, "Smart_unit", raw_cmd_unit, 1),
  Function.raw_ability(101, "Stop_quick", raw_cmd, 3665),
  Function.raw_ability(555, "Stop_Battlecruiser_quick", raw_cmd, 3783, 3665),
  Function.raw_ability(496, "Stop_Building_quick", raw_cmd, 2057, 3665),
  Function.raw_ability(497, "Stop_Redirect_quick", raw_cmd, 1691, 3665),
  Function.raw_ability(155, "Stop_Stop_quick", raw_cmd, 4, 3665),
  Function.raw_ability(54, "Train_Adept_quick", raw_cmd, 922),
  Function.raw_ability(498, "Train_Baneling_quick", raw_cmd, 80),
  Function.raw_ability(499, "Train_Banshee_quick", raw_cmd, 621),
  Function.raw_ability(500, "Train_Battlecruiser_quick", raw_cmd, 623),
  Function.raw_ability(56, "Train_Carrier_quick", raw_cmd, 948),
  Function.raw_ability(62, "Train_Colossus_quick", raw_cmd, 978),
  Function.raw_ability(501, "Train_Corruptor_quick", raw_cmd, 1353),
  Function.raw_ability(502, "Train_Cyclone_quick", raw_cmd, 597),
  Function.raw_ability(52, "Train_DarkTemplar_quick", raw_cmd, 920),
  Function.raw_ability(166, "Train_Disruptor_quick", raw_cmd, 994),
  Function.raw_ability(503, "Train_Drone_quick", raw_cmd, 1342),
  Function.raw_ability(504, "Train_Ghost_quick", raw_cmd, 562),
  Function.raw_ability(505, "Train_Hellbat_quick", raw_cmd, 596),
  Function.raw_ability(506, "Train_Hellion_quick", raw_cmd, 595),
  Function.raw_ability(51, "Train_HighTemplar_quick", raw_cmd, 919),
  Function.raw_ability(507, "Train_Hydralisk_quick", raw_cmd, 1345),
  Function.raw_ability(63, "Train_Immortal_quick", raw_cmd, 979),
  Function.raw_ability(508, "Train_Infestor_quick", raw_cmd, 1352),
  Function.raw_ability(509, "Train_Liberator_quick", raw_cmd, 626),
  Function.raw_ability(510, "Train_Marauder_quick", raw_cmd, 563),
  Function.raw_ability(511, "Train_Marine_quick", raw_cmd, 560),
  Function.raw_ability(512, "Train_Medivac_quick", raw_cmd, 620),
  Function.raw_ability(513, "Train_MothershipCore_quick", raw_cmd, 1853),
  Function.raw_ability(21, "Train_Mothership_quick", raw_cmd, 110),
  Function.raw_ability(514, "Train_Mutalisk_quick", raw_cmd, 1346),
  Function.raw_ability(61, "Train_Observer_quick", raw_cmd, 977),
  Function.raw_ability(58, "Train_Oracle_quick", raw_cmd, 954),
  Function.raw_ability(515, "Train_Overlord_quick", raw_cmd, 1344),
  Function.raw_ability(55, "Train_Phoenix_quick", raw_cmd, 946),
  Function.raw_ability(64, "Train_Probe_quick", raw_cmd, 1006),
  Function.raw_ability(516, "Train_Queen_quick", raw_cmd, 1632),
  Function.raw_ability(517, "Train_Raven_quick", raw_cmd, 622),
  Function.raw_ability(518, "Train_Reaper_quick", raw_cmd, 561),
  Function.raw_ability(519, "Train_Roach_quick", raw_cmd, 1351),
  Function.raw_ability(520, "Train_SCV_quick", raw_cmd, 524),
  Function.raw_ability(53, "Train_Sentry_quick", raw_cmd, 921),
  Function.raw_ability(521, "Train_SiegeTank_quick", raw_cmd, 591),
  Function.raw_ability(50, "Train_Stalker_quick", raw_cmd, 917),
  Function.raw_ability(522, "Train_SwarmHost_quick", raw_cmd, 1356),
  Function.raw_ability(59, "Train_Tempest_quick", raw_cmd, 955),
  Function.raw_ability(523, "Train_Thor_quick", raw_cmd, 594),
  Function.raw_ability(524, "Train_Ultralisk_quick", raw_cmd, 1348),
  Function.raw_ability(525, "Train_VikingFighter_quick", raw_cmd, 624),
  Function.raw_ability(526, "Train_Viper_quick", raw_cmd, 1354),
  Function.raw_ability(57, "Train_VoidRay_quick", raw_cmd, 950),
  Function.raw_ability(76, "TrainWarp_Adept_pt", raw_cmd_pt, 1419),
  Function.raw_ability(74, "TrainWarp_DarkTemplar_pt", raw_cmd_pt, 1417),
  Function.raw_ability(73, "TrainWarp_HighTemplar_pt", raw_cmd_pt, 1416),
  Function.raw_ability(60, "Train_WarpPrism_quick", raw_cmd, 976),
  Function.raw_ability(75, "TrainWarp_Sentry_pt", raw_cmd_pt, 1418),
  Function.raw_ability(72, "TrainWarp_Stalker_pt", raw_cmd_pt, 1414),
  Function.raw_ability(71, "TrainWarp_Zealot_pt", raw_cmd_pt, 1413),
  Function.raw_ability(527, "Train_WidowMine_quick", raw_cmd, 614),
  Function.raw_ability(49, "Train_Zealot_quick", raw_cmd, 916),
  Function.raw_ability(528, "Train_Zergling_quick", raw_cmd, 1343),
  Function.raw_ability(529, "UnloadAllAt_Medivac_pt", raw_cmd_pt, 396, 3669),
  Function.raw_ability(530, "UnloadAllAt_Medivac_unit", raw_cmd_unit, 396, 3669),
  Function.raw_ability(531, "UnloadAllAt_Overlord_pt", raw_cmd_pt, 1408, 3669),
  Function.raw_ability(532, "UnloadAllAt_Overlord_unit", raw_cmd_unit, 1408, 3669),
  Function.raw_ability(105, "UnloadAllAt_pt", raw_cmd_pt, 3669),
  Function.raw_ability(164, "UnloadAllAt_unit", raw_cmd_unit, 3669),
  Function.raw_ability(156, "UnloadAllAt_WarpPrism_pt", raw_cmd_pt, 913, 3669),
  Function.raw_ability(163, "UnloadAllAt_WarpPrism_unit", raw_cmd_unit, 913, 3669),
  Function.raw_ability(533, "UnloadAll_Bunker_quick", raw_cmd, 408, 3664),
  Function.raw_ability(534, "UnloadAll_CommandCenter_quick", raw_cmd, 413, 3664),
  Function.raw_ability(535, "UnloadAll_NydusNetwork_quick", raw_cmd, 1438, 3664),
  Function.raw_ability(536, "UnloadAll_NydusWorm_quick", raw_cmd, 2371, 3664),
  Function.raw_ability(100, "UnloadAll_quick", raw_cmd, 3664),
  Function.raw_ability(556, "UnloadUnit_quick", raw_cmd, 3796),
  Function.raw_ability(557, "UnloadUnit_Bunker_quick", raw_cmd, 410, 3796),
  Function.raw_ability(558, "UnloadUnit_CommandCenter_quick", raw_cmd, 415, 3796),
  Function.raw_ability(559, "UnloadUnit_Medivac_quick", raw_cmd, 397, 3796),
  Function.raw_ability(560, "UnloadUnit_NydusNetwork_quick", raw_cmd, 1440, 3796),
  Function.raw_ability(561, "UnloadUnit_Overlord_quick", raw_cmd, 1409, 3796),
  Function.raw_ability(562, "UnloadUnit_WarpPrism_quick", raw_cmd, 914, 3796),
]

tempDict = {}
// Create an IntEnum of the function names/ids so that printing the id will
// show something useful.
_RAW_FUNCTIONS.forEach((f) => {
  tempDict[f.name] = f.id
})
const _Raw_Functions = Enum.IntEnum("_Raw_Functions", tempDict)
_RAW_FUNCTIONS = _RAW_FUNCTIONS
  .map((f) => f._replace({ id: _Raw_Functions(f.id) }))

const RAW_FUNCTIONS = new Functions(_RAW_FUNCTIONS)

// Some indexes to support features.py and action conversion.
const RAW_ABILITY_IDS = {}
const RAW_ABILITY_IDS_seen = new Map()
for (let i = 0; i < RAW_FUNCTIONS.length; i++) {
  const _func = RAW_FUNCTIONS[i];
  RAW_ABILITY_IDS[_func.ability_id] = RAW_ABILITY_IDS[_func.ability_id] || []
  if (_func.ability_id >= 0 && !RAW_ABILITY_IDS_seen.has(_func)) {
    RAW_ABILITY_IDS[_func.ability_id].push(_func)
    RAW_ABILITY_IDS_seen.set(_func, true)
  }
}

Object.keys(RAW_ABILITY_IDS).forEach((key) => {
  Object.freeze(RAW_ABILITY_IDS[key])
})
const RAW_FUNCTIONS_AVAILABLE = {}
RAW_FUNCTIONS.forEach((f) => {
  if (f.avail_fn) {
    RAW_FUNCTIONS_AVAILABLE[f.id] = f
  }
})
const RAW_ABILITY_ID_TO_FUNC_ID = {}
Object.keys(RAW_ABILITY_IDS).forEach((key) => {
  const set = RAW_ABILITY_IDS[key]
  const minIndex = Math.min(...set.map((f) => f.id))
  const minF = set.find((f) => f.id == minIndex)
  RAW_ABILITY_ID_TO_FUNC_ID[key] = minF
})
// const temp_fields_ref["functionn", "argumentss"]
class FunctionCall extends namedtuple("FunctionCall", ["functionn", "argumentss"]) {
  /*Represents a function call action.
  Attributes:
    function: Store the function id, eg 2 for select_point.
    arguments: The list of arguments for that function, each being a list of
        ints. For select_point this could be: [[0], [23, 38]].
  */
  constructor() {
    //eslint-disable-next-line
    if (typeof arguments[0] === 'object' && arguments.length === 1 && FunctionCall._fields.length > 1) {
      const kwargs = arguments[0]  //eslint-disable-line
      if (kwargs.arguments || kwargs.funtion) {
        kwargs.argumentss = kwargs.arguments
        kwargs.functionn = kwargs.function
      }
    }

    super(...arguments) //eslint-disable-line
    const self = this
    Object.defineProperty(this, 'function', {
      get: function() {
        return self[0]
      },
      set: function(val) {
        self[0] = val; return val
      }
    });
    Object.defineProperty(this, 'arguments', {
      get: function() {
        return self[1]
      },
      set: function(val) {
        self[1] = val; return val
      }
    });
  }

  static init_with_validation(_function, _arguments, raw = false) {
    /*Return a `FunctionCall` given some validation for the function and args.

    Args:
      function: A function name or id, to be converted into a function id Enum.
      arguments: An iterable of function arguments. Arguments that are enum
          types can be passed by name. Arguments that only take one value (ie
          not a point) don't need to be wrapped in a list.
      raw: Whether this is a raw function call.

    Returns:
      A new `FunctionCall` instance.``

    Raises:
      KeyError: if the enum name doesn't exist.
      ValueError: if the enum id doesn't exist.
    */
    const func = raw ? RAW_FUNCTIONS[_function.key] : FUNCTIONS[_function.key]
    const args = []
    const zipped = zip(_arguments, func.args)
    zipped.forEach(([arg, arg_type]) => {
      arg = numpy_to_python(arg)
      if (arg_type.values) {
        if (typeof (arg) === 'string') {
          try {
            args.push([arg_type.values[arg]])
          } catch (err) {
            throw new Error(`KeyError: Unknown argument value: ${arg}, valid values: ${JSON.stringify(arg_type.values.map((v) => v.name))}`)
          }
        } else {
          if (isinstance(arg, Array)) {
            arg = arg[0]
          }
          try {
            if (isinstance(arg_type.values, Enum.EnumMeta)) {
              arg = Number(arg)
            }
            args.push([arg_type.values(arg)])
          } catch (err) {
            console.log('Error using arg: ', arg, '  err: ', err)
            throw new ValueError(`Unknown argument value: ${arg}, valid values: ${arg_type.values}`)
          }
        }
      } else if (typeof (arg) === 'number' || typeof (arg) === 'boolean') {
        args.push([arg])
      } else if (isinstance(arg, Array)) {
        args.push(arg)
      } else {
        throw new ValueError(`Unknown argument value type: ${typeof (arg)}, expected int or list of ints, or "
            "their numpy equivalents. Value: ${arg}`)
      }
    })
    return new FunctionCall(func.id, args)
  }

  static all_arguments(_function, _arguments, raw = false) {
    /*Helper function for creating `FunctionCall`s with `Arguments`.

    Args:
      function: The value to store for the action function.
      arguments: The values to store for the arguments of the action. Can either
        be an `Arguments` object, a `dict`, or an iterable. If a `dict` or an
        iterable is provided, the values will be unpacked into an `Arguments`
        object.
      raw: Whether this is a raw function call.

    Returns:
      A new `FunctionCall` instance.
    */
    const args_type = raw ? RawArguments : Arguments
    if (isObject(_arguments)) {
      _arguments = args_type(_arguments)
    } else if (!isinstance(_arguments, args_type)) {
      // both Arguments and RawArguments constructors can handle array
      _arguments = args_type(_arguments)
    }
    return new FunctionCall(_function, _arguments)
  }
}

class ValidActions extends namedtuple("ValidActions", ["types", "functions"]) {}

module.exports = {
  ActionSpace,
  ABILITY_FUNCTIONS,
  ABILITY_IDS,
  always,
  ArgumentType,
  Arguments,
  autocast,
  build_queue,
  cmd_quick,
  control_group,
  ControlGroupAct,
  CONTROL_GROUP_ACT_OPTIONS,
  cmd_screen,
  cmd_minimap,
  Function,
  FunctionCall,
  Functions,
  FUNCTIONS,
  FUNCTIONS_AVAILABLE,
  FUNCTION_TYPES,
  Queued,
  QUEUED_OPTIONS,
  move_camera,
  no_op,
  numpy_to_python,
  POINT_REQUIRED_FUNCS,
  RawArguments,
  RAW_ABILITY_FUNCTIONS,
  RAW_ABILITY_IDS,
  RAW_ABILITY_ID_TO_FUNC_ID,
  raw_autocast,
  raw_cmd,
  raw_cmd_pt,
  raw_cmd_unit,
  RAW_FUNCTIONS,
  RAW_FUNCTIONS_AVAILABLE,
  raw_move_camera,
  raw_no_op,
  RAW_TYPES,
  SelectAdd,
  select_army,
  SELECT_ADD_OPTIONS,
  select_idle_worker,
  select_larva,
  select_point,
  SelectPointAct,
  SELECT_POINT_ACT_OPTIONS,
  select_rect,
  select_unit,
  SelectUnitAct,
  SELECT_UNIT_ACT_OPTIONS,
  select_warp_gates,
  SELECT_WORKER_OPTIONS,
  SelectWorker,
  spatial,
  TYPES,
  unload,
  ValidActions,
}

}).call(this,"/")
},{"path":6,"python-enum":103,"s2clientprotocol":"s2clientprotocol"}],"/colors.js":[function(require,module,exports){
(function (__dirname){
const path = require('path') //eslint-disable-line
const np = require(path.resolve(__dirname, './numpy.js'))
const static_data = require(path.resolve(__dirname, './static_data.js'))
const pythonUtils = require(path.resolve(__dirname, './pythonUtils.js'))
const { assert, int, namedtuple, zip } = pythonUtils

/*eslint-disable no-use-before-define*/

class Color extends namedtuple('Color', ['r', 'g', 'b']) {
  set(r = this.r, g = this.g, b = this.b) {
    return new Color(r, g, b)
  }

  round() {
    return this.set(Math.round(this.r), Math.round(this.g), Math.round(this.b))
  }

  floor() {
    return this.set(int(this.r), int(this.g), int(this.b))
  }

  ceil() {
    return this.set(Math.ceil(this.r), Math.ceil(this.g), Math.ceil(this.b))
  }

  toString() {
    return `${this.r},${this.g},${this.b}`
  }

  add(o) {
    return this.set(this.r + o.r, this.g + o.g, this.b + o.b)
  }

  sub(o) {
    return this.set(this.r - o.r, this.g - o.g, this.b - o.b)
  }

  mul(val) {
    return this.set(this.r * val, this.g * val, this.b * val)
  }

  __truediv__(val) {
    return this.set(this.r / val, this.g / val, this.b / val)
  }

  floordiv(val) {
    return this.set(Math.floor(this.r / val), Math.floor(this.g / val), Math.floor(this.b / val))
  }

  div(val) {
    return this.__truediv__(val)
  }

  toCSS() {
    return `rgb(${this.r},${this.g},${this.b})`
  }
}

const black = new Color(0, 0, 0)
const white = new Color(255, 255, 255)
const red = new Color(255, 0, 0)
const green = new Color(0, 255, 0)
const blue = new Color(0, 0, 255)
const cyan = new Color(0, 255, 255)
const yellow = new Color(255, 255, 0)
const purple = new Color(255, 0, 255)

function getMaskFirst(s) {
  const v = np.range(0, s).mul(6 / s) // range of [0,6)
  const ones = np.ones([s])
  const zeros = np.zeros([s])
  // (0 < v) & (v < 1)
  return v.greater(zeros).logicalAnd(v.less(ones))
}
function getMaskN(s, n = 2) {
  const v = np.range(0, s).mul(6 / s) // range of [0,6)
  const ones = np.ones([s])
  const lower = ones.mul(n - 1)
  const upper = ones.mul(n)
  // n = 2: (1 <= h) & (h < 2)
  return v.greaterEqual(lower).logicalAnd(v.less(upper))
}

function getMaskLast(s) {
  const v = np.range(0, s).mul(6 / s) // range of [0,6)
  const ones = np.ones([s])
  const fives = ones.mul(5)
  // (5 <= h
  return v.greaterEqual(fives)
}
function smooth_hue_palette(scale) {
  //Takes an array of ints and returns a corresponding colored rgb array.//
  // http://en.wikipedia.org/wiki/HSL_and_HSV//From_HSL
  // Based on http://stackoverflow.com/a/17382854 , with simplifications and
  // optimizations. Assumes S=1, L=0.5, meaning C=1 and m=0.
  // 0 stays black, everything else moves into a hue.
  // Some initial values and scaling. Check wikipedia for variable meanings.
  const h = np.range(0, scale).mul(6 / scale)
  //x = 255 * (1 - np.absolute(np.mod(h, 2) - 1))
  const x = ((np.abs(np.mod(h, 2).add(-1))).add(-1)).mul(255)
  // Initialize outputs to zero/black
  // const out = np.zeros(mask.shape.concat(3), 'float32')
  let r = np.zeros([scale])
  let g = np.zeros([scale])
  let b = np.zeros([scale])

  // mask = (0 < h) & (h < 1)
  let mask = getMaskFirst(scale)
  // const c = 255
  const c = np.ones([scale]).mul(255)
  // r[mask] = c
  r = c.where(mask, r)
  // g[mask] = x[mask]
  g = x.where(mask, g)

  // mask = (1 <= h) & (h < 2)
  mask = getMaskN(scale, 2)
  // r[mask] = x[mask]
  r = x.where(mask, r)
  // g[mask] = c
  g = c.where(mask, g)

  //mask = (2 <= h) & (h < 3)
  mask = getMaskN(scale, 3)
  // g[mask] = c
  g = c.where(mask, g)
  // b[mask] = x[mask]
  b = x.where(mask, b)

  // mask = (3 <= h) & (h < 4)
  mask = getMaskN(scale, 4)
  // g[mask] = x[mask]
  g = x.where(mask, g)
  // b[mask] = c
  b = c.where(mask, b)

  // mask = (4 <= h) & (h < 5)
  mask = getMaskN(scale, 5)
  // r[mask] = x[mask]
  r = x.where(mask, r)
  // b[mask] = c
  b = c.where(mask, b)

  // mask = 5 <= h
  mask = getMaskLast(scale)
  // r[mask] = c
  r = c.where(mask, r)
  // b[mask] = x[mask]
  b = x.where(mask, b)

  return np.stack([r, g, b]).transpose([1, 0])
}

function shuffled_hue(scale) {
  let palette = smooth_hue_palette(scale)
  palette = palette.arraySync()
  // const bufferSize = palette.size
  // palette = tf.data.array(palette.arraySync())
  // palette = palette.shuffle(bufferSize, 0.5) // Return a fixed shuffle
  np.util.shuffle(palette)
  return palette
  // return np.tensor(palette)
}

function piece_wise_linear(scale, points) {
  //Create a palette that is piece-wise linear given some colors at points.//
  assert(points.length >= 2, 'points.length >= 2')
  assert(points[0][0] === 0, 'points[0][0] === 0')
  assert(points[points.length - 1][0] === 1, 'points[points.length - 1][0] === 1')
  zip(points.slice(0, -1), points.slice(1))
    .forEach((zipPair) => {
      const [i, j] = zipPair
      np.util.assert(i < j)
    })
  let [p1, c1] = points[0]
  let [p2, c2] = points[1]
  const out = Array(scale)
  out[0] = new Color(0, 0, 0)
  let next_pt = 2
  let frac
  let v
  for (let i = 1; i < scale; i++) {
    v = i / scale
    if (v > p2) {
      p1 = p2
      c1 = c2
      p2 = points[next_pt][0]
      c2 = points[next_pt][1]
      next_pt += 1
    }
    frac = (v - p1) / (p2 - p1)
    out[i] = c1.mul(1 - frac).add(c2.mul(frac))
  }
  return out
}

function winter(scale) {
  return piece_wise_linear(scale, [
    [0, new Color(0, 0.5, 0.4).mul(255)],
    [1, new Color(1, 1, 0.4).mul(255)]
  ])
}

function hot(scale) {
  return piece_wise_linear(scale, [
    [0, new Color(0.5, 0, 0).mul(255)],
    [0.2, new Color(1, 0, 0).mul(255)],
    [0.6, new Color(1, 1, 0).mul(255)],
    [1, new Color(1, 1, 1).mul(255)]
  ])
}

function height_map(scale) {
  return piece_wise_linear(scale, [
    [0, new Color(0, 0, 0)], // Abyss
    [40 / 255, new Color(67, 109, 95)], // Water, little below this height.
    [50 / 255, new Color(168, 152, 129)], // Beach
    [60 / 255, new Color(154, 124, 90)], // Sand, the mode height.
    [70 / 255, new Color(117, 150, 96)], // Grass
    [80 / 255, new Color(166, 98, 97)], // Dirt, should be the top.
    [1, new Color(255, 255, 100)], // Heaven. Shouldn't be seen.
  ])
}

/*eslint-disable no-multi-spaces*/
// Palette used to color player_relative features.
const PLAYER_RELATIVE_PALETTE = [
  black,                 // Background.
  new Color(0, 142, 0),      // Self. (Green).
  yellow,                // Ally.
  new Color(129, 166, 196),  // Neutral. (Cyan.)
  new Color(113, 25, 34),    // Enemy. (Red).
]

const PLAYER_ABSOLUTE_PALETTE = [
  black,                 // Background
  new Color(0, 142, 0),      // 1: Green
  new Color(113, 25, 34),    // 2: Red
  new Color(223, 215, 67),   // 3: Yellow
  new Color(66, 26, 121),    // 4: Purple
  new Color(222, 144, 50),   // 5: Orange
  new Color(46, 72, 237),    // 6: Blue
  new Color(207, 111, 176),  // 7: Pink
  new Color(189, 251, 157),  // 8: Light green
  white.mul(0.1),           // 9: Does the game ever have more than 8 players?
  white.mul(0.1),           // 10: Does the game ever have more than 8 players?
  white.mul(0.1),           // 11: Does the game ever have more than 8 players?
  white.mul(0.1),           // 12: Does the game ever have more than 8 players?
  white.mul(0.1),           // 13: Does the game ever have more than 8 players?
  white.mul(0.1),           // 14: Does the game ever have more than 8 players?
  white.mul(0.1),           // 15: Does the game ever have more than 8 players?
  new Color(129, 166, 196),  // 16 Neutral: Cyan
]

const VISIBILITY_PALETTE = [
  black,         // Hidden
  white.mul(0.25),  // Fogged
  white.mul(0.6),   // Visible
]

const CAMERA_PALETTE = [black, white.mul(0.6)]
const CREEP_PALETTE = [black, purple.mul(0.4)]
const POWER_PALETTE = [black, cyan.mul(0.7)]
const SELECTED_PALETTE = [black, green.mul(0.7)]

function unit_type(scale = null) {
  //Returns a palette that maps unit types to rgb colors.//
  return categorical(static_data.UNIT_TYPES, scale)
}

function buffs(scale = null) {
  //Returns a palette that maps buffs to rgb colors.//
  return categorical(static_data.BUFFS, scale)
}

function categorical(options, scale = null) {
  // Can specify a scale to match the api or to accept unknown unit types.
  const palette_size = scale || Math.max(...options) + 1
  const palette = shuffled_hue(palette_size)
  assert(options.length <= distinct_colors.length, 'options.length <= distinct_colors.length')
  options.forEach((v, i) => {
    palette[v] = distinct_colors[i]
  })
  return palette
}

const effects = [
  [0, 0, 0],
  [72, 173, 207],
  [203, 76, 49],
  [122, 98, 209],
  [109, 183, 67],
  [192, 80, 181],
  [86, 185, 138],
  [211, 63, 115],
  [81, 128, 60],
  [182, 135, 208],
  [182, 174, 73],
  [95, 123, 196],
  [220, 146, 71],
  [187, 102, 147],
  [138, 109, 48],
  [197, 103, 99],
]

// Generated with http://tools.medialab.sciences-po.fr/iwanthue/
// 280 colors: H: 0-360, C: 0-100, L: 35-100; then shuffled.
const distinct_colors = [
  [255, 165, 150],
  [255, 255, 138],
  [0, 82, 232],
  [196, 141, 0],
  [7, 94, 71],
  [1, 138, 253],
  [152, 255, 143],
  [39, 95, 4],
  [209, 207, 0],
  [52, 255, 213],
  [89, 84, 31],
  [90, 77, 113],
  [255, 102, 141],
  [78, 184, 0],
  [96, 82, 1],
  [238, 42, 0],
  [101, 45, 194],
  [255, 57, 114],
  [1, 248, 160],
  [87, 127, 255],
  [74, 69, 167],
  [153, 255, 86],
  [0, 173, 108],
  [168, 0, 126],
  [255, 230, 75],
  [2, 195, 226],
  [120, 70, 42],
  [138, 166, 0],
  [255, 191, 133],
  [165, 0, 191],
  [0, 162, 104],
  [255, 192, 88],
  [145, 255, 161],
  [1, 247, 184],
  [162, 27, 18],
  [115, 251, 255],
  [255, 157, 168],
  [1, 129, 186],
  [228, 0, 198],
  [2, 164, 126],
  [191, 3, 0],
  [1, 108, 241],
  [255, 149, 208],
  [152, 49, 0],
  [0, 137, 99],
  [255, 244, 181],
  [1, 208, 245],
  [110, 57, 152],
  [0, 104, 91],
  [255, 203, 51],
  [255, 33, 205],
  [0, 115, 135],
  [135, 136, 255],
  [130, 199, 0],
  [115, 214, 0],
  [149, 173, 255],
  [0, 137, 117],
  [220, 255, 158],
  [3, 230, 191],
  [255, 72, 235],
  [122, 66, 72],
  [70, 82, 114],
  [159, 243, 8],
  [255, 105, 35],
  [2, 110, 200],
  [42, 94, 255],
  [254, 123, 255],
  [43, 57, 218],
  [255, 144, 85],
  [111, 75, 55],
  [132, 68, 0],
  [0, 110, 58],
  [138, 56, 67],
  [227, 245, 255],
  [255, 123, 171],
  [206, 145, 255],
  [79, 86, 46],
  [1, 205, 73],
  [0, 87, 162],
  [179, 146, 0],
  [63, 139, 0],
  [1, 140, 22],
  [1, 235, 254],
  [47, 87, 113],
  [133, 255, 237],
  [227, 193, 0],
  [139, 114, 0],
  [137, 15, 169],
  [244, 255, 187],
  [240, 163, 255],
  [166, 0, 78],
  [255, 72, 32],
  [86, 84, 60],
  [87, 255, 124],
  [210, 70, 0],
  [255, 175, 185],
  [0, 205, 203],
  [120, 66, 87],
  [255, 143, 236],
  [255, 248, 243],
  [0, 226, 110],
  [255, 230, 135],
  [255, 59, 163],
  [247, 0, 179],
  [117, 235, 255],
  [219, 96, 0],
  [255, 140, 172],
  [210, 255, 201],
  [78, 84, 78],
  [188, 255, 181],
  [129, 255, 173],
  [255, 154, 21],
  [255, 42, 126],
  [255, 159, 95],
  [200, 0, 175],
  [95, 223, 14],
  [77, 76, 138],
  [157, 255, 186],
  [1, 184, 192],
  [115, 124, 0],
  [167, 255, 121],
  [255, 216, 240],
  [0, 169, 235],
  [145, 50, 46],
  [144, 43, 100],
  [234, 255, 242],
  [117, 176, 255],
  [154, 65, 241],
  [62, 88, 77],
  [125, 46, 150],
  [131, 57, 91],
  [205, 0, 60],
  [255, 169, 45],
  [177, 111, 0],
  [0, 215, 154],
  [61, 108, 0],
  [246, 255, 162],
  [145, 29, 131],
  [138, 85, 255],
  [255, 138, 131],
  [112, 188, 255],
  [244, 154, 0],
  [255, 226, 222],
  [2, 191, 165],
  [166, 205, 0],
  [237, 77, 254],
  [1, 131, 204],
  [251, 0, 34],
  [178, 0, 21],
  [141, 222, 255],
  [1, 168, 204],
  [61, 207, 0],
  [46, 89, 95],
  [100, 170, 0],
  [255, 115, 75],
  [255, 199, 111],
  [255, 184, 252],
  [41, 157, 0],
  [155, 255, 100],
  [1, 199, 181],
  [105, 72, 97],
  [231, 0, 96],
  [213, 0, 142],
  [149, 47, 28],
  [255, 226, 102],
  [255, 52, 144],
  [56, 87, 99],
  [155, 22, 106],
  [179, 82, 0],
  [213, 255, 109],
  [236, 255, 99],
  [227, 0, 40],
  [86, 98, 0],
  [131, 249, 51],
  [1, 118, 89],
  [255, 209, 172],
  [171, 50, 0],
  [245, 81, 0],
  [136, 202, 255],
  [0, 110, 25],
  [227, 128, 255],
  [255, 190, 169],
  [0, 178, 39],
  [230, 255, 63],
  [255, 217, 133],
  [182, 238, 0],
  [182, 255, 209],
  [0, 172, 47],
  [94, 117, 0],
  [210, 0, 123],
  [244, 184, 0],
  [216, 160, 255],
  [134, 255, 207],
  [45, 84, 132],
  [240, 255, 132],
  [0, 147, 143],
  [199, 0, 45],
  [15, 154, 255],
  [49, 255, 249],
  [255, 159, 189],
  [255, 200, 213],
  [105, 114, 255],
  [255, 99, 228],
  [0, 180, 134],
  [212, 178, 255],
  [159, 29, 59],
  [244, 243, 0],
  [198, 164, 255],
  [1, 134, 146],
  [0, 121, 9],
  [137, 131, 0],
  [255, 178, 223],
  [122, 42, 218],
  [0, 143, 83],
  [255, 105, 120],
  [0, 134, 160],
  [164, 116, 0],
  [255, 135, 96],
  [165, 151, 0],
  [159, 96, 0],
  [255, 228, 204],
  [225, 0, 208],
  [255, 165, 135],
  [12, 68, 203],
  [90, 158, 255],
  [1, 102, 174],
  [127, 57, 112],
  [105, 55, 168],
  [203, 95, 255],
  [159, 0, 145],
  [193, 106, 0],
  [255, 131, 207],
  [200, 223, 255],
  [100, 255, 185],
  [1, 102, 116],
  [178, 255, 240],
  [1, 209, 39],
  [236, 205, 255],
  [18, 247, 88],
  [118, 72, 15],
  [1, 153, 55],
  [183, 209, 0],
  [255, 139, 42],
  [171, 125, 255],
  [1, 85, 210],
  [227, 135, 0],
  [183, 0, 96],
  [16, 202, 255],
  [194, 0, 209],
  [255, 232, 168],
  [255, 75, 149],
  [106, 63, 140],
  [101, 79, 41],
  [92, 79, 93],
  [181, 101, 255],
  [0, 235, 234],
  [92, 242, 61],
  [1, 122, 159],
  [224, 0, 173],
  [155, 185, 1],
  [127, 84, 0],
  [0, 101, 148],
  [255, 213, 42],
  [188, 255, 115],
  [255, 53, 184],
  [183, 210, 255],
  [234, 224, 255],
  [76, 88, 17],
  [253, 26, 16],
  [169, 0, 59],
  [0, 163, 81],
  [255, 173, 96],
  [210, 255, 236],
  [1, 182, 242],
  [136, 60, 30],
  [53, 92, 34],
  [1, 103, 210],
  [255, 90, 83],
  [126, 54, 124],
  [193, 249, 255],
]

module.exports = {
  buffs,
  categorical,
  Color,
  CAMERA_PALETTE,
  CREEP_PALETTE,
  distinct_colors,
  effects,
  height_map,
  hot,
  piece_wise_linear,
  PLAYER_ABSOLUTE_PALETTE,
  PLAYER_RELATIVE_PALETTE,
  POWER_PALETTE,
  SELECTED_PALETTE,
  shuffled_hue,
  smooth_hue_palette,
  VISIBILITY_PALETTE,
  winter,
  unit_type,
  //colors
  black,
  white,
  red,
  green,
  blue,
  cyan,
  yellow,
  purple,
}

}).call(this,"/")
},{"path":6}],"/features.js":[function(require,module,exports){
(function (__dirname){
const path = require('path') //eslint-disable-line
const s2clientprotocol = require('s2clientprotocol') //eslint-disable-line
const Enum = require('python-enum') //eslint-disable-line
const actions = require(path.resolve(__dirname, './actions.js'))
const colors = require(path.resolve(__dirname, './colors.js'))
const named_array = require(path.resolve(__dirname, './named_array.js'))
const point = require(path.resolve(__dirname, './point.js'))
const static_data = require(path.resolve(__dirname, './static_data.js'))
const stopwatch = require(path.resolve(__dirname, './stopwatch.js'))
const transform = require(path.resolve(__dirname, './transform.js'))
const pythonUtils = require(path.resolve(__dirname, './pythonUtils.js'))
const np = require(path.resolve(__dirname, './numpy.js'))

const sw = stopwatch.sw
const { raw_pb, sc2api_pb } = s2clientprotocol
const sc_raw = raw_pb
const sc_pb = sc2api_pb
const { clip, DefaultDict, getArgsArray, getattr, getImageData, int, isinstance, len, namedtuple, setUpProtoAction, sum, unpackbits, ValueError, withPython, zip } = pythonUtils
const EPSILON = 1e-5

const FeatureType = Enum.Enum('FeatureType', {
  SCALAR: 1,
  CATEGORICAL: 2,
})

const PlayerRelative = Enum.IntEnum('PlayerRelative', {
  /*The values for the `player_relative` feature layers.*/
  none: 0,
  SELF: 1,
  ALLY: 2,
  NEUTRAL: 3,
  ENEMY: 4,
})

const Visibility = Enum.IntEnum('Visibility', {
  /*Values for the `visibility` feature layers.*/
  HIDDEN: 0,
  SEEN: 1,
  VISIBLE: 2,
})

const Effects = Enum.IntEnum('Effects', {
  /*Values for the `effects` feature layer.*/
  none: 0,
  PsiStorm: 1,
  GuardianShield: 2,
  TemporalFieldGrowing: 3,
  TemporalField: 4,
  ThermalLance: 5,
  ScannerSweep: 6,
  NukeDot: 7,
  LiberatorDefenderZoneSetup: 8,
  LiberatorDefenderZone: 9,
  BlindingCloud: 10,
  CorrosiveBile: 11,
  LurkerSpines: 12,
})

const ScoreCumulative = Enum.IntEnum('ScoreCumulative', {
  /*Indices into the `score_cumulative` observation.*/
  score: 0,
  idle_production_time: 1,
  idle_worker_time: 2,
  total_value_units: 3,
  total_value_structures: 4,
  killed_value_units: 5,
  killed_value_structures: 6,
  collected_minerals: 7,
  collected_vespene: 8,
  collection_rate_minerals: 9,
  collection_rate_vespene: 10,
  spent_minerals: 11,
  spent_vespene: 12,
})

const ScoreByCategory = Enum.IntEnum('ScoreByCategory', {
  /*Indices for the `score_by_category` observation's first dimension.*/
  food_used: 0,
  killed_minerals: 1,
  killed_vespene: 2,
  lost_minerals: 3,
  lost_vespene: 4,
  friendly_fire_minerals: 5,
  friendly_fire_vespene: 6,
  used_minerals: 7,
  used_vespene: 8,
  total_used_minerals: 9,
  total_used_vespene: 10,
})

const ScoreCategories = Enum.IntEnum('ScoreCategories', {
  /*Indices for the `score_by_category` observation's second dimension.*/
  none: 0,
  army: 1,
  economy: 2,
  technology: 3,
  upgrade: 4,
})

const ScoreByVital = Enum.IntEnum('ScoreByVital', {
  /*Indices for the `score_by_vital` observation's first dimension.*/
  total_damage_dealt: 0,
  total_damage_taken: 1,
  total_healed: 2,
})

const ScoreVitals = Enum.IntEnum('ScoreVitals', {
  /*Indices for the `score_by_vital` observation's second dimension.*/
  life: 0,
  shields: 1,
  energy: 2,
})

const Player = Enum.IntEnum('Player', {
  /*Indices into the `player` observation.*/
  player_id: 0,
  minerals: 1,
  vespene: 2,
  food_used: 3,
  food_cap: 4,
  food_army: 5,
  food_workers: 6,
  idle_worker_count: 7,
  army_count: 8,
  warp_gate_count: 9,
  larva_count: 10,
})

const UnitLayer = Enum.IntEnum('UnitLayer', {
  /*Indices into the unit layers in the observations.*/
  unit_type: 0,
  player_relative: 1,
  health: 2,
  shields: 3,
  energy: 4,
  transport_slots_taken: 5,
  build_progress: 6,
})

const UnitCounts = Enum.IntEnum('UnitCounts', {
  /*Indices into the `unit_counts` observations.*/
  unit_type: 0,
  count: 1,
})

const FeatureUnit = Enum.IntEnum('FeatureUnit', {
  /*Indices for the `feature_unit` observations.*/
  unit_type: 0,
  alliance: 1,
  health: 2,
  shield: 3,
  energy: 4,
  cargo_space_taken: 5,
  build_progress: 6,
  health_ratio: 7,
  shield_ratio: 8,
  energy_ratio: 9,
  display_type: 10,
  owner: 11,
  x: 12,
  y: 13,
  facing: 14,
  radius: 15,
  cloak: 16,
  is_selected: 17,
  is_blip: 18,
  is_powered: 19,
  mineral_contents: 20,
  vespene_contents: 21,
  cargo_space_max: 22,
  assigned_harvesters: 23,
  ideal_harvesters: 24,
  weapon_cooldown: 25,
  order_length: 26, // If zero, the unit is idle.
  order_id_0: 27,
  order_id_1: 28,
  tag: 29, // Unique identifier for a unit (only populated for raw units).
  hallucination: 30,
  buff_id_0: 31,
  buff_id_1: 32,
  addon_unit_type: 33,
  active: 34,
  is_on_screen: 35,
  order_progress_0: 36,
  order_progress_1: 37,
  order_id_2: 38,
  order_id_3: 39,
  is_in_cargo: 40,
  buff_duration_remain: 41,
  buff_duration_max: 42,
  attack_upgrade_level: 43,
  armor_upgrade_level: 44,
  shield_upgrade_level: 45,
})

const EffectPos = Enum.IntEnum('EffectPos', {
  /*Positions of the active effects.*/
  effect: 0,
  alliance: 1,
  owner: 2,
  radius: 3,
  x: 4,
  y: 5,
})

const Radar = Enum.IntEnum('Radar', {
  /*Positions of the Sensor towers.*/
  x: 0,
  y: 1,
  radius: 2,
})

const ProductionQueue = Enum.IntEnum('ProductionQueue', {
  /*Indices for the `production_queue` observations.*/
  ability_id: 0,
  build_progress: 1,
})

class Feature extends namedtuple('Feature', ['index', 'name', 'layer_set', 'full_name', 'scale', 'type', 'palette', 'clip']) {
  /*Define properties of a feature layer.

  Attributes:
    index: Index of this layer into the set of layers.
    name: The name of the layer within the set.
    layer_set: Which set of feature layers to look at in the observation proto.
    full_name: The full name including for visualization.
    scale: Max value (+1) of this layer, used to scale the values.
    type: A FeatureType for scalar vs categorical.
    palette: A color palette for rendering.
    clip: Whether to clip the values for coloring.
  */

  constructor(kwargs) {
    super(kwargs)
    // javascript only set up
    this.color = sw.decorate(this.color.bind(this))
    if (this.palette) {
      this._palette_tf = np.tensor(this.palette, undefined, 'float32')//'int32')
    }
  }

  static get dtypes() {
    return {
      1: np.uint8,
      8: np.uint8,
      16: np.uint16,
      32: np.int32,
    }
  }

  static get sdtypes() {
    return {
      1: 'uint8',
      8: 'uint8',
      16: 'uint16',
      32: 'int32',
    }
  }

  unpack(obs) {
    //Return a correctly shaped numpy array for this feature.//
    const planes = getattr(obs.getFeatureLayerData(), this.layer_set)
    const plane = getattr(planes, this.name) || new sc_pb.ImageData()
    return this.unpack_layer(plane)
  }

  unpack_obs(obs, asTensor = false) {
    const planes = getattr(obs.getFeatureLayerData(), this.layer_set)
    const plane = getattr(planes, this.name) || new sc_pb.ImageData()
    if (asTensor) {
      return np.tensor(plane.getData())
    }
    return plane
  }

  unpack_layer(plane, asTensor, shape) {//eslint-disable-line
    return Feature.unpack_layer(plane, asTensor, shape)
  }

  static unpack_layer(plane, asTensor = true, shape) {
    //Return a correctly shaped numpy array given the feature layer bytes.//
    if (plane.getSize() === undefined) {
      return null
    }
    const size = point.Point.build(plane.getSize())
    if (size[0] === 0 && size[1] === 0) {
      // New layer that isn't implemented in this SC2 version.
      return null
    }
    // console.log('-----------------------------------')
    let data = plane.getData()
    // console.log('data: ', data.length)
    const buffer = data.buffer
    // console.log('is ArrayBuffer: '/*, buffer instanceof ArrayBuffer*/, buffer.byteLength, ' byteOffset: ', data.byteOffset)
    // console.log('buffer length: ', buffer.byteLength)
    // console.log('bits per pixel: ', plane.getBitsPerPixel())

    if (plane.getBitsPerPixel() !== 8 && plane.getBitsPerPixel() !== 1) {
      data = new Feature.dtypes[plane.getBitsPerPixel()](
        buffer.slice(data.byteOffset, data.byteOffset + data.byteLength)
      )
    }

    // console.log('typeArray data: ', data.length)
    // console.log('shape: ', size.x, ' x ', size.y)
    if (plane.getBitsPerPixel() === 1) {
      data = unpackbits(data)
      if (data.length !== (size.x * size.y)) {
        // This could happen if the correct length isn't a multiple of 8, leading
        // to some padding bits at the end of the string which are incorrectly
        // interpreted as data.
        data = data.slice(0, size.x * size.y)
      }
      // data = unpackbitsToShape(data, [size.x, size.y])
      // data.shape = [size.x, size.y]
      // return data
    }
    if (asTensor) {
      return np.tensor(data, shape || [size.y, size.x], 'int32')
    }
    return data
  }

  static unpack_image_data(plane, rgb = true, color, palette) {
    //Return a correctly shaped ImageData given the feature layer bytes.//
    if (plane.getSize() === undefined) {
      return null
    }
    const size = { x: plane.getSize().getX(), y: plane.getSize().getY() } //point.Point.build(plane.getSize())
    if (size[0] === 0 && size[1] === 0) {
      // New layer that isn't implemented in this SC2 version.
      return null
    }
    let data = plane.getData()
    const buffer = data.buffer
    if (plane.getBitsPerPixel() === 24) {
      // rgb data, don't do anything
    } else if (plane.getBitsPerPixel() !== 8 && plane.getBitsPerPixel() !== 1) {
      data = new Feature.dtypes[plane.getBitsPerPixel()](
        buffer.slice(data.byteOffset, data.byteOffset + data.byteLength)
      )
    } else if (plane.getBitsPerPixel() === 1) {
      data = unpackbits(data)
      if (data.length !== (size.x * size.y)) {
        // This could happen if the correct length isn't a multiple of 8, leading
        // to some padding bits at the end of the string which are incorrectly
        // interpreted as data.
        data = data.slice(0, size.x * size.y)
      }
    }
    if (palette) {
      clip(data, 0, palette.length - 1)
    }
    return getImageData(data, [size.x, size.y], rgb, color, palette)
  }

  unpack_rgb_image(plane) {//eslint-disable-line
    return Feature.unpack_rgb_image(plane)
  }

  static unpack_rgb_image(plane) {
    //Return a correctly shaped numpy array given the image bytes.//]
    if (plane.getBitsPerPixel() !== 24) {
      throw new ValueError(`plane.bits_per_pixel ${plane.getBitsPerPixel()} !== 24`)
    }
    const size = point.Point.build(plane.getSize())
    let data = plane.getData()
    data = np.tensor(data, [size.y, size.x, 3])
    return data
  }

  color(plane, isTensor = false) {
    if (isTensor) {
      if (this.scale) {
        // map values of plane to indexs of the palette
        plane = np.clipByValue(plane, 0, this.scale - 1)
      }
      // Palette tf is 1x n colors => n x 3
      return this._palette_tf.gather(plane)
    }
    const rgb = false
    const color = null
    return Feature.unpack_image_data(plane, rgb, color, this.palette)
  }
}

Feature.unpack_layer = sw.decorate(Feature.unpack_layer)
Feature.unpack_rgb_image = sw.decorate(Feature.unpack_rgb_image)

class ScreenFeatures extends namedtuple('ScreenFeatures', [
  'height_map', 'visibility_map', 'creep', 'power', 'player_id',
  'player_relative', 'unit_type', 'selected', 'unit_hit_points',
  'unit_hit_points_ratio', 'unit_energy', 'unit_energy_ratio', 'unit_shields',
  'unit_shields_ratio', 'unit_density', 'unit_density_aa', 'effects',
  'hallucinations', 'cloaked', 'blip', 'buffs', 'buff_duration', 'active',
  'build_progress', 'pathable', 'buildable', 'placeholder']) {
  constructor(kwargs) {
    //The set of screen feature layers.//
    const feats = {}
    let val
    Object.keys(kwargs).forEach((name) => {
      val = kwargs[name]
      const [scale, type_, palette, clip] = val //eslint-disable-line
      feats[name] = new Feature({
        index: ScreenFeatures._fields.indexOf(name),
        name,
        layer_set: 'renders',
        full_name: 'screen ' + name,
        scale,
        type: type_,
        palette: typeof (palette) === 'function' ? palette(scale) : palette,
        clip,
      })
    })
    super(feats)
  }
}

class MinimapFeatures extends namedtuple('MinimapFeatures', [
  'height_map', 'visibility_map', 'creep', 'camera', 'player_id',
  'player_relative', 'selected', 'unit_type', 'alerts', 'pathable',
  'buildable']) {
  //The set of minimap feature layers.//
  constructor(kwargs) {
    const feats = {}
    let val
    Object.keys(kwargs).forEach((name) => {
      val = kwargs[name]
      const [scale, type_, palette] = val
      feats[name] = new Feature({
        index: MinimapFeatures._fields.indexOf(name),
        name,
        layer_set: 'minimap_renders',
        full_name: 'minimap ' + name,
        scale,
        type: type_,
        palette: typeof (palette) === 'function' ? palette(scale) : palette,
        clip: false,
      })
    })
    super(feats)
  }
}

const SCREEN_FEATURES = new ScreenFeatures({
  height_map: [256, FeatureType.SCALAR, colors.height_map, false],
  visibility_map: [4, FeatureType.CATEGORICAL, colors.VISIBILITY_PALETTE, false],
  creep: [2, FeatureType.CATEGORICAL, colors.CREEP_PALETTE, false],
  power: [2, FeatureType.CATEGORICAL, colors.POWER_PALETTE, false],
  player_id: [17, FeatureType.CATEGORICAL,
    colors.PLAYER_ABSOLUTE_PALETTE, false],
  player_relative: [5, FeatureType.CATEGORICAL,
    colors.PLAYER_RELATIVE_PALETTE, false],
  unit_type: [Math.max(...static_data.UNIT_TYPES) + 1, FeatureType.CATEGORICAL,
    colors.unit_type, false],
  selected: [2, FeatureType.CATEGORICAL, colors.SELECTED_PALETTE, false],
  unit_hit_points: [1600, FeatureType.SCALAR, colors.hot, true],
  unit_hit_points_ratio: [256, FeatureType.SCALAR, colors.hot, false],
  unit_energy: [1000, FeatureType.SCALAR, colors.hot, true],
  unit_energy_ratio: [256, FeatureType.SCALAR, colors.hot, false],
  unit_shields: [1000, FeatureType.SCALAR, colors.hot, true],
  unit_shields_ratio: [256, FeatureType.SCALAR, colors.hot, false],
  unit_density: [16, FeatureType.SCALAR, colors.hot, true],
  unit_density_aa: [256, FeatureType.SCALAR, colors.hot, false],
  effects: [16, FeatureType.CATEGORICAL, colors.effects, false],
  hallucinations: [2, FeatureType.CATEGORICAL, colors.POWER_PALETTE, false],
  cloaked: [2, FeatureType.CATEGORICAL, colors.POWER_PALETTE, false],
  blip: [2, FeatureType.CATEGORICAL, colors.POWER_PALETTE, false],
  buffs: [Math.max(...static_data.BUFFS) + 1, FeatureType.CATEGORICAL,
    colors.buffs, false],
  buff_duration: [256, FeatureType.SCALAR, colors.hot, false],
  active: [2, FeatureType.CATEGORICAL, colors.POWER_PALETTE, false],
  build_progress: [256, FeatureType.SCALAR, colors.hot, false],
  pathable: [2, FeatureType.CATEGORICAL, colors.winter, false],
  buildable: [2, FeatureType.CATEGORICAL, colors.winter, false],
  placeholder: [2, FeatureType.CATEGORICAL, colors.winter, false],
})

const MINIMAP_FEATURES = new MinimapFeatures({
  height_map: [256, FeatureType.SCALAR, colors.height_map],
  visibility_map: [4, FeatureType.CATEGORICAL, colors.VISIBILITY_PALETTE],
  creep: [2, FeatureType.CATEGORICAL, colors.CREEP_PALETTE],
  camera: [2, FeatureType.CATEGORICAL, colors.CAMERA_PALETTE],
  player_id: [17, FeatureType.CATEGORICAL, colors.PLAYER_ABSOLUTE_PALETTE],
  player_relative: [5, FeatureType.CATEGORICAL,
    colors.PLAYER_RELATIVE_PALETTE],
  selected: [2, FeatureType.CATEGORICAL, colors.winter],
  unit_type: [Math.max(...static_data.UNIT_TYPES) + 1, FeatureType.CATEGORICAL,
    colors.unit_type],
  alerts: [2, FeatureType.CATEGORICAL, colors.winter],
  pathable: [2, FeatureType.CATEGORICAL, colors.winter],
  buildable: [2, FeatureType.CATEGORICAL, colors.winter],
})

function _to_point(dims) {
  //Convert (width, height) or size -> point.Point.//
  if (!dims) {
    throw new ValueError(`Must pass a valid dims argument, got:\n${dims}`)
  }
  if (isinstance(dims, [Array])) {
    if (dims.length !== 2) {
      throw new ValueError(`A two element array is expected here, got ${dims}.`)
    } else {
      const width = int(dims[0])
      const height = int(dims[1])
      if (width <= 0 || height <= 0) {
        throw new ValueError(`Must specify +ve dims, got ${dims}.`)
      }
      return new point.Point(width, height)
    }
  } else {
    const size = int(dims)
    if (size <= 0) {
      throw new ValueError(`Must specify +ve value for size, got ${dims}.`)
    }
    return new point.Point(size, size)
  }
}

class Dimensions {
  constructor(screen = null, minimap = null) {
    /*Screen and minimap dimensions configuration.
    Both screen and minimap must be specified. Sizes must be positive.
    Screen size must be greater than or equal to minimap size in both dimensions.

    Attributes:
      screen: A (width, height) int tuple or a single int to be used for both.
      minimap: A (width, height) int tuple or a single int to be used for both.
    */
    if (!screen || !minimap) {
      // arguments got passed as object
      if (screen.screen && screen.minimap) {
        const args = arguments[0] //eslint-disable-line
        screen = args.screen
        minimap = args.minimap
      } else {
        throw new ValueError(`screen and minimap must both be set, screen=${screen}, minimap=${minimap}.`)
      }
    }
    this._screen = _to_point(screen)
    this._minimap = _to_point(minimap)
  }

  get screen() {
    return this._screen
  }

  get minimap() {
    return this._minimap
  }

  toString() {
    return `Dimensions(screen=${this.screen}, minimap=${this.minimap})`
  }

  eq(other) {
    return other instanceof Dimensions && this.screen.eq(other.screen)
      && this.minimap.eq(other.minimap)
  }

  ne(other) {
    return !(this.eq(other))
  }
}

class AgentInterfaceFormat {
  //Observation and action interface format specific to a particular agent.//
  constructor({
    feature_dimensions = null,
    rgb_dimensions = null,
    raw_resolution = null,
    action_space = null,
    camera_width_world_units = null,
    use_feature_units = false,
    use_raw_units = false,
    use_raw_actions = false,
    max_raw_actions = 512,
    max_selected_units = 30,
    use_unit_counts = false,
    use_camera_position = false,
    show_cloaked = false,
    show_burrowed_shadows = false,
    show_placeholders = false,
    hide_specific_actions = true,
    action_delay_fn = null,
    send_observation_proto = false,
    crop_to_playable_area = false,
    raw_crop_to_playable_area = false,
    allow_cheating_layers = false,
    add_cargo_to_units = false
  }) {
    /*Initializer.

    Args:
      feature_dimensions: Feature layer `Dimension`s. Either this or
          rgb_dimensions (or both) must be set.
      rgb_dimensions: RGB `Dimension`. Either this or feature_dimensions
          (or both) must be set.
      raw_resolution: Discretize the `raw_units` observation's x,y to this
          resolution. Default is the map_size.
      action_space: If you pass both feature and rgb sizes, then you must also
          specify which you want to use for your actions as an ActionSpace Enum.
      camera_width_world_units: The width of your screen in world units. If your
          feature_dimensions.screen=(64, 48) and camera_width is 24, then each
          px represents 24 / 64 = 0.375 world units in each of x and y.
          It'll then represent a camera of size (24, 0.375 * 48) = (24, 18)
          world units.
      use_feature_units: Whether to include feature_unit observations.
      use_raw_units: Whether to include raw unit data in observations. This
          differs from feature_units because it includes units outside the
          screen and hidden units, and because unit positions are given in
          terms of world units instead of screen units.
      use_raw_actions: [bool] Whether to use raw actions as the interface.
          Same as specifying action_space=ActionSpace.RAW.
      max_raw_actions: [int] Maximum number of raw actions
      max_selected_units: [int] The maximum number of selected units in the
          raw interface.
      use_unit_counts: Whether to include unit_counts observation. Disabled by
          default since it gives information outside the visible area.
      use_camera_position: Whether to include the camera's position (in minimap
          coordinates) in the observations.
      show_cloaked: Whether to show limited information for cloaked units.
      show_burrowed_shadows: Whether to show limited information for burrowed
          units that leave a shadow on the ground (ie widow mines and moving
          roaches and infestors).
      show_placeholders: Whether to show buildings that are queued for
          construction.
      hide_specific_actions: [bool] Some actions (eg cancel) have many
          specific versions (cancel this building, cancel that spell) and can
          be represented in a more general form. If a specific action is
          available, the general will also be available. If you set
          `hide_specific_actions` to False, the specific versions will also be
          available, but if it's True, the specific ones will be hidden.
          Similarly, when transforming back, a specific action will be returned
          as the general action. This simplifies the action space, though can
          lead to some actions in replays not being exactly representable using
          only the general actions.
      action_delay_fn: A callable which when invoked returns a delay in game
          loops to apply to a requested action. Defaults to null, meaning no
          delays are added (actions will be executed on the next game loop,
          hence with the minimum delay of 1).
      send_observation_proto: Whether or not to send the raw observation
          response proto in the observations.
      crop_to_playable_area: Crop the feature layer minimap observations down
          from the full map area to just the playable area. Also improves the
          heightmap rendering.
      raw_crop_to_playable_area: Crop the raw units to the playable area. This
          means units will show up closer to the origin with less dead space
          around their valid locations.
      allow_cheating_layers: Show the unit types and potentially other cheating
          layers on the minimap.
      add_cargo_to_units: Whether to add the units that are currently in cargo
          to the feature_units and raw_units lists.

    Raises:
      ValueError: if the parameters are inconsistent.
    */
    if (!(feature_dimensions || rgb_dimensions || use_raw_units)) {
      throw new Error(`Must set either the feature layer or rgb dimensions, or use raw units`)
    }

    if (action_space) {
      if (!isinstance(action_space, actions.ActionSpace)) {
        throw new ValueError(' action_space must be of type ActionSpace.')
      }
      if (action_space === actions.ActionSpace.RAW) {
        use_raw_actions = true
      } else if ((action_space === actions.ActionSpace.FEATURES && !(feature_dimensions)) || (action_space === actions.ActionSpace.RGB && !(rgb_dimensions))) {
        throw new ValueError(`Action space must match the observations, action space=${action_space}, feature_dimensions=${feature_dimensions}, rgb_dimensions=${rgb_dimensions} `)
      }
    } else {
      if (use_raw_actions) {//eslint-disable-line
        action_space = actions.ActionSpace.RAW
      } else if (feature_dimensions && rgb_dimensions) {
        throw new ValueError('You must specify the action space if you have both screen and rgb observations.')
      } else if (feature_dimensions) {
        action_space = actions.ActionSpace.FEATURES
      } else {
        action_space = actions.ActionSpace.RGB
      }
    }

    if (raw_resolution) {
      raw_resolution = _to_point(raw_resolution)
    }

    if (use_raw_actions) {
      if (!use_raw_units) {
        throw new ValueError('You must set use_raw_units if you intend to use_raw_actions')
      }
      if (action_space !== actions.ActionSpace.RAW) {
        throw new ValueError('Don\'t specify both an action_space and use_raw_actions.')
      }
    }

    if (rgb_dimensions && (rgb_dimensions.screen.x < rgb_dimensions.minimap.x
      || rgb_dimensions.screen.y < rgb_dimensions.minimap.y)) {
      throw new ValueError(`RGB Screen (${rgb_dimensions.screen}) can't be smaller than the minimap (${rgb_dimensions.minimap}).`)
    }

    this._feature_dimensions = feature_dimensions
    this._rgb_dimensions = rgb_dimensions
    this._action_space = action_space
    this._camera_width_world_units = camera_width_world_units || 24
    this._use_feature_units = use_feature_units
    this._use_raw_units = use_raw_units
    this._raw_resolution = raw_resolution
    this._use_raw_actions = use_raw_actions
    this._max_raw_actions = max_raw_actions
    this._max_selected_units = max_selected_units
    this._use_unit_counts = use_unit_counts
    this._use_camera_position = use_camera_position
    this._show_cloaked = show_cloaked
    this._show_burrowed_shadows = show_burrowed_shadows
    this._show_placeholders = show_placeholders
    this._hide_specific_actions = hide_specific_actions
    this._action_delay_fn = action_delay_fn
    this._send_observation_proto = send_observation_proto
    this._add_cargo_to_units = add_cargo_to_units
    this._crop_to_playable_area = crop_to_playable_area
    this._raw_crop_to_playable_area = raw_crop_to_playable_area
    this._allow_cheating_layers = allow_cheating_layers

    if (action_space === actions.ActionSpace.FEATURES) {
      this._action_dimensions = feature_dimensions
    } else {
      this._action_dimensions = rgb_dimensions
    }
    this._pickle_args = arguments//eslint-disable-line
  }

  get feature_dimensions() {
    return this._feature_dimensions
  }

  get rgb_dimensions() {
    return this._rgb_dimensions
  }

  get action_space() {
    return this._action_space
  }

  get camera_width_world_units() {
    return this._camera_width_world_units
  }

  get use_feature_units() {
    return this._use_feature_units
  }

  get use_raw_units() {
    return this._use_raw_units
  }

  get raw_resolution() {
    return this._raw_resolution
  }

  set raw_resolution(value) {
    this._raw_resolution = value
  }

  get use_raw_actions() {
    return this._use_raw_actions
  }

  get max_raw_actions() {
    return this._max_raw_actions
  }

  get max_selected_units() {
    return this._max_selected_units
  }

  get use_unit_counts() {
    return this._use_unit_counts
  }

  get use_camera_position() {
    return this._use_camera_position
  }

  get show_cloaked() {
    return this._show_cloaked
  }

  get show_burrowed_shadows() {
    return this._show_burrowed_shadows
  }

  get show_placeholders() {
    return this._show_placeholders
  }

  get hide_specific_actions() {
    return this._hide_specific_actions
  }

  get action_delay_fn() {
    return this._action_delay_fn
  }

  get send_observation_proto() {
    return this._send_observation_proto
  }

  get add_cargo_to_units() {
    return this._add_cargo_to_units
  }

  get action_dimensions() {
    return this._action_dimensions
  }

  get crop_to_playable_area() {
    return this._crop_to_playable_area
  }

  get raw_crop_to_playable_area() {
    return this._raw_crop_to_playable_area
  }

  get allow_cheating_layers() {
    return this._allow_cheating_layers
  }
}

function parse_agent_interface_format({
  feature_screen = null,
  feature_minimap = null,
  rgb_screen = null,
  rgb_minimap = null,
  action_space = null,
  action_delays = null,
  kwargs,
}) {
  /*Creates an AgentInterfaceFormat object from keyword args.

  Convenient when using dictionaries or command-line arguments for config.

  Note that the feature_* and rgb_* properties define the respective spatial
  observation dimensions and accept:
      * null or 0 to disable that spatial observation.
      * A single int for a square observation with that side length.
      * A (int, int) tuple for a rectangular (width, height) observation.

  Args:
    feature_screen: If specified, so must feature_minimap be.
    feature_minimap: If specified, so must feature_screen be.
    rgb_screen: If specified, so must rgb_minimap be.
    rgb_minimap: If specified, so must rgb_screen be.
    action_space: ["FEATURES", "RGB", "RAW"].
    action_delays: List of relative frequencies for each of [1, 2, 3, ...]
      game loop delays on executed actions. Only used when the environment
      is non-realtime. Intended to simulate the delays which can be
      experienced when playing in realtime. Note that 1 is the minimum
      possible delay; as actions can only ever be executed on a subsequent
      game loop.
    **kwargs: Anything else is passed through to AgentInterfaceFormat.

  Returns:
    An `AgentInterfaceFormat` object.

  Raises:
    ValueError: If an invalid parameter is specified.
  */
  let feature_dimensions
  let rgb_dimensions
  if (feature_screen || feature_minimap) {
    feature_dimensions = new Dimensions(feature_screen, feature_minimap)
  } else {
    feature_dimensions = null
  }

  if (rgb_screen || rgb_minimap) {
    rgb_dimensions = new Dimensions(rgb_screen, rgb_minimap)
  } else {
    rgb_dimensions = null
  }

  function _action_delay_fn(delays) {
    //Delay frequencies per game loop delay -> fn returning game loop delay.//
    if (!delays) {
      return null
    }
    const total = sum(delays)
    let delay
    const cumulative_sum = np.cumsum(Object.keys(delays).map((key) => {
      delay = delays[key]
      return delay / total
    }))
    function fn() {
      const sample = Math.random() - EPSILON
      let cumulative
      for (let i = 0; i < cumulative_sum.length; i++) {
        cumulative = cumulative_sum[0]
        if (sample <= cumulative) {
          return i + 1
        }
      }
      throw new ValueError('Failed to sample action delay??')
    }
    return fn
  }
  const usedArgs = {
    feature_dimensions,
    rgb_dimensions,
    action_space: (action_space && actions.ActionSpace[action_space.toUpperCase()]),
    action_delay_fn: _action_delay_fn(action_delays),
    kwargs,
  }
  Object.keys(arguments[0]).forEach((key) => { //eslint-disable-line prefer-rest-params
    usedArgs[key] = usedArgs[key] || arguments[0][key] //eslint-disable-line prefer-rest-params
  })
  return new AgentInterfaceFormat(usedArgs)
}

function features_from_game_info({ game_info, agent_interface_format = null, map_name = null, kwargs }) {
  /*Construct a Features object using data extracted from game info.

  Args:
    game_info: A `sc_pb.ResponseGameInfo` from the game.
    agent_interface_format: an optional AgentInterfaceFormat.
    map_name: an optional map name, which overrides the one in game_info.
    **kwargs: Anything else is passed through to AgentInterfaceFormat. It's an
        error to send any kwargs if you pass an agent_interface_format.

  Returns:
    A features object matching the specified parameterisation.

  Raises:
    ValueError: if you pass both agent_interface_format and kwargs.
    ValueError: if you pass an agent_interface_format that doesn't match
        game_info's resolutions.
  */
  if (!map_name) {
    map_name = game_info.getMapName()
  }
  let fl_opts
  let feature_dimensions
  let camera_width_world_units
  if (game_info.getOptions().hasFeatureLayer()) {
    fl_opts = game_info.getOptions().getFeatureLayer()
    feature_dimensions = new Dimensions({
      screen: [fl_opts.getResolution().getX(), fl_opts.getResolution().getY()],
      minimap: [fl_opts.getMinimapResolution().getX(), fl_opts.getMinimapResolution().getY()],
    })
    camera_width_world_units = game_info.getOptions().getFeatureLayer().getWidth()
  } else {
    feature_dimensions = null
    camera_width_world_units = null
  }
  let rgb_opts
  let rgb_dimensions
  if (game_info.getOptions().hasRender()) {
    rgb_opts = game_info.getOptions().getRender()
    rgb_dimensions = new Dimensions({
      screen: [rgb_opts.getResolution().getX(), rgb_opts.getResolution().getY()],
      minimap: [rgb_opts.getMinimapResolution().getX(), rgb_opts.getMinimapResolution().getY()],
    })
  } else {
    rgb_dimensions = null
  }

  const map_size = game_info.getStartRaw().getMapSize()

  const requested_races = {}
  game_info.getPlayerInfoList().forEach((info) => {
    if (info.getType() !== sc_pb.PlayerType.OBSERVER) {
      requested_races[info.getPlayerId()] = info.getRaceRequested()
    }
  })

  if (agent_interface_format) {
    if (kwargs) {
      throw new ValueError(' Either give an agent_interface_format or kwargs, not both.')
    }
    const aif = agent_interface_format
    if (!(aif.rgb_dimensions ? aif.rgb_dimensions.eq(rgb_dimensions) : true)
      || !(aif.feature_dimensions ? aif.feature_dimensions.eq(feature_dimensions) : true)
      || (feature_dimensions
      && aif.camera_width_world_units !== camera_width_world_units)) {
      console.error('aif.rgb_dimensions !== rgb_dimensions')
      console.error(aif.rgb_dimensions, '   ', rgb_dimensions)
      console.error('aif.feature_dimensions !== feature_dimensions')
      console.error(aif.feature_dimensions, '   ', feature_dimensions)
      throw new Error('The supplied agent_interface_format doesn\'t match the resolutions computed from the game_info')
      // rgb_dimensions: ${aif.rgb_dimensions} !== ${rgb_dimensions}
      // feature_dimensions: ${aif.feature_dimensions} !== ${feature_dimensions}
      // camera_width_world_units: ${aif.camera_width_world_units} !== ${camera_width_world_units}`)
    }
  } else {
    const args = {
      feature_dimensions,
      rgb_dimensions,
      camera_width_world_units,
    }
    Object.keys(kwargs).forEach((key) => {
      args[key] = kwargs[key]
    })
    agent_interface_format = new AgentInterfaceFormat(args)
  }
  return new Features( //eslint-disable-line
    agent_interface_format,
    map_size,
    requested_races,
    map_name,
  )
}

function _init_valid_functions(action_dimensions) {
  //Initialize ValidFunctions and set up the callbacks.//
  const screen = []
  const screen2 = []
  const minimap = []
  action_dimensions.screen.forEach((i) => {
    screen.push(int(i))
    screen2.push(int(i))
  })
  action_dimensions.minimap.forEach((i) => {
    minimap.push(int(i))
  })
  const sizes = {
    screen,
    screen2,
    minimap,
  }
  let args = actions.TYPES.map((t) => {
    return actions.ArgumentType.spec(t.id, t.name, sizes[t.name] || t.sizes)
  })
  const types = new actions.Arguments(args)
  args = actions.FUNCTIONS.map((f) => {
    const tuple = []
    f.args.forEach((t) => {
      tuple.push(types[t.id])
    })
    return actions.Function.spec(f.id, f.name, tuple)
  })
  const functions = new actions.Functions(args)
  return new actions.ValidActions(types, functions)
}

function _init_valid_raw_functions(raw_resolution, max_selected_units) {
  //Initialize ValidFunctions and set up the callbacks.//
  const world = []
  const unit_tags = [max_selected_units]
  Object.keys(raw_resolution).forEach((key) => {
    const i = raw_resolution[key]
    world.push(int(i))
  })
  const sizes = {
    world,
    unit_tags,
  }
  let args = actions.RAW_TYPES.map((t) => actions.ArgumentType
    .spec(t.id, t.name, sizes[t.name] || t.sizes))
  const types = new actions.RawArguments(args)
  args = actions.RAW_FUNCTIONS.map((f) => {
    const tuple = []
    Object.keys(f.args).forEach((k) => {
      const t = f.args[k]
      tuple.push(types[t.id])
    })
    return actions.Function.spec(f.id, f.name, tuple)
  })
  const functions = new actions.Functions(args)
  return new actions.ValidActions(types, functions)
}

class Features {
  /*Render feature layers from SC2 Observation protos into numpy arrays.

  This has the implementation details of how to render a starcraft environment.
  It translates between agent action/observation formats and starcraft
  action/observation formats, which should not be seen by agent authors. The
  starcraft protos contain more information than they should have access to.

  This is outside of the environment so that it can also be used in other
  contexts, eg a supervised dataset pipeline.
  */

  constructor(agent_interface_format = null, map_size = null,
    requested_races = null, map_name = 'unknown') {
    /*Initialize a Features instance matching the specified interface format.

    Args:
      agent_interface_format: See the documentation for `AgentInterfaceFormat`.
      map_size: The size of the map in world units, needed for feature_units.
      requested_races: Optional. Dict mapping `player_id`s to that player's
          requested race. If present, will send player races in observation.
      map_name: Optional name of the map, to be added to the observation.

    Raises:
      ValueError: if agent_interface_format isn't specified.
      ValueError: if map_size isn't specified when use_feature_units or
          use_camera_position is.
    */
    if (!agent_interface_format) {
      throw new ValueError(' Please specify agent_interface_format')
    }

    this._agent_interface_format = agent_interface_format
    const aif = this._agent_interface_format
    if (!aif.raw_resolution && map_size) {
      aif.raw_resolution = point.Point.build(map_size)
    }
    this._map_size = map_size
    this._map_name = map_name

    if (aif.use_feature_units
        || aif.use_camera_position
        || aif.use_raw_units) {
      this.init_camera(
        aif.feature_dimensions,
        map_size,
        aif.camera_width_world_units,
        aif.raw_resolution
      )
    }
    this._send_observation_proto = aif.send_observation_proto
    this._raw = aif.use_raw_actions

    if (this._raw) {
      this._valid_functions = _init_valid_raw_functions(
        aif.raw_resolution, aif.max_selected_units
      )
      this._raw_tags = []
    } else {
      this._valid_functions = _init_valid_functions(aif.action_dimensions)
    }
    this._requested_races = requested_races

    if (requested_races !== null && requested_races.length <= 2) {
      throw new ValueError(' requested_races.length is greater than 2')
    }
    // apply @sw.decorate
    this.transform_obs = sw.decorate(this.transform_obs.bind(this))
    this.available_actions = sw.decorate(this.available_actions.bind(this))
    this.transform_action = sw.decorate(this.transform_action.bind(this))
    this.reverse_action = sw.decorate(this.reverse_action.bind(this))
    this.reverse_raw_action = sw.decorate(this.reverse_raw_action.bind(this))
  }

  init_camera(feature_dimensions, map_size, camera_width_world_units, raw_resolution) {
    /*Initialize the camera (especially for feature_units).

    This is called in the constructor and may be called repeatedly after
    `Features` is constructed, since it deals with rescaling coordinates and not
    changing environment/action specs.

    Args:
      feature_dimensions: See the documentation in `AgentInterfaceFormat`.
      map_size: The size of the map in world units.
      camera_width_world_units: See the documentation in `AgentInterfaceFormat`.
      raw_resolution: See the documentation in `AgentInterfaceFormat`.

    Raises:
      ValueError: If map_size or camera_width_world_units are falsey (which
          should mainly happen if called by the constructor).
    */
    if (!map_size || !camera_width_world_units) {
      throw new ValueError(`
          "Either pass the game_info with raw enabled, or map_size and "
          "camera_width_world_units in order to use feature_units or camera"
          "position.`)
    }
    map_size = point.Point.build(map_size)
    this._world_to_world_tl = new transform.Linear(
      new point.Point(1, -1),
      new point.Point(0, map_size.y)
    )
    const offset = -map_size.div(4)
    this._world_tl_to_world_camera_rel = new transform.Linear(null, offset)
    if (feature_dimensions) {
      const world_camera_rel_to_feature_screen = new transform.Linear(
        feature_dimensions.screen.div(camera_width_world_units),
        feature_dimensions.screen.div(2)
      )
      this._world_to_feature_screen_px = new transform.Chain(
        this._world_to_world_tl,
        this._world_tl_to_world_camera_rel,
        world_camera_rel_to_feature_screen,
        new transform.PixelToCoord()
      )
    }
    // If we don't have a specified raw resolution, we do no new transform.
    const scale = raw_resolution ? raw_resolution.div(map_size.max_dim()) : null
    const world_tl_to_feature_minimap = new transform.Linear(scale)
    this._world_to_minimap_px = new transform.Chain(
      this._world_to_world_tl,
      world_tl_to_feature_minimap,
      new transform.PixelToCoord()
    )
    this._camera_size = (
      raw_resolution.div(map_size.max_dim()) * camera_width_world_units
    )
  }

  _update_camera(camera_center) {
    //Update the camera transform based on the new camera center.//
    this._world_tl_to_world_camera_rel.offset = (
      -this._world_to_world_tl.fwd_pt(camera_center)
      * this._world_tl_to_world_camera_rel.scale
    )
  }

  observation_spec() {
    /*The observation spec for the SC2 environment.

    It's worth noting that the image-like observations are in y,x/row,column
    order which is different than the actions which are in x,y order. This is
    due to conflicting conventions, and to facilitate printing of the images.

    Returns:
      The dict of observation names to their tensor shapes. Shapes with a 0 can
      vary in length, for example the number of valid actions depends on which
      units you have selected.
    */
    const obs_spec = new named_array.NamedDict({
      "action_result": [0], // See error.proto: ActionResult.
      "alerts": [0], // See sc2api.proto: Alert.
      "build_queue": [0, UnitLayer._keys.length],
      "cargo": [0, UnitLayer._keys.length],
      "cargo_slots_available": [1],
      "control_groups": [10, 2],
      "game_loop": [1],
      "last_actions": [0],
      "map_name": [0],
      "multi_select": [0, UnitLayer._keys.length],
      "player": [Player._keys.length],
      "production_queue": [0, ProductionQueue._keys.length],
      "score_cumulative": [ScoreCumulative._keys.length],
      "score_by_category": [ScoreByCategory._keys.length, ScoreCategories._keys.length],
      "score_by_vital": [ScoreByVital._keys.length, ScoreVitals._keys.length],
      "single_select": [0, UnitLayer._keys.length], // Only (n, 7) for n in (0, 1).
    })

    if (!this._raw) {
      obs_spec["available_actions"] = [0]
    }

    const aif = this._agent_interface_format
    if (aif.feature_dimensions) {
      obs_spec["feature_screen"] = [
        SCREEN_FEATURES.length,
        aif.feature_dimensions.screen.y,
        aif.feature_dimensions.screen.x
      ]

      obs_spec["feature_minimap"] = [
        MINIMAP_FEATURES.length,
        aif.feature_dimensions.minimap.y,
        aif.feature_dimensions.minimap.x
      ]
    }
    if (aif.rgb_dimensions) {
      obs_spec["rgb_screen"] = [
        aif.rgb_dimensions.screen.y,
        aif.rgb_dimensions.screen.x,
        3
      ]
      obs_spec["rgb_minimap"] = [
        aif.rgb_dimensions.minimap.y,
        aif.rgb_dimensions.minimap.x,
        3
      ]
    }
    if (aif.use_feature_units) {
      obs_spec["feature_units"] = [0, FeatureUnit._keys.length]
      obs_spec["feature_effects"] = [0, EffectPos._keys.length]
    }
    if (aif.use_raw_units) {
      obs_spec["raw_units"] = [0, FeatureUnit._keys.length]
      obs_spec["raw_effects"] = [0, EffectPos._keys.length]
    }
    if (aif.use_feature_units || aif.use_raw_units) {
      obs_spec["radar"] = [0, Radar._keys.length]
    }

    obs_spec["upgrades"] = [0]

    if (aif.use_unit_counts) {
      obs_spec["unit_counts"] = [0, UnitCounts._keys.length]
    }

    if (aif.use_camera_position) {
      obs_spec["camera_position"] = [2]
      obs_spec["camera_size"] = [2]
    }
    if (this._send_observation_proto) {
      obs_spec["_response_observation"] = [0]
    }

    obs_spec["home_race_requested"] = [1]
    obs_spec["away_race_requested"] = [1]
    return obs_spec
  }

  action_spec() {
    //The action space pretty complicated and fills the ValidFunctions.//
    return this._valid_functions
  }

  get map_size() {
    return this._map_size
  }

  get requested_races() {
    return this._requested_races
  }

  transform_obs(obs) {
    //Render some SC2 observations into something an agent can handle.//
    const dtype = 'int32'
    const empty_unit = np.array(Array(UnitLayer._keys.length).fill(0), [UnitLayer._keys.length], dtype)
    const out = new named_array.NamedDict({ // Fill out some that are sometimes empty.
      'single_select': empty_unit,
      'multi_select': empty_unit,
      'build_queue': empty_unit,
      'cargo': empty_unit,
      'production_queue': np.array(Array(ProductionQueue._keys.length).fill(0), [ProductionQueue._keys.length], dtype),
      'last_actions': np.array([0], [1], dtype),
      'cargo_slots_available': np.array([0], [1], dtype),
      'home_race_requested': np.array([0], [1], dtype),
      'away_race_requested': np.array([0], [1], dtype),
      'map_name': this._map_name,
    })
    let raw // defined on line 1497
    function or_zeros(layer, size) {
      if (layer !== null) {
        // python uses np.astype <Copy of the array, cast to a specified type.>
        // return Array(...layer.values) // tensorflow buffer.values
        return layer
      }
      return np.zeros([size.y, size.x], 'int32')
    }
    const aif = this._agent_interface_format
    if (aif.feature_dimensions) {
      withPython(sw('feature_screen'), () => {
        const stacks = SCREEN_FEATURES.map((f) => {
          return or_zeros(f.unpack(obs.getObservation()), aif.feature_dimensions.screen)
        })
        out['feature_screen'] = named_array.NamedNumpyArray(
          np.stack(stacks),
          /*names=*/[ScreenFeatures, null, null]
        )
      })
      withPython(sw('feature_minimap'), () => {
        const stacks = MINIMAP_FEATURES.map((f) => {
          return or_zeros(f.unpack(obs.getObservation()), aif.feature_dimensions.minimap)
        })
        out['feature_minimap'] = new named_array.NamedNumpyArray(
          np.stack(stacks),
          /*names=*/[MinimapFeatures, null, null]
        )
      })
    }
    if (aif.rgb_dimensions) {
      withPython(sw('rgb_screen'), () => {
        out['rgb_screen'] = Feature.unpack_rgb_image(
          obs.getObservation().getRenderData().getMap()
        )
      })
      withPython(sw('rgb_minimap'), () => {
        out['rgb_minimap'] = Feature.unpack_rgb_image(
          obs.getObservation().getRenderData().getMinimap()
        )
      })
    }
    if (!this._raw) {
      withPython(sw('last_actions'), () => {
        const acts = obs.getActionsList().map((a) => {
          return this.reverse_action(a).function
        })
        out['last_actions'] = np.array(acts)
      })
    }
    out['action_result'] = np.array(
      (getattr(obs, 'action_errors') || getattr(obs, 'action_errors_list'))
        .map((o) => o.getResult())
    )

    out['alerts'] = np.array(obs.getObservation().getAlertsList())

    out['game_loop'] = np.array([obs.getObservation().getGameLoop()])

    withPython(sw('score'), () => {
      let score_details
      if (obs.getObservation().hasScore()) {
        score_details = obs.getObservation().getScore().getScoreDetails()
      } else {
        score_details = new sc_pb.ScoreDetails()
        obs.getObservation().setScore(new sc_pb.Score())
        score_details.setFoodUsed(new sc_pb.CategoryScoreDetails())
        score_details.setKilledMinerals(new sc_pb.CategoryScoreDetails())
        score_details.setKilledVespene(new sc_pb.CategoryScoreDetails())
        score_details.setLostMinerals(new sc_pb.CategoryScoreDetails())
        score_details.setLostVespene(new sc_pb.CategoryScoreDetails())
        score_details.setFriendlyFireMinerals(new sc_pb.CategoryScoreDetails())
        score_details.setFriendlyFireVespene(new sc_pb.CategoryScoreDetails())
        score_details.setUsedMinerals(new sc_pb.CategoryScoreDetails())
        score_details.setUsedVespene(new sc_pb.CategoryScoreDetails())
        score_details.setTotalUsedMinerals(new sc_pb.CategoryScoreDetails())
        score_details.setTotalUsedVespene(new sc_pb.CategoryScoreDetails())
        score_details.setTotalDamageDealt(new sc_pb.VitalScoreDetails())
        score_details.setTotalDamageTaken(new sc_pb.VitalScoreDetails())
        score_details.setTotalHealed(new sc_pb.VitalScoreDetails())
        obs.getObservation().getScore().setScoreDetails(score_details)
      }
      out['score_cumulative'] = named_array.NamedNumpyArray([
        obs.getObservation().getScore().getScore() || 0,
        score_details.getIdleProductionTime() || 0,
        score_details.getIdleWorkerTime() || 0,
        score_details.getTotalValueUnits() || 0,
        score_details.getTotalValueStructures() || 0,
        score_details.getKilledValueUnits() || 0,
        score_details.getKilledValueStructures() || 0,
        score_details.getCollectedMinerals() || 0,
        score_details.getCollectedVespene() || 0,
        score_details.getCollectionRateMinerals() || 0,
        score_details.getCollectionRateVespene() || 0,
        score_details.getSpentMinerals() || 0,
        score_details.getSpentVespene() || 0,
      ], /*names=*/ScoreCumulative)

      function get_score_details(key, details, categories) {
        const row = (getattr(details, key) || getattr(details, key + '_list'))
        return categories._keys
          .map((categoryKey) => getattr(row, categoryKey))
      }

      out['score_by_category'] = named_array.NamedNumpyArray(
        ScoreByCategory._keys.map((key) => get_score_details(key, score_details, ScoreCategories)),
        /*names=*/[ScoreByCategory, ScoreCategories]
      )

      out['score_by_vital'] = named_array.NamedNumpyArray(
        ScoreByVital._keys.map((key) => get_score_details(key, score_details, ScoreVitals)),
        /*names=*/[ScoreByVital, ScoreVitals]
      )
    })
    const player = obs.getObservation().getPlayerCommon()
    out['player'] = named_array.NamedNumpyArray(
      [
        getattr(player, 'player_id'),
        getattr(player, 'minerals'),
        getattr(player, 'vespene'),
        getattr(player, 'food_used'),
        getattr(player, 'food_cap'),
        getattr(player, 'food_army'),
        getattr(player, 'food_workers'),
        getattr(player, 'idle_worker_count'),
        getattr(player, 'army_count'),
        getattr(player, 'warp_gate_count'),
        getattr(player, 'larva_count'),
      ],
      /*names=*/Player
    )

    function unit_vec(u) {
      return np.array([
        u.getUnitType(),
        u.getPlayerRelative(),
        u.getHealth(),
        u.getShields(),
        u.getEnergy(),
        u.getTransportSlotsTaken(),
        int(u.getBuildProgress() * 100), // discretize
      ])
    }
    const ui = obs.getObservation().getUiData()

    withPython(sw('ui'), () => {
      const groups = np.zeros([10, 2])
      ui.getGroupsList().forEach((g) => {
        groups[g.getControlGroupIndex()] = [g.getLeaderUnitType(), g.getCount()]
      })
      out['control_groups'] = groups

      if (ui.hasSingle()) {
        out['single_select'] = named_array.NamedNumpyArray(
          [unit_vec(ui.getSingle().getUnit())], [null, UnitLayer]
        )
      } else if (ui.hasMulti()) {
        out['multi_select'] = named_array.NamedNumpyArray(
          ui.getMulti().getUnitsList().map((u) => unit_vec(u)),
          [null, UnitLayer]
        )
      } else if (ui.hasCargo()) {
        out['single_select'] = named_array.NamedNumpyArray(
          [unit_vec(ui.getCargo().getUnit())], [null, UnitLayer]
        )
        out['cargo'] = named_array.NamedNumpyArray(
          ui.getCargo().getPassengersList().map((u) => unit_vec(u)),
          [null, UnitLayer]
        )
        out['cargo_slots_available'] = np.array(
          [ui.getCargo().getSlotsAvailable()],
        )
      } else if (ui.hasProduction()) {
        out['single_select'] = named_array.NamedNumpyArray(
          [unit_vec(ui.getProduction().getUnit())], [null, UnitLayer]
        )
        if (ui.getProduction().getBuildQueueList()) {
          out['build_queue'] = named_array.NamedNumpyArray(
            ui.getProduction().getBuildQueueList().map((u) => unit_vec(u)),
            [null, UnitLayer]
          )
        }
        if (ui.getProduction().getProductionQueueList()) {
          out['production_queue'] = named_array.NamedNumpyArray(
            ui.getProduction().getProductionQueueList().map((item) => [
              item.getAbilityId(), item.getBuildProgress() * 100
            ]),
            [null, ProductionQueue]
          )
        }
      }
    })
    const tag_types = {} // Only populate the cache if it's needed.
    function get_addon_type(tag) {
      if (!Object.keys(tag_types).length) {
        raw.getUnitsList().forEach((u) => {
          tag_types[u.getTag()] = u.getUnitType()
        })
      }
      return tag_types[tag] || 0
    }
    function full_unit_vec(u, pos_transform, is_raw = false) {
      //Compute unit features.//
      const screen_pos = pos_transform.fwd_pt(
        point.Point.build(u.getPos())
      )
      const screen_radius = pos_transform.fwd_dist(u.getRadius())
      function raw_order(i) {
        if (u.getOrdersList().length > i) {
          // TODO(tewalds): Return a generalized func id.
          return actions.RAW_ABILITY_ID_TO_FUNC_ID[u.getOrdersList()[i].ability_id] || 0
        }
        return 0
      }
      const features = [
        // Match unit_vec order
        u.getUnitType(),
        u.getAlliance(), // this = 1, Ally = 2, Neutral = 3, Enemy = 4
        u.getHealth(),
        u.getShield(),
        u.getEnergy(),
        u.getCargoSpaceTaken(),
        int(u.getBuildProgress() * 100), // discretize

        // Resume API order
        u.getHealthMax() > 0 ? int(u.getHealth() / u.getHealthMax() * 255) : 0,
        u.getShieldMax() > 0 ? int(u.getShield() / u.getShieldMax() * 255) : 0,
        u.getEnergyMax() > 0 ? int(u.getEnergy() / u.getEnergyMax() * 255) : 0,
        u.getDisplayType(), // Visible = 1, Snapshot = 2, Hidden = 3
        u.getOwner(), // 1-15, 16 = neutral
        screen_pos.x,
        screen_pos.y,
        u.getFacing(),
        screen_radius,
        u.getCloak(), // Cloaked = 1, CloakedDetected = 2, NotCloaked = 3
        u.getIsSelected(),
        u.getIsBlip(),
        u.getIsPowered(),
        u.getMineralContents(),
        u.getVespeneContents(),

        // Not populated for enemies or neutral
        u.getCargoSpaceMax(),
        u.getAssignedHarvesters(),
        u.getIdealHarvesters(),
        u.getWeaponCooldown(),
        u.getOrdersList().length,
        raw_order(0),
        raw_order(1),
        is_raw ? u.getTag() : 0,
        u.getIsHallucination(),
        u.getBuffIdsList().length >= 1 ? u.getBuffIdsList()[0] : 0,
        u.getBuffIdsList().length >= 2 ? u.getBuffIdsList()[1] : 0,
        u.getAddOnTag() ? get_addon_type(u.getAddOnTag()) : 0,
        u.getIsActive(),
        u.getIsOnScreen(),
        u.getOrdersList().length >= 1 ? int(u.getOrdersList()[0].getProgress() * 100) : 0,
        u.getOrdersList().length >= 2 ? int(u.getOrdersList()[1].getProgress() * 100) : 0,
        raw_order(2),
        raw_order(3),
        0,
        u.getBuffDurationRemain(),
        u.getBuffDurationMax(),
        u.getAttackUpgradeLevel(),
        u.getArmorUpgradeLevel(),
        u.getShieldUpgradeLevel(),
      ]
      return features
    }
    raw = obs.getObservation().getRawData()

    if (aif.use_feature_units) {
      withPython(sw('feature_units'), () => {
        // Update the camera location so we can calculate world to screen pos
        this._update_camera(point.Point.build(raw.getPlayer().getCamera()))
        const feature_units = raw.getUnitsList().filter((u) => u.getIsOnScreen())
          .map((u) => full_unit_vec(u, this._world_to_feature_screen_px))
        out['feature_units'] = named_array.NamedNumpyArray(
          feature_units, [null, FeatureUnit],
        )

        const feature_effects = []
        const feature_screen_size = aif.feature_dimensions.screen
        raw.getEffectsList().forEach((effect) => {
          effect.getPosList().forEach((pos) => {
            const screen_pos = this._world_to_feature_screen_px.fwd_pt(
              point.Point.build(pos)
            )
            if (screen_pos.x >= 0 && screen_pos.x < feature_screen_size.x
              && screen_pos.y >= 0 && screen_pos.y < feature_screen_size.y) {
              feature_effects.push([
                effect.getEffectId(),
                effect.getAlliance(),
                effect.getOwner(),
                effect.getRadius(),
                screen_pos.x,
                screen_pos.y,
              ])
            }
          })
        })
        out['feature_effects'] = named_array.NamedNumpyArray(
          feature_effects, [null, EffectPos]
        )
      })
    }
    if (aif.use_raw_units) {
      let raw_units
      withPython(sw('raw_units'), () => {
        withPython(sw('to_list'), () => {
          raw_units = raw.getUnitsList().map((u) => full_unit_vec(u, this._world_to_minimap_px, /*is_raw=*/true))
        })
        withPython(sw('to_numpy'), () => {
          out['raw_units'] = named_array.NamedNumpyArray(
            raw_units, [null, FeatureUnit]
          )
        })
        if (raw_units) {
          const temp = []
          for (let i = 0; i < out['raw_units'].length; i++) {
            temp.push(out['raw_units'][i][FeatureUnit.tag])
          }
          this._raw_tags = temp
        } else {
          this._raw_tags = np.array([])
        }

        const raw_effects = []
        raw.getEffectsList().forEach((effect) => {
          effect.getPosList().forEach((pos) => {
            const raw_pos = this._world_to_minimap_px.fwd_pt(point.Point.build(pos))
            raw_effects.push([
              effect.getEffectId(),
              effect.getAlliance(),
              effect.getOwner(),
              effect.getRadius(),
              raw_pos.x,
              raw_pos.y,
            ])
          })
        })
        out['raw_effects'] = named_array.NamedNumpyArray(
          raw_effects, [null, EffectPos]
        )
      })
    }
    out['upgrades'] = np.array(raw.getPlayer().getUpgradeIdsList())

    function cargo_units(u, pos_transform, is_raw = false) {
      //Compute unit features.//
      const screen_pos = pos_transform.fwd_pt(
        point.Point.build(u.getPos())
      )
      const features = []
      u.getPassengersList().forEach((v) => {
        features.push([
          v.getUnitType(),
          u.getAlliance(), // this = 1, Ally = 2, Neutral = 3, Enemy = 4
          v.getHealth(),
          v.getShield(),
          v.getEnergy(),
          0, // cargo_space_taken
          0, // build_progress
          v.getHealthMax() > 0 ? int(v.getHealth() / v.getHealthMax() * 255) : 0,
          v.getShieldMax() > 0 ? int(v.getShield() / v.getShieldMax() * 255) : 0,
          v.getEnergyMax() > 0 ? int(v.getEnergy() / v.getEnergyMax() * 255) : 0,
          0, // display_type
          u.getOwner(), // 1-15, 16 = neutral
          screen_pos.x,
          screen_pos.y,
          0, // facing
          0, // screen_radius
          0, // cloak
          0, // is_selected
          0, // is_blip
          0, // is powered
          0, // mineral_contents
          0, // vespene_contents
          0, // cargo_space_max
          0, // assigned_harvesters
          0, // ideal_harvesters
          0, // weapon_cooldown
          0, // order_length
          0, // order_id_0
          0, // order_id_1
          is_raw ? v.getTag() : 0,
          0, // is hallucination
          0, // buff_id_1
          0, // buff_id_2
          0, // addon_unit_type
          0, // active
          0, // is_on_screen
          0, // order_progress_1
          0, // order_progress_2
          0, // order_id_2
          0, // order_id_3
          1, // is_in_cargo
          0, // buff_duration_remain
          0, // buff_duration_max
          0, // attack_upgrade_level
          0, // armor_upgrade_level
          0, // shield_upgrade_level
        ])
      })
      return features
    }
    if (aif.add_cargo_to_units) {
      let feature_cargo_units
      withPython(sw('add_cargo_to_units'), () => {
        if (aif.use_feature_units) {
          withPython(sw('feature_units'), () => {
            withPython(sw('to_list'), () => {
              feature_cargo_units = []
              raw.getUnitsList().forEach((u) => {
                if (!u.getIsOnScreen()) {
                  return
                }
                feature_cargo_units
                  .push(cargo_units(u, this._world_to_feature_screen_px))
              })
            })
            withPython(sw('to_numpy'), () => {
              if (feature_cargo_units) {
                let all_feature_units = np.array(feature_cargo_units)
                all_feature_units = np.concatenate(
                  [out['feature_units'], feature_cargo_units], /*axis=*/
                  0
                )
                out['feature_units'] = named_array.NamedNumpyArray(
                  all_feature_units, [null, FeatureUnit]
                )
              }
            })
          })
        }
        if (aif.use_raw_units) {
          let raw_cargo_units
          withPython(sw('raw_units'), () => {
            withPython(sw('to_list'), () => {
              raw_cargo_units = []
              raw.getUnitsList().forEach((u) => {
                if (!u.getIsOnScreen()) {
                  return
                }
                raw_cargo_units
                  .push(cargo_units(u, this._world_to_minimap_px, true))
              })
            })
            withPython(sw('to_numpy'), () => {
              if (raw_cargo_units) {
                raw_cargo_units = np.array(raw_cargo_units)
                const all_raw_units = np.concatenate(
                  [out['raw_units'], raw_cargo_units], /*axis=*/0
                )
                out['raw_units'] = named_array.NamedNumpyArray(
                  all_raw_units, [null, FeatureUnit]
                )
                const temp = []
                for (let i = 0; i < out['raw_units'].length; i++) {
                  temp.push(out['raw_units'][i][FeatureUnit.tag])
                }
                this._raw_tags = temp
              }
            })
          })
        }
      })
    }

    if (aif.use_unit_counts) {
      withPython(sw('unit_counts'), () => {
        const unit_counts = new DefaultDict(0)
        raw.getUnitsList().forEach((u) => {
          if (u.getAlliance() !== sc_raw.Alliance.SELF) {
            return
          }
          unit_counts[u.unit_type] += 1
        })
        out['unit_counts'] = named_array.NamedNumpyArray(
          Object.keys(unit_counts).map((key) => [key, unit_counts[key]])
            .sort((a, b) => a[0] < b[0]),
          [null, UnitCounts]
        )
      })
    }

    if (aif.use_camera_position) {
      const camera_position = this._world_to_minimap_px.fwd_pt(
        point.Point.build(raw.getPlayer().getCamera())
      )
      out['camera_position'] = np.array([camera_position.x, camera_position.y])
      out['camera_size'] = np.array([this._camera_size.x, this._camera_size.y])
    }
    if (!this._raw) {
      out['available_actions'] = np.array(
        this.available_actions(obs.getObservation())
      )
    }

    if (this._requested_races !== null) {
      out['home_race_requested'] = np.array(
        [this._requested_races[player.getPlayerId()]]
      )
      Object.keys(this._requested_races).forEach((player_id) => {
        const race = this._requested_races[player_id]
        if (player_id !== player.getPlayerId()) {
          out['away_race_requested'] = np.array([race])
        }
      })
    }
    if (aif.use_feature_units || aif.use_raw_units) {
      function transform_radar(radar) { //eslint-disable-line
        const p = this._world_to_minimap_px.fwd_pt(point.Point.build(radar.getPos()))
        return [p.x, p.y, radar.getRadius()]
      }
      out['radar'] = named_array.NamedNumpyArray(
        obs.getObservation().getRawData().getRadarList().map(transform_radar),
        [null, Radar]
      )
    }
    // Send the entire proto as well (in a function, so it isn't copied).
    if (this._send_observation_proto) {
      out['_response_observation'] = () => obs
    }
    return out
  }

  available_actions(obs) {
    //Return the list of available action ids.//
    const available_actions = new Set()
    const hide_specific_actions = this._agent_interface_format.hide_specific_actions
    Object.keys(actions.FUNCTIONS_AVAILABLE).forEach((i) => {
      const func = actions.FUNCTIONS_AVAILABLE[i]
      if (func.avail_fn(obs)) {
        available_actions.add(func.id.key)
      }
    })
    const abilities = obs.getAbilitiesList()
    console.log('abilities: ', abilities, 'abilities.length: ', abilities.length)
    console.log(abilities.map((a) => a.toObject()))
    for (let index = 0; index < abilities.length; index++) {
      const a = abilities[index]
      if (!(actions.ABILITY_IDS.hasOwnProperty(a.getAbilityId()))) {
        console.warn(`Unknown ability ${a.ability_id} seen as available.`, a.ability_id)
        return
      }
      let found_applicable = false
      const ability_id = a.getAbilityId()
      Object.keys(actions.ABILITY_IDS[ability_id]).forEach((k_id) => {
        const func = actions.ABILITY_IDS[ability_id][k_id]
        if (actions.POINT_REQUIRED_FUNCS.get(a.getRequiresPoint())
          .hasOwnProperty(func.function_type.name)) {
          if (func.general_id == 0 || !hide_specific_actions) {
            available_actions.add(func.id.key)
            found_applicable = true
          }
          if (func.general_id != 0) { // Always offer generic actions.
            const general_funcs = actions.ABILITY_IDS[func.general_id]
            for (let i = 0; i < general_funcs.length; i++) {
              const general_func = general_funcs[i]
              if (general_func.function_type === func.function_type) {
                // Only the right type. Don't want to expose the general action
                // to minimap if only the screen version is available.
                available_actions.add(general_func.id.key)
                found_applicable = true
                break
              }
            }
          }
        }
      })
      if (!found_applicable) {
        throw new ValueError(`Failed to find applicable action for ${JSON.stringify(a.toObject())}`)
      }
    }
    const results = []
    const iter = available_actions.values()
    let i
    while(i = iter.next().value) { results.push(i) } //eslint-disable-line
    return results
  }

  transform_action(obs, func_call, skip_available = false) {
    /*Transform an agent-style action to one that SC2 can consume.

    Args:
      obs: a `sc_pb.Observation` from the previous frame.
      func_call: a `FunctionCall` to be turned into a `sc_pb.Action`.
      skip_available: If true, assume the action is available. This should only
          be used for testing or if you expect to make actions that weren't
          valid at the last observation.

    Returns:
      a corresponding `sc_pb.Action`.

    Raises:
      ValueError: if the action doesn't pass validation.
    */
    // Ignore sc_pb.Action's to make the env more flexible, eg raw actions.
    if (isinstance(func_call, sc_pb.Action)) {
      return func_call
    }
    let func_id = func_call.function
    if (func_id instanceof Enum.EnumMeta) {
      func_id = Number(func_id)
    }
    let func
    try {
      if (this._raw) {
        func = actions.RAW_FUNCTIONS[func_id]
      } else {
        func = actions.FUNCTIONS[func_id]
      }
    } catch (err) {
      throw new ValueError(`Invalid function id: ${func_id}.`)
    }
    console.log('func_id: ', func_id)
    console.log('this.available_actions(obs).includes(func_id)): ', this.available_actions(obs).includes(func_id))
    // Available?
    if (!(skip_available || this._raw || this.available_actions(obs).includes(func_id))) {
      throw new ValueError(`Function ${func_id} ${func.name} is currently not available`)
    }
    // Right number of args?
    if (func_call.arguments.length !== func.args.length) {
      throw new ValueError(`Wrong number of arguments for function: ${func}, got:${func_call} ${func_call.arguments}`)
    }
    // Args are valid?
    const aif = this._agent_interface_format
    zip(func.args, func_call.arguments).forEach(([t, arg]) => {
      if (t.count) {
        if (len(arg) >= 1 && len(arg) <= t.count) {
          return
        }
        throw new ValueError(`Wrong number of values for argument of ${func}, got: ${func_call.arguments}`)
      }
      let sizes
      if (t.name === 'screen' || t.name === 'screen2') {
        sizes = aif.action_dimensions.screen
      } else if (t.name === 'minimap') {
        sizes = aif.action_dimensions.minimap
      } else if (t.name === 'world') {
        sizes = aif.raw_resolution
      } else {
        sizes = t.sizes
      }
      if (sizes.length !== arg.length) {
        throw new ValueError(`Wrong number of values for argument of ${func}, got: ${func_call.arguments}`)
      }
      zip(sizes, arg).forEach((p) => {
        const [s, a] = p
        if (!(a >= 0) && (a < s)) {
          throw new ValueError(`Argument is out of range for ${func}, got: ${func_call.arguments}`)
        }
      })
    })

    // Convert them to python types.
    const kwargs = {}
    zip(func.args, func_call.arguments).forEach((pair) => {
      const [type_, a] = pair
      kwargs[type_.name] = type_.fn(a)
    })
    // Call the right callback to get an SC2 action proto.
    /**** set up proto ****/
    /*     SPATIAL     */
    const sc2_action = new sc_pb.Action()
    setUpProtoAction(sc2_action, func.function_type.name)
    kwargs['action'] = sc2_action
    if (func.ability_id) {
      kwargs['ability_id'] = func.ability_id
    }

    if (this._raw) {
      if (kwargs.hasOwnProperty('world')) {
        kwargs['world'] = this._world_to_minimap_px.back_pt(kwargs['world'])
      }
      const self = this
      function find_original_tag(position) {//eslint-disable-line
        if (position >= self._raw_tags.length) { // Assume it's a real unit tag.
          return position
        }
        const original_tag = self._raw_tags[position]
        if (original_tag == 0) {
          console.warn(`Tag not found: ${original_tag}`)
        }
        return original_tag
      }
      if (kwargs.hasOwnProperty('target_unit_tag')) {
        kwargs['target_unit_tag'] = find_original_tag(
          kwargs['target_unit_tag'][0]
        )
      }
      if (kwargs.hasOwnProperty('unit_tags')) {
        Object.keys(kwargs['unit_tags']).map((key) => {
          const t = kwargs['unit_tags'][key]
          return find_original_tag(t)
        })
      }
      const argArray = getArgsArray(actions.RAW_FUNCTIONS[func_id].function_type, kwargs)
      actions.RAW_FUNCTIONS[func_id].function_type(...argArray)
    } else {
      kwargs['action_space'] = aif.action_space
      const argArray = getArgsArray(actions.FUNCTIONS[func_id].function_type, kwargs)
      actions.FUNCTIONS[func_id].function_type(...argArray)
    }
    return sc2_action
  }

  reverse_action(action) {
    /*Transform an SC2-style action into an agent-style action.

    This should be the inverse of `transform_action`.

    Args:
      action: a `sc_pb.Action` to be transformed.

    Returns:
      A corresponding `actions.FunctionCall`.

    Raises:
      ValueError: if it doesn't know how to transform this action.
    */
    const FUNCTIONS = actions.FUNCTIONS

    const aif = this._agent_interface_format

    function func_call_ability(ability_id, cmd_type) {
      if (!actions.ABILITY_IDS.hasOwnProperty(ability_id)) {
        console.warn(`Unknown ability_id: ${ability_id}. This is probably dance or cheer, or some unknown new or map specific ability. Treating it as a no-op.", ability_id`)
        return FUNCTIONS.no_op()
      }
      if (aif.hide_specific_actions) {
        const general_id = actions.ABILITY_IDS[ability_id][0].general_id
        if (general_id) {
          ability_id = general_id
        }
      }
      const ks = Object.keys(actions.ABILITY_IDS[ability_id])
      let key
      for (let i = 0; i < ks.length; i++) {
        key = ks[i]
        const func = actions.ABILITY_IDS[ability_id][key]
        if (func.function_type === cmd_type) {
          const args = []
          for (let j = 2; j < arguments.length; j++) {
            args.push(arguments[j]) //eslint-disable-line
          }
          return FUNCTIONS[func.id.key](...args)
        }
      }

      throw new ValueError(`Unknown ability_id: ${ability_id}, type: ${cmd_type.__name__}. Likely a bug.`)
    }

    if (action.getActionUi()) {
      const actUi = action.getActionUi()
      if (actUi.getMultiPanel()) {
        return FUNCTIONS.select_unit(
          actUi.getMultiPanel().getType() - 1,
          actUi.getMultiPanel().getUnitIndex()
        )
      }
      if (actUi.getControlGroup()) {
        return FUNCTIONS.select_control_group(
          actUi.getControlGroup().getAction() - 1,
          actUi.getControlGroup().getControlGroupIndex()
        )
      }
      if (actUi.getSelectIdleWorker()) {
        return FUNCTIONS.select_idle_worker(actUi.getSelectIdleWorker().getType() - 1)
      }
      if (actUi.getSelectArmy()) {
        return FUNCTIONS.select_army(actUi.getSelectArmy().getSelectionAdd())
      }
      if (actUi.getSelectWarpGates()) {
        return FUNCTIONS.select_warp_gates(
          actUi.getSelectWarpGates().getSelectionAdd()
        )
      }
      if (actUi.getSelectLarva()) {
        return FUNCTIONS.select_larva()
      }
      if (actUi.getCargoPanel()) {
        return FUNCTIONS.unload(actUi.getCargoPanel().getUnitIndex())
      }
      if (actUi.getProductionPanel()) {
        return FUNCTIONS.build_queue(actUi.getProductionPanel().getUnitIndex())
      }
      if (actUi.getToggleAutocast()) {
        return func_call_ability(
          actUi.getToggleAutocast().getAbilityId(),
          actions.autocast
        )
      }
    }
    if (action.getActionFeatureLayer() || action.getActionRender()) {
      const act_sp = actions.spatial(action, aif.action_space)
      if (act_sp.getCameraMove()) {
        const coord = point.Point.build(act_sp.getCameraMove().getCenterMinimap())
        return FUNCTIONS.move_camera(coord)
      }
      if (act_sp.getUnitSelectionPoint()) {
        const select_point = act_sp.getUnitSelectionPoint()
        const coord = point.Point.build(select_point.getSelectionScreenCoord())
        return FUNCTIONS.select_point(select_point.getType() - 1, coord)
      }
      if (act_sp.getUnitSelectionRect()) {
        const select_rect = act_sp.getUnitSelectionRect()
        // TODO(tewalds) {} After looking at some replays we should decide if
        // this is good enough. Maybe we need to simulate multiple actions or
        // merge the selection rects into a bigger one.
        const tl = point.Point.build(select_rect.getSelectionScreenCoordList()[0].getP0())
        const br = point.Point.build(select_rect.getSelectionScreenCoordList()[0].getP1())
        return FUNCTIONS.select_rect(select_rect.getSelectionAdd(), tl, br)
      }
      if (act_sp.getUnitCommand()) {
        const cmd = act_sp.getUnitCommand()
        const queue = int(cmd.getQueueCommand())
        if (cmd.getTargetScreenCoord()) {
          const coord = point.Point.build(cmd.getTargetScreenCoord())
          return func_call_ability(cmd.getAbilityId(), actions.cmd_screen,
            queue, coord)
        }
        if (cmd.getTargetMinimapCoord()) {
          const coord = point.Point.build(cmd.getTargetMinimapCoord())
          return func_call_ability(cmd.getAbilityId(), actions.cmd_minimap,
            queue, coord)
        }
        return func_call_ability(cmd.getAbilityId(), actions.cmd_quick, queue)
      }
    }
    if (action.getActionRaw() || action.getActionRender()) {
      throw new ValueError(`Unknown action:\n${action}`)
    }

    return FUNCTIONS.no_op()
  }

  reverse_raw_action(action, prev_obs) {
    /*Transform an SC2-style action into an agent-style action.

    This should be the inverse of `transform_action`.

    Args:
      action: a `sc_pb.Action` to be transformed.
      prev_obs: an obs to figure out tags.

    Returns:
      A corresponding `actions.FunctionCall`.

    Raises:
      ValueError: if it doesn't know how to transform this action.
    */
    const aif = this._agent_interface_format
    const raw_tags = []
    for (let i = 0; i < prev_obs['raw_units'].length; i++) {
      raw_tags.push(prev_obs['raw_units'][FeatureUnit.tag])
    }
    function find_tag_position(original_tag) {
      let tag
      for (let i = 0; i < raw_tags.length; i++) {
        tag = raw_tags[i]
        if (tag === original_tag) {
          return i
        }
      }
      console.warn(`Not found tag! ${original_tag}`)
      return -1
    }
    function func_call_ability(ability_id, cmd_type, args) {
      //Get the function id for a specific ability id and action type.//
      if (actions.RAW_ABILITY_IDS.hasOwnProperty(ability_id)) {
        console.warn(`Unknown ability_id: ${ability_id}. This is probably dance or cheer, or some unknown new or map specific ability. Treating it as a no-op.`)
        return actions.RAW_FUNCTIONS.no_op()
      }
      if (aif.hide_specific_actions) {
        const general_id = actions.RAW_ABILITY_IDS[ability_id][0].general_id
        if (general_id) {
          ability_id = general_id
        }
      }
      const ks = Object.keys(actions.RAW_ABILITY_IDS[ability_id])
      let key
      for (let i = 0; i < ks.length; i++) {
        key = ks[i]
        const func = actions.RAW_ABILITY_IDS[ability_id][key]
        if (func.function_type === cmd_type) {
          return actions.RAW_FUNCTIONS[func.id](...args)
        }
      }
      throw new ValueError(`Unknown ability_id: ${ability_id}, type:${cmd_type.__name__}. Likely a bug.`)
    }
    if (action.getRawAction()) {
      const raw_act = action.getRawAction()
      if (raw_act.getUnitCommand()) {
        const uc = raw_act.getUnitCommand()
        const ability_id = uc.getAbilityId()
        const queue_command = uc.getQueueCommand()
        let unit_tags = uc.getUnitTagsList().map((t) => find_tag_position(t))
        // Remove invalid units.
        unit_tags = unit_tags.filter((t) => t != -1)
        if (!unit_tags) {
          return actions.RAW_FUNCTIONS.no_op()
        }

        if (uc.getTargetUnitTag()) {
          const target_unit_tag = find_tag_position(uc.getTargetUnitTag())
          if (target_unit_tag == -1) {
            return actions.RAW_FUNCTIONS.no_op()
          }
          return func_call_ability(ability_id, actions.raw_cmd_unit,
            queue_command, unit_tags, target_unit_tag)
        }
        if (uc.getTargetWorldSpacePos()) {
          let coord = point.Point.build(uc.getTargetWorldSpacePos())
          coord = this._world_to_minimap_px.fwd_pt(coord)
          return func_call_ability(ability_id, actions.raw_cmd_pt,
            queue_command, unit_tags, coord)
        }
        return func_call_ability(ability_id, actions.raw_cmd,
          queue_command, unit_tags)
      }
      if (raw_act.getToggleAutocast()) {
        const uc = raw_act.getToggleAutocast()
        const ability_id = uc.getAbilityId()
        let unit_tags = uc.getUnitTags().map((t) => find_tag_position(t))
        // Remove invalid units.
        unit_tags = unit_tags.filter((t) => t != -1)
        if (!unit_tags) {
          return actions.RAW_FUNCTIONS.no_op()
        }
        return func_call_ability(ability_id, actions.raw_autocast, unit_tags)
      }
      if (raw_act.getUnitCommand()) {
        throw new ValueError(`Unknown action:\n${action}`)
      }

      if (raw_act.getCameraMove()) {
        let coord = point.Point.build(raw_act.getCameraMove().getCenterWorldSpace())
        coord = this._world_to_minimap_px.fwd_pt(coord)
        return actions.RAW_FUNCTIONS.raw_move_camera(coord)
      }
    }
    return actions.RAW_FUNCTIONS.no_op()
  }
}

module.exports = {
  AgentInterfaceFormat,
  Dimensions,
  Features,
  EffectPos,
  Effects,
  Feature,
  FeatureType,
  FeatureUnit,
  features_from_game_info,
  MinimapFeatures,
  MINIMAP_FEATURES,
  parse_agent_interface_format,
  Player,
  PlayerRelative,
  ProductionQueue,
  Radar,
  ScoreCumulative,
  ScoreByCategory,
  ScoreCategories,
  ScoreByVital,
  ScoreVitals,
  ScreenFeatures,
  SCREEN_FEATURES,
  UnitLayer,
  UnitCounts,
  Visibility,
  _to_point,
  _init_valid_functions,
  _init_valid_raw_functions,
}

}).call(this,"/")
},{"path":6,"python-enum":103,"s2clientprotocol":"s2clientprotocol"}],"/named_array.js":[function(require,module,exports){
(function (__dirname){
//Named numpy arrays for easier access to the observation data.

/*
https://docs.scipy.org/doc/numpy/user/basics.rec.html are not enough since they
actually change the type and don't interoperate well with tensorflow.
*/

const path = require('path') //eslint-disable-line
const Enum = require('python-enum') //eslint-disable-line
const np = require(path.resolve(__dirname, './numpy.js'))
const pythonUtils = require(path.resolve(__dirname, './pythonUtils.js'))
const { isinstance } = pythonUtils
Array.prototype.valueAt = function valueAt() { //eslint-disable-line
  let value = this
  let args = arguments //eslint-disable-line
  if (args[0] === null) {
    return this.getProxy(this)
  }
  if (args[0]._named_array_values) {
    args[0] = args[0]._named_array_values
  }
  if (Array.isArray(args[0])) {
    args = args[0]
    const results = []
    args.forEach((ind) => {
      results.push(this[ind])
    })
    return this.getProxy(results, true)
  }
  for (let i = 0; i < args.length; i++) {
    value = value[args[i]]
  }
  return value
}
Array.prototype.where = function where(conditionFunc, start = this._named_array_values, results = [], init = true) { //eslint-disable-line
  start.forEach((ele, index) => {
    if (Array.isArray(ele)) {
      const temp = this.where(conditionFunc, ele, results, false)
      results.concat(temp)
      // results = results.concat(this.where(conditionFunc, ele, results, false))
      return
    }
    if (conditionFunc(ele, index)) {
      results.push(ele)
    }
  })
  if (init === false) {
    return results
  }
  return this.getProxy(results, true)
}
function assign(values, name, keyPathArray) {
  let value = values
  let parent
  let lookUpIndex
  if (name === null || name === undefined) {
    return
  }
  let i = 0
  let index
  while (i < keyPathArray.length) {
    if (i === (keyPathArray.length - 1)) {
      parent = value
    }
    index = keyPathArray[i]
    i++
    if (value === undefined) {
      console.log('values:\n  ', values, '\nname:\n  ', name, '\nkeyPathArray:\n  ', keyPathArray)
    }
    lookUpIndex = index
    value = value[index]
  }
  Object.defineProperty(parent, name, {
    get: function() { return parent[lookUpIndex] },
    set: function(val) { parent[lookUpIndex] = val; return val || true }
  })
}
function unpack(values, names, nameIndex = 0, keyPathArray = []) {
  //sanitize input
  if (isinstance(names, Enum.EnumMeta)) {
    names = names.member_names_
  } else if (names.contructor && names.constructor._fields) {
    names = names.constructor._fields
  } else if (!Array.isArray(names)) {
    names = Object.keys(names)
  }
  let nameList = names[nameIndex]
  if (nameList === undefined) {
    return
  }
  if (nameList === null) {
    nameList = names
  }
  if (typeof nameList === 'string') {
    nameList = names
  } else if (nameList._fields) {
    nameList = nameList._fields
  } else if (nameList.constructor && nameList.constructor._fields) {
    nameList = nameList.constructor._fields
  } else if (isinstance(nameList, Enum.EnumMeta)) {
    nameList = nameList.member_names_
  }

  nameList.forEach((name, index) => {
    assign(values, name, keyPathArray.concat(index))
    if (values.length <= index) {
      return
    }
    unpack(values, names, nameIndex + 1, keyPathArray.concat(index))
  })
}

class NamedDict {
  //A dict where you can use `d["element"]` or `d.element`.//
  constructor(kwargs) {
    if (!kwargs) {
      return
    }
    Object.keys(kwargs).forEach((key) => {
      this[key] = kwargs[key]
    })
  }
}
class NamedNumpyArray extends Array {// extends np.ndarray:
  /*A subclass of ndarray that lets you give names to indices.

  This is a normal ndarray in the sense that you can always index by numbers and
  slices, though elipses don't work. Also, all elements have the same type,
  unlike a record array.

  Names should be a list of names per dimension in the ndarray shape. The names
  should be a list or tuple of strings, a namedtuple class (with names taken
  from _fields), or an IntEnum. Alternatively if you don't want to give a name
  to a particular dimension, use None. If your array only has one dimension, the
  second level of list can be skipped.


    Jihan & Ryan - Documentation notes:

     var foo = named_array.NamedNumpyArray([1, 3, 6], ["a", "b", "c"])
                col
    dimension    0
       a         1
       b         3
       c         6

    usage: foo.a => 1, foo.b => 3, foo.c => 6

      bar = named_array.NamedNumpyArray([[1, 3], [6, 8]], [["a", "b"], None])
                col   col
    dimension    0     1
       a (0)     1     3
       b (1)     6     8

    usage: bar.a => [1,3], bar.a[0] => 1, bar.a[1] => 3
    usage: bar.b => [6,8], bar.b[0] => 6, bar.b[1] => 8

     baz = named_array.NamedNumpyArray([[1, 3], [6, 8]], [None, ["a", "b"]])

                col           col
    dimension    a             b
    None (0)     1             3
    None (1)     6             8

    usage: bar[0] => [1,3], bar[0].a => 1, bar[0].a => 3
    usage: bar[1] => [6,8], bar[0].b => 6, bar[1].b => 8

  Look at the tests for more examples including using enums and named tuples.
  */
  constructor(values, names) {
    let tensor
    if (values instanceof np.TensorMeta) {
      tensor = values
      values = values.arraySync()
    } else {
      tensor = np.tensor(values)
    }
    super(...values)
    if (isinstance(names, Enum.EnumMeta)) {
      names = names.member_names_
    } else if (names._fields) {
      names = names._fields
    } else if (names.contructor && names.constructor._fields) {
      names = names.constructor._fields
    } else if (!Array.isArray(names)) {
      names = Object.keys(names)
    }
    this.__pickleArgs = [values, names]
    this.tensor = tensor
    this.shape = this.tensor.shape
    if (this.shape.length === 0) {
      throw new Error('ValueError: Scalar arrays are unsupported')
    }
    if (this.shape.length === 1) {
      if (this.shape[0] === 0 && names && names[0] === null) {
        // Support arrays of length 0.
        names = [null]
      } else {
        // Allow just a single dimension if the array is also single dimension.
        try {
          if (names.length > 1) {
            names = [names]
          }
        } catch (err) { // len of a namedtuple is a TypeError
          names = [names]
        }
      }
    }

    // Validate names!
    if (!isinstance(names, Array) || names.length !== this.shape.length) {
      throw new Error(`ValueError: Names must be a list of length equal to the array shape: ${names.length} != ${this.shape.length}.`)
    }
    let only_none = this.shape[0] > 0
    Object.keys(names).forEach((key, i) => {
      let o = names[key]
      if (o === null) {
        // skip
      } else {
        only_none = false
        if (isinstance(o, Enum.EnumMeta)) {
          o.member_names_.forEach((n, j) => {
            if (j != o[n]) {
              throw new Error('ValueError: Enum has holes or doesn\'t start from 0.')
            }
          })
          o = o.member_names_
        } else if (o._fields) {
          o = o._fields
        } else if (o.constructor && o.constructor._fields) {
          o = o.constructor._fields
        } else if (isinstance(o, Array)) {
          o.forEach((n) => {
            if (typeof (n) !== 'string') {
              throw new Error(`ValueError: Bad name, must be a list of strings not: ${JSON.stringify(o)}`)
            }
          })
        } else {
          console.error(o)
          throw new Error('Bad names. Must be None, a list of strings, a namedtuple, or Intenum.')
        }
        if (this.shape[i] !== o.length) {
          throw new Error(`ValueError: Wrong number of names in dimension ${i}. Got ${o.length}, expected ${this.shape[i]}.`)
        }
      }
    })

    if (only_none) {
      throw new Error('No names given. Use a normal numpy.ndarray instead.')
    }
    const copy = values.map((e) => e)
    this._named_array_values = copy
    // Finally convert to a NamedNumpyArray.
    unpack(this, names)
  }

  valueAt() {
    let value = this
    let args = arguments //eslint-disable-line
    if (args[0] === null) {
      return this.getProxy(this)
    }
    if (args[0]._named_array_values) {
      args[0] = args[0]._named_array_values
    }
    if (Array.isArray(args[0])) {
      args = args[0]
      const results = []
      args.forEach((ind) => {
        results.push(this[ind])
      })
      return this.getProxy(results, true)
    }
    for (let i = 0; i < args.length; i++) {
      value = value[args[i]]
    }
    return value
  }

  where(conditionFunc, start = this._named_array_values, results = [], init = true) {
    start.forEach((ele, index) => {
      if (Array.isArray(ele)) {
        const temp = this.where(conditionFunc, ele, results, false)
        results.concat(temp)
        // NOTE: below will NOT wor
        // results = results.concat(this.where(conditionFunc, ele, results, false))
        return
      }
      if (conditionFunc(ele, index)) {
        results.push(ele)
      }
    })
    if (init === false) {
      return results
    }
    return this.getProxy(results, true)
  }

  slice() {
    return this.getProxy(this._named_array_values.slice(...arguments), true) //eslint-disable-line
  }

  getProxy() { //eslint-disable-line
    return arguments //eslint-disable-line
  }

  pickle() {
    return JSON.stringify(this.__pickleArgs)
  }
}

function getNamedNumpyArray(values, names) {
  let returnVal
  function getProxy(thing, override) {
    return new Proxy(thing, {
      get: (target, name) => {
        if (name === Symbol.iterator) {
          return target[Symbol.iterator].bind(target)
        }
        if (name === '_named_array_values') {
          return target._named_array_values
        }
        if (name === 'length') {
          return target[name]
        }
        let val
        if (typeof name === 'string' && Number.isInteger(Number(name))) {
          name = Number(name)
          if (name >= 0) {
            val = target[name]
          } else {
            val = target[target.length + name]
          }
          // gather
        } else if (name === 'undefined' || name === 'null') {
          val = [target]
        } else if (override) {
          val = returnVal[name]
        } else {
          val = target[name]
        }
        if (Array.isArray(val)) {
          return getProxy(val)
        }
        return val
      },
      set(target, key, value) {
        target[key] = value
        return value || true
      },
      // ownKeys: (target) => Object.keys(target).concat(['length']),
      getOwnPropertyDescriptor: function(target, key) {
        const notEnumerable = {
          'extends': true,
          '_named_array_values': true,
          'shape': true,
          '__pickleArgs': true,
          'tensor': true,
          'getProxy': true,
        }
        if (key === 'length') {
          return Object.getOwnPropertyDescriptor(target, key)
        }
        // if (key === 'extends') {
        //   return { value: this.get(target, key), enumerable: false, configurable: true }
        // }
        if (notEnumerable[key]) {
          return { value: this.get(target, key), enumerable: false, configurable: true }
        }
        return Object.getOwnPropertyDescriptor(target, key)
        // return { value: this.get(target, key), enumerable: true, configurable: true }
      }
    })
  }
  const obj = new NamedNumpyArray(values, names) //eslint-disable-line
  obj.getProxy = getProxy
  returnVal = getProxy(obj)
  return returnVal
}
module.exports = {
  NamedDict,
  NamedNumpyArray: getNamedNumpyArray,
}

}).call(this,"/")
},{"path":6,"python-enum":103}],"/numpy.js":[function(require,module,exports){
// let tf = require('@tensorflow/tfjs') //eslint-disable-line
let tf = require('@tensorflow/tfjs-node') //eslint-disable-line
const foo = tf.tensor([1])
const TensorMeta = foo.constructor // currently unknown where else to get this value
/*eslint-disable prefer-rest-params*/
module.exports = {
  absolute: tf.abs,
  abs: tf.abs,
  any: (tensor) => {
    if (tensor.dtype !== 'bool') {
      return tf.any(tf.cast(tensor, 'bool'))
    }
    return tf.any(tensor)
  },
  arange() {
    if (arguments.length === 1) {
      return tf.range(0, arguments[0])
    }
    return tf.range(...arguments)
  },
  // array: tf.tensor,
  array(arr) { return arr },
  argMin: tf.argMin,
  argMax: tf.argMax,
  buffer: tf.buffer,
  // clipByValue(x, min, max) {
  //   const minT = tf.zerosLike(x).add(tf.tensor([min], undefined, x.dtype))
  //   const maxT = tf.zerosLike(x).add(tf.tensor([max], undefined, x.dtype))
  //   return x.where(x.greaterEqual(min), minT).where(x.lessEqual(max), maxT)
  // },
  clipByValue(x, min, max) {
    const minT = tf.fill(x.shape, min, x.dtype)
    const maxT = tf.fill(x.shape, max, x.dtype)
    return x.where(x.greaterEqual(min), minT).where(x.lessEqual(max), maxT)
  },
  cumsum() {
    return tf.cumsum(...arguments).dataSync() //eslint-disable-line
  },
  gather: tf.gather,
  getValueAt(arr, index) {
    if (arr instanceof TensorMeta) {
      arr = arr.arraySync()
    }
    if (Number.isInteger(index)) {
      return arr[index]
    }
    let curVal = arr
    for (let i = 0; i < index.length; i++) {
      curVal = curVal[index[i]]
    }
    return curVal
  },
  getCol(tensor, col) {
    const temp = tf.transpose(tensor)
    return temp.slice(col, 1)
  },
  greater: tf.greater,
  greaterEqual: tf.greaterEqual,
  less: tf.less,
  mean: tf.mean,
  mod: tf.mod,
  ndarray: tf.tensor,
  norm: tf.norm,
  ones: tf.ones,
  round: tf.round,
  range: tf.range,
  stack: tf.stack,
  tensor: tf.tensor,
  TensorMeta, // used for type checking
  transpose: tf.transpose,
  where: tf.where,
  whereAsync: tf.whereAsync,
  util: tf.util,
  zeros: tf.zeros,
  zip(tensorA, tensorB) {
    if (Array.isArray(tensorA)) {
      tensorA = tf.tensor(tensorA)
    }
    if (Array.isArray(tensorB)) {
      tensorA = tf.tensor(tensorB)
    }
    return tf.transpose(tf.stack([tensorA, tensorB]))
  },
  // dtypes
  int8: Int8Array,
  int16: Int16Array,
  int32: Int32Array,
  uint8: Uint8Array,
  uint16: Uint16Array,
  uint32: Uint32Array,
  float32: Float32Array,
  float64: Float64Array,
  // node utility functions
  node: tf.node,
  tf,
}

},{"@tensorflow/tfjs-node":"@tensorflow/tfjs-node"}],"/point.js":[function(require,module,exports){
(function (__dirname){
const path = require('path') //eslint-disable-line
const s2clientprotocol = require('s2clientprotocol') //eslint-disable-line
const { common_pb, spatial_pb } = s2clientprotocol
// const all_collections_generated_classes = require(path.resolve(__dirname, './all_collections_generated_classes.js'))
const pythonUtils = require(path.resolve(__dirname, 'pythonUtils.js'))
const { isinstance, namedtuple, randomUniform } = pythonUtils

Math.radians = function(degrees) {
  return degrees * Math.PI / 180;
}
Math.degrees = function(radians) {
  return radians * 180 / Math.PI;
}

// class Point extends all_collections_generated_classes.Point {
class Point extends namedtuple('Point', ['x', 'y']) {
  //A basic Point class.//
  constructor(x, y) {
    super({})
    if (Array.isArray(x)) {
      this.y = x[1]
      this.x = x[0]
    } else if (Number(x) == x) {
      this.x = x
      this.y = y
    } else if (x && x.x && isinstance(x.x, [common_pb.Point, spatial_pb.PointI, common_pb.Point2D])) { // if x is a proto point class
      const point = x.x
      this.x = point.getX() || 0.0
      this.y = point.getY() || 0.0
    } else if (isinstance(x, [common_pb.Point, spatial_pb.PointI, common_pb.Point2D]) || x.toObject) {
      const point = x
      this.x = point.getX() || 0.0
      this.y = point.getY() || 0.0
    } else if (x && x.hasOwnProperty('x') && x.hasOwnProperty('y')) {
      const point = x
      this.x = point.x //x is an object { x, y }
      this.y = point.y
    }
    this[0] = this.x
    this[1] = this.y
    this.length = 2
  }

  static build(obj) {
    //Build a Point from an object that has properties `x` and `y`.//
    let usedObj = obj
    if (isinstance(obj, [common_pb.Point, common_pb.PointI, common_pb.Point2D]) || obj.toObject) {
      usedObj = {
        x: obj.getX(),
        y: obj.getY(),
      }
    } else if (Number(obj) == obj) { // arguments: (a, b) a and b are numbers
      usedObj = {
        x: obj,
        y: arguments[1], //eslint-disable-line
      }
    }
    return new Point(usedObj)
  }

  static unit_rand() {
    // Return a Point with x, y chosen randomly with 0 <= x < 1, 0 <= y < 1.//
    return this._make({ x: Math.random(), y: Math.random() })
  }

  assign_to(obj) {
    // Assign `x` and `y` to an object that has properties `x` and `y`.//
    if (isinstance(obj, [common_pb.Point, common_pb.PointI, common_pb.Point2D]) || obj.toObject) {
      obj.setX(this.x)
      obj.setY(this.y)
      return
    }
    obj.x = this.x
    obj.y = this.y
  }

  dist(other) {
    // Distance to some other point.//
    const dx = this.x - other.x
    const dy = this.y - other.y
    return Math.sqrt((dx ** 2) + (dy ** 2))
  }

  dist_sq(other) {
    // Distance squared to some other point.//
    const dx = this.x - other.x
    const dy = this.y - other.y
    return (dx ** 2) + (dy ** 2)
  }

  round() {
    // Round `x` and `y` to integers.//
    return new Point(Math.round(this.x), Math.round(this.y))
  }

  floor() {
    // Round `x` and `y` down to integers.//
    return new Point(Math.floor(this.x), Math.floor(this.y))
  }

  ceil() {
    // Round `x` and `y` up to integers.//
    return new Point(Math.ceil(this.x), Math.ceil(this.y))
  }

  abs() {
    // Take the absolute value of `x` and `y`.//
    return new Point(Math.abs(this.x), Math.abs(this.y))
  }

  len() {
    // Length of the vector to this point.//
    return Math.sqrt((this.x ** 2) + (this.y ** 2))
  }

  scale(target_len) {
    // Scale the vector to have the target length.//
    return this.mul(target_len / this.len())
  }

  scale_max_size(max_size) {
    // Scale this value, keeping aspect ratio, but fitting inside `max_size`.//

    return this.mul(max_size.div(this).min_dim())
  }

  scale_min_size(min_size) {
    // Scale this value, keeping aspect ratio, but fitting around `min_size`.//
    return this.mul(min_size.div(this).max_dim())
  }

  min_dim() {
    return Math.min(this.x, this.y)
  }

  max_dim() {
    return Math.max(this.x, this.y)
  }

  transpose() {
    // Flip x and y.//
    return new Point({ x: this.y, y: this.x })
  }

  rotate_deg(angle) {
    return this.rotate_rad(Math.radians(angle))
  }

  rotate_rad(angle) {
    return new Point(
      this.x * Math.cos(angle) - this.y * Math.sin(angle),
      this.x * Math.sin(angle) + this.y * Math.cos(angle)
    )
  }

  rotate_rand(angle = 180) {
    return this.rotate_deg(randomUniform(-angle, angle))
  }

  contained_circle(pt, radius) {
    //Is this point inside the circle defined by (`pt`, `radius`)?//
    return this.dist(pt) < radius
  }

  bound(p1, p2 = null) {
    //Bound this point within the rect defined by (`p1`, `p2`).//
    const r = new Rect(p1, p2) //eslint-disable-line
    return this.constructor._make({
      x: Math.min(Math.max(this.x, r.l), r.r),
      y: Math.min(Math.max(this.y, r.t), r.b),
    })
  }

  toString() {
    return `${this.x},${this.y}`
  }

  neg() {
    return this.constructor.build(-this.x, -this.y)
  }

  add(pt_or_val) {
    if (isinstance(pt_or_val, this.constructor)) {
      return this.constructor.build(this.x + pt_or_val.x, this.y + pt_or_val.y)
    }
    return this.constructor.build(this.x + pt_or_val, this.y + pt_or_val)
  }

  sub(pt_or_val) {
    if (isinstance(pt_or_val, this.constructor)) {
      return this.constructor.build(this.x - (pt_or_val.x), this.y - (pt_or_val.y))
    }
    return this.constructor.build(this.x - pt_or_val, this.y - pt_or_val)
  }

  mul(pt_or_val) {
    if (isinstance(pt_or_val, this.constructor)) {
      return this.constructor.build(this.x * pt_or_val.x, this.y * pt_or_val.y)
    }
    return this.constructor.build(this.x * pt_or_val, this.y * pt_or_val)
  }

  truediv(pt_or_val) {
    if (isinstance(pt_or_val, this.constructor)) {
      return this.constructor.build(this.x / pt_or_val.x, this.y / pt_or_val.y)
    }
    return this.constructor.build(this.x / pt_or_val, this.y / pt_or_val)
  }

  floordiv(pt_or_val) {
    if (isinstance(pt_or_val, this.constructor.build)) {
      return this.constructor.build(
        Math.floor(this.x / pt_or_val.x),
        Math.floor(this.y / pt_or_val.y)
      )
    }
    return this.constructor.build(
      Math.floor(this.x / pt_or_val),
      Math.floor(this.y / pt_or_val)
    )
  }

  div() {
    return this.truediv(...arguments) //eslint-disable-line
  }

  eq(pt_or_proto) {
    if (!pt_or_proto) {
      return false
    }
    if (pt_or_proto.getX) {
      return pt_or_proto.getX() == this.x && pt_or_proto.getY() == this.y
    }
    return pt_or_proto.x == this.x && pt_or_proto.y == this.y
  }
}

const origin = new Point(0.0, 0.0)

// class Rect extends all_collections_generated_classes.Rect {
class Rect extends namedtuple("Rect", ["t", "l", "b", "r"]) {
  //A basic Rect class. Assumes tl <= br.//

  constructor() {
    let arg = arguments //eslint-disable-line
    if (arg.length === 1 || (arg.length === 2 && arg[1] === null)) {
      arg = [origin, arg[0]]
    }
    if (arg.length === 2) {
      const [p1, p2] = arg
      if (!isinstance(p1, Point) || !isinstance(p2, Point)) {
        throw new Error(`TypeError: Rect expected Points`)
      }
      super({
        t: Math.min(p1.y, p2.y),
        l: Math.min(p1.x, p2.x),
        b: Math.max(p1.y, p2.y),
        r: Math.max(p1.x, p2.x),
      })
      return
    }
    if (arg.length === 4) {
      if (arg[0] > arg[2] || arg[1] > arg[3]) {
        throw new Error(`TypeError:"Rect requires: t <= b and l <= r`)
      }
      super({
        t: arg[0],
        l: arg[1],
        b: arg[2],
        r: arg[3],
      })
      return
    }
    throw new Error(`TypeError:
        "Unexpected arguments to Rect. Takes 1 or 2 Points, or 4 coords.`)
  }

  str() {
    return `${this.l},${this.r},${this.t},${this.b},`
  }

  toString() {
    return this.str()
  }

  get center() {
    return new Point(this.l + this.r, this.t + this.b).mul(0.5)
  }

  get top() {
    return this.t
  }

  get left() {
    return this.l
  }

  get bottom() {
    return this.b
  }

  get right() {
    return this.r
  }

  get width() {
    return this.r - this.l
  }

  get height() {
    return this.b - this.t
  }

  get tl() {
    return new Point(this.l, this.t)
  }

  get br() {
    return new Point(this.r, this.b)
  }

  get tr() {
    return new Point(this.r, this.t)
  }

  get bl() {
    return new Point(this.l, this.b)
  }

  get diagonal() {
    return new Point(this.width, this.height)
  }

  get size() {
    return this.br.sub(this.tl)
  }

  get area() {
    const size = this.size
    return size.x * size.y
  }

  round() {
    return new Rect(this.tl.round(), this.br.round())
  }

  floor() {
    return new Rect(this.tl.floor(), this.br.floor())
  }

  ceil() {
    return new Rect(this.tl.ceil(), this.br.ceil())
  }

  contains_point(pt) {
    //Is the point inside this rect?//
    return (this.l < pt.x && this.r > pt.x &&
            this.t < pt.y && this.b > pt.y)
  }

  contains_circle(pt, radius) {
    //Is the circle completely inside this rect?//
    return (this.l < pt.x - radius && this.r > pt.x + radius &&
            this.t < pt.y - radius && this.b > pt.y + radius)
  }

  intersects_circle(pt, radius) {
    //Does the circle intersect with this rect?//
    // How this works: http://stackoverflow.com/a/402010
    const rect_corner = this.size.mul(0.5) // relative to the rect center
    const circle_center = pt.sub(this.center).abs() // relative to the rect center

    // console.log('rect_corner: ', rect_corner, '\ncircle_center: ', circle_center)
    // Is the circle far from the rect?
    if (circle_center.x > rect_corner.x + radius ||
        circle_center.y > rect_corner.y + radius) {
      return false
    }
    // Is the circle center inside the rect or near one of the edges?
    if (circle_center.x <= rect_corner.x ||
        circle_center.y <= rect_corner.y) {
      return true
    }

    // Does the circle contain the corner of the rect?
    return circle_center.dist_sq(rect_corner) <= (radius ** 2)
  }
}

module.exports = {
  origin,
  Point,
  Rect,
}

}).call(this,"/")
},{"path":6,"s2clientprotocol":"s2clientprotocol"}],"/protocol.js":[function(require,module,exports){
(function (process,__dirname){
const path = require('path') //eslint-disable-line
const Enum = require('python-enum') //eslint-disable-line
const s2clientprotocol = require('s2clientprotocol') //eslint-disable-line
const websocket = require('ws') //eslint-disable-line
const flags = require('flags') //eslint-disable-line
const { performance } = require('perf_hooks') //eslint-disable-line
const stopwatch = require(path.resolve(__dirname, 'stopwatch.js'))
const pythonUtils = require(path.resolve(__dirname, './pythonUtils.js'))

/*** Protocol library to make communication easy ***

All communication over the connection is based around Request and Response messages. Requests are used for controlling the state of the application, retrieving data and controlling gameplay.

The data sent into the game must be exactly a series of protobuf defined “Request” objects. The data sent back from the game will be exactly a series of protobuf defined “Response” objects, whose type exactly matches the order of incoming “Request” objects.

You are allowed to send additional requests before receiving a response to an earlier request. Requests will be queued and processed in received order. Keeping the request queue saturated is best for optimal performance.

*/
const { sc2api_pb } = s2clientprotocol
const sc_pb = sc2api_pb
const { assert, snakeToPascal, withPython, withPythonAsync } = pythonUtils

flags.defineInteger('sc2_verbose_protocol', 0, `
  Print the communication packets with SC2. 0 disables.
  -1 means all. >0 will print that many lines per 
  'packet. 20 is a good starting value.`
) //eslint-disable-line

// Create a python version of the Status enum in the proto.
const Status = Enum.Enum('Status', sc_pb.Status)

const MAX_WIDTH = Number(process.env.COLUMNS) || 200 // Get your TTY width.

class ConnectionError extends Error {
  //Failed to read/write a message, details in the error string.//
  constructor(msg) {
    super(msg)
    this.name = 'ConnectionError'
  }
}
class ProtocolError extends Error {
  constructor(msg) {
    super(msg)
    this.name = 'ProtocolError'
  }
}
// function catch_websocket_connection_errors() {
//   //A context manager that translates websocket errors into ConnectionError.//

//   /* not sure we need this in javascript */
// }
class StarcraftProtocol {
  constructor(ws, passedSw) {
    // set the stop watch to a specific instance if provided
    this._sw = passedSw || stopwatch.sw
    const sw = this._sw
    flags.parse(null, true)
    this._status = Status.LAUNCHED
    this._sock = ws._socket
    this._port = this._sock.address().port
    // console.log('********************** _sock.address():', this._sock.address())
    this._ws = ws
    this._count = 1
    // apply @decoraters
    this.read = sw.decorate(this.read.bind(this))
    this.write = sw.decorate(this.write.bind(this))
    // set up sync-like read
    this._trigger = null
    this._que = []
    this._ws.on('message', (response) => {
      if (!response) {
        throw new ProtocolError('Got an empty response from SC2.')
      }
      if (this._trigger) {
        this._trigger(response)
        this._trigger = null
        return
      }
      this._que.push(response)
    })
  }

  get status() {
    return this._status
  }

  next(n) {
    this._count = n + 1
    return this._count
  }

  close() {
    if (this._sock) {
      this._ws.terminate()
      this._ws = null
      this._sock = null
    }
    this._status = Status.QUIT
  }

  async read() {
    //Read a Response, do some validation, and return it.//
    let start
    if (flags.get('sc2_verbose_protocol')) {
      this._log(`-------------- [${this._port}] Reading response --------------`)
      // performance.now() => measured in milliseconds.
      start = performance.now() * 1000
    }
    const response = await this._read()
    if (flags.get('sc2_verbose_protocol')) {
      this._log(`-------------- [${this._port}] Read ${response.getResponseCase()} in ${performance.now() * 1000 - start} msec --------------\n${this._packet_str(response)}`)
    }
    if (response.getStatus && !response.getStatus()) {
      throw new ProtocolError('Got an incomplete response without a status')
    }
    const prev_status = this._status
    this._status = Status(response.getStatus())
    if (response.hasError && response.hasError() && response.getError()) {
    // if (response.getError && response.getError()) {
      const err_str = `Error in RPC response (likely a bug).\n Prev status: ${prev_status}, new status: ${this._status} \n ${response.getError()}`
      this._log(err_str)
      throw new ProtocolError(err_str)
    }
    return response
  }

  write(request) {
    //Write a Request.//
    if (flags.get('sc2_verbose_protocol')) {
      const printObj = request.toObject()
      if (printObj.saveMap && printObj.saveMap.mapData) {
        printObj.saveMap.mapData = `<buffer ${printObj.saveMap.mapData.length} bytes>`
      }
      if (printObj.startReplay && printObj.startReplay.mapData) {
        printObj.startReplay.mapData = `<buffer ${printObj.startReplay.mapData.length} bytes>`
        printObj.startReplay.replayData = `<buffer ${printObj.startReplay.replayData.length} bytes>`
      }
      this._log(`-------------- [${this._port}] Writing request: ${JSON.stringify(printObj)} --------------\n${this._packet_str(request)}`)
    }
    this._write(request)
  }

  async send_req(request) {
    //Write a pre-filled Request and return the Response.//
    this.write(request) //eslint-disable-next-line
    return await this.read() // written this way to keep control flow same as python
  }

  async send(kwargs) {
    /*
    Create and send a specific request, and return the response.

    For example: send(ping=sc_pb.RequestPing()) => sc_pb.ResponsePing

    Args:
      **kwargs: A single kwarg with the name and value to fill in to Request.

    Returns:
      The Response corresponding to your request.
    Raises:
      ConnectionError: if it gets a different response.
    */
    const names = Object.keys(kwargs)
    assert(names.length === 1, 'Must make a single request')
    let name = names[0]
    const val = kwargs[name]
    const req = new sc_pb.Request() // init proto req class
    name = snakeToPascal(name)
    const isList = Array.isArray(val)
    // proto setters: setFoo, setFooList
    req[`set${name + (isList ? 'List' : '')}`](val)
    req.setId(this.next(this._count))
    let res
    try {
      res = await this.send_req(req)
    } catch (err) {
      console.warn('PORT: ', this._port, '\nreq:\n', req.toObject(), '\nres:\n', res ? res.toObject() : 'undefined')
      throw new ConnectionError(`Error during ${name}: ${err}`)
    }
    if (res.getId && res.getId() !== req.getId()) {
      const reqObj = req.toObject()
      Object.keys(reqObj).forEach((key) => {
        if (key.match('data') && reqObj[key]) {
          reqObj[key] = `<data ${reqObj[key].length}>`
        }
      })
      console.warn('PORT: ', this._port, '\nreq:\n', reqObj, '\nres:\n', res ? res.toObject() : 'undefined')
      throw new ConnectionError(`Error during ${name}: Got a response with a different id\n expected: ${req.getId()}, got: ${res.getId()}`)
    }

    // proto getters: getFoo, getFooList
    return res[`get${name + (isList ? 'List' : '')}`]()
  }

  _packet_str(packet) { //eslint-disable-line
    //Return a string form of this packet.//
    const max_lines = flags.get('sc2_verbose_protocol')
    const packet_str = String(packet).trim()
    if (max_lines <= 0) {
      return packet_str
    }
    let lines = packet_str.split('\n')
    const line_count = lines.length
    lines = lines.slice(0, max_lines + 1).map((line) => line.slice(0, MAX_WIDTH))
    if (line_count > max_lines + 1) { // +1 to prefer the last line to skipped msg.
      lines.push(`***** ${line_count - max_lines} lines skipped *****`)
    }
    return lines.join('\n')
  }

  _log(s) { //eslint-disable-line
    const args = []
    for (let i = 1; i < arguments.length; i++) {
      args.push(arguments[i]) //eslint-disable-line
    }
    process.stderr.write(s + '\n' + args)
    // process.stderr.clearScreenDown() // js equivalent of flush, unsure if we need it though
  }

  async _read() {
    //Actually read the response and parse it, returning a Response.//
    // let response = await withPythonAsync(this._sw('read_response'), async () => {
    let response = await withPython(this._sw('read_response'), async () => {
      if (this._que.length) {
        return this._que.shift()
      }
      return new Promise((resolve) => { this._trigger = resolve })
    })
    withPython(this._sw('parse_response'), () => {
      response = sc_pb.Response.deserializeBinary(response)
    })
    return response
  }

  _write(request) {
    //Actually serialize and write the request.//
    let request_str
    withPython(this._sw('serialize_request'), () => {
      request_str = request.serializeBinary()
    })
    withPython(this._sw('write_request'), () => {
      try { //eslint-disable-line
        this._ws.send(request_str)
      } catch (err) {
        /* TODO: Handling of different error types
            raise ConnectionError("Connection already closed. SC2 probably crashed. "
              "Check the error log.")
            except websocket.WebSocketTimeoutException:
              raise ConnectionError("Websocket timed out.")
            except socket.error as e:
              raise ConnectionError("Socket error: %s" % e)
        */
        throw err
      }
    })
  }
}

module.exports = {
  ConnectionError,
  ProtocolError,
  StarcraftProtocol,
  Status,
}

}).call(this,require('_process'),"/")
},{"_process":7,"flags":41,"path":6,"perf_hooks":1,"python-enum":103,"s2clientprotocol":"s2clientprotocol","ws":115}],"/pythonUtils.js":[function(require,module,exports){
const os = require('os') //eslint-disable-line
const s2clientprotocol = require('s2clientprotocol') //eslint-disable-line
const { common_pb, raw_pb, spatial_pb, ui_pb } = s2clientprotocol

/*eslint-disable no-use-before-define*/

class ABCMeta {
  static get abstractMethods() { return [] }

  constructor() {
    const abstractMethods = this.constructor.abstractMethods
    function NotImplementedError(message) {
      this.name = "NotImplementedError"
      this.message = (message || "")
    }
    NotImplementedError.prototype = Error.prototype
    Object.keys(abstractMethods).forEach((key) => {
      const methodName = abstractMethods[key]
      /* keeping this comment for inheritance blocking in the future */
      // if (!this.constructor.prototype.hasOwnProperty(methodName) || typeof this.constructor.prototype[methodName] !== 'function') {
      //   throw new NotImplementedError(methodName)
      // }
      if (typeof this.constructor.prototype[methodName] !== 'function') {
        throw new NotImplementedError(methodName)
      }
    })
  }
}

function any(iterable) {
  for (let index = 0; index < iterable.length; index++) {
    if (iterable[index]) return true
  }
  return false
}

function arrayCompare(a, b, sameOrder = false) {
  if (sameOrder) {
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false
      }
    }
    return true
  }
  const aSeen = {}
  const bSeen = {}
  for (let i = 0; i < a.length; i++) {
    aSeen[a[i]] = true
    bSeen[b[i]] = true
  }
  for (let i = 0; i < a.length; i++) {
    if (!(aSeen[a[i]] && bSeen[a[i]])) {
      return false
    }
  }
  return true
}

function arrayDtype(array) {
  if (array.length == null) {
    return typeof (array)
  }
  return arrayDtype(array[0])
}

function arrayShape(array) {
  let shape = []
  let keepgoing = true
  let count = 0
  while (keepgoing) {
    if (array.length > 0) {
      count += 1
      shape.push(array.length)
      array = array[0]
    } else {
      keepgoing = false
      if (count == 1) {
        shape = [1]
      }
    }
  }
  return shape
}

function arraySub(a, b) {
  // This function operates subtraction with 1D or 2d array
  const result = []
  const c = []
  if (a.length === 0) {
    if (b.length === 0) {
      return []
    }
    return b
  }
  if (a[0].length === undefined) {
    for (let i = 0; i < a.length; i++) {
      result.push(a[i] - b[i])
    }
  } else {
    for (let row = 0; row < a.length; row++) {
      for (let col = 0; col < a[0].length; col++) {
        c.push(a[row][col] - b[row][col])
      }
    }
    while (c.length) { result.push(c.splice(0, a[0].length)) }
  }
  return result
}

function assert(cond, errMsg) {
  if (cond === false) {
    throw new Error(errMsg)
  }
}

function clip(a, a_min, a_max) {
  let n
  for (let i = 0; i < a.length; i++) {
    n = a[i]
    if (n < a_min) {
      a[i] = a_min
    } else if (n > a_max) {
      a[i] = a_max
    }
  }
}

function compareKey(a, b, key) {
  if (Array.isArray(a)) {
    return arrayCompare(a, b)
  }
  return a[key] === b[key]
}

function compareAIF(a, b) {
  assert(compareKey(a, b, 'feature_dimensions'), "compareKey(a, b, 'feature_dimensions'")
  assert(compareKey(a, b, 'rgb_dimensions'), "compareKey(a, b, 'rgb_dimensions')")
  assert(compareKey(a, b, 'raw_resolution'), "compareKey(a, b, 'raw_resolution')")
  assert(compareKey(a, b, 'action_space'), "compareKey(a, b, 'action_space')")
  assert(compareKey(a, b, 'camera_width_world_units'), "compareKey(a, b, 'camera_width_world_units')")
  assert(compareKey(a, b, 'use_feature_units'), "compareKey(a, b, 'use_feature_units')")
  assert(compareKey(a, b, 'use_raw_units'), "compareKey(a, b, 'use_raw_units')")
  assert(compareKey(a, b, 'use_raw_actions'), "compareKey(a, b, 'use_raw_actions')")
  assert(compareKey(a, b, 'max_raw_actions'), "compareKey(a, b, 'max_raw_actions')")
  assert(compareKey(a, b, 'max_selected_units'), "compareKey(a, b, 'max_selected_units')")
  assert(compareKey(a, b, 'use_unit_counts'), "compareKey(a, b, 'use_unit_counts')")
  assert(compareKey(a, b, 'use_camera_position'), "compareKey(a, b, 'use_camera_position')")
  assert(compareKey(a, b, 'show_cloaked'), "compareKey(a, b, 'show_cloaked')")
  assert(compareKey(a, b, 'show_burrowed_shadows'), "compareKey(a, b, 'show_burrowed_shadows')")
  assert(compareKey(a, b, 'show_placeholders'), "compareKey(a, b, 'show_placeholders')")
  assert(compareKey(a, b, 'hide_specific_actions'), "compareKey(a, b, 'hide_specific_actions')")
  assert(compareKey(a, b, 'action_delay_fn'), "compareKey(a, b, 'action_delay_fn')")
  assert(compareKey(a, b, 'send_observation_proto'), "compareKey(a, b, 'send_observation_proto')")
  assert(compareKey(a, b, 'crop_to_playable_area'), "compareKey(a, b, 'crop_to_playable_area')")
  assert(compareKey(a, b, 'raw_crop_to_playable_area'), "compareKey(a, b, 'raw_crop_to_playable_area')")
  assert(compareKey(a, b, 'allow_cheating_layers'), "compareKey(a, b, 'allow_cheating_layers')")
  assert(compareKey(a, b, 'add_cargo_to_units'), "compareKey(a, b, 'add_cargo_to_units')")
}

function compareObsSpec(a, b) {
  assert(compareKey(a, b, "action_result"))
  assert(compareKey(a, b, "alerts"))
  assert(compareKey(a, b, "build_queue"))
  assert(compareKey(a, b, "cargo"))
  assert(compareKey(a, b, "cargo_slots_available"))
  assert(compareKey(a, b, "control_groups"))
  assert(compareKey(a, b, "game_loop"))
  assert(compareKey(a, b, "last_actions"))
  assert(compareKey(a, b, "map_name"))
  assert(compareKey(a, b, "multi_select"))
  assert(compareKey(a, b, "player"))
  assert(compareKey(a, b, "production_queue"))
  assert(compareKey(a, b, "score_cumulative"))
  assert(compareKey(a, b, "score_by_category"))
  assert(compareKey(a, b, "score_by_vital"))
  assert(compareKey(a, b, "single_select"))
}

function eq(a, b) {
  if (a.__eq__) {
    return a.__eq__(b)
  }
  if (b.__eq__) {
    return b.__eq__(a)
  }
  return a === b
}

function expanduser(path) {
  const homedir = os.homedir()
  path = path.replace(/~user/g, homedir)
  path = path.replace(/~/g, homedir)
  path = path.replace(/\\/g, '/')
  return path
}

//eslint-disable-next-line
Array.prototype.extend = function(array) {
  for (let i = 0; i < array.length; i++) {
    this.push(array[i])
  }
}
//eslint-disable-next-line
Object.defineProperty(Array.prototype, 'extend', {
  value: Array.prototype.extend,
  iterable: false,
  enumerable: false,
})

function getArgNames(func) {
  // First match everything inside the function argument parens.
  const args = func.toString().match(/function\s.*?\(([^)]*)\)/)[1]

  // Split the arguments string into an array comma delimited.
  return args.split(',').map(function(arg) {
    // Ensure no inline comments are parsed and trim the whitespace.
    return arg.replace(/\/\*.*\*\//, '').trim()
  }).filter(function(arg) {
    // Ensure no undefined values are added.
    return arg
  })
}
function getArgsArray(func, kwargs) {
  if (getArgsArray.argSignatures[func.name]) {
    return getArgsArray.argSignatures[func.name].map((argName) => kwargs[argName])
  }
  getArgsArray.argSignatures[func.name] = getArgNames(func)
  return getArgsArray.argSignatures[func.name].map((argName) => kwargs[argName])
}
getArgsArray.argSignatures = {}
getArgsArray.getArgNames = getArgNames
//eslint-disable-next-line
String.prototype.splitlines = function() {
  return this.split(/\r?\n/)
}

function getImageData(unit8data, [width, height], rgb = true, color, palette) {
  const multiplier = 1
  const bytes = new Uint8ClampedArray(width * height * 4);
  const a = Math.round(255);

  if (rgb) {
    for (let i = 0; i < height * width; ++i) {
      const r = unit8data[i * 3] * multiplier;
      const g = unit8data[i * 3 + 1] * multiplier;
      const b = unit8data[i * 3 + 2] * multiplier;
      const j = i * 4;
      // start craft 2 api appears to be switching the red and blue channels
      bytes[j + 0] = b | 0;
      bytes[j + 1] = g | 0;
      bytes[j + 2] = r | 0;
      bytes[j + 3] = a;
    }
  } else if (palette) {
    for (let i = 0; i < height * width; ++i) {
      const j = i * 4;
      if (unit8data[i]) {
        color = palette[unit8data[i]]
        bytes[j + 0] = color[0] | 0;
        bytes[j + 1] = color[1] | 0;
        bytes[j + 2] = color[2] | 0;
        bytes[j + 3] = a;
      } else {
        bytes[j + 0] = 0;
        bytes[j + 1] = 0;
        bytes[j + 2] = 0;
        bytes[j + 3] = a;
      }
    }
  } else if (color) {
    for (let i = 0; i < height * width; ++i) {
      const j = i * 4;
      if (unit8data[i]) {
        bytes[j + 0] = color[0] | 0;
        bytes[j + 1] = color[1] | 0;
        bytes[j + 2] = color[2] | 0;
        bytes[j + 3] = a;
      } else {
        bytes[j + 0] = 0;
        bytes[j + 1] = 0;
        bytes[j + 2] = 0;
        bytes[j + 3] = a;
      }
    }
  } else {
    for (let i = 0; i < height * width; ++i) {
      const r = unit8data[i] * multiplier;
      const g = r
      const b = r
      const j = i * 4;
      bytes[j + 0] = r | 0;
      bytes[j + 1] = g | 0;
      bytes[j + 2] = b | 0;
      bytes[j + 3] = a;
    }
  }

  return new ImageData(bytes, width, height);
}

function hashCode(str) {
// https://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
  var hash = 0;
  if (str.length == 0) {
    return hash
  }
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash &= hash; // Convert to 32bit integer
  }
  return hash;
}

function getattr(proto, key) {
  if (proto[`get${snakeToPascal(key)}`]) {
    return proto[`get${snakeToPascal(key)}`]()
  }
  if (proto[`get${snakeToPascal(key)}List`]) {
    return proto[`get${snakeToPascal(key)}List`]()
  }
  return null
}

//eslint-disable-next-line
String.prototype.ljust = function(length, char = ' ') {
  const fill = []
  while (fill.length + this.length < length) {
    fill[fill.length] = char;
  }
  return this + fill.join('');
}
//eslint-disable-next-line
String.prototype.rjust = function(length, char = ' ') {
  const fill = []
  while (fill.length + this.length < length) {
    fill[fill.length] = char;
  }
  return fill.join('') + this;
}

function int(numOrStr) {
  return Math.floor(numOrStr)
}

//eslint-disable-next-line
String.prototype.lpad = function(length, char = ' ') {
  const fill = Array(length);
  for (let i = 0; i < length; i++) {
    fill[i] = char;
  }
  return this + fill.join('');
}
//eslint-disable-next-line
String.prototype.rpad = function(length, char = ' ') {
  const fill = Array(length);
  for (let i = 0; i < length; i++) {
    fill[i] = char;
  }
  return fill.join('') + this;
}

function isinstance(a, compare) {
  const keys = Object.keys(compare);
  if (Array.isArray(compare) && keys.length) {
    for (let i = 0; i < keys.length; i++) {
      if (isinstance(a, compare[keys[i]])) {
        return true
      }
    }
    return false
  }
  if (compare === Number) {
    return Number(a) === a
  }
  if (compare === Boolean) {
    return Boolean(a) === a
  }
  if (compare === String) {
    return String(a) === a
  }
  return a instanceof compare;
}

function isObject(a) {
  return a === Object(a)
}

function iter(container) {
  if (container.__iter__) {
    return container.__iter__()
  }
  if (len(container)) {
    return Object.keys(container).map((key) => container[key])
  }
  throw new Error('ValueError: Cannont iterate over non-iterable')
}

function len(container) {
  if (container.__len__) {
    return container.__len__()
  }
  return Object.keys(container).length;
}

function map(func, collection) {
  function clone(obj) {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }
    const copy = obj.constructor();
    for (let attr in obj) {//eslint-disable-line
      if (obj.hasOwnProperty(attr)) {
        copy[attr] = obj[attr];
      }
    }
    return copy;
  }
  const copy = clone(collection)
  Object.keys(copy).forEach((key) => {
    collection[key] = func(collection[key])
  })
}

function namedtuple(name, fields) {
  let consArgs = '';
  fields.forEach((field, i) => {
    consArgs += i < fields.length - 1 ? `${field}, ` : `${field}`;
  });
  const classStr = `const _fields = ${JSON.stringify(fields)}; return class ${name} extends Array {
  static get classname() { return '${name}' }
  static get _fields() { return ${JSON.stringify(fields)} }
  constructor(${consArgs}) {
    const usedArgs = []
    if (typeof arguments[0] === 'object' && arguments.length === 1 && _fields.length > 1) {
      const kwargs = arguments[0]
      _fields.forEach((field, index) => {
        usedArgs[index] = kwargs[field]
      })
      super(...usedArgs)
    } else {
      _fields.forEach((field, index) => {
        usedArgs[index] = arguments[index]
      })
      super(...usedArgs)
    }
  }
  static _make(kwargs) {
    return new this.prototype.constructor(kwargs);
  }
  _replace(kwargs) {
    this.constructor._fields.forEach((field) => {
        kwargs[field] = kwargs[field] || this[field];
    });
    return this.constructor._make(kwargs);
  }
  __reduce__() {
    return [this.constructor, this.constructor._fields.map((field) => this[field])];
  }
${fields.map((field, index) => { //eslint-disable-line
    return `  get ${field}() {\n    return this[${index}]\n  }\n  set ${field}(val) {\n    this[${index}] = val; return val\n  }`
  }).join('\n')}
}`;
  return Function(classStr)() //eslint-disable-line
}

function NotImplementedError(message) {
  ///<summary>The error thrown when the given function isn't implemented.</summary>
  const sender = (new Error) //eslint-disable-line
    .stack
    .split('\n')[2]
    .replace(' at ', '');

  this.message = `The method ${sender} isn't implemented.`;

  // Append the message if given.
  if (message) {
    this.message += ` Message: "${message}".`;
  }

  let str = this.message;

  while (str.indexOf('  ') > -1) {
    str = str.replace('  ', ' ');
  }

  this.message = str;
}

function nonZero(arr) {
  // This function outputs a array of indices of nonzero elements
  const indices = []
  if (arr[0].length == undefined) {
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] !== 0) {
        indices.push(i)
      }
    }
  } else {
    const shape = [arr.length, arr[0].length]
    for (let row = 0; row < shape[0]; row++) {
      for (let col = 0; col < shape[1]; col++) {
        if (arr[row][col] !== 0) {
          indices.push([row, col])
        }
      }
    }
  }
  return indices
}

function randomChoice(arr) {
  // This function does not support "size" of output shape.
  return arr[Math.floor(Math.random() * arr.length)]
}

function randomSample(arr, size) {
  var shuffled = arr.slice(0)
  let i = arr.length
  let temp
  let index
  while (i--) {
    index = Math.floor((i + 1) * Math.random())
    temp = shuffled[index]
    shuffled[index] = shuffled[i]
    shuffled[i] = temp
  }
  return shuffled.slice(0, size)
}

function randomUniform(min, max) {
  return Math.random() * (max - min) + min
}

randomUniform.int = function (min, max) {
  return Math.round(randomUniform(min, max))
}

async function sequentialTaskQueue(tasks) {
  const results = []
  const reducer = (promiseChain, currentTask) => { //eslint-disable-line
    return promiseChain.then((result) => {
      if (result) {
        results.push(result)
      }
      return currentTask()
    })
  }
  await tasks.reduce(reducer, Promise.resolve())
  return results
}

function setattr(proto, key, value) {
  if (Array.isArray(value) && proto[`set${snakeToPascal(key)}List`]) {
    proto[`set${snakeToPascal(key)}List`](value)
  } else if (proto[`set${snakeToPascal(key)}`]) {
    proto[`set${snakeToPascal(key)}`](value)
  } else {
    console.error(`Failed to find setter method for field "${key}"\n using "set${snakeToPascal(key)}" or "set${snakeToPascal(key)}List"\n on proto:\n`, proto.toObject())
    throw new Error(`Failed to find setter method for field "${key}" on proto.`)
  }
}

function setUpProtoAction(action, name) {
  if (name === 'no_op') {
    return action
  }
  if (name === 'move_camera') {
    const actionSpatial = new spatial_pb.ActionSpatial()
    const camMove = new spatial_pb.ActionSpatialCameraMove()
    camMove.setCenterMinimap(new common_pb.PointI())
    actionSpatial.setCameraMove(camMove)
    action.setActionFeatureLayer(actionSpatial)
    action.setActionRender(actionSpatial)
    return action
  }
  if (name === 'select_point') {
    const actionSpatial = new spatial_pb.ActionSpatial()
    const unitSelectionPoint = new spatial_pb.ActionSpatialUnitSelectionPoint()
    unitSelectionPoint.setSelectionScreenCoord(new common_pb.PointI())
    actionSpatial.setUnitSelectionPoint(unitSelectionPoint)
    action.setActionFeatureLayer(actionSpatial)
    action.setActionRender(actionSpatial)
    return action
  }
  if (name === 'select_rect') {
    const actionSpatial = new spatial_pb.ActionSpatial()
    const unitSelectionRect = new spatial_pb.ActionSpatialUnitSelectionRect()
    // unitSelectionRect.addSelectionScreenCoord(new common_pb.RectangleI())
    actionSpatial.setUnitSelectionRect(unitSelectionRect)
    action.setActionFeatureLayer(actionSpatial)
    action.setActionRender(actionSpatial)
    return action
  }
  if (name === 'select_idle_worker') {
    const actionUI = new ui_pb.ActionUI()
    const selectIdleWorker = new ui_pb.ActionSelectIdleWorker()
    actionUI.setSelectIdleWorker(selectIdleWorker)
    action.setActionUi(actionUI)
    return action
  }
  if (name === 'select_army') {
    const actionUI = new ui_pb.ActionUI()
    const selectArmy = new ui_pb.ActionSelectArmy()
    actionUI.setSelectArmy(selectArmy)
    action.setActionUi(actionUI)
    return action
  }
  if (name === 'select_warp_gates') {
    const actionUI = new ui_pb.ActionUI()
    const selectWarpGates = new ui_pb.ActionSelectWarpGates()
    actionUI.setSelectWarpGates(selectWarpGates)
    action.setActionUi(actionUI)
    return action
  }
  if (name === 'select_larva') {
    const actionUI = new ui_pb.ActionUI()
    // const selectLarva = new ui_pb.ActionSelectLarva()
    // actionUI.setSelectLarva(selectLarva)
    action.setActionUi(actionUI)
    return action
  }
  if (name === 'select_unit') {
    const actionUI = new ui_pb.ActionUI()
    const multiPanel = new ui_pb.ActionMultiPanel()
    actionUI.setMultiPanel(multiPanel)
    action.setActionUi(actionUI)
    return action
  }
  if (name === 'select_control_group' || name === 'control_group') {
    const actionUI = new ui_pb.ActionUI()
    const controlGroup = new ui_pb.ActionControlGroup()
    actionUI.setControlGroup(controlGroup)
    action.setActionUi(actionUI)
    return action
  }
  if (name === 'unload') {
    const actionUI = new ui_pb.ActionUI()
    const cargoPanel = new ui_pb.ActionCargoPanelUnload()
    actionUI.setCargoPanel(cargoPanel)
    action.setActionUi(actionUI)
    return action
  }
  if (name === 'build_queue') {
    const actionUI = new ui_pb.ActionUI()
    const productionPanel = new ui_pb.ActionProductionPanelRemoveFromQueue()
    actionUI.setProductionPanel(productionPanel)
    action.setActionUi(actionUI)
    return action
  }
  if (name === 'cmd_quick') {
    const unitCommand = new spatial_pb.ActionSpatialUnitCommand()
    const actionSpatial = new spatial_pb.ActionSpatial()
    actionSpatial.setUnitCommand(unitCommand)
    action.setActionFeatureLayer(actionSpatial)
    action.setActionRender(actionSpatial)
    return action
  }
  if (name === 'cmd_screen') {
    const unitCommand = new spatial_pb.ActionSpatialUnitCommand()
    unitCommand.setTargetScreenCoord(new common_pb.PointI())
    const actionSpatial = new spatial_pb.ActionSpatial()
    actionSpatial.setUnitCommand(unitCommand)
    action.setActionFeatureLayer(actionSpatial)
    action.setActionRender(actionSpatial)
    return action
  }
  if (name === 'cmd_minimap') {
    const unitCommand = new spatial_pb.ActionSpatialUnitCommand()
    unitCommand.setTargetMinimapCoord(new common_pb.PointI())
    const actionSpatial = new spatial_pb.ActionSpatial()
    actionSpatial.setUnitCommand(unitCommand)
    action.setActionFeatureLayer(actionSpatial)
    action.setActionRender(actionSpatial)
    return action
  }
  if (name === 'autocast') {
    const actionUI = new ui_pb.ActionUI()
    const toggleAutocast = new ui_pb.ActionToggleAutocast()
    actionUI.setToggleAutocast(toggleAutocast)
    action.setActionUi(actionUI)
    return action
  }
  if (name === 'raw_no_op') {
    return action
  }
  if (name === 'raw_move_camera') {
    const actionRaw = new raw_pb.ActionRaw()
    const camMove = new raw_pb.ActionRawCameraMove()
    camMove.setCenterWorldSpace(new common_pb.Point())
    actionRaw.setCameraMove(camMove)
    action.setActionRaw(actionRaw)
    return action
  }
  if (name === 'raw_cmd') {
    const actionRaw = new raw_pb.ActionRaw()
    const unitCommand = new raw_pb.ActionRawUnitCommand()
    actionRaw.setUnitCommand(unitCommand)
    action.setActionRaw(actionRaw)
    return action
  }
  if (name === 'raw_cmd_pt') {
    const actionRaw = new raw_pb.ActionRaw()
    const unitCommand = new raw_pb.ActionRawUnitCommand()
    unitCommand.setTargetWorldSpacePos(new common_pb.Point2D())
    actionRaw.setUnitCommand(unitCommand)
    action.setActionRaw(actionRaw)
    return action
  }
  if (name === 'raw_cmd_unit') {
    const actionRaw = new raw_pb.ActionRaw()
    const unitCommand = new raw_pb.ActionRawUnitCommand()
    actionRaw.setUnitCommand(unitCommand)
    action.setActionRaw(actionRaw)
    return action
  }
  if (name === 'raw_autocast') {
    const actionRaw = new raw_pb.ActionRaw()
    const toggleAutocast = new raw_pb.ActionRawCameraMove()
    actionRaw.setToggleAutocast(toggleAutocast)
    action.setActionRaw(actionRaw)
    return action
  }
}

const snakeToCamel = (str) => {
  if (!str.match('_')) {
    return str
  }
  return str
    .toLowerCase().replace(/([-_][a-z])/g, (group) => group
      .toUpperCase()
      .replace('-', '')
      .replace('_', ''))
}

function snakeToPascal(str) {
  const usedStr = snakeToCamel(str)
  return usedStr[0].toUpperCase() + usedStr.slice(1, usedStr.length)
}

function sum(collection) {
  let total = 0
  Object.keys(collection).forEach((key) => {
    total += collection[key]
  })
  return total
}

class DefaultDict {
  constructor(DefaultInit) {
    return new Proxy({}, {
      //eslint-disable-next-line
      get: (target, name) => {
        if (name in target) {
          return target[name]
        }
        if (typeof DefaultInit === 'function') {
          target[name] = new DefaultInit().valueOf()
        } else {
          target[name] = DefaultInit
        }
        return target[name]
      },
    })
  }
}

function unpackbits(uint8data) {
  if (Number.isInteger(uint8data)) {
    uint8data = Uint8Array.from([uint8data])
  }
  if (uint8data instanceof Array) {
    uint8data = Uint8Array.from(uint8data)
  }
  const results = new Uint8Array(8 * uint8data.length)
  let byte
  let offset
  for (let i = 0; i < uint8data.length; i++) {
    byte = uint8data[i]
    offset = (8 * i)
    results[offset + 7] = ((byte & (1 << 0)) >> 0)
    results[offset + 6] = ((byte & (1 << 1)) >> 1)
    results[offset + 5] = ((byte & (1 << 2)) >> 2)
    results[offset + 4] = ((byte & (1 << 3)) >> 3)
    results[offset + 3] = ((byte & (1 << 4)) >> 4)
    results[offset + 2] = ((byte & (1 << 5)) >> 5)
    results[offset + 1] = ((byte & (1 << 6)) >> 6)
    results[offset + 0] = ((byte & (1 << 7)) >> 7)
  }
  return results
}

function unpackbitsToShape(uint8data, shape = [1, 1]) {
  var data = unpackbits(uint8data)
  const dims = [shape[0] | 0, shape[1] | 0]
  const result = new Array(dims[0])
  const width = dims[1]
  let offset
  for (let i = 0 | 0; i < dims[0]; i++) {
    offset = (width * i)
    result[i] = data.slice(offset, offset + width)
  }
  return result
}
function ValueError(value) {
  /*
  The error thrown when an invalid argument is passed.
  */
  const sender = (new Error) //eslint-disable-line
    .stack
    .split('\n')[2]
    .replace(' at ', '');

  this.message = `The argument from ${sender} is an invalid arugment.`;

  // Append the message if given.
  if (value) {
    this.message += ` Invalid argument: "${value}".`;
  }

  let str = this.message;

  while (str.indexOf('  ') > -1) {
    str = str.replace('  ', ' ');
  }

  this.message = str;
}
function withPython(withInterface, callback) {
  if (!withInterface.__enter__ || !withInterface.__exit__) {
    throw new Error('ValueError: withInterface must define a __enter__ and __exit__ method')
  }
  let tempResult = withInterface.__enter__.call(withInterface)
  tempResult = callback(tempResult)
  if (tempResult instanceof Promise) {
    tempResult.then(() => withInterface.__exit__.call(withInterface))
  } else {
    withInterface.__exit__.call(withInterface)
  }
  return tempResult
}
async function withPythonAsync(pendingWithInterface, callback) {
  const withInterface = await pendingWithInterface
  if (!withInterface.__enter__ || !withInterface.__exit__) {
    throw new Error('ValueError: withInterface must define a __enter__ and __exit__ method')
  }
  let tempResult = withInterface.__enter__.call(withInterface)
  tempResult = await callback(tempResult)
  await withInterface.__exit__.call(withInterface)
  return tempResult
}

/**
 From:
 https://gist.github.com/tregusti/0b37804798a7634bc49c#gistcomment-2193237

 * @summary A error thrown when a method is defined but not implemented (yet).
 * @param {any} message An additional message for the error.
 */
function zip() {
  var args = [].slice.call(arguments); //eslint-disable-line
  var shortest = args.length === 0 ? [] : args.reduce(function(a, b) {
    return a.length < b.length ? a : b
  });

  return shortest.map(function(_, i) {
    return args.map(function(array) { return array[i] })
  });
}

module.exports = {
  ABCMeta,
  any,
  arrayCompare,
  arrayDtype,
  arrayShape,
  arraySub,
  assert,
  clip,
  compareObsSpec,
  compareAIF,
  DefaultDict,
  eq,
  expanduser,
  getArgsArray,
  getattr,
  getImageData,
  hashCode,
  int,
  iter,
  isinstance,
  isObject,
  len,
  map,
  namedtuple,
  NotImplementedError,
  nonZero,
  randomChoice,
  randomSample,
  randomUniform,
  sequentialTaskQueue,
  setattr,
  setUpProtoAction,
  snakeToCamel,
  snakeToPascal,
  String,
  sum,
  unpackbits,
  unpackbitsToShape,
  ValueError,
  withPython,
  withPythonAsync,
  zip,
}

},{"os":5,"s2clientprotocol":"s2clientprotocol"}],"/renderer_human.js":[function(require,module,exports){
const path = require('path') //eslint-disable-line
const s2clientprotocol = require('s2clientprotocol') //eslint-disable-line
const Enum = require('python-enum') //eslint-disable-line
const protobuf = require('protobufjs') //eslint-disable-line
const deque = require('collections/deque') //eslint-disable-line
const pythonUtils = require('./pythonUtils.js') //eslint-disable-line
const point = require('./point.js') //eslint-disable-line
const actions = require('./actions.js') //eslint-disable-line
const features = require('./features.js') //eslint-disable-line
const colors = require('./colors.js') //eslint-disable-line
const named_array = require('./named_array.js') //eslint-disable-line
const static_data = require('./static_data.js') //eslint-disable-line
const stopwatch = require('./stopwatch.js') //eslint-disable-line
const transform = require('./transform.js') //eslint-disable-line
const remote_controller = require('./protocol.js') //eslint-disable-line
const np = require('./numpy.js') //eslint-disable-line

/*NOTE: Currently using this block to toggle rgb rendering and manual rendering
line 2175 (as of commit c34643e6e02bdb46a4ffd7d2dd0170d38077315c)
  draw_screen(surf) {
    //Draw the screen area.//
    if (this._render_rgb &&
      this._obs.getObservation().hasRenderData() &&
      this._obs.getObservation().getRenderData().hasMap() && false) {

*/

// const sc_error = s2clientprotocol.error_pb
const sc_raw = s2clientprotocol.raw_pb
const sc_pb = s2clientprotocol.sc2api_pb
// const spatial = s2clientprotocol.spatial_pb
const sc_ui = s2clientprotocol.ui_pb
const sw = stopwatch.sw

const { assert, DefaultDict, getattr, getImageData, namedtuple, ValueError, withPython } = pythonUtils

function clamp(n, smallest, largest) {
  return Math.max(smallest, Math.min(n, largest))
}

const MouseButtons = Enum.IntEnum('MouseButtons', {
  LEFT: 1,
  MIDDLE: 2,
  RIGHT: 3,
  WHEEL_UP: 4,
  WHEEL_DOWN: 5,
})

const SurfType = Enum.IntEnum('SurfType', {
  //Used to tell what a mouse click refers to.//
  CHROME: 1, //ie help, feature layer titles, etc
  SCREEN: 2,
  MINIMAP: 4,
  FEATURE: 8,
  RGB: 16,
})

const ActionCmd = Enum.IntEnum('ActionCmd', {
  STEP: 1,
  RESTART: 2,
  QUIT: 3,
})

async function sleep(time) {
  const prom = new Promise((res) => {
    setTimeout(res, time * 1000)
  })
  return prom
}

class _Ability extends namedtuple("_Ability", ["ability_id", "name", "footprint_radius", "requires_point", "hotkey"]) {
  constructor(ability, static_data) { //eslint-disable-line
    super()
    const specific_data = static_data[ability.ability_id]
    let general_data
    if (specific_data.remaps_to_ability_id) {
      general_data = static_data[specific_data.remaps_to_ability_id]
    } else {
      general_data = specific_data
    }
    this.ability_id = general_data.ability_id
    this.name = (general_data.friendly_name || general_data.button_name || general_data.link_name)
    this.footprint_radius = general_data.footprint_radius
    this.requires_point = ability.requires_point
    this.hotkey = specific_data.hotkey
  }
}

class _Surface {
  //A surface to display on screen.//
  constructor(surf, surf_type, surf_rect, world_to_surf, world_to_obs, draw) {
    /*A surface to display on screen.

    Args:
      surf: The actual gamejs.Surface (or subsurface).
      surf_type: A SurfType, used to tell how to treat clicks in that area.
      surf_rect: Rect of the surface relative to the window.
      world_to_surf: Convert a world point to a pixel on the surface.
      world_to_obs: Convert a world point to a pixel in the observation.
      draw: A function that draws onto the surface.
    */
    this.surf = surf
    this.surf_type = surf_type
    this.surf_rect = surf_rect
    this.world_to_surf = world_to_surf
    this.world_to_obs = world_to_obs
    this.draw = draw
    window.gamejs.display.getSurface().blit(surf, [surf_rect.left, surf_rect.top])
  }

  draw_line(color, start_loc, end_loc, thickness = 1) {
    window.gamejs.graphics.line(
      this.surf, color.toCSS(),
      this.world_to_surf.fwd_pt(start_loc).round(),
      this.world_to_surf.fwd_pt(end_loc).round(),
      Math.max(1, thickness)
    )
  }

  draw_arc(color, world_loc, world_radius, start_angle, stop_angle, thickness = 1) {
    //Draw an arc using world coordinates, radius, start and stop angles.//
    const center = this.world_to_surf.fwd_pt(world_loc).round()
    const radius = Math.max(1, Math.floor(this.world_to_surf.fwd_dist(world_radius)))
    const rect = new window.gamejs.Rect(center - radius, (radius * 2, radius * 2))
    window.gamejs.graphics.arc(
      this.surf, color.toCSS(), rect, start_angle, stop_angle,
      thickness < radius ? thickness : 0
    )
  }

  draw_circle(color, world_loc, world_radius, thickness = 0) {
    //Draw a circle using world coordinates and radius.//
    if (world_radius > 0) {
      const center = this.world_to_surf.fwd_pt(world_loc).round()
      const radius = Math.max(1, Math.floor(this.world_to_surf.fwd_dist(world_radius)))
      window.gamejs.graphics.circle(
        this.surf, color.toCSS(), center, radius,
        thickness < radius ? thickness : 0
      )
    }
  }

  draw_rect(color, world_rect, thickness = 0) {
    //Draw a rectangle using world coordinates.//
    const tl = this.world_to_surf.fwd_pt(world_rect.tl).round()
    const br = this.world_to_surf.fwd_pt(world_rect.br).round()
    const rect = new window.gamejs.Rect(tl, br.sub(tl))
    window.gamejs.graphics.rect(this.surf, color.toCSS(), rect, thickness)
  }

  blit_np_array(imageData) {
    //Fill this surface using the contents of a numpy array.//
    const raw_surface = new window.gamejs.graphics.Surface(imageData.width, imageData.height)
    withPython(sw('make_surface'), () => {
      // fill surface from pixel data (imageData)
      window.gamejs.graphics.blitArray(raw_surface, {
        imageData
      })
    })
    withPython(sw('draw'), () => {
      this.surf.blit(raw_surface.scale(this.surf.getSize()))
    })
  }

  write_screen(font, color, screen_pos, text, align = 'left', valign = 'top') {
    //Write to the screen in font.size relative coordinates.//
    const line_size = font.size()[1]
    const rectDim = font.size(text)
    const pos = (new point.Point(screen_pos)).mul(new point.Point(0.75, 1)).mul(line_size)
    const text_surf = font.render(text.toString ? text.toString() : String(text), color.toCSS())
    const rect = text_surf.getRect()
    if (pos.x >= 0) {
      rect[align] = pos.x
    } else {
      rect[align] = this.surf.getSize()[0] + pos.x
    }
    if (pos.y >= 0) {
      rect[valign] = pos.y
    } else {
      rect[valign] = this.surf.getSize()[1] + pos.y
    }
    rect.height = rectDim[1]
    rect.width = rectDim[0]
    this.surf.blit(text_surf, rect)
  }

  write_world(font, color, world_loc, text) {
    const text_surf = font.render(text, color)
    const rect = text_surf.getRect()
    rect.center = this.world_to_surf.fwd_pt(world_loc)
    this.surf.blit(text_surf, rect)
  }
}

class MousePos extends namedtuple('MousePos', ['world_pos', 'surf']) {
  //Holds the mouse position in world coordinates and the surf it came from.//
  get surf_pos() {
    return this.surf.world_to_surf.fwd_pt(this.world_pos)
  }

  get obs_pos() {
    return this.surf.world_to_obs.fwd_pt(this.world_pos)
  }

  action_spatial(action) {
    //Given an Action, return the right spatial action.//
    if (this.surf.surf_type & SurfType.FEATURE) {
      return action.action_feature_layer
    }
    if (this.surf.surf_type & SurfType.RGB) {
      return action.action_render
    }
    assert(this.surf.surf_type & (SurfType.RGB | SurfType.FEATURE), 'this.surf.surf_type & (SurfType.RGB | SurfType.FEATURE)')
  }
}

class PastAction extends namedtuple('PastAction', ['ability', 'color', 'pos', 'time', 'deadline']) {
  // Holds a past action for drawing over time.//
}

function _get_desktop_size() {
  //Get the browser screen size.//
  /*
  https://stackoverflow.com/questions/3437786/get-the-size-of-the-screen-current-web-page-and-browser-window
  */
  /*eslint-disable*/

  const win = window
  const doc = document
  const docElem = doc.documentElement
  const body = doc.getElementsByTagName('body')[0]
  const x = win.innerWidth || docElem.clientWidth || body.clientWidth
  const y = win.innerHeight|| docElem.clientHeight|| body.clientHeight
  return new point.Point(x, y)
}


function circle_mask(shape, pt, radius) {
  let rows = new Array(shape.y)
  let yInd = 0
  for (let y = -pt.y; y < (shape.y - pt.y); y++) {
    const row = new Array(shape.x)
    let xInd = 0
    for (let x = -pt.x; x < (shape.x - pt.x); x++) {
      row[xInd] = (x**2 + y**2) <= (radius **2)
      xInd ++
    }
    rows[yInd] = row
    yInd ++
  }
  return rows
}

class RendererHuman {
  //Render starcraft obs with gamejs such that it's playable by humans.//

  static get camera_actions() {
    const camera_actions = {}
    camera_actions[window.gamejs.event.K_LEFT] = new point.Point(-3, 0)
    camera_actions[window.gamejs.event.K_RIGHT] = new point.Point(3, 0)
    camera_actions[window.gamejs.event.K_UP] = new point.Point(0, 3)
    camera_actions[window.gamejs.event.K_DOWN] = new point.Point(0, -3)
    return camera_actions
  }

  get camera_actions() { //eslint-disable-line
    return RendererHuman.camera_actions
  }

  static get cmd_group_keys() {
    const cmd_group_keys = {}
    cmd_group_keys[window.gamejs.event.K_0] = 0
    cmd_group_keys[window.gamejs.event.K_1] = 1
    cmd_group_keys[window.gamejs.event.K_2] = 2
    cmd_group_keys[window.gamejs.event.K_3] = 3
    cmd_group_keys[window.gamejs.event.K_4] = 4
    cmd_group_keys[window.gamejs.event.K_5] = 5
    cmd_group_keys[window.gamejs.event.K_6] = 6
    cmd_group_keys[window.gamejs.event.K_7] = 7
    cmd_group_keys[window.gamejs.event.K_8] = 8
    cmd_group_keys[window.gamejs.event.K_9] = 9
    return cmd_group_keys
  }

  get cmd_group_keys() { //eslint-disable-line
    return RendererHuman.cmd_group_keys
  }

  static get shortcuts() {
    return [
      ["F1", "Select idle worker"],
      ["F2", "Select army"],
      ["F3", "Select larva (zerg) or warp gates (protoss)"],
      ["F4", "Quit the game"],
      ["F5", "Restart the map"],
      ["F8", "Save a replay"],
      ["F9", "Toggle RGB rendering"],
      ["F10", "Toggle rendering the player_relative layer."],
      ["F11", "Toggle synchronous rendering"],
      ["F12", "Toggle raw/feature layer actions"],
      ["Ctrl++", "Zoom in"],
      ["Ctrl+-", "Zoom out"],
      ["PgUp/PgDn", "Increase/decrease the max game speed"],
      ["Ctrl+PgUp/PgDn", "Increase/decrease the step multiplier"],
      ["Pause", "Pause the game"],
      ["?", "This help screen"],
    ]
  }

  get shortcuts() {
    return RendererHuman.shortcuts
  }

  static get upgrade_colors() {
    return [
      colors.black,  // unused...
      colors.white.mul(0.6),
      colors.white.mul(0.8),
      colors.white,
    ]
  }

  get upgrade_colors() {
    return RendererHuman.upgrade_colors
  }

  constructor(fps = 22.4, step_mul = 1, render_sync = false, render_feature_grid = true, video = null) {
    /*Create a renderer for use by humans.

    Make sure to call `init` with the game info, or just use `run`.

    Args:
      fps: How fast should the game be run.
      step_mul: How many game steps to take per observation.
      render_sync: Whether to wait for the obs to render before continuing.
      render_feature_grid: When RGB and feature layers are available, whether
          to render the grid of feature layers.
      video: A filename to write the video to. Implicitly enables render_sync.
    */
    this._fps = fps
    this._step_mul = step_mul
    this._render_sync = render_sync || Boolean(video)
    this._raw_actions = false
    this._render_player_relative = false
    this._render_rgb = null
    this._render_feature_grid = render_feature_grid
    this._window = null
    this._window_scale = 0.75
    this._obs_queue = deque(undefined, 100)
    // probably won't need these in javascript
    this._render_thread = null //threading.Thread(target=this.render_thread, name="Renderer")
    this._game_times = deque(undefined, 100)  // Avg FPS over 100 frames.
    this._render_times = deque(undefined, 100)
    this._last_time = performance.now()
    this._last_game_loop = 0
    this._name_lengths = {}
    this._video_writer = video ? new video_writer.VideoWriter(video, fps) : null
    // apply decorators
    this.init_window = sw.decorate(this.init_window.bind(this))
    this.get_actions = sw.decorate(this.get_actions.bind(this))
    this.draw_units = sw.decorate(this.draw_units.bind(this))
    this.draw_effects = sw.decorate(this.draw_effects.bind(this))
    this.draw_selection = sw.decorate(this.draw_selection.bind(this))
    this.draw_build_target = sw.decorate(this.draw_build_target.bind(this))
    this.draw_overlay = sw.decorate(this.draw_overlay.bind(this))
    this.draw_help = sw.decorate(this.draw_help.bind(this))
    this.draw_commands = sw.decorate(this.draw_commands.bind(this))
    this.draw_panel = sw.decorate(this.draw_panel.bind(this))
    this.draw_actions = sw.decorate(this.draw_actions.bind(this))
    this.prepare_actions = sw.decorate(this.prepare_actions.bind(this))
    this.draw_base_map = sw.decorate(this.draw_base_map.bind(this))
    this.draw_mini_map = sw.decorate(this.draw_mini_map.bind(this))
    this.draw_rendered_map = sw.decorate(this.draw_rendered_map.bind(this))
    this.draw_feature_layer = sw.decorate(this.draw_feature_layer.bind(this))
    this.draw_raw_layer = sw.decorate(this.draw_raw_layer.bind(this))
    this.render = sw.decorate(this.render.bind(this))
    this.render_obs = sw.decorate(this.render_obs.bind(this))
  }

  close() {
    if (this._obs_queue.length) {
      this._obs_queue = null
      this._render_thread = null
    }
    if (this._video_writer) {
      this._video_writer.close()
      this._video_writer = null
    }
  }

  async init(game_info, static_data) {
    /*Take the game info and the static data needed to set up the game.

    This must be called before render or get_actions for each game or restart.

    Args:
      game_info: A `sc_pb.ResponseGameInfo` object for this game.
      static_data: A `StaticData` object for this game.

    Raises:
      ValueError: if there is nothing to render.
    
    */
    this._game_info = game_info
    this._static_data = static_data
    assert(game_info.hasStartRaw(), 'game_info.hasStartRaw()')

    this._map_size = point.Point.build(game_info.getStartRaw().getMapSize())
    this._playable = new point.Rect(
      point.Point.build(game_info.getStartRaw().getPlayableArea().getP0()),
      point.Point.build(game_info.getStartRaw().getPlayableArea().getP1())
    )

    if (game_info.getOptions().hasFeatureLayer()) {
      const fl_opts = game_info.getOptions().getFeatureLayer()
      this._feature_screen_px = point.Point.build(fl_opts.getResolution())
      this._feature_minimap_px = point.Point.build(fl_opts.getMinimapResolution())
      this._feature_camera_width_world_units = fl_opts.getWidth()
      this._render_rgb = false
      if (!fl_opts.getCropToPlayableArea()) {
        this._playable = new point.Rect(this._map_size)
      }
    } else {
      this._feature_screen_px = null
      this._feature_minimap_px = null
    }
    if (game_info.getOptions().hasRender()) {
      const render_opts = game_info.getOptions().getRender()
      this._rgb_screen_px = point.Point.build(render_opts.getResolution())
      this._rgb_minimap_px = point.Point.build(render_opts.getMinimapResolution())
      this._render_rgb = true
    } else {
      this._rgb_screen_px = null
      this._rgb_minimap_px = null
    }

    if (!this._feature_screen_px && !this._rgb_screen_px) {
      throw new ValueError('Nothing to render.')
    }

    try {
      await this.init_window()
      this._initialized = true
    } catch (err) {
      this._initialized = false
      console.error(''.lpad(60, '-'))
      console.error('Failed to initialize gamejs: ', err)
      console.error('Continuing without gamejs.')
      console.error('If you\'re using ssh and have an X server, try ssh -X.')
      console.error(''.lpad(60, '-'))
    }

    this._obs = new sc_pb.ResponseObservation()
    const ob = new sc_pb.Observation()
    ob.setGameLoop(0)
    this._obs.setObservation(ob)
    this._queued_action = null
    this._queued_hotkey = ''
    this._select_start = null
    this._alerts = {}
    this._past_actions = []
    this._help = false
    this._last_zoom_time = 0
  }

  async init_window() {
    //Initialize the gamejs window and lay out the surfaces//

    let main_screen_px
    if (this._render_rgb && this._rgb_screen_px) {
      main_screen_px = this._rgb_screen_px
    }
    else {
      main_screen_px = this._feature_screen_px
    }

    let window_size_ratio = main_screen_px
    let num_feature_layers = 0
    let feature_cols
    let feature_rows
    if (this._render_feature_grid) {
      // Want a roughly square grid of feature layers, each being roughly square.
      if (this._game_info.getOptions().getRaw()) {
        num_feature_layers += 5
      }
      if (this._feature_screen_px) {
        num_feature_layers += features.SCREEN_FEATURES.length
        num_feature_layers += features.MINIMAP_FEATURES.length
      }
      if (num_feature_layers > 0) {
        feature_cols = Math.ceil(Math.sqrt(num_feature_layers))
        feature_rows = Math.ceil(num_feature_layers / feature_cols)
        const features_layout = new point.Point(
          feature_cols, feature_rows * 1.05 // Make room for titles.
        )

        // Scale features_layout to main_screen_px height so we know its width.
        const features_aspect_ratio = features_layout 
          .mul(main_screen_px.y)
          .div(features_layout.y)
        window_size_ratio = window_size_ratio.add(
          new point.Point(features_aspect_ratio.x, 0)
          // features_aspect_ratio
        )
      }
    }
    const window_size_px = window_size_ratio.scale_max_size(
      _get_desktop_size().mul(this._window_scale)
    ).ceil()

    // Create the actual window surface. This should only be blitted to from one
    // of the sub-surfaces defined below.
    this._window = gamejs.display.setMode(window_size_px, 0)
    gamejs.display.setCaption('Starcraft Viewer')

    // The sub-surfaces that the various draw functions will draw to.
    this._surfaces = []
    const self = this
    function add_surface(surf_type, surf_loc, world_to_surf, world_to_obs, draw_fn) {
      //Add a surface. Drawn in order and intersect in reverse order.//
      const sub_surf = new window.gamejs.graphics.Surface(surf_loc.size)
      self._surfaces.push(new _Surface(
          sub_surf, surf_type, surf_loc, world_to_surf, world_to_obs, draw_fn.bind(self)
        )
      )
    }

    this._scale = Math.floor(window_size_px.y / 32)
    this._font_size = 10
    this._font_style = 'Arial'
    this._font_small = new gamejs.font.Font(`${Math.floor(this._font_size * 0.5)}px ${this._font_style}`)
    this._font_large = new gamejs.font.Font(`${this._font_size}px ${this._font_style}`)

    function check_eq(a, b) {
      //Used to run unit tests on the transforms.//
      assert(a.sub(b).len() < 0.0001, `${a} != ${b}`)
    }

    // World has origin at bl, world_tl has origin at tl.
    this._world_to_world_tl = new transform.Linear(
      new point.Point(1, -1), new point.Point(0, this._map_size.y)
    )

    check_eq(
      this._world_to_world_tl.fwd_pt(new point.Point(0, 0)),
      new point.Point(0, this._map_size.y)
    )
    check_eq(
      this._world_to_world_tl.fwd_pt(new point.Point(5, 10)),
      new point.Point(5, this._map_size.y - 10)
    )

    // Move the point to be relative to the camera. This gets updated per frame.
    this._world_tl_to_world_camera_rel = new transform.Linear({
      offset: this._map_size.div(4).mul(-1)
    })

    check_eq(
      this._world_tl_to_world_camera_rel.fwd_pt(this._map_size.div(4)),
      new point.Point(0, 0)
    )
    check_eq(
      this._world_tl_to_world_camera_rel.fwd_pt(
        this._map_size.div(4).add(new point.Point(5, 10))
      ),
      new point.Point(5, 10)
    )

    if (this._feature_screen_px) {
      // Feature layer locations in continuous space.
      let feature_world_per_pixel = this._feature_screen_px
        .div(this._feature_camera_width_world_units)
      let world_camera_rel_to_feature_screen = new transform.Linear(
        feature_world_per_pixel, this._feature_screen_px.div(2)
      )

      check_eq(world_camera_rel_to_feature_screen.fwd_pt(
        new point.Point(0, 0)),
        this._feature_screen_px.div(2)
      )
      check_eq(
        world_camera_rel_to_feature_screen.fwd_pt(
          (new point.Point(-0.5, -0.5)).mul(this._feature_camera_width_world_units)
        ),
        new point.Point(0, 0)
      )

      this._world_to_feature_screen = new transform.Chain(
        this._world_to_world_tl,
        this._world_tl_to_world_camera_rel,
        world_camera_rel_to_feature_screen
      )
      this._world_to_feature_screen_px = new transform.Chain(
        this._world_to_feature_screen,
        new transform.PixelToCoord()
      )

      const world_tl_to_feature_minimap = new transform.Linear(
        this._feature_minimap_px.div(this._playable.diagonal.max_dim())
      )
      world_tl_to_feature_minimap.offset = world_tl_to_feature_minimap.fwd_pt(
        this._world_to_world_tl.fwd_pt(this._playable.bl).mul(-1)
      )

      this._world_to_feature_minimap = new transform.Chain(
        this._world_to_world_tl,
        world_tl_to_feature_minimap
      )
      this._world_to_feature_minimap_px = new transform.Chain(
        this._world_to_feature_minimap,
        new transform.PixelToCoord()
      )

      // These are confusing since this._playable is in world coords which is
      // (bl <= tr), but stored in a Rect that is (tl <= br).
      check_eq(this._world_to_feature_minimap.fwd_pt(
        this._playable.bl),
        new point.Point(0, 0)
      )
      check_eq(
        this._world_to_feature_minimap.fwd_pt(this._playable.tr),
        this._playable.diagonal.scale_max_size(this._feature_minimap_px)
      )
    }

    if (this._rgb_screen_px) {
      // RGB pixel locations in continuous space.

      // TODO(tewalds): Use a real 3d projection instead of orthogonal.
      let rgb_world_per_pixel = this._rgb_screen_px.div(24)
      let world_camera_rel_to_rgb_screen = new transform.Linear(
        rgb_world_per_pixel, 
        this._rgb_screen_px.div(2)
      )

      check_eq(
        world_camera_rel_to_rgb_screen.fwd_pt(
          new point.Point(0, 0)
        ),
        this._rgb_screen_px.div(2)
      )
      check_eq(
        world_camera_rel_to_rgb_screen.fwd_pt(
          new point.Point(-0.5, -0.5).mul(24)
        ),
        new point.Point(0, 0)
      )

      this._world_to_rgb_screen = new transform.Chain(
        this._world_to_world_tl,
        this._world_tl_to_world_camera_rel,
        world_camera_rel_to_rgb_screen
      )
      this._world_to_rgb_screen_px = new transform.Chain(
        this._world_to_rgb_screen,
        new transform.PixelToCoord()
      )

      const world_tl_to_rgb_minimap = new transform.Linear(
        this._rgb_minimap_px.div(this._map_size.max_dim())
      )

      check_eq(world_tl_to_rgb_minimap.fwd_pt(
        new point.Point(0, 0)),
        new point.Point(0, 0)
      )
      check_eq(
        world_tl_to_rgb_minimap.fwd_pt(this._map_size),
        this._map_size.scale_max_size(this._rgb_minimap_px)
      )

      this._world_to_rgb_minimap = new transform.Chain(
        this._world_to_world_tl,
        world_tl_to_rgb_minimap
      )
      this._world_to_rgb_minimap_px = new transform.Chain(
        this._world_to_rgb_minimap,
        new transform.PixelToCoord()
      )
    }
    // Renderable space for the screen.
    let screen_size_px = main_screen_px.scale_max_size(window_size_px)
    let minimap_size_px = this._playable.diagonal.scale_max_size(screen_size_px.div(4))
    let minimap_offset = new point.Point(0, (screen_size_px.y - minimap_size_px.y))

    if (this._render_rgb) {
      let rgb_screen_to_main_screen = new transform.Linear(
        screen_size_px.div(this._rgb_screen_px)
      )
      add_surface(
        SurfType.RGB | SurfType.SCREEN,
        new point.Rect(point.origin, screen_size_px),
        new transform.Chain(  // surf
            this._world_to_rgb_screen,
            rgb_screen_to_main_screen),
        this._world_to_rgb_screen_px,
        this.draw_screen
      )
      let rgb_minimap_to_main_minimap = new transform.Linear(
        minimap_size_px.div(this._rgb_minimap_px)
      )
      add_surface(
        SurfType.RGB | SurfType.MINIMAP,
        new point.Rect(
          minimap_offset,
          minimap_offset.add(minimap_size_px)
        ),
        new transform.Chain(  // surf
          this._world_to_rgb_minimap,
          rgb_minimap_to_main_minimap
        ),
        this._world_to_rgb_minimap_px,
        this.draw_mini_map
      )
    } else {  // Feature layer main screen
      const feature_screen_to_main_screen = new transform.Linear(
        screen_size_px.div(this._feature_screen_px)
      )
      add_surface(
        SurfType.FEATURE | SurfType.SCREEN,
        new point.Rect(point.origin, screen_size_px),
        new transform.Chain(  // surf
          this._world_to_feature_screen,
          feature_screen_to_main_screen
        ),
        this._world_to_feature_screen_px,
        this.draw_screen
      )
      const feature_minimap_to_main_minimap = new transform.Linear(
        minimap_size_px.max_dim() / this._feature_minimap_px.max_dim()
      )
      add_surface(
        SurfType.FEATURE | SurfType.MINIMAP,
        new point.Rect(
          minimap_offset,
          minimap_offset.add(minimap_size_px)
        ),
        new transform.Chain(  // surf
          this._world_to_feature_minimap,
          feature_minimap_to_main_minimap
        ),
        this._world_to_feature_minimap_px,
        this.draw_mini_map
      )
    }

    if (this._render_feature_grid && num_feature_layers > 0) {
      // Add the raw and feature layers
      const features_loc = new point.Point(screen_size_px.x, 0)
      const feature_pane_rect = new gamejs.Rect(features_loc, window_size_px.sub(features_loc))
      const feature_pane = new window.gamejs.graphics.Surface(
        feature_pane_rect
      )
      feature_pane.fill(colors.white.div(2).toCSS())
      window.gamejs.display.getSurface().blit(feature_pane, feature_pane_rect)
      const feature_pane_size = new point.Point(...feature_pane.getSize())
      const feature_grid_size = feature_pane_size.div(
        new point.Point(
          feature_cols,
          feature_rows
        )
      )
      const feature_layer_area = new point.Point(1, 1)
        .scale_max_size(feature_grid_size)
      const feature_layer_padding = feature_layer_area.div(20).floor()
      const feature_layer_size = feature_layer_area.sub(feature_layer_padding.mul(2))

      const feature_font_size = Math.floor(feature_grid_size.y * 0.08) || 1
      const feature_font = new gamejs.font.Font(`${feature_font_size}px ${this._font_style}`)
      
      console.log('feature_grid_size:' + feature_grid_size.round())
      console.log('feature_layer_area:' + feature_layer_area.round())

      let feature_counter = 0
      function add_layer(surf_type, world_to_surf, world_to_obs, name, fn) {
        //Add a layer surface.//
        const i = feature_counter++
        const grid_offset = new point.Point(
          i % feature_cols,
          Math.floor(i / feature_cols)
        ).mul(feature_grid_size)
        const text = feature_font.render(name, colors.white.toCSS(), null, 'bottom')
        const rect = text.getRect()
        rect.center = grid_offset.add(
          new point.Point(
            feature_grid_size.x / 2,
            feature_font_size
          )
        )
        console.log( `grid_offset ${grid_offset.round()} +  ${new point.Point((feature_grid_size.x / 2), feature_font_size).round()} = rect.center ${rect.center}    i = ${i}`)

        feature_pane.blit(text, rect)
        window.gamejs.display.getSurface().blit(feature_pane, feature_pane_rect)
        const surf_loc = features_loc
          .add(grid_offset)
          .add(feature_layer_padding)
          .add(
            new point.Point(0, feature_font_size)
          )
        console.log('surf_loc ' + surf_loc.round())
        add_surface(
          surf_type,
          new point.Rect(
            surf_loc,
            surf_loc.add(feature_layer_size).round()
          ),
          world_to_surf, world_to_obs, fn
        )
      }

      const raw_world_to_obs = new transform.Linear()
      const raw_world_to_surf = new transform.Linear(
        feature_layer_size.div(this._map_size)
      )
      const self = this
      function add_raw_layer(from_obs, name, colorPalette) {
        add_layer(
          SurfType.FEATURE | SurfType.MINIMAP,
          raw_world_to_surf, raw_world_to_obs, "raw " + name,
          (surf) => self.draw_raw_layer(surf, from_obs, name, null, colorPalette)
        )
      }

      if (this._game_info.getOptions().getRaw()) {
        add_raw_layer(false, "terrain_height", colors.height_map(256))
        add_raw_layer(false, "pathing_grid", colors.winter(2))
        add_raw_layer(false, "placement_grid", colors.winter(2))
        add_raw_layer(true, "visibility", colors.VISIBILITY_PALETTE)
        add_raw_layer(true, "creep", colors.CREEP_PALETTE)
      }

      function add_feature_layer(feature, surf_type, world_to_surf, world_to_obs) {
        add_layer(
          surf_type, world_to_surf, world_to_obs, feature.full_name,
          (surf) => self.draw_feature_layer(surf, feature)
        )
      }

      if (this._feature_minimap_px) {
        // Add the minimap feature layers
        const feature_minimap_to_feature_minimap_surf = new transform.Linear(
          feature_layer_size.div(this._feature_minimap_px)
        )
        const world_to_feature_minimap_surf = new transform.Chain(
          this._world_to_feature_minimap,
          feature_minimap_to_feature_minimap_surf
        )
        features.MINIMAP_FEATURES.forEach((feature) => {
          add_feature_layer(
            feature, SurfType.FEATURE | SurfType.MINIMAP,
            world_to_feature_minimap_surf,
            this._world_to_feature_minimap_px
          )
        })
      }

      if (this._feature_screen_px) {
        // Add the screen feature layers
        const feature_screen_to_feature_screen_surf = new transform.Linear(
          feature_layer_size.div(this._feature_screen_px)
        )
        const world_to_feature_screen_surf = new transform.Chain(
          this._world_to_feature_screen,
          feature_screen_to_feature_screen_surf
        )
        features.SCREEN_FEATURES.forEach((feature) => {
          add_feature_layer(
            feature, SurfType.FEATURE | SurfType.SCREEN,
            world_to_feature_screen_surf,
            this._world_to_feature_screen_px
          )
        })

      }
    }
    // Add the help screen
    const help_size = new point.Point(
      (Math.max(...this.shortcuts.map((s) => s.length)) +
      Math.max(...this.shortcuts.map((_, s) => String(s).length))) * 0.4 + 4,
      this.shortcuts.length + 3
    ).mul(this._scale)
    const help_rect = new point.Rect(
      window_size_px.div(2).sub(help_size.div(2)),
      window_size_px.div(2).add(help_size.div(2))
    )
    add_surface(SurfType.CHROME, help_rect, null, null, this.draw_help)

    // Arbitrarily set the initial camera to the center of the map.
    this._update_camera(this._map_size.div(2))
  }

  _update_camera(camera_center) {
    //Update the camera transform based on the new camera center.//
    this._world_tl_to_world_camera_rel.offset = (
      this._world_to_world_tl.fwd_pt(camera_center).mul(-1).mul(this._world_tl_to_world_camera_rel.scale)
    )

    if (this._feature_screen_px) {
      const camera_radius = (this._feature_screen_px.div(
        this._feature_screen_px.x).mul(this._feature_camera_width_world_units).div(2)
      )
      const center = camera_center.bound(camera_radius, this._map_size.sub(camera_radius))

      this._camera = new point.Rect(
        center.sub(camera_radius).bound(this._map_size),
        center.add(camera_radius).bound(this._map_size)
      )
    }
  }

  zoom(factor) {
    //Zoom the window in/out.//
    this._window_scale *= factor
    if (performance.now() - this._last_zoom_time < 1) {
      // Avoid a deadlock in gamejs if you zoom too quickly
      return
    }
    this.init_window()
    this._last_zoom_time = performance.now()
  }

  get_mouse_pos(window_pos = null) {
    //Return a MousePos filled with the world position and surf it hit.//
    window_pos = window_pos || gamejs.mouse.get_pos()
    // +0.5 to center the point on the middle of the pixel.
    const window_pt = new point.Point(window_pos).add(0.5)
    for (let i = this._surfaces.length - 1; i >= 0; i--) {
      const surf = this._surfaces[i]
      if (surf.surf_type != SurfType.CHROME && surf.surf_rect.contains_point(window_pt)) {
        const surf_rel_pt = window_pt.sub(surf.surf_rect.tl)
        const world_pt = surf.world_to_surf.back_pt(surf_rel_pt)
        return new MousePos(world_pt, surf)
      }
    }
  }

  clear_queued_action() {
    this._queued_hotkey = ''
    this._queued_action = null
  }

  save_replay(run_config, controller) {
    if (controller.status == remote_controller.Status.in_game || controller.status == remote_controller.Status.ended) {
      const prefix = path.basename(this._game_info.getLocalMap_Path()).split('.')[0]
      const replay_path = run_config.save_replay(controller.save_replay(), 'local', prefix)
      console.log('Wrote replay to: ', replay_path)
    }
  }

  async get_actions(run_config, controller) {
    //Get actions from the UI, apply to controller, and return an ActionCmd.
    if (!this._initialized) {
      return ActionCmd.STEP
    }
    const events = gamejs.getEvents()
    for (let i = 0; i < events.length; i++) {
      ctrl = gamejs.key.get_mods() & gamejs.event.KMOD_CTRL
      shift = gamejs.key.get_mods() & gamejs.event.KMOD_SHIFT
      alt = gamejs.key.get_mods() & gamejs.event.KMOD_ALT
      if (event.type == gamejs.event.QUIT) {
        return ActionCmd.QUIT
      } else if (event.type == gamejs.event.KEYDOWN) {
        if (this._help) {
          this._help = false
        } else if (event.key == gamejs.event.K_QUESTION || event.key == gamejs.event.K_SLASH) {
          this._help = true
        } else if (event.key == gamejs.event.K_PAUSE) {
          let pause = true
          while (pause) {
            await sleep(0.1)
            const events2 = gamejs.getEvents()
            for (let j = 0; j < events2.length; j++) {
              const event2 = events2[i]
              if (event2.type == gamejs.event.KEYDOWN) {
                if (event2.key == gamejs.event.K_PAUSE ||  gamejs.event.K_ESCAPE) {
                  pause = false
                } else if (event2.key == gamejs.event.K_F4){
                  return ActionCmd.QUIT
                } else if (event2.key == gamejs.event.K_F5) {
                  return ActionCmd.RESTART
                }
              }
            }
          }
        } else if (event.key == gamejs.event.K_F4) {
          return ActionCmd.QUIT
        } else if (event.key == gamejs.event.K_F5) {
          return ActionCmd.RESTART
        } else if (event.key == gamejs.event.K_F9) {  // Toggle rgb rendering.
          if (this._rgb_screen_px && this._feature_screen_px) {
            this._render_rgb = !this._render_rgb
            console.log('Rendering', this._render_rgb && 'RGB' || 'Feature Layers')
            this.init_window()
          }
        } else if (event.key == gamejs.event.K_F11) { // Toggle synchronous rendering.
          this._render_sync = !this._render_sync
          console.log('Rendering', this._render_sync && 'Sync' || 'Async')
        } else if (event.key == gamejs.event.K_F12) {
          this._raw_actions = !this._raw_actions
          console.log('Action space:', this._raw_actions && 'Raw' || 'Spatial')
         } else if (event.key == gamejs.event.K_F10) {  // Toggle player_relative layer.
          this._render_player_relative = !this._render_player_relative
         } else if (event.key == gamejs.event.K_F8) {  // Save a replay.
          this.save_replay(run_config, controller)
         } else if (event.key == gamejs.event.K_PLUS || event.key == gamejs.event.K_EQUALS && ctrl) {
          this.zoom(1.1)  // zoom in
         } else if (event.key == gamejs.event.K_MINUS || event.key == gamejs.event.K_UNDERSCORE && ctrl) {
          this.zoom(1 / 1.1)  // zoom out
         } else if (event.key == gamejs.event.K_PAGEUP || event.key == gamejs.event.K_PAGEDOWN) {
          if (ctrl) {
            if (event.key == gamejs.event.K_PAGEUP) {
              this._step_mul += 1
            } else if (this._step_mul > 1) {
              this._step_mul -= 1
            }
            console.log('New step mul:', this._step_mul)
          } else {
            event.key == gamejs.event.K_PAGEUP ? (this._fps *= 1.25) : (1 / 1.25)
            console.log(`New max game speed: ${this._fps}`)
          }
        } else if (event.key == gamejs.event.K_F1) {
          if (this._obs.observation.player_common.idle_worker_count > 0) {
            controller.act(this.select_idle_worker(ctrl, shift))
          }
        } else if (event.key == gamejs.event.K_F2) {
          if (this._obs.observation.player_common.army_count > 0) {
            controller.act(this.select_army(shift))
          }
        } else if (event.key == gamejs.event.K_F3) {
          if (this._obs.observation.player_common.warp_gate_count > 0) {
            controller.act(this.select_warp_gates(shift))
          }
          if (this._obs.observation.player_common.larva_count > 0) {
            controller.act(this.select_larva())
          }
        } else if (this.cmd_group_keys.hasOwnProperty(event.key)) {
          controller.act(this.control_group(this.cmd_group_keys[event.key], ctrl, shift, alt))
        } else if (this.camera_actions.hasOwnProperty(event.key)) {
          if (this._obs) {
            pt = point.Point.build(this._obs.observation.raw_data.player.camera)
            pt += this.camera_actions[event.key]
            controller.act(this.camera_action_raw(pt))
            controller.observer_act(this.camera_action_observer_pt(pt))
          }
        } else if (event.key == gamejs.event.K_ESCAPE) {
          controller.observer_act(this.camera_action_observer_player(
              this._obs.observation.player_common.player_id))
          if (this._queued_action) {
            this.clear_queued_action()
          } else {
            cmds = this._abilities((cmd) => cmd.hotkey == 'escape')  // Cancel
            cmds.forEach((cmd) => {
              // There could be multiple cancels.
              assert(!cmd.requires_point, '!cmd.requires_point')
              controller.act(this.unit_action(cmd, null, shift))
            })
          }
        } else {
          if (!this._queued_action) {
            key = gamejs.key.name(event.key).toLowerCase()
            new_cmd = this._queued_hotkey + key
            cmds = this._abilities((cmd, n=new_cmd) =>  cmd.hotkey != 'escape' && cmd.hotkey.startswith(n))
            if (cmds) {
              this._queued_hotkey = new_cmd
              if (cmds.length == 1) {
                cmd = cmds[0]
                if (cmd.hotkey == this._queued_hotkey) {
                  if (cmd.requires_point) {
                    this.clear_queued_action()
                    this._queued_action = cmd
                  } else {
                    controller.act(this.unit_action(cmd, null, shift))
                  }
                }
              }
            }
          }
        }
      } else if (event.type == gamejs.MOUSEBUTTONDOWN) {
        mouse_pos = this.get_mouse_pos(event.pos)
        if (event.button == MouseButtons.LEFT && mouse_pos) {
          if (this._queued_action) {
            controller.act(this.unit_action(
                this._queued_action, mouse_pos, shift))
          } else if (mouse_pos.surf.surf_type & SurfType.MINIMAP) {
            controller.act(this.camera_action(mouse_pos))
            controller.observer_act(this.camera_action_observer_pt(
                mouse_pos.world_pos))
          } else {
            this._select_start = mouse_pos
          }
        } else if (event.button == MouseButtons.RIGHT) {
          if (this._queued_action) {
            this.clear_queued_action()
          }
          cmds = this._abilities((cmd) => cmd.name == 'Smart')
          if (cmds) {
            controller.act(this.unit_action(cmds[0], mouse_pos, shift))
          }
        }
      } else if (event.type == gamejs.MOUSEBUTTONUP) {
        mouse_pos = this.get_mouse_pos(event.pos)
        if (event.button == MouseButtons.LEFT && this._select_start) {
          if (mouse_pos
            && mouse_pos.surf.surf_type & SurfType.SCREEN
            && mouse_pos.surf.surf_type == this._select_start.surf.surf_type) {
            controller.act(
              this.select_action(
                this._select_start, mouse_pos, ctrl, shift
              )
            )
          }
          this._select_start = null
        }
      }
      return ActionCmd.STEP
    }
  }

  camera_action(mouse_pos) {
    //Return a `sc_pb.Action` with the camera movement filled.//
    const action = new sc_pb.Action()
    const action_spatial = mouse_pos.action_spatial(action)
    mouse_pos.obs_pos.assign_to(action_spatial.getCameraMove().getCenterMinimap())
    return action
  }

  camera_action_raw(world_pos) {
    //Return a `sc_pb.Action` with the camera movement filled.//
    const action = new sc_pb.Action()
    const action_raw = new sc_pb.ActionRaw()
    const camera_move = new sc_pb.ActionObserverCameraMove()
    const center_world_space = new sc_pb.Point2d()
    camera_move.setCenterWorldSpace(center_world_space)
    action_raw.setCameraMove(camera_move)
    action.setActionRaw(action_raw)
    world_pos.assign_to(action.action_raw.camera_move.center_world_space)
    return action
  }

  camera_action_observer_pt(world_pos) {
    //Return a `sc_pb.ObserverAction` with the camera movement filled.//
    const action = new sc_pb.ObserverAction()
    const camera_move = new sc_pb.ActionObserverCameraMove()
    const proto_world_pos = new sc_pb.Point2d()
    world_pos.assign_to(proto_world_pos)
    camera_move.setWorldPos(proto_world_pos)
    action.setCameraMove(camera_move)
    return action
  }

  camera_action_observer_player(player_id) {
    //Return a `sc_pb.ObserverAction` with the camera movement filled.//
    const action = new sc_pb.ObserverAction()
    const camera_follow_player = new sc_pb.ActionObserverCameraFollowPlayer()
    camera_follow_player.setPlayerId(player_id)
    action.setCameraFollowPlayer(camera_follow_player)
    return action
  }

  select_action(pos1, pos2, ctrl, shift) {
    //Return a `sc_pb.Action` with the selection filled.//
    console.log('here in select_action')
    assert(
      pos1.surf.surf_type == pos2.surf.surf_type,
      'pos1.surf.surf_type == pos2.surf.surf_type'
    )
    assert(
      pos1.surf.world_to_obs == pos2.surf.world_to_obs,
      'pos1.surf.world_to_obs == pos2.surf.world_to_obs'
    )

    const action = new sc_pb.Action()
    const action_raw = new sc_pb.ActionRaw()
    const unit_command = new sc_pb.ActionRawUnitCommand()
    action_raw.setUnitCommand(unit_command)
    action.setActionRaw(action_raw)
    if (this._raw_actions) {
      unit_command.setAbilityId(0) // no-op
      const player_id = this._obs.getObservation().getPlayerCommon().getPlayerId()
      if (pos1.world_pos == po2.word_pos) { //select a point
        this._visible_units().forEach(([u, p]) => {
          if (pos1.world_pos.contained_circle(p, u.getRadius()) && u.getOwner() === player_id) {
            unit_command.addUnitTags(u.getTag())
          }
        })
      } else {
        const rect = new point.Rect(pos1.world_pos, pos2.world_pos)
        const unitTags = []
        this._visible_units().forEach(([u, p]) => {
          if (u.getOwner() === player_id && rect.intersects_circle(p, u.getRadius())) {
            unit_command.addUnitTags(u.getTag())
          }
        })
        const usedTags = unit_command.getUnitTags()
        usedTags.extend()
        unit_command.addUnitTags(u.getUn)
      }
    } else {
      const action_spatial = pos1.action_spatial(action)
      if (pos1.world_pos.eq(pos2.world_pos)) {
        const select = action_spatial.getUnitSelectionPoint()
        pos1.obs_pos.assign_to(select.getSelectionScreenCoord())
        const mod = new sc_spatial.ActionSpatialUnitSelectionPoint()
        if (ctrl) {
          shift ? select.setType(mod.getAddAllType()) : select.setType(mod.getAllType())
        } else {
          shift ? select.setType(mod.getToggle()) : select.setType(mod.getSelect())
        }
      } else {
        const select = action_spatial.getUnitSelectionRect()
        const rect = select.getSelectionScreenCoord()
        pos1.obs_pos.assign_to(rect.getP0())
        pos2.obs_pos.assign_to(rect.getP1())
        select.setSelectionAdd(shift)
      }
    }
    // Clear the queued action if something will be selected. An alternative
    // implementation may check whether the selection changed next frame.
    const units = this._units_in_area(new point.Rect(pos1.world_pos, pos2.world_pos))
    if (units) {
      this.clear_queued_action()
    }
    return action
  }

  select_idle_worker(ctrl, shift) {
    //Select an idle worker.//
    const action = new sc_pb.Action()
    const action_ui = new sc_pb.ActionUI()
    const selectIdleWorker = new sc_pb.ActionSelectIdleWorker()
    action_ui.setSelectIdleWorker(selectIdleWorker)
    action.setActionUi(action_ui)
    const mod = sc_ui.ActionSelectIdleWorker.Type
    let select_worker
    if (ctrl) {
      select_worker = shift ? mod.ADDALL : mod.ALL
    } else {
      select_worker = shift ? mod.ADD : mod.SET
    }
    action.getActionUi().getSelectIdleWorker().setType(select_worker)
    return action
  }

  select_army(shift) {
    //Select the entire army.//
    const action = new sc_pb.Action()
    const action_ui = new sc_pb.ActionUI()
    const select_army = new sc_pb.ActionSelectArmy()
    select_army.setSelectionAdd(shift)
    action_ui.setSelectArmy(select_army)
    action.setActionUi(action_ui)
    return action

  }

  select_warp_gates(shift) {
    //Select all warp gates.//
    const action = new sc_pb.Action()
    const action_ui = new sc_pb.ActionUI()
    const select_warp_gates = new sc_pb.ActionSelectWarpGates()
    select_warp_gates.setSelectionAdd(shift)
    action_ui.setSelectWarpGates(select_warp_gates)
    action.setActionUi(action_ui) 
    return action
  }

  select_larva() {
    //Select all larva.//
    const action = new sc_pb.Action()
    const action_ui = new sc_pb.ActionUI()
    const select_larva = new sc_pb.ActionSelectLarva()
    action_ui.setSelectLarva(select_larva)
    action.setActionUi(action_ui)
    // action.action_ui.select_larva.SetInParent() // Adds the empty proto field.
    return action
  }

  control_group(control_group_id, ctrl, shift, alt) {
    //Act on a control group, selecting, setting, etc.//
    const action = new sc_pb.Action()
    const action_ui = new sc_pb.ActionUI()
    action.setActionUi(action_ui)
    const select = new sc_pb.ActionControlGroup()
    action_ui.setControlGroup(select)
    const mod = sc_pb.ActionControlGroup.ControlGroupAction
    if (!(ctrl && shift && alt)) {
      select.setAction(mod.RECALL)
    } else if (ctrl && !(shift && alt)) {
      select.setAction(mod.SET)
    } else if (!ctrl && shift && !alt) {
      select.setAction(mod.APPEND)
    } else if (!(ctrl && shift) && alt) {
      select.setAction(mod.SETANDSTEAL)
    } else if (!ctrl && shift && alt) {
      select.setAction(mod.APPENDANDSTEAL)
    } else {
      return //unknown
    }
    select.setControlGroupId(control_group_id)
    return action
  }

  unit_action(cmd, pos, shift) {
    //Return a `sc_pb.Action` filled with the cmd and appropriate target.//
    const action = new sc_pb.Action()
    const action_raw = new sc_pb.ActionRaw()
    let unit_command = new sc_pb.ActionRawUnitCommand()
    const target_world_space_pos = new sc_pb.Point2D()
    unit_command.setTargetWorldSpacePos(target_world_space_pos)
    action_raw.setUnitCommand(unit_command)
    if (this._raw_actions) {
      unit_command.setAbilityId(cmd.getAbilityId())
      unit_command.setQueueCommand(shift)
      const player_id = this._obs.getObservation().getPlayerCommon().getPlayerId()
      unit_command.setUnitTagsList(
        this._visible_units().filter(([u]) => u.getIsSelected() && u.getOwner() == player_id)
      )
      if (pos) {
        const units = this._visible_units()
        let found
        for (let i = 0; i < units.length; i++) {
          const [u, p] = units[i]
          if (pos.world_pos.contained_circle(p, u.getRadius())) {
            unit_command.setTargetUnitTag(u.getTag())
            found = true
            break
          }
        }
        if (!found) {
          pos.world_pos.assign_to(target_world_space_pos)
        }
      }
    } else {
      if (pos) {
        const action_spatial = pos.action_spatial(action)
        unit_command.setAbilityId(cmd.getAbilityId())
        unit_command.setQueueCommand(shift)
        if (pos.surf.surf_type & SurfType.SCREEN) {
          pos.obs_pos.assign_to(unit_command.target_screen_coord)
        } else if (pos.surf.surf_type & SurfType.MINIMAP) {
          pos.obs_pos.assign_to(unit_command.target_minimap_coord)
        }
      } else {
        unit_command = new sc_pb.ActionSpatialUnitCommand()
        unit_command.setAbilityId(cmd.getAbilityId())
        if (this._feature_screen_px) {
          const action_feature_layer = new sc_pb.ActionSpatial()
          action_feature_layer.setUnitCommand(unit_command)
          action.setFeatureLayer(action_feature_layer)
        } else {
          const action_render = new sc_pb.ActionSpatial()
          action_render.setUnitCommand(unit_command)
          action.setActionRender(action_render)
        }
      }
    }

    this.clear_queued_action()
    return action
  }

  _abilities(fn = null) {
    //Return the list of abilities filtered by `fn`.//
    const out = []
    this._obs.getObservation().getAbilitiesList().forEach((cmd) => {
      const ability = _Ability(cmd, this._static_data.abilities)
      if (!fn || fn(ability)) {
        // out[ability.ability_id] = ability
        out.push(ability)
      }
    })
    return out
  }

  _visible_units() {
    /*
      A generator of visible units and their positions as `Point`s, sorted.//
      Sort the units by elevation, then owned (eg refinery) above world (ie 16)
      (eg geiser), small above big, and otherwise arbitrary but stable.
    */
    let units = new Array(this._obs.getObservation().getRawData().getUnitsList().length)
    this._obs.getObservation().getRawData().getUnitsList().forEach((u, i) => {
      units[i] = [u.getPos().getZ(), u.getOwner() != 16, -u.getRadius(), u.getTag(), u]
    })
    units = units.sorted((a, b) => a[0] - b[0])
    return units.map((arr) => {
      const u = arr[arr.length - 1]
      return [u, new point.Point(u.getPos())]
    })
  }

  _units_in_area(rect) {
    //Return the list of units that intersect the rect.//
    const player_id = this._obs.getObservation().getPlayerCommon().getPlayerId()
    return this._visible_units.filter(([u, p]) => rect.intersects_circle(p, u.getRadius()) && u.getOwner() == player_id)
  }

  get_unit_name(surf, name, radius) {
    //Get a length limited unit name for drawing units.//
    const key = [name, radius].join(',')
    if (!this._name_lengths.hasOwnProperty(key)) {
      const max_len = surf.world_to_surf.fwd_dist(radius * 1.6)
      let found = false
      for (let i = 0; i < name.length; i++) {
        if (this._font_small.size(name.slice(0, i + 1)) > max_len) {
          this._name_lengths[key] = name.slice(0, i)
          found = true
          break
        }
      }
      if (!found) {
        this._name_lengths[key] = name
      }
    }
    return this._name_lengths[key]
  }

  draw_units(surf) {
    //Draw the units and buildings.//
    const unit_dict = null // Cache the units {tag: unit_proto} for orders.
    const tau = 2 * Math.PI
    this._visible_units().forEach(([u, p]) => {
      if (this._camera.intersects_circle(p, u.getRadius())) {
        const fraction_damage = clamp(
          (u.getHealthMax() - u.getHealth()) / (u.getHealthMax() || 1),
          0,
          1
        )
        if (u.getDisplayType() == sc_raw.DisplayType.PLACEHOLDER) {
          surf.draw_circle(
            colors.PLAYER_ABSOLUTE_PALETTE[u.getOwner()].div(3).floor(),
            p,
            u.getRadius()
          )
        } else {
          surf.draw_circle(
            colors.PLAYER_ABSOLUTE_PALETTE[u.getOwner()],
            p,
            u.getRadius()
          )

          if (fraction_damage > 0) {
            surf.draw_circle(
              colors.PLAYER_ABSOLUTE_PALETTE[u.getOwner()].div(2).floor(),
              p,
              u.getRadius() * fraction_damage
            )
          }
        }
        let thickness = 1
        surf.draw_circle(colors.black, p, u.getRadius(), thickness)

        if (this._static_data.unit_stats[u.getUnitType()].movement_speed > 0) {
          surf.draw_arc(
            colors.white,
            p,
            u.getRadius(),
            u.getFacing() - 0.1,
            u.getFacing() + 0.1,
            thickness
          )
        }

        function draw_arc_ratio(color, world_loc, radius, start, end, thickness) {
          surf.draw_arc(
            color,
            world_loc,
            radius,
            start * tau,
            end * tau,
            thickness
          )
        }

        if (u.getShield() && u.getShieldMax()) {
          draw_arc_ratio(colors.blue, p, u.getRadius() - 0.05, 0, u.getShield() / u.getShieldMax())
        }

        if (u.getEnergy() && u.getEnergyMax()) {
          draw_arc_ratio(colors.purple.mul(0.9), p, u.getRadius() - 0.1, 0, u.getEnergy() / u.getEnergyMax())
        }

        if (0 < u.getBuildProgress() < 1) {
          draw_arc_ratio(colors.cyan, p, u.getRadius() - 0.15, 0, u.getBuildProgress())
        } else if (u.getOrdersList().length && 0 < u.getOrdersList()[0].getProgress() < 1) {
          draw_arc_ratio(colors.cyan, p, u.getRadius() - 0.15, 0,
                         u.getOrdersList()[0].getProgress())
        }

        if (u.getBuffDurationRemain() && u.buff_duration_max) {
          draw_arc_ratio(colors.white, p, u.getRadius() - 0.2, 0,
                         u.getBuffDurationRemain() / u.buffDurationMax())
        }

        thickness = 3
        if (u.getAttackUpgradeLevel()) {
          draw_arc_ratio(this.upgrade_colors[u.getAttackUpgradeLevel()], p,
                         u.getRadius() - 0.25, 0.18, 0.22, thickness)
        }

        if (u.getArmorUpgradeLevel()) {
          draw_arc_ratio(this.upgrade_colors[u.getArmorUpgradeLevel()], p,
                         u.getRadius() - 0.25, 0.23, 0.27, thickness)
        }

        if (u.getShieldUpgradeLevel()) {
          draw_arc_ratio(this.upgrade_colors[u.getShieldUpgradeLevel()], p,
                         u.getRadius() - 0.25, 0.28, 0.32, thickness)
        }

        const self = this
        function write_small(loc, s) {
          surf.write_world(self._font_small, colors.white, loc, String(s))
        }

        const name = this.get_unit_name(
            surf, this._static_data.units[u.getUnitType()] || "<none>", u.getRadius())
        if (name) {
          write_small(p, name)
        }
        if (u.getIdealHarvesters() > 0) {
          write_small(p.add(new point.Point(0, 0.5)),
                      `${u.getAssignedHarvesters()} / ${u.getIdealHarvesters()}`)
        }
        if (u.getMineralContents() > 0) {
          write_small(p.sub(new point.Point(0, 0.5)), u.getMineralContents())
        } else if (u.getVespeneContents() > 0) {
          write_small(p.sub(new point.Point(0, 0.5)), u.getVespeneContents())
        } else if (u.getDisplayType() == sc_raw.DisplayType.SNAPSHOT) {
          write_small(p.sub(new point.Point(0, 0.5)), "snapshot")
        } else if (u.getDisplayType() == sc_raw.DisplayType.PLACEHOLDER) {
          write_small(p.sub(new point.Point(0, 0.5)), "placeholder")
        } else if (u.getIsHallucination()) {
          write_small(p.sub(new point.Point(0, 0.5)), "hallucination")
        } else if (u.getIsBurrowed()) {
          write_small(p.sub(new point.Point(0, 0.5)), "burrowed")
        } else if (u.getCloak() != sc_raw.CloakState.NOTCLOAKED) {
          write_small(p.sub(new point.Point(0, 0.5)), "cloaked")
        }

        if (u.getIsSelected()) {
          surf.draw_circle(colors.green, p, u.radius + 0.1, 1)
          const unit_dict = {}

          // Draw the orders of selected units.
          let start_point = p
          const orders = u.getOrdersList()
          for (let i = 0; i < orders.length; i++) {
            let target_point = null
            const o = orders[i]
            if (o.hasTargetWorldSpacePos()) {
              target_point = new point.Point(o.getTargetWorldSpacePos())
            } else if (o.hasTargetUnitTag()) {
              this._obs.getObservation().getRawData().getUnitsList().forEach((t) => {
                unit_dict[t.getTag()] = t
              })
              const target_unit = unit_dict[o.getTargetUnitTag()]
              let target_point
              if (target_unit) {
                target_point = new point.Point(target_unit.getPos())
              }
              if (target_point) {
                surf.draw_line(colors.cyan * 0.75, start_point, target_point)
                start_point = target_point
              } else {
                break
              }
            }
          }
          const rallyTargets = u.getRallyTargetsList()
          for (let i = 0; i < rallyTargets.length; i++) {
            surf.draw_line(colors.cyan * 0.75, p,
                           new point.Point(rally.getPoint()))
          }
        }
      }
    })
    window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
  }

  draw_effects(surf) {
    //Draw the effects.//
    this._obs.getObservation().getRawData().getEffectsList().forEach((effect) => {
      const color = [
        colors.effects[effect.getEffectId()],
        colors.effects[effect.getEffectId()],
        colors.PLAYER_ABSOLUTE_PALETTE[effect.getOwner()]
      ]
      const name = this.get_unit_name(
        surf, features.Effects(effect.getEffectId()).name, effect.getRadius()
      )
      effect.getPosList().forEach((pos) => {
        const p = point.Point.build(pos)
        // pygame alpha transparency doesn't work, so just draw thin circles.
        const thickness = 2
        for (let r = 1; r < Math.floor(effect.getRadius() * 3); r++) {
          surf.draw_circle(color[r % 3], p, r / 3, thickness)
        }
        if (name) {
          surf.write_world(this._font_small, colors.white, p, name)
        }
      })
    })
    window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
  }

  draw_selection(surf) {
    //Draw the selection rectangle.//
    const select_start = this._select_start // Cache to avoid a race condition.
    if (select_start) {
      const mouse_pos = this.get_mouse_pos()
      if (mouse_pos && mouse_pos.surf.surft_type & SurfType.SCREEN && mouse_pos.surf.surf_type == select_start.surf.surf_type) {
        const rect = new point.Rect(select_start.world_pos, mouse_pos.world_pos)
        surf.draw_rect(colors.green, rect, 1)
      }
    }
    window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
  }

  draw_build_target(surf) {
    // Draw the build target//
    const round_half = (v, cond) => cond ?  Math.round(v - 0.5) + 0.5 : Math.round(v)

    const queued_action = this._queued_action
    if (queued_action) {
      const radius = queued_action.footprint_radius
      if (radius) {
        let pos = this.get_mouse_pos()
        if (pos) {
          pos = new point.Point(
            round_half(pos.world_pos.y, (radius * 2) % 2),
            round_half(pos.world_pos.y, (radius * 2) % 2)
          )
          surf.draw_circle(
            colors.PLAYER_ABSOLUTE_PALETTE[
              this._obs.getObservation().getPlayerCommon().getPlayerId()
            ],
            pos,
            radius
          )
        }
      }
    }
    window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
  }

  draw_overlay(surf) {
    function sum(arr) {
     return arr.reduce((acc, curr = 0) => acc + curr)
    }
    //Draw the overlay describing resources.//
    const obs = this._obs.getObservation()
    const player = obs.getPlayerCommon()
    surf.write_screen(
      this._font_large, colors.green, [0.2, 0.2],
      `Minearls: ${player.getMinerals()}, Vespene: ${player.getVespene()}, Food: ${player.getFoodUsed()} / ${player.getFoodCap()}`,
      'left'
    )
    const times = []
    const steps = []
    this._game_times.forEach(([time, step]) => {
      times.push(time)
      steps.push(step)
    })
    const sec = Math.floor(obs.getGameLoop() / 22.4)
    surf.write_screen(
      this._font_large, colors.green, [-0.2, 0.2],
      `Score: ${obs.getScore().getScore()}, Step: ${obs.getGameLoop()}, ${(sum(steps) / (sum(times) || 1)).toFixed(1)}/s, Time: ${Math.floor(sec / 60)}:${sec % 60}`,
      'right'
    )
    surf.write_screen(
      this._font_large, colors.green.mul(0.8), [-0.2, 1.2],
      `APM: ${obs.getScore().getScoreDetails().getCurrentApm()}, EPM: ${obs.getScore().getScoreDetails().getCurrentEffectiveApm()}, FPS: O:${((times.length * 1000) / (sum(times) || 1)).toFixed(1)}, R: ${(this._render_times.length / (sum(this._render_times) || 1)).toFixed(1)}`,
      'right'
    )

    const line = 3
    const alerts = Object.keys(this._alerts).map((key) => [this._alerts[key], key]).sort((a, b) => a[0] - b[0])
    alerts.forEach(([alert, ts]) => {
      if (performance.now() < ts + (3 * 1000)) { // Show for 3 seconds.
        surf.write_screen(this._font_large, colors.red, [20, line], alert)
        line += 1
      } else {
        delete this._alerts[alert]
      }
    })
  }

  draw_help(surf) {
    //Draw the help dialog.//
    if (!this._help) {
      return
    }
    function write(loc, text) {
      surf.write_screen(this._font_large, colors.black, loc, text)
    }

    surf.surf.fill(colors.white * 0.8)
    write([1, 1], 'Shortcuts:')

    const max_len = Math.max(...this.shortcuts.map((s) => s.length))
    const shortcuts = this.shortcuts.slice(2)
    shortcuts.forEach(([hotkey, description], i) => {
      write([2, i], hotkey)
      write([3 + max_len * 0.7, i], description)
    })
    window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
  }
  
  draw_commands(surf) {
    // Draw the list of upgrades available commands.//
    function write(loc, text, color = colors.yellow) {
      surf.write_screen(this._font_large, color, loc, text)
    }
    let line = 2
    function write_line(x, args) {
      line += 1
      write([x, line], ...(Array.from(arguments).slice(1)))
    }
    const action_count = this._obs.getObservation().getAbilitiesList().length
    if (action_count > 0) {
      write_line(0.2, 'Available Actions: ', colors.green)
      const past_abilities = {}
      this._past_actions.forEach((act) => {
        if (act.ability) {
          past_abilities[act.abilitiy] = act
        }
      })
      let color
      this._abilities((c) => c.name != 'Smart')
        .sort((a, b) => a.name > b.name ? 1 : -1)
        .forEach((cmd) => {
          if (this._queued_action && cmd == this._queued_action) {
            color = colors.green
          } else if (this._queued_hotkey
            && cmd.hotkey.slice(0, this._queued_hotkey.length) == this._queued_hotkey) {
            color = colors.green * 0.75
          } else if (past_abilities.hasOwnProperty(cmd.ability_id)) {
            color = colors.red
          } else {
            color = colors.yellow
          }
          const hotkey = cmd.hotkey.slice(0, 3) // trunccate "escape" -> "esc"
          line += 1
          y = line
          write([1, y], hotkey, color)
          write([4, y], cmd.name, color)
      })
      line += 1
    }
    const upgradesList = this._obs.getObservation().getRawData().getPlayer().getUpgradeIdsList()
    const upgrade_count = upgradesList.length
    if (upgrade_count > 0) {
      write_line(0.2, `Upgrades: ${upgrade_count}`, colors.green)
      const upgrades = upgradesList
        .map((upgrade_id) => this._static_data.upgrades[upgrade_id].name)
      upgrades.sort().forEach((name) => write_line(1, name))
    }
    window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
  }

  draw_panel(surf) {
    //Draw the unit selection or build queue.//
    const left = -14 // How far from the right border
    let line = 3
    const self = this
    function unit_name(unit_type) {
      return self._static_data.units[unit_type] || '<unknown>'
    }
    function write(loc, text, color = colors.yellow) {
      surf.write_screen(self._font_large, color, loc,  text)
    }
    function write_line(x, args) {
      line += 1
      write([left + x, line], ...(Array.from(arguments).slice(1)))
    }

    function write_single(unit) {
      // Write a description of a single selected unit.//
      write_line(1, unit_name(unit.getUnitType()), colors.cyan)
      write_line(1, `Health: ${unit.getHealth()} / ${unit.getMaxHealth()}`)
      if (unit.getMaxShields()) {
        write_line(1, `Shields: ${unit.getShields()} / ${unit.getMaxShields()}`)
      }
      if (unit.getMaxEnergy()) {
        write_line(1, `Energy: ${unit.getEnergy()} / ${unit.getMaxEnergy()}`)
      }
      if (unit.getBuildProgress() > 0) {
        write_line(1, `Progress: ${Math.round(unit.getBuildProgress() * 100)}`)
      }
      if (unit.getTransportSlotsTaken()> 0) {
        write_line(1, `Slots: ${unit.getTransportSlotsTaken()}`)
      }
    }

    function write_multi(units) {
      //Write a description of multiple selected units.//
      const counts = new DefaultDict(1)
      units.forEach((unit) => {
        counts[unit_name(unit.getUnitType())] += 1
      })
      Object.keys(counts).sort().forEach((name) => {
        const count = counts[name]
        line += 1
        const y = line
        write([left + 1, y], count)
        write([left + 3, y], name)
      })
    }

    const ui = this._obs.getObservation().getUiData()

    if (ui.getGroupsList().length) {
      write_line(0, 'Control Groups: ', colors.green)
      ui.getGroupsList().forEach((group) => {
        line += 1
        const y = line
        write([left + 1, y], `${group.getControlGroupIndex()}`, colors.green)
        write([left + 3, y], `${group.getCount()} ${unit_name(group.getLeaderUnitType())}`)
      })
      line += 1
    }

    if (ui.hasSingle()) {
      write_line(0, 'Selection: ', colors.green)
      write_single(ui.getSingleUnit())
      if (ui.getSingle().getAttackUpgradeLevel()
        || ui.getSingle().getArmorUpgradeLevel()
        || ui.getSingle().getShieldUpgradeLevel()) {
        write_line(1, 'Upgrades: ')
        if (ui.getSingle().getAttackUpgradeLevel()) {
          write_line(2, `Attack: ${ui.getSingle().getAttackUpgradeLevel()}`)
        }
        if (ui.getSingle().getArmorUpgradeLevel()) {
          write_line(2, `Armor: ${ui.getSingle().getArmorUpgradeLevel()}`)
        }
        if (ui.getSingle().getShieldUpgradeLevel()) {
          write_line(2, `Shield: ${ui.getSingle().getShieldUpgradeLevel()}`)
        }
      }
      if (ui.getSingle().getBuffsList().length) {
        write_line(1, 'Buffs:')
        ui.getSinge().getBuffsList().forEach((b) => {
          write(line(2, buffs.Buffs(b).name))
        })
      }
    } else if (ui.hasMulti()) {
      write_line(0, 'Selection: ', colors.green)
      write_multi(ui.getMulti().getUnitsList())
    } else if (ui.hasCargo()) {
      write_line(0, 'Selection: ', colors.green)
      write_single(ui.getCargo().getUnit())
      line += 1
      write_line(0, 'Cargo: ', colors.green)
      write_line(1, `Empty slots: ${ui.getCargo().getSlotsAvailable()}`)
      write_multi(ui.getCargo().getPassengersList())
    } else if (ui.hasProduction()) {
      write_line(0, 'Selection: ', colors.green)
      write_single(ui.getProduction().getUnit())
      line += 1
      if (ui.getProduction().getProductionQueue()) {
        write_line(0, 'Production: ', colors.green)
        ui.getProduction().getProductionQueue().forEach((item) => {
          const specific_data =this.static_data.abilities[item.ability_id]
          let general_data
          if (specific_data.remaps_to_ability_id) {
            general_data = this._static_data.abilities[specific_data.remaps_to_ability_id]
          } else {
            general_data = specific_data
          }
          let s = general_data.friendly_name || general_data.button_name || general_data.link_name
          s = s.replace('Research ', '').replace('Train ', '')
          if (item.getBuildProgress() > 0) {
            s += `: ${Math.round(item.getBuildProgress() * 100)}`
          }
          write_line(1, s)
        })
      }
    }
    window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
  }

  draw_actions() {
    //Draw the actions so that they can be inspected for accuracy.//
    const now = performance.now()
    this._past_actions.forEach((act) => {
      if (act.pos && now < act.deadline) {
        const remain = (act.deadline - now) / (act.deadline - act.time)
        if (act.pos instanceof point.Point) {
          const size = remain / 3
          this.all_surfs((surf) => {
            surf.draw_circle(act.color, act.pos, size, 1)
            window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
          })
        } else {
          this.all_surfs((surf) => {
            // Fade with alpha would be nice, but doesn't seem to work.
            surf.draw_rect(act.color, act.pos, 1)
            window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
          })
        }
      }
    })

  }
  prepare_actions(obs) {
    //Keep a list of the past actions so they can be drawn.//
    const now = performance.now()
    while (this._past_actions.length && this._past_actions[0].dealine < now) {
      this._past_actions.pop()
    }

    function add_act(ability_id, color, pos, timeout = 1000) {
      let ability
      if (ability_id) {
        ability = this._static_data.abilities[ability_id]
        if (ability.remaps_to_ability_id) {
          ability_id = ability.remaps_to_ability_id
        }
      }
      this._past_actions.append(new PastAction(ability_id, color, pos, now, now + timeout))
    }

    obs.getActionsList().forEach((act) => {
      let pos
      if (act.hasActionRaw()
        && act.getActionRaw().hasUnitCommand()
        && act.getActionRaw().getUnitCommand().hasTargetWorldSpacePos()) {
        pos = new point.Point(act.getActionRaw().getUnitCommand().getTargetWorldSpacePos())
      add_act(act.getActionRaw().getUnitCommand().getAbilityId(), colors.yellow, pos)
      }
      if (act.hasActionFeatureLayer()) {
        const act_fl = act.getActionFeatureLayer()
        if (act_fl.hasUnitCommand()) {
          if (act_fl.getUnitCommand().hasTargetScreenCoord()) {
            pos = this._world_to_feature_screen_px.back_pt(
              new point.Point(act_fl.getUnitCommand().getTargetScreenCoord())
            )
            add_act(act_fl.getUnitCommand().getAbilityId(), colors.cyan, pos)
          } else if (act_fl.getUnitCommand().hasTargetMinimapCoord()) {
            pos = this._world_to_feature_minimap_px.back_pt(
              new point.Point(act_fl.getUnitCommand().getTargetMinimapCoord())
            )
            add_act(act_fl.getUnitCommand().getAbilityId(), colors.cyan, pos)
          } else {
            add_act(act_fl.getUnitCommand().getAbilityId(), null, null)
          }
        }
        if (act_fl.hasUnitSelectionPoint()
          && act_fl.getUnitSelectionPoint().hasSelectionScreenCoord()) {
          pos = this._world_to_feature_screen_px.back_pt(
            new point.Point(act_fl.getUnitSelectionPoint().getSelectionScreenCoord())
          )
          add_act(null, colors.cyan, pos)
        }
        if (act_fl.hasUnitSelectionRect()) {
          act_fl.hasUnitSelectionRect().getSelectionScreenCoordList().forEach((r) => {
            const rect = new point.Rect(
              this._world_to_feature_screen_px.back_pt(
                new point.Point(r.getP0()),
              ),
              this._world_to_feature_screen_px.back_pt(
                new point.Point(r.getP1())
              )
            )
            add_act(null, colors.cyan, rect, 0.3)
          })
        }
        if (act.hasActionRender()) {
          const act_rgb = act.getActionRender()
          if (act_rgb.hasUnitCommand()) {
            if (act_rgb.getUnitCommand().hasTargetSCreenCoord()) {
              pos = this._world_to_rgb_screen_px.back_pt(
                new point.Point(act_rgb.getUnitCommand().getTargetScreenCoord())
              )
              add_act(act_rgb.getUnitCommand().getAbilityId(), colors.red, pos)
            } else if (act_rgb.getUnitCommand().hasTargetMinimapCoord()) {
              pos = this._world_to_rgb_minimap_px.back_pt(
                new point.Point(act_rgb.getUnitCommand().getTargetMinimapCoord())
              )
              add_act(act_rgb.getUnitCommand().getAbilityId(), colors.red, pos)
            } else {
              add_act(act_rgb.getUnitCommand().getAbilityId(), null, null)
            }
          }
          if (act_rgb.hasUnitSelectionPoint()
            && act_rgb.getUnitSelectionPoint.hasSelectionScreenCoord()) {
            pos = this._word_to_rgb_screen_px.back_pt(
              new point.Point(act_rgb.getUnitSelectionPoint().getSelectionScreenCoord())
            )
            add_act(null, colors.red, pos)
          }
          if (act_rgb.hasUnitSelectionRect()) {
            act_rgb.getUnitSelectionRect().getSelectionScreenCoordList().forEach((r) => {
              const rect = new point.Rect(
                this._world_to_rgb_screen_px.back_pt(
                  new point.Point(r.getP0())
                ),
                this._world_to_rgb_screen_px.back_pt(
                  new point.Point(r.getP1())
                )
              )
              add_act(null, colors.red, rect, 0.3)
            })
          }
        }
      } 
    })
  }

  draw_base_map(surf) {
    //Draw the base map.//
    const hmap_feature = features.SCREEN_FEATURES.height_map
    let hmap = hmap_feature.unpack(this._obs.getObservation())
    if (!tf.any(tf.cast(hmap, 'bool'))) {
      hmap = hmap.add(100)
    }
    const hmap_color = hmap_feature.color(hmap, true)
    let out = hmap_color.mul(0.6)

    const creep_feature = features.SCREEN_FEATURES.creep
    const creep = creep_feature.unpack(this._obs.getObservation())
    const creep_mask = creep.greater(0)
    let creep_mask_out = creep_mask.broadcastTo([out.shape[2], out.shape[0], out.shape[1]])
    creep_mask_out = creep_mask_out.transpose([1, 2, 0])
    const creep_color = creep_feature.color(creep, true)

    let temp1 = out.where(creep_mask_out, out.mul(0.4))
    let temp2 = creep_color.where(creep_mask_out, creep_color.mul(0.6))
    out = out.where(creep_mask_out, temp1.add(temp2))

    const power_feature = features.SCREEN_FEATURES.power
    const power = power_feature.unpack(this._obs.getObservation())
    const power_mask = power.greater(0)
    let power_mask_out = power_mask.broadcastTo([out.shape[2], out.shape[0], out.shape[1]])
    power_mask_out = power_mask_out.transpose([1, 2, 0])
    const power_color = power_feature.color(power, true)

    temp1 = out.where(power_mask_out, out.mul(0.7))
    temp2 = power_color.where(power_mask_out, power_color.mul(0.3))
    // 84 x 84 x color => 84 x 84 x 3
    out = out.where(power_mask_out, temp1.add(temp2))

    if (this._render_player_relative) {
      const player_rel_feature = features.SCREEN_FEATURES.player_relative
      const player_rel = player_rel_feature.unpack(this._obs.getObservation())
      const player_rel_mask = player_rel.greater(0)
      let player_rel_mask_out = player_rel_mask.broadcastTo([out.shape[2], out.shape[0], out.shape[1]])
      player_rel_mask_out = player_rel_mask_out.transpose([1, 2, 0])
      const player_rel_color = player_rel_feature.color(player_rel, true)
      out = out.where(player_rel_mask, player_rel_color)
    }

    // 84 x 84
    let visibility = features.SCREEN_FEATURES.visibility_map.unpack(this._obs.getObservation())
    visibility = tf.cast(visibility, 'int32')
    // 3 x color => 3 x 3
    const visibility_fade = tf.tensor([[0.5, 0.5, 0.5], [0.75, 0.75, 0.75], [1, 1, 1]])

    // console.log('tf.gather(visibility_fade, visibility) shape: ', tf.gather(visibility_fade, visibility).print())
    //out *= visibility_fade[visibility]
    out = out.mul(tf.gather(visibility_fade, visibility))
    const rgb = true
    out = tf.cast(out, 'int32')
    surf.blit_np_array(getImageData(out.dataSync(), out.shape, rgb))
    // window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
  }

  draw_mini_map(surf) {
    //Draw the minimap//
    if (this._render_rgb
      && this._obs.getObservation().hasRenderData()
      && this._obs.getObservation().getRenderData().hasMinimap()) {
      // Draw the rendered version.
      surf.blit_np_array(features.Feature.unpack_image_data(
        this._obs.getObservation().getRenderData().getMinimap(),
      ))
    } else { // Render it manually from feature layer data.
      const hmap_feature = features.MINIMAP_FEATURES.height_map
      let hmap = hmap_feature.unpack(this._obs.getObservation())
      if (!np.any(hmap)) {
        hmap = hmap.add(100)
      }
      hmap_color = hmap_feaure.color(hmap)

      const creep_feature = features.MINIMAP_FEATURES.creep
      const creep = creep_feature.unpack(this._obs.getObservation())
      const creep_mask = creep.greater(0)
      const creep_color = creep_feature.color(creep)

      const player_id = this._obs.getObservation().getPlayerCommon().getPlayerId()
      let player_feature
      if (player_id == 0 || player_id == 16) { // observer
        // If we're the observer, show the absolute since otherwise all player
        // units are friendly, making it pretty boring.
        const player_feature = features.MINIMAP_FEATURES.player_id
      } else {
        const player_feature = features.MINIMAP_FEATURES.player_id
      }

      const player_data = player_feature.unpack(self._obs.observation)
      const player_mask = player_data.greater(0)
      const player_color = player_feature.color(player_data)

      const visibility = features.MINIMAP_FEATURES.visibility_map.unpack(
        this._obs.getObservation()
      )
      const visibility_fade = np.tensor([[0.5, 0.5, 0.5], [0.75, 0.75, 0.75], [1, 1, 1]])
      // Compose and color the different layers.
      let out = hmap_color.mul(0.6)
      let temp1 = out.where(creep_mask, out.mul(0.4))
      let temp2 = creep_color.where(creep_mask, creep_color.mul(0.6))
      out = out.where(creep_mask, temp1.add(temp2))

      out = out.where(player_mask, player_color)
      out = out.where(visibility, out.mul(visibility_fade))

      const shape = this._playable.diagonal.scale_max_size(
        this._feature_minimap_px
      ).floor()
      surf.blit_np_array(
        getImageData(
          out.slice([0, 0], [shape.y, shape.x]).dataSync(),
          [shape.y, shape.x],
          false
        )
      )

      surf.draw_rect(colors.white.mul(0.8), this._camera, 1) // Camera

      // Sensor rings.
      this._obs.getObservation().getRawData().getRadarList().forEach((radar) => {
        surf.draw_circle(
          colors.white.div(2),
          new point.Point(radar.getPos()),
          radar.getRadius(),
          1
        )
      })
    }

    // highlight enemy base locations for a short while at start of game
    if (this._obs.getObservation().getGameLoop() < 22.4 * 20) {
      this._game_info.getStartRaw().getStartLocationsList().forEach((loc) => {
        surf.draw_circle(colors.red, new point.Point(loc), 5, 1)
      })
    }

    window.gamejs.graphics.rect(surf.surf, colors.red.toCSS(), surf.surf.getRect(), 1) // Border

    window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
  }

  check_valid_queued_action() {
    // Make sure the existing command is still valid
    if (this._queued_hotkey && !this._abilities((cmd) => cmd.hotkey.slice(0, this._queued_hotkey.length) == this._queued_hotkey)) {
      this._queued_hotkey = ''
    }
    if (this._queued_action && !this._abilities((cmd) => this._queued_action == cmd)) {
      this._queued_action = null
    }
  }

  draw_rendered_map(surf) {
    // Draw the rendered pixels.//
    surf.blit_np_array(features.Feature.unpack_image_data(
      this._obs.getObservation().getRenderData().getMap()
    ))
    window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
  }

  draw_screen(surf) {
    //Draw the screen area.//
    if (this._render_rgb &&
      this._obs.getObservation().hasRenderData() &&
      this._obs.getObservation().getRenderData().hasMap() && true) {
      this.draw_rendered_map(surf)
    } else {
      this.draw_base_map(surf)
      this.draw_effects(surf)
      this.draw_units(surf)
    }
    this.draw_selection(surf)
    this.draw_build_target(surf)
    this.draw_overlay(surf)
    this.draw_commands(surf)
    this.draw_panel(surf)
  }

  draw_feature_layer(surf, feature) {
    //Draw a feature layer//
    const layer = feature.unpack_obs(this._obs.getObservation())
    if (layer != null) {
      const rgb = false
      surf.blit_np_array(features.Feature.unpack_image_data(layer, rgb, null, feature.palette))
    // window.gamejs.display.getSurface().blit_np_array(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
    } else { // Ignore layers that aren't in this version of SC2.
      surf.surf.fill(colors.black.toCSS())
    }
    window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])

  }

  draw_raw_layer(surf, from_obs, name, color, palette) {
    //Draw a raw layer.//
    let layer
    if (from_obs) {
      layer = getattr(this._obs.getObservation().getRawData().getMapState(), name)
    } else {
      layer = getattr(this._game_info.getStartRaw(), name)
    }
    if (layer) {
      const rgb = false
      surf.blit_np_array(features.Feature.unpack_image_data(layer, rgb, color, palette))
    } else { //Ignore layers that aren't in this version of SC2.
      surf.surf.fill(colors.black.toCSS())
    }
    window.gamejs.display.getSurface().blit(surf.surf, [surf.surf_rect.left, surf.surf_rect.top])
  }

  all_surfs(cb, args) {
    this._surfaces.forEach((surf) => {
      if (surf.world_to_surf) {
        cb(surf)
      }
    })
  }

  render(obs) {
    //Push an observation onto the queue to be rendered.//
    if (!this._initialized) {
      return
    }
    const now = performance.now()
    this._game_times.add([
      now - this._last_time,
      Math.max(1, obs.getObservation().getGameLoop() - this._obs.getObservation().getGameLoop())
    ])
    this._last_time = now
    this._last_game_loop = this._obs.getObservation().getGameLoop()
    if (this._obs_trigger) {
      this._obs_trigger(obs)
      this._obs_trigger = null
      return
    }
    this._obs_queue.add(obs)
    // dont think we need this for JavaScript
    // if (this._render_sync) {
    //   this._obs_queue.join()
    // }
  }

  get_next_obs() {
    if (this._obs_queue.length) {
      return Promsise.resolve(this._obs_queue.get())
    }
    return new Promise((resolve) => {
      this._obs_trigger = resolve
    })
  }

  get sc_alerts() {
    return Enum.IntEnum('Alert', sc_pb.Alert)
  }

  get sc_error_action_result() {
    return Enum.IntEnum('ActionResult')
  }

  async render_thread() {
    //A render loop that pulls observations off the queue to render.//
    let obs = true
    while (obs) {  // Send something falsy through the queue to shut down.
      try { 
        // obs = this._obs_queue.get()
        obs = await this.get_next_obs()
        if (obs) {
          obs.getObservation().getAlertsList().forEach((alert) => {
            this._alerts[this.sc_alerts(alert).key] = performance.now()
          })
          obs.getActionErrorsList().forEach((err) => {
            console.log('in action errors list: ', err)
            if (err.getResult() != this.sc_error_action_result.SUCCESS) {
              this._alerts[this.sc_error_action_result(err.getResult()).key] = performance.now()
            }
          })
          this.prepare_actions(obs)
          if (this._obs_queue.length === 0) {
            // Only render the latest observation so we keep up with the game.
            this.render_obs(obs)
          }
          if (this._video_writer) {
            const axes = [1, 0, 2]
            this._video_writer.add(np.transpose(
              window.gamejs.surfarray.pixels3d(this._window), axes)
            )
          }
        }
        // Dont think we need this in JavaScript
        // this._obs_queue.task_done()
      } catch (err) {
        console.error(err)
      }
    }
  }

  render_obs(obs) {
    //Render a frame given an observation.//
    const start_time = performance.now()
    this._obs = obs
    this.check_valid_queued_action()
    this._update_camera(new point.Point(
      this._obs.getObservation().getRawData().getPlayer().getCamera())
    )

    this._surfaces.forEach((surf) => {
      // Render that surface.
      surf.draw(surf)
    })
    const mouse_pos = this.get_mouse_pos()
    if (mouse_pos) {
      // Draw a small mouse cursor
      // this.all_surfs(_Surface.draw_circle, colors.green, mouse_pos.world_pos, 0.1)
      this.all_surfs((surf) => surf.draw_circle(colors.green, mouse_pos.world_pos, 0.1))
    }

    this.draw_actions()

    // withPython(sw('flip'), () => {
    //   // window.gamejs.display.flip()
    // })

    // withPython(sw('tf.tidy'), () => {
    //   window.tf.tidy(() => {})
    // })

    this._render_times.add(performance.now() - start_time)
  }

}

module.exports = {
  ActionCmd,
  circle_mask,
  MouseButtons,
  MousePos,
  PastAction,
  RendererHuman,
  SurfType,
  _get_desktop_size,
  _Surface,
  _Ability,
}

},{"./actions.js":"/actions.js","./colors.js":"/colors.js","./features.js":"/features.js","./named_array.js":"/named_array.js","./numpy.js":"/numpy.js","./point.js":"/point.js","./protocol.js":"/protocol.js","./pythonUtils.js":"/pythonUtils.js","./static_data.js":"/static_data.js","./stopwatch.js":"/stopwatch.js","./transform.js":"/transform.js","collections/deque":26,"path":6,"protobufjs":69,"python-enum":103,"s2clientprotocol":"s2clientprotocol"}],"/static_data.js":[function(require,module,exports){
// Copyright 2017 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//Expose static data in a more useful form than the raw protos.//

class StaticData {
  //Expose static data in a more useful form than the raw protos.//

  constructor(data) {
    //Takes data from RequestData.//
    const _units = {}
    const _unit_stats = {}
    const _upgrades = {}
    const _abilities = {}
    const _general_abilities = new Set()
    data.unitsList.forEach((u) => {
      _units[u.unitId] = u.name
      _unit_stats[u.unitId] = u
    })
    data.upgradesList.forEach((a) => {
      _upgrades[a.upgradeId] = a
    })
    data.abilitiesList.forEach((a) => {
      _abilities[a.abilityId] = a
      if (a.remapsToAbilityId) {
        _general_abilities.add(a.remapsToAbilityId)
      }
    })
    this._units = _units
    this._unit_stats = _unit_stats
    this._upgrades = _upgrades
    this._abilities = _abilities
    this._general_abilities = _general_abilities
    Object.keys(this._abilities).forEach((key) => {
      const a = this._abilities[key]
      if (a.hotkey) {
        a.hotkey = a.hotkey.toLowerCase()
      }
    })
  }

  get abilities() {
    return this._abilities
  }

  get upgrades() {
    return this._upgrades
  }

  get units() {
    return this._units
  }

  get unit_stats() {
    return this._unit_stats
  }

  get general_abilities() {
    return this._general_abilities
  }
}
// List of used/available abilities found by parsing replays.
const ABILITIES = [
  1, 4, 6, 7, 16, 17, 18, 19, 23, 26, 28, 30, 32, 36, 38, 42, 44, 46, 74, 76,
  78, 80, 110, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162,
  164, 166, 167, 169, 171, 173, 174, 181, 195, 199, 203, 207, 211, 212, 216,
  217, 247, 249, 250, 251, 253, 255, 261, 263, 265, 295, 296, 298, 299, 304,
  305, 306, 307, 308, 309, 312, 313, 314, 315, 316, 318, 319, 320, 321, 322,
  323, 324, 326, 327, 328, 329, 331, 333, 348, 380, 382, 383, 386, 388, 390,
  392, 393, 394, 396, 397, 399, 401, 403, 405, 407, 408, 410, 413, 415, 416,
  417, 419, 421, 422, 451, 452, 454, 455, 484, 485, 487, 488, 517, 518, 520,
  522, 524, 554, 556, 558, 560, 561, 562, 563, 591, 594, 595, 596, 597, 614,
  620, 621, 622, 623, 624, 626, 650, 651, 652, 653, 654, 655, 656, 657, 658,
  710, 730, 731, 732, 761, 764, 766, 768, 769, 790, 793, 799, 803, 804, 805,
  820, 822, 855, 856, 857, 861, 862, 863, 864, 865, 866, 880, 881, 882, 883,
  884, 885, 886, 887, 889, 890, 891, 892, 893, 894, 895, 911, 913, 914, 916,
  917, 919, 920, 921, 922, 946, 948, 950, 954, 955, 976, 977, 978, 979, 994,
  1006, 1036, 1038, 1039, 1042, 1062, 1063, 1064, 1065, 1066, 1067, 1068,
  1069, 1070, 1093, 1094, 1097, 1126, 1152, 1154, 1155, 1156, 1157, 1158,
  1159, 1160, 1161, 1162, 1163, 1165, 1166, 1167, 1183, 1184, 1186, 1187,
  1188, 1189, 1190, 1191, 1192, 1193, 1194, 1216, 1217, 1218, 1219, 1220,
  1221, 1223, 1225, 1252, 1253, 1282, 1283, 1312, 1313, 1314, 1315, 1316,
  1317, 1342, 1343, 1344, 1345, 1346, 1348, 1351, 1352, 1353, 1354, 1356,
  1372, 1373, 1374, 1376, 1378, 1380, 1382, 1384, 1386, 1388, 1390, 1392,
  1394, 1396, 1406, 1408, 1409, 1413, 1414, 1416, 1417, 1418, 1419, 1433,
  1435, 1437, 1438, 1440, 1442, 1444, 1446, 1448, 1449, 1450, 1451, 1454,
  1455, 1482, 1512, 1514, 1516, 1517, 1518, 1520, 1522, 1524, 1526, 1528,
  1530, 1532, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1592, 1593, 1594,
  1622, 1623, 1628, 1632, 1664, 1682, 1683, 1684, 1691, 1692, 1693, 1694,
  1725, 1727, 1729, 1730, 1731, 1732, 1733, 1763, 1764, 1766, 1768, 1819,
  1825, 1831, 1832, 1833, 1834, 1847, 1848, 1853, 1974, 1978, 1998, 2014,
  2016, 2048, 2057, 2063, 2067, 2073, 2081, 2082, 2095, 2097, 2099, 2108,
  2110, 2112, 2113, 2114, 2116, 2146, 2162, 2244, 2324, 2328, 2330, 2331,
  2332, 2333, 2338, 2340, 2342, 2346, 2350, 2354, 2358, 2362, 2364, 2365,
  2368, 2370, 2371, 2373, 2375, 2376, 2387, 2389, 2391, 2393, 2505, 2535,
  2542, 2544, 2550, 2552, 2558, 2560, 2588, 2594, 2596, 2700, 2704, 2708,
  2709, 2714, 2720, 3707, 3709, 3739, 3741, 3743, 3745, 3747, 3749, 3751,
  3753, 3755, 3757, 3765, 3771, 3776, 3777, 3778, 3783,
]

// List of known unit types. It is generated by parsing replays and from:
// https://github.com/Blizzard/s2client-api/blob/master/include/sc2api/sc2_typeenums.h
const UNIT_TYPES = [
  4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
  24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
  43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
  62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
  81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
  100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 125, 126, 127, 128, 129, 130, 131, 132, 133,
  134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 149,
  150, 151, 268, 289, 311, 321, 322, 324, 330, 335, 336, 341, 342, 343, 344,
  350, 364, 365, 371, 372, 373, 376, 377, 472, 473, 474, 475, 483, 484, 485,
  486, 487, 488, 489, 490, 493, 494, 495, 496, 498, 499, 500, 501, 502, 503,
  504, 517, 518, 559, 560, 561, 562, 563, 564, 588, 589, 590, 591, 608, 609,
  610, 612, 628, 629, 630, 638, 639, 640, 641, 642, 643, 648, 649, 651, 661,
  662, 663, 664, 665, 666, 687, 688, 689, 690, 691, 692, 693, 694, 732, 733,
  734, 796, 797, 801, 824, 830, 877, 880, 881, 884, 885, 886, 887, 892, 893,
  894, 1904, 1908, 1910, 1911, 1912, 1913, 1955, 1956, 1957, 1958, 1960, 1961,
]

// List of used buffs found by parsing replays.
const BUFFS = [
  5, 6, 7, 8, 11, 12, 13, 16, 17, 18, 22, 24, 25, 27, 28, 29, 30, 33, 36, 38,
  49, 59, 83, 89, 99, 102, 116, 121, 122, 129, 132, 133, 134, 136, 137, 145,
  271, 272, 273, 274, 275, 277, 279, 280, 281, 288, 289,
]

// List of used upgrades found by parsing replays.
const UPGRADES = [
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 16, 17, 19, 20, 22, 25, 30,
  31, 32, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 52, 53,
  54, 55, 56, 57, 58, 59, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 72, 73, 74,
  75, 76, 78, 79, 80, 81, 82, 83, 84, 86, 87, 88, 99, 101, 116, 117, 118, 122,
  130, 134, 135, 136, 139, 140, 141, 144, 289, 291, 293, 296,
]

module.exports = {
  ABILITIES,
  BUFFS,
  StaticData,
  UNIT_TYPES,
  UPGRADES,
}

},{}],"/stopwatch.js":[function(require,module,exports){
(function (process,__dirname){
const path = require('path') //eslint-disable-line

/*A stopwatch to check how much time is used by bits of code.*/

const { performance } = require('perf_hooks') //eslint-disable-line
const pythonUtils = require(path.resolve(__dirname, './pythonUtils.js'))

const { DefaultDict, withPython, zip } = pythonUtils
// String = pythonUtils.String //eslint-disable-line
// Array = pythonUtils.Array //eslint-disable-line
const msToS = 1 / 1000
const usedVal = { val: 0 }
const perf_hooks_mock = {
  usedVal,
  useRealish: false,
  set return_val(val) {
    usedVal.val = val
  },
  get return_val() {
    return usedVal.val
  },
  performance: {
    now() {
      if (perf_hooks_mock.useRealish) {
        return Date.now()
      }
      return usedVal.val
    },
  },
}

class Stat {
  static get _fields() { return ["num", "min", "max", "sum", "sum_sq"] }

  constructor() {
    this.reset()
  }

  reset() {
    this.num = 0
    this.min = 1000000000
    this.max = 0
    this.sum = 0
    this.sum_sq = 0
  }

  add(val) {
    this.num += 1
    if (this.min > val) {
      this.min = val
    }
    if (this.max < val) {
      this.max = val
    }
    this.sum += val
    this.sum_sq += (val ** 2)
  }

  get avg() {
    if (this.num === 0) {
      return 0
    }
    return this.sum / this.num
  }

  get dev() {
    //Standard deviation.//
    if (this.num === 0) {
      return 0
    }
    return Math.sqrt(Math.max(0, (this.sum_sq / this.num) - ((this.sum / this.num) ** 2)))
  }

  merge(other) {
    this.num += other.num
    this.min = Math.min(this.min, other.min)
    this.max = Math.max(this.max, other.max)
    this.sum += other.sum
    this.sum_sq += other.sum_sq
  }

  static build(summation, average, standard_deviation, minimum, maximum, number) {
    const stat = new this.prototype.constructor()
    if (number > 0) {
      stat.num = number
      stat.min = minimum
      stat.max = maximum
      stat.sum = summation
      stat.sum_sq = number * ((standard_deviation ** 2) + (average ** 2))
    }
    return stat
  }

  static parse(s) {
    if (s === 'num=0') {
      return new this.prototype.constructor()
    } //eslint-disable-next-line
    const parts = s.split(', ').map((p) => {
      return Number(p.split(':')[1])
    })
    return Stat.build(...parts)
  }

  toString() {
    if (this.num === 0) {
      return 'num=0'
    }
    return `sum: ${this.sum.toFixed(4)}, avg: ${this.avg.toFixed(4)}, dev: ${this.dev.toFixed(4)}, min: ${this.min.toFixed(4)}, max: ${this.max.toFixed(4)}, num: ${this.num}`
  }
}

class StopWatchContext {
  //Time an individual call.//
  static get _fields() { return ['_sw', '_start'] }

  constructor(stopwatch, name, mock_time = false) {
    this._sw = stopwatch
    this._sw.push(name)
    this.__enter__ = this.__enter__.bind(this)
    this.__exit__ = this.__exit__.bind(this)
    if (mock_time) {
      this.performance = perf_hooks_mock.performance
      // NOTE: Jest will define a window object
    } else if (typeof window === 'undefined') {
      // this.performance = performance
      this.performance = Date
    } else {
      // this.performance = window.performance
      this.performance = Date
    }
  }

  // performance.now() => measured in milliseconds.
  __enter__() {
    this._start = this.performance.now()
  }

  __exit__() {
    // this._sw.add(this._sw.pop(), (this.performance.now() * msToS) - this._start)
    this._sw.add(this._sw.pop(), (this.performance.now() - this._start) * msToS)
  }
}

class TracingStopWatchContext extends StopWatchContext {
  //Time an individual call, but also output all the enter/exit calls.//
  constructor(stopwatch, name, mock_time = false) {
    super(stopwatch, name, mock_time)
    this.__enter__ = this.__enter__.bind(this)
    this.__exit__ = this.__exit__.bind(this)
  }

  __enter__() {
    super.__enter__()
    this._log(`>>> ${this._sw.cur_stack()}`)
  }

  __exit__() {
    this._log(`<<< ${this._sw.cur_stack()} ${(this.performance.now() - this._start).toFixed(6)} secs`)
    super.__exit__()
  }

  //eslint-disable-next-line
  _log(s) {
    process.stderr.write(s + '\n')
  }
}

class FakeStopWatchContext {
  constructor() {} //eslint-disable-line

  __enter__() {} //eslint-disable-line

  __exit__() {} //eslint-disable-line
}

const fake_context = new FakeStopWatchContext()

let StopWatchRef

class StopWatch {
  /*A context manager that tracks call count and latency, and other stats.

  Usage:
      sw = stopwatch.Stopwatch()
      with sw("foo"):
        foo()
      with sw("bar"):
        bar()
      @sw.decorate
      def func():
        pass
      func()
      print(sw)
  */
  static get _fields() { return ['_times', '_local', '_factory'] }

  static _make(kwargs) {
    return new this.prototype.constructor(kwargs);
  }

  constructor(enabled = true, trace = false, mock_time = false) {
    this._times = new DefaultDict(Stat)
    // we dont need to declare anything as being local to the context
    // of the thread since by default node js worker threads are local
    this._local = {}
    if (trace) {
      this.trace()
    } else if (enabled) {
      this.enable()
    } else {
      this.disable()
    }
    const self = this
    function stopwatchProxy(name) {
      return self.__call__(name)
    }
    ['disable', 'enable', 'trace', 'custom', 'decorate', 'push', 'pop', 'cur_stack', 'clear', 'add', 'merge', 'str', 'toString'].forEach((methodName) => {
      stopwatchProxy[methodName] = this[methodName].bind(this)
    })
    Object.defineProperty(stopwatchProxy, 'times', {
      get() {
        return self._times
      }
    })
    stopwatchProxy._times = this._times
    stopwatchProxy.parse = this.constructor.parse
    stopwatchProxy.instanceRef = this
    this._mock_time = mock_time
    if (this._mock_time) {
      stopwatchProxy._perf_hooks_mock = perf_hooks_mock
    }
    this._funcProxy = stopwatchProxy
    return stopwatchProxy
  }

  disable() {
    this._factory = () => fake_context
  }

  enable() {
    this._factory = (name) => new StopWatchContext(this, name, this._mock_time)
  }

  trace() {
    this._factory = (name) => new TracingStopWatchContext(this, name, this._mock_time)
  }

  custom(factory) {
    this._factory = factory
  }

  __call__(name) {
    return this._factory(name)
  }

  decorate(name_or_func) {
    /*Decorate a function/method to check its timings.

    To use the function's name:
      @sw.decorate
      def func():
        pass

    To name it explicitly:
      @sw.decorate("name")
      def random_func_name():
        pass

    Args:
      name_or_func: the name or the function to decorate.

    Returns:
      If a name is passed, returns this as a decorator, otherwise returns the
      decorated function.
    */
    if (process.env['SC2_NO_STOPWATCH']) {
      return typeof (name_or_func) === 'function' ? name_or_func : (func) => func
    }
    const self = this
    function decorator(name, func) {
      function _stopwatch() {
        return withPython(self.__call__(name), () => { //eslint-disable-line
          return func(...arguments) //eslint-disable-line
        })
      }
      return _stopwatch
    }
    if (typeof (name_or_func) === 'function') {
      return decorator(name_or_func.name.replace('bound ', ''), name_or_func)
    }
    return (func) => decorator(name_or_func, func)
  }

  push(name) {
    try {
      this._local.stack.push(name)
    } catch (err) {
      this._local.stack = [name]
    }
  }

  pop() {
    const stack = this._local.stack
    const ret = stack.join('.')
    stack.pop()
    return ret
  }

  cur_stack() {
    return this._local.stack.join('.')
  }

  clear() {
    this._times = new DefaultDict(Stat)// this._times.clear()
    this._funcProxy._times = this._times
  }

  add(name, duration) {
    this._times[name].add(duration)
  }

  get times() {
    return this._times
  }

  merge(other) {
    let value
    Object.keys(other.times).forEach((key) => {
      value = other[key]
      if (!value) {
        return
      }
      this._times[key].merge(value)
    })
  }

  static parse(s) {
    //Parse the output below to create a new StopWatch.//
    const stopwatch = new StopWatchRef()
    s.splitlines().forEach((line) => {
      if (line.trim()) {
        const parts = line.match(/\S+/g)
        const name = parts[0]
        if (name !== '%') { // ie not the header line
          const rest = parts.slice(2, parts.length).map((v) => Number(v))
          stopwatch.times[parts[0]].merge(Stat.build(...rest))
        }
      }
    })
    return stopwatch
  }

  str(threshold = 0.1) {
    //Return a string representation of the timings.//
    if (!this._times) {
      return ''
    }
    let cur
    const total = Object.keys(this._times).reduce((acc, key) => {
      cur = this._times[key]
      return !(key.includes('.')) ? cur.sum + acc : acc
    }, 0)
    const table = [['', '% total', 'sum', 'avg', 'dev', 'min', 'max', 'num']]
    let percent
    let v
    Object.keys(this._times).sort().forEach((key) => {
      v = this._times[key]
      percent = (100 * v.sum) / (total || 1)
      if (percent > threshold) {
        table.push([
          key,
          percent.toFixed(2),
          v.sum.toFixed(4),
          v.avg.toFixed(4),
          v.dev.toFixed(4),
          v.min.toFixed(4),
          v.max.toFixed(4),
          String(v.num)
        ])
      }
    })
    let col
    const col_widths = []
    const nCol = table[0].length
    for (let colIndex = 0; colIndex < nCol; colIndex++) {
      col = []
      table.forEach((row) => {//eslint-disable-line
        col.push(row[colIndex].length)
      })
      col_widths[colIndex] = Math.max(...col)
    }
    let out = ''
    let val
    let width
    table.forEach((row) => {
      //eslint-disable-next-line
      out += '  ' + row[0].ljust(col_widths[0]) + '  '
      out += zip(row.slice(1), col_widths.slice(1))
        .map((zipPair) => {
          val = zipPair[0]
          width = zipPair[1]
          return val.rjust(width)
        }).join('  ')
      out += '\n'
    })
    return out
  }

  toString() {
    return this.str()
  }
}
StopWatchRef = StopWatch

// Global stopwatch is disabled by default to not incur the performance hit if
// it's not wanted.
const sw = new StopWatch(false)

module.exports = {
  Stat,
  StopWatchContext,
  TracingStopWatchContext,
  FakeStopWatchContext,
  fake_context,
  StopWatch,
  StopWatchRef,
  sw,
}

}).call(this,require('_process'),"/")
},{"_process":7,"path":6,"perf_hooks":1}],"/transform.js":[function(require,module,exports){
(function (__dirname){
const path = require('path') //eslint-disable-line
const point = require(path.resolve(__dirname, './point.js'))
const pythonUtils = require(path.resolve(__dirname, './pythonUtils.js'))

const { assert, isinstance, NotImplementedError } = pythonUtils

class Transform {
  fwd_dist() {//eslint-disable-line
    throw NotImplementedError()
  }

  fwd_pt() {//eslint-disable-line
    throw NotImplementedError()
  }

  back_dist() {//eslint-disable-line
    throw NotImplementedError()
  }

  back_pt() {//eslint-disable-line
    throw NotImplementedError()
  }
}

class Linear extends Transform {
  constructor(scale = null, offset = null) {
    //object was passed in
    // { scale: scale, offset: offset }
    if (!(scale instanceof point.Point)) {
      if (scale && scale.offset) {
        offset = scale.offset
        scale = scale.scale || null
      }
    }
    super(scale, offset)
    if (scale == null || scale == undefined) {
      this.scale = new point.Point(1, 1)
    } else if (isinstance(scale, Number)) {
      this.scale = new point.Point(scale, scale)
    } else {
      this.scale = scale
    }
    assert(this.scale.x !== 0 && this.scale.y !== 0, ' new Linear.scale.x !== 0 && new Linear.scale.y !== 0')
    this.offset = offset || new point.Point(0, 0)
  }

  fwd_dist(dist) {
    return dist * this.scale.x
  }

  fwd_pt(pt) {
    return pt.mul(this.scale).add(this.offset)
  }

  back_dist(dist) {
    return dist / this.scale.x
  }

  back_pt(pt) {
    pt = pt.sub(this.offset).div(this.scale)
    return pt
  }

  toString() {
    return `Linear(scale = ${this.scale}, offset = ${this.offset})`
  }
}

class Chain extends Transform {
  constructor() {
    super(arguments) //eslint-disable-line
    this.transforms = arguments //eslint-disable-line
  }

  fwd_dist(dist) {
    for (let i = 0; i < this.transforms.length; i++) {
      const transform = this.transforms[i]
      dist = transform.fwd_dist(dist)
    }
    return dist
  }

  fwd_pt(pt) {
    for (let i = 0; i < this.transforms.length; i++) {
      const transform = this.transforms[i]
      pt = transform.fwd_pt(pt)
    }
    return pt
  }

  back_dist(dist) {
    for (let i = this.transforms.length - 1; i >= 0; i--) {
      const transform = this.transforms[i]
      dist = transform.back_dist(dist)
    }
    return dist
  }

  back_pt(pt) {
    for (let i = this.transforms.length - 1; i >= 0; i--) {
      const transform = this.transforms[i]
      pt = transform.back_pt(pt)
    }
    return pt
  }

  toString() {
    return `Chain(${this.transforms})`
  }
}

class PixelToCoord extends Transform {
  fwd_dist(dist) { //eslint-disable-line
    return dist
  }

  fwd_pt(pt) { //eslint-disable-line
    return pt.floor()
  }

  back_dist(dist) { //eslint-disable-line
    return dist
  }

  back_pt(pt) { //eslint-disable-line
    return pt.floor().add(0.5)
  }

  toString() { //eslint-disable-line
    return 'PixelToCoord()'
  }
}

module.exports = {
  Chain,
  Linear,
  PixelToCoord,
  Transform,
}

}).call(this,"/")
},{"path":6}],"@tensorflow/tfjs-node":[function(require,module,exports){
const tf = window.tf
module.exports = tf

},{}],"@tensorflow/tfjs":[function(require,module,exports){
const tf = window.tf
module.exports = tf
},{}],1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],3:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)
},{"base64-js":2,"buffer":3,"ieee754":4}],4:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],5:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],6:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":7}],7:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],8:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],9:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],10:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":9,"_process":7,"inherits":8}],11:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],12:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],13:[function(require,module,exports){
"use strict";
module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;

},{}],14:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],15:[function(require,module,exports){
"use strict";
module.exports = fetch;

var asPromise = require("@protobufjs/aspromise"),
    inquire   = require("@protobufjs/inquire");

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};

},{"@protobufjs/aspromise":11,"@protobufjs/inquire":17}],16:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],17:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],18:[function(require,module,exports){
"use strict";

/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};

},{}],19:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],20:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],21:[function(require,module,exports){
"use strict";

var Shim = require("./shim");
var GenericCollection = require("./generic-collection");
var GenericMap = require("./generic-map");

// Burgled from https://github.com/domenic/dict

module.exports = Dict;
function Dict(values, getDefault) {
    if (!(this instanceof Dict)) {
        return new Dict(values, getDefault);
    }
    getDefault = getDefault || Function.noop;
    this.getDefault = getDefault;
    this.store = Object.create(null);
    this.length = 0;
    this.addEach(values);
}

Dict.Dict = Dict; // hack so require("dict").Dict will work in MontageJS.

Object.addEach(Dict.prototype, GenericCollection.prototype);
Object.addEach(Dict.prototype, GenericMap.prototype);

Dict.from = GenericCollection.from;

Dict.prototype.constructClone = function (values) {
    return new this.constructor(values, this.getDefault);
};

Dict.prototype.assertString = function (key) {
    if (typeof key !== "string") {
        throw new TypeError("key must be a string but Got " + key);
    }
}

Object.defineProperty(Dict.prototype,"$__proto__",{writable:true});
Object.defineProperty(Dict.prototype,"_hasProto",{
    get:function() {
        return this.hasOwnProperty("$__proto__") && typeof this._protoValue !== "undefined";
    }
});
Object.defineProperty(Dict.prototype,"_protoValue",{
    get:function() {
        return this["$__proto__"];
    },
    set: function(value) {
        this["$__proto__"] = value;
    }
});

Object.defineProperty(Dict.prototype,"size",GenericCollection._sizePropertyDescriptor);


Dict.prototype.get = function (key, defaultValue) {
    this.assertString(key);
    if (key === "__proto__") {
        if (this._hasProto) {
            return this._protoValue;
        } else if (arguments.length > 1) {
            return defaultValue;
        } else {
            return this.getDefault(key);
        }
    }
    else {
        if (key in this.store) {
            return this.store[key];
        } else if (arguments.length > 1) {
            return defaultValue;
        } else {
            return this.getDefault(key);
        }
    }
};

Dict.prototype.set = function (key, value) {
    this.assertString(key);
    var isProtoKey = (key === "__proto__");

    if (isProtoKey ? this._hasProto : key in this.store) { // update
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange(key, isProtoKey ? this._protoValue : this.store[key]);
        }

        isProtoKey
            ? this._protoValue = value
            : this.store[key] = value;

        if (this.dispatchesMapChanges) {
            this.dispatchMapChange(key, value);
        }
        return false;
    } else { // create
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange(key, undefined);
        }
        this.length++;

        isProtoKey
            ? this._protoValue = value
            : this.store[key] = value;

        if (this.dispatchesMapChanges) {
            this.dispatchMapChange(key, value);
        }
        return true;
    }
};

Dict.prototype.has = function (key) {
    this.assertString(key);
    return key === "__proto__" ? this._hasProto : key in this.store;
};

Dict.prototype["delete"] = function (key) {
    this.assertString(key);
    if (key === "__proto__") {
        if (this._hasProto) {
            if (this.dispatchesMapChanges) {
                this.dispatchBeforeMapChange(key, this._protoValue);
            }
            this._protoValue = undefined;
            this.length--;
            if (this.dispatchesMapChanges) {
                this.dispatchMapChange(key, undefined);
            }
            return true;
        }
        return false;
    }
    else {
        if (key in this.store) {
            if (this.dispatchesMapChanges) {
                this.dispatchBeforeMapChange(key, this.store[key]);
            }
            delete this.store[key];
            this.length--;
            if (this.dispatchesMapChanges) {
                this.dispatchMapChange(key, undefined);
            }
            return true;
        }
        return false;
    }
};

Dict.prototype.clear = function () {
    var key;
    if (this._hasProto) {
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange("__proto__", this._protoValue);
        }
        this._protoValue = undefined;
        if (this.dispatchesMapChanges) {
            this.dispatchMapChange("__proto__", undefined);
        }
    }
    for (key in this.store) {
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange(key, this.store[key]);
        }
        delete this.store[key];
        if (this.dispatchesMapChanges) {
            this.dispatchMapChange(key, undefined);
        }
    }
    this.length = 0;
};

Dict.prototype.reduce = function (callback, basis, thisp) {
    if(this._hasProto) {
        basis = callback.call(thisp, basis, "$__proto__", "__proto__", this);
    }
    var store = this.store;
    for (var key in this.store) {
        basis = callback.call(thisp, basis, store[key], key, this);
    }
    return basis;
};

Dict.prototype.reduceRight = function (callback, basis, thisp) {
    var self = this;
    var store = this.store;
    basis = Object.keys(this.store).reduceRight(function (basis, key) {
        return callback.call(thisp, basis, store[key], key, self);
    }, basis);

    if(this._hasProto) {
        return callback.call(thisp, basis, this._protoValue, "__proto__", self);
    }
    return basis;
};

Dict.prototype.one = function () {
    var key;
    for (key in this.store) {
        return this.store[key];
    }
    return this._protoValue;
};

Dict.prototype.toJSON = function () {
    return this.toObject();
};

},{"./generic-collection":27,"./generic-map":28,"./shim":38}],22:[function(require,module,exports){
"use strict";

var Shim = require("./shim");
var Dict = require("./_dict");
var List = require("./_list");
var GenericCollection = require("./generic-collection");
var GenericSet = require("./generic-set");
var TreeLog = require("./tree-log");

var object_has = Object.prototype.hasOwnProperty;

module.exports = FastSet;

function FastSet(values, equals, hash, getDefault) {
    if (!(this instanceof FastSet)) {
        return new FastSet(values, equals, hash, getDefault);
    }
    equals = equals || Object.equals;
    hash = hash || Object.hash;
    getDefault = getDefault || Function.noop;
    this.contentEquals = equals;
    this.contentHash = hash;
    this.getDefault = getDefault;
    var self = this;
    this.buckets = new this.Buckets(null, function getDefaultBucket() {
        return new self.Bucket();
    });
    this.length = 0;
    this.addEach(values);
}

FastSet.FastSet = FastSet; // hack so require("fast-set").FastSet will work in MontageJS

Object.addEach(FastSet.prototype, GenericCollection.prototype);
Object.addEach(FastSet.prototype, GenericSet.prototype);
FastSet.from = GenericCollection.from;

FastSet.prototype.Buckets = Dict;
FastSet.prototype.Bucket = List;

FastSet.prototype.constructClone = function (values) {
    return new this.constructor(
        values,
        this.contentEquals,
        this.contentHash,
        this.getDefault
    );
};

FastSet.prototype.has = function (value) {
    var hash = this.contentHash(value);
    return this.buckets.get(hash).has(value);
};

FastSet.prototype.get = function (value, equals) {
    if (equals) {
        throw new Error("FastSet#get does not support second argument: equals");
    }
    var hash = this.contentHash(value);
    var buckets = this.buckets;
    if (buckets.has(hash)) {
        return buckets.get(hash).get(value);
    } else {
        return this.getDefault(value);
    }
};

FastSet.prototype["delete"] = function (value, equals) {
    if (equals) {
        throw new Error("FastSet#delete does not support second argument: equals");
    }
    var hash = this.contentHash(value);
    var buckets = this.buckets;
    if (buckets.has(hash)) {
        var bucket = buckets.get(hash);
        if (bucket["delete"](value)) {
            this.length--;
            if (bucket.length === 0) {
                buckets["delete"](hash);
            }
            return true;
        }
    }
    return false;
};

FastSet.prototype.clear = function () {
    this.buckets.clear();
    this.length = 0;
};

FastSet.prototype.add = function (value) {
    var hash = this.contentHash(value);
    var buckets = this.buckets;
    if (!buckets.has(hash)) {
        buckets.set(hash, new this.Bucket(null, this.contentEquals));
    }
    if (!buckets.get(hash).has(value)) {
        buckets.get(hash).add(value);
        this.length++;
        return true;
    }
    return false;
};

FastSet.prototype.reduce = function (callback, basis /*, thisp*/) {
    var thisp = arguments[2];
    var buckets = this.buckets;
    var index = 0;
    return buckets.reduce(function (basis, bucket) {
        return bucket.reduce(function (basis, value) {
            return callback.call(thisp, basis, value, index++, this);
        }, basis, this);
    }, basis, this);
};

FastSet.prototype.one = function () {
    if (this.length > 0) {
        return this.buckets.one().one();
    }
};

FastSet.prototype.iterate = function () {
    return this.buckets.valuesArray().flatten().iterate();
};

FastSet.prototype.log = function (charmap, logNode, callback, thisp) {
    charmap = charmap || TreeLog.unicodeSharp;
    logNode = logNode || this.logNode;
    if (!callback) {
        callback = console.log;
        thisp = console;
    }
    callback = callback.bind(thisp);

    var buckets = this.buckets, bucketsSize = buckets.size,
        mapIter = buckets.keys(), hash, index = 0,
        branch, leader, bucket;

    while (hash = mapIter.next().value) {
        if (index === bucketsSize - 1) {
            branch = charmap.fromAbove;
            leader = ' ';
        } else if (index === 0) {
            branch = charmap.branchDown;
            leader = charmap.strafe;
        } else {
            branch = charmap.fromBoth;
            leader = charmap.strafe;
        }
        bucket = buckets.get(hash);
        callback.call(thisp, branch + charmap.through + charmap.branchDown + ' ' + hash);
        bucket.forEach(function (value, node) {
            var branch, below, written;
            if (node === bucket.head.prev) {
                branch = charmap.fromAbove;
                below = ' ';
            } else {
                branch = charmap.fromBoth;
                below = charmap.strafe;
            }
            logNode(
                node,
                function (line) {
                    if (!written) {
                        callback.call(thisp, leader + ' ' + branch + charmap.through + charmap.through + line);
                        written = true;
                    } else {
                        callback.call(thisp, leader + ' ' + below + '  ' + line);
                    }
                },
                function (line) {
                    callback.call(thisp, leader + ' ' + charmap.strafe + '  ' + line);
                }
            );
        });
        index++;
    }

    //var hashes = buckets.keysArray();
    // hashes.forEach(function (hash, index) {
    //     var branch;
    //     var leader;
    //     if (index === hashes.length - 1) {
    //         branch = charmap.fromAbove;
    //         leader = ' ';
    //     } else if (index === 0) {
    //         branch = charmap.branchDown;
    //         leader = charmap.strafe;
    //     } else {
    //         branch = charmap.fromBoth;
    //         leader = charmap.strafe;
    //     }
    //     var bucket = buckets.get(hash);
    //     callback.call(thisp, branch + charmap.through + charmap.branchDown + ' ' + hash);
    //     bucket.forEach(function (value, node) {
    //         var branch, below;
    //         if (node === bucket.head.prev) {
    //             branch = charmap.fromAbove;
    //             below = ' ';
    //         } else {
    //             branch = charmap.fromBoth;
    //             below = charmap.strafe;
    //         }
    //         var written;
    //         logNode(
    //             node,
    //             function (line) {
    //                 if (!written) {
    //                     callback.call(thisp, leader + ' ' + branch + charmap.through + charmap.through + line);
    //                     written = true;
    //                 } else {
    //                     callback.call(thisp, leader + ' ' + below + '  ' + line);
    //                 }
    //             },
    //             function (line) {
    //                 callback.call(thisp, leader + ' ' + charmap.strafe + '  ' + line);
    //             }
    //         );
    //     });
    // });
};

FastSet.prototype.logNode = function (node, write) {
    var value = node.value;
    if (Object(value) === value) {
        JSON.stringify(value, null, 4).split("\n").forEach(function (line) {
            write(" " + line);
        });
    } else {
        write(" " + value);
    }
};

},{"./_dict":21,"./_list":23,"./generic-collection":27,"./generic-set":30,"./shim":38,"./tree-log":39}],23:[function(require,module,exports){
"use strict";

module.exports = List;

var Shim = require("./shim");
var GenericCollection = require("./generic-collection");
var GenericOrder = require("./generic-order");

function List(values, equals, getDefault) {
    return List._init(List, this, values, equals, getDefault);
}

List._init = function (constructor, object, values, equals, getDefault) {
    if (!(object instanceof constructor)) {
        return new constructor(values, equals, getDefault);
    }
    var head = object.head = new object.Node();
    head.next = head;
    head.prev = head;
    object.contentEquals = equals || Object.equals;
    object.getDefault = getDefault || Function.noop;
    object.length = 0;
    object.addEach(values);
}

List.List = List; // hack so require("list").List will work in MontageJS

Object.addEach(List.prototype, GenericCollection.prototype);
Object.addEach(List.prototype, GenericOrder.prototype);

List.from = GenericCollection.from;

List.prototype.constructClone = function (values) {
    return new this.constructor(values, this.contentEquals, this.getDefault);
};

List.prototype.find = function (value, equals, index) {
    equals = equals || this.contentEquals;
    var head = this.head;
    var at = this.scan(index, head.next);
    while (at !== head) {
        if (equals(at.value, value)) {
            return at;
        }
        at = at.next;
    }
};

List.prototype.findLast = function (value, equals, index) {
    equals = equals || this.contentEquals;
    var head = this.head;
    var at = this.scan(index, head.prev);
    while (at !== head) {
        if (equals(at.value, value)) {
            return at;
        }
        at = at.prev;
    }
};

List.prototype.has = function (value, equals) {
    return !!this.find(value, equals);
};

List.prototype.get = function (value, equals) {
    var found = this.find(value, equals);
    if (found) {
        return found.value;
    }
    return this.getDefault(value);
};

// LIFO (delete removes the most recently added equivalent value)
List.prototype["delete"] = function (value, equals) {
    var found = this.findLast(value, equals);
    if (found) {
        found["delete"]();
        this.length--;
        return true;
    }
    return false;
};

List.prototype.deleteAll = function (value, equals) {
    equals = equals || this.contentEquals;
    var head = this.head;
    var at = head.next;
    var count = 0;
    while (at !== head) {
        if (equals(value, at.value)) {
            at["delete"]();
            count++;
        }
        at = at.next;
    }
    this.length -= count;
    return count;
};

List.prototype.clear = function () {
    this.head.next = this.head.prev = this.head;
    this.length = 0;
};

List.prototype.add = function (value) {
    var node = new this.Node(value)
    return this._addNode(node);
};

List.prototype._addNode = function (node) {
    this.head.addBefore(node);
    this.length++;
    return true;
};

List.prototype.push = function () {
    var head = this.head;
    for (var i = 0; i < arguments.length; i++) {
        var value = arguments[i];
        var node = new this.Node(value);
        head.addBefore(node);
    }
    this.length += arguments.length;
};

List.prototype.unshift = function () {
    var at = this.head;
    for (var i = 0; i < arguments.length; i++) {
        var value = arguments[i];
        var node = new this.Node(value);
        at.addAfter(node);
        at = node;
    }
    this.length += arguments.length;
};

List.prototype._shouldPop = function () {
    var value;
    var head = this.head;
    if (head.prev !== head) {
        value = head.prev.value;
    }
    return value;
}

List.prototype.pop = function (_before, _after) {
    var value;
    var head = this.head;
    if (head.prev !== head) {
        value = head.prev.value;
        var index = this.length - 1;
        var popDispatchValueArray = _before ? _before.call(this,value,index) : void 0;
        head.prev['delete']();
        this.length--;
        _after ? _after.call(this,value,index, popDispatchValueArray) : void 0;
    }
    return value;
};

List.prototype.shift = function (_before, _after) {
    var value;
    var head = this.head;
    if (head.prev !== head) {
        value = head.next.value;
        var dispatchValueArray = _before ? _before.call(this,value,0) : void 0;
        head.next['delete']();
        this.length--;
        _after ? _after.call(this,value,0,dispatchValueArray) : void 0;
    }
    return value;
};

List.prototype.peek = function () {
    if (this.head !== this.head.next) {
        return this.head.next.value;
    }
};

List.prototype.poke = function (value) {
    if (this.head !== this.head.next) {
        this.head.next.value = value;
    } else {
        this.push(value);
    }
};

List.prototype.one = function () {
    return this.peek();
};

// TODO
// List.prototype.indexOf = function (value) {
// };

// TODO
// List.prototype.lastIndexOf = function (value) {
// };

// an internal utility for coercing index offsets to nodes
List.prototype.scan = function (at, fallback) {
    var head = this.head;
    if (typeof at === "number") {
        var count = at;
        if (count >= 0) {
            at = head.next;
            while (count) {
                count--;
                at = at.next;
                if (at == head) {
                    break;
                }
            }
        } else {
            at = head;
            while (count < 0) {
                count++;
                at = at.prev;
                if (at == head) {
                    break;
                }
            }
        }
        return at;
    } else {
        return at || fallback;
    }
};

// at and end may both be positive or negative numbers (in which cases they
// correspond to numeric indicies, or nodes)
List.prototype.slice = function (at, end) {
    var sliced = [];
    var head = this.head;
    at = this.scan(at, head.next);
    end = this.scan(end, head);

    while (at !== end && at !== head) {
        sliced.push(at.value);
        at = at.next;
    }

    return sliced;
};

List.prototype.splice = function (at, length /*...plus*/) {
    return this.swap(at, length, Array.prototype.slice.call(arguments, 2));
};

List.prototype.swap = function (start, length, plus, _before, _after) {
    var initial = start;
    // start will be head if start is null or -1 (meaning from the end), but
    // will be head.next if start is 0 (meaning from the beginning)
    start = this.scan(start, this.head);
    if (length == null) {
        length = Infinity;
    }
    plus = Array.from(plus);

    // collect the minus array
    var minus = [];
    var at = start;
    while (length-- && length >= 0 && at !== this.head) {
        minus.push(at.value);
        at = at.next;
    }

    // before range change
    var index, startNode;
    index = _before ? _before.call(this, start, plus, minus) : void 0;

    // delete minus
    var at = start;
    for (var i = 0, at = start; i < minus.length; i++, at = at.next) {
        at["delete"]();
    }
    // add plus
    if (initial == null && at === this.head) {
        at = this.head.next;
    }
    for (var i = 0; i < plus.length; i++) {
        var node = new this.Node(plus[i]);
        at.addBefore(node);
    }
    // adjust length
    this.length += plus.length - minus.length;

    _after ? _after.call(this, start, plus, minus) : void 0;

    return minus;
};

List.prototype.reverse = function () {
    var at = this.head;
    do {
        var temp = at.next;
        at.next = at.prev;
        at.prev = temp;
        at = at.next;
    } while (at !== this.head);
    return this;
};

List.prototype.sort = function () {
    this.swap(0, this.length, this.sorted.apply(this, arguments));
};

// TODO account for missing basis argument
List.prototype.reduce = function (callback, basis /*, thisp*/) {
    var thisp = arguments[2];
    var head = this.head;
    var at = head.next;
    while (at !== head) {
        basis = callback.call(thisp, basis, at.value, at, this);
        at = at.next;
    }
    return basis;
};

List.prototype.reduceRight = function (callback, basis /*, thisp*/) {
    var thisp = arguments[2];
    var head = this.head;
    var at = head.prev;
    while (at !== head) {
        basis = callback.call(thisp, basis, at.value, at, this);
        at = at.prev;
    }
    return basis;
};

List.prototype.updateIndexes = function (node, index) {
    while (node !== this.head) {
        node.index = index++;
        node = node.next;
    }
};


List.prototype.iterate = function () {
    return new ListIterator(this.head);
};

function ListIterator(head) {
    this.head = head;
    this.at = head.next;
};

ListIterator.prototype.__iterationObject = null;
Object.defineProperty(ListIterator.prototype,"_iterationObject", {
    get: function() {
        return this.__iterationObject || (this.__iterationObject = { done: false, value:null});
    }
});


ListIterator.prototype.next = function () {
    if (this.at === this.head) {
        this._iterationObject.done = true;
        this._iterationObject.value = void 0;
    } else {
        var value = this.at.value;
        this.at = this.at.next;
        this._iterationObject.value = value;
    }
    return this._iterationObject;
};

List.prototype.Node = Node;

function Node(value) {
    this.value = value;
    this.prev = null;
    this.next = null;
};

Node.prototype["delete"] = function () {
    this.prev.next = this.next;
    this.next.prev = this.prev;
};

Node.prototype.addBefore = function (node) {
    var prev = this.prev;
    this.prev = node;
    node.prev = prev;
    prev.next = node;
    node.next = this;
};

Node.prototype.addAfter = function (node) {
    var next = this.next;
    this.next = node;
    node.next = next;
    next.prev = node;
    node.prev = this;
};

},{"./generic-collection":27,"./generic-order":29,"./shim":38}],24:[function(require,module,exports){
(function (global){
"use strict";

var Shim = require("./shim");
var GenericCollection = require("./generic-collection");
var Map, GlobalMap, CollectionsMap;

if((global.Map !== void 0) && (typeof global.Set.prototype.values === "function")) {

    Map = module.exports = global.Map,
    GlobalMap = Map;
    Map.Map = Map; // hack so require("map").Map will work in MontageJS

    // use different strategies for making sets observable between Internet
    // Explorer and other browsers.
    var protoIsSupported = {}.__proto__ === Object.prototype,
        map_makeObservable;

    if (protoIsSupported) {
        map_makeObservable = function () {
            this.__proto__ = ChangeDispatchMap;
        };
    } else {
        map_makeObservable = function () {
            Object.defineProperties(this, observableSetProperties);
        };
    }

    Object.defineProperty(Map.prototype, "makeObservable", {
        value: map_makeObservable,
        writable: true,
        configurable: true,
        enumerable: false
    });

    //This is a no-op test in property-changes.js - PropertyChanges.prototype.makePropertyObservable, so might as well not pay the price every time....
    Object.defineProperty(Map.prototype, "makePropertyObservable", {
        value: function(){},
        writable: true,
        configurable: true,
        enumerable: false
    });


    Map.prototype.constructClone = function (values) {
        return new this.constructor(values);
    };

    Map.prototype.isMap = true;
    Map.prototype.addEach = function (values) {
        if (values && Object(values) === values) {
            if (typeof values.forEach === "function") {
                // copy map-alikes
                if (values.isMap === true) {
                    values.forEach(function (value, key) {
                        this.set(key, value);
                    }, this);
                // iterate key value pairs of other iterables
                } else {
                    values.forEach(function (pair) {
                        this.set(pair[0], pair[1]);
                    }, this);
                }
            } else if (typeof values.length === "number") {
                // Array-like objects that do not implement forEach, ergo,
                // Arguments
                for (var i = 0; i < values.length; i++) {
                    this.add(values[i], i);
                }
            } else {
                // copy other objects as map-alikes
                Object.keys(values).forEach(function (key) {
                    this.set(key, values[key]);
                }, this);
            }
        } else if (values && typeof values.length === "number") {
            // String
            for (var i = 0; i < values.length; i++) {
                this.add(values[i], i);
            }
        }
        return this;
    };

    Map.prototype.add = function (value, key) {
        return this.set(key, value);
    };

    Map.prototype.reduce = function (callback, basis /*, thisp*/) {
        var thisp = arguments[2];
        this.forEach(function(value, key, map) {
            basis = callback.call(thisp, basis, value, key, this);
        });
        return basis;
    };

    Map.prototype.reduceRight = function (callback, basis /*, thisp*/) {
        var thisp = arguments[2];
        var keysIterator = this.keys();
        var size = this.size;
        var reverseOrder = new Array(this.size);
        var aKey, i = 0;
        while ((aKey = keysIterator.next().value)) {
            reverseOrder[--size] = aKey;
        }
        while (i++ < size) {
            basis = callback.call(thisp, basis, this.get(reverseOrder[i]), reverseOrder[i], this);
        }
        return basis;
    };

    Map.prototype.equals = function (that, equals) {
        equals = equals || Object.equals;
        if (this === that) {
            return true;
        } else if (that && typeof that.every === "function") {
            return that.size === this.size && that.every(function (value, key) {
                return equals(this.get(key), value);
            }, this);
        } else {
            var keys = Object.keys(that);
            return keys.length === this.size && Object.keys(that).every(function (key) {
                return equals(this.get(key), that[key]);
            }, this);
        }
    };

    var _keysArrayFunction = function(value,key) {return key;};
    Map.prototype.keysArray = function() {
        return this.map(_keysArrayFunction);
    }
    var _valuesArrayFunction = function(value,key) {return value;};
    Map.prototype.valuesArray = function() {
        return this.map(_valuesArrayFunction);
    }
    var _entriesArrayFunction = function(value,key) {return [key,value];};
    Map.prototype.entriesArray = function() {
        return this.map(_entriesArrayFunction);
    }
    Map.prototype.toJSON = function () {
        return this.entriesArray();
    };

    // XXX deprecated
    Map.prototype.items = function () {
        return this.entriesArray();
    };

    // Map.prototype.contentEquals = Object.equals;
    // Map.prototype.contentHash = Object.hash;


    Map.from = function (value) {
        var result = new this;
        result.addEach(value);
        return result;
    };


    //Backward compatibility:
    Object.defineProperty(Map.prototype,"length",{
        get: function() {
            return this.size;
        },
        enumerable: true,
        configurable:true
    });


    var map_clear = Map.prototype.clear,
        map_set = Map.prototype.set,
        map_delete = Map.prototype.delete;

    var observableMapProperties = {
        clear : {
            value: function () {
                var keys;
                if (this.dispatchesMapChanges) {
                    this.forEach(function (value, key) {
                        this.dispatchBeforeMapChange(key, value);
                    }, this);
                    keys = this.keysArray();
                }
                map_clear.call(this);
                if (this.dispatchesMapChanges) {
                    keys.forEach(function (key) {
                        this.dispatchMapChange(key);
                    }, this);
                }
            },
            writable: true,
            configurable: true

        },
        set : {
            value: function (key, value) {
                var found = this.get(key);
                if (found) { // update
                    if (this.dispatchesMapChanges) {
                        this.dispatchBeforeMapChange(key, found);
                    }

                    map_set.call(this,key, value);

                    if (this.dispatchesMapChanges) {
                        this.dispatchMapChange(key, value);
                    }
                } else { // create
                    if (this.dispatchesMapChanges) {
                        this.dispatchBeforeMapChange(key, undefined);
                    }

                    map_set.call(this,key, value);

                    if (this.dispatchesMapChanges) {
                        this.dispatchMapChange(key, value);
                    }
                }
                return this;
            },
            writable: true,
            configurable: true
        },

        "delete": {
            value: function (key) {
                if (this.has(key)) {
                    if (this.dispatchesMapChanges) {
                        this.dispatchBeforeMapChange(key, this.get(key));
                    }
                    map_delete.call(this,key);

                    if (this.dispatchesMapChanges) {
                        this.dispatchMapChange(key, undefined);
                    }
                    return true;
                }
                return false;
            }
        }
    };



    Object.addEach(Map.prototype, GenericCollection.prototype, false);

    var ChangeDispatchMap = Object.create(Map.prototype, observableMapProperties);
}

    var Set = require("./_set").CollectionsSet;
    var GenericMap = require("./generic-map");

    CollectionsMap = Map = function Map(values, equals, hash, getDefault) {
        if (!(this instanceof Map)) {
            return new Map(values, equals, hash, getDefault);
        }
        equals = equals || Object.equals;
        hash = hash || Object.hash;
        getDefault = getDefault || Function.noop;
        this.contentEquals = equals;
        this.contentHash = hash;
        this.getDefault = getDefault;
        this.store = new Set(
            undefined,
            function keysEqual(a, b) {
                return equals(a.key, b.key);
            },
            function keyHash(item) {
                return hash(item.key);
            }
        );
        this.length = 0;
        this.addEach(values);
    }

    Map.Map = Map; // hack so require("map").Map will work in MontageJS

    Object.addEach(Map.prototype, GenericCollection.prototype);
    Object.addEach(Map.prototype, GenericMap.prototype); // overrides GenericCollection
    Object.defineProperty(Map.prototype,"size",GenericCollection._sizePropertyDescriptor);

    Map.from = GenericCollection.from;

    Map.prototype.constructClone = function (values) {
        return new this.constructor(
            values,
            this.contentEquals,
            this.contentHash,
            this.getDefault
        );
    };

    Map.prototype.log = function (charmap, logNode, callback, thisp) {
        logNode = logNode || this.logNode;
        this.store.log(charmap, function (node, log, logBefore) {
            logNode(node.value.value, log, logBefore);
        }, callback, thisp);
    };

    Map.prototype.logNode = function (node, log) {
        log(' key: ' + node.key);
        log(' value: ' + node.value);
    };

    if(!GlobalMap) {
        module.exports = CollectionsMap;
    }
    else {
        module.exports = GlobalMap;
        GlobalMap.CollectionsMap = CollectionsMap;
    }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_set":25,"./generic-collection":27,"./generic-map":28,"./shim":38}],25:[function(require,module,exports){
(function (global){
"use strict";

var Shim = require("./shim");
var GenericCollection = require("./generic-collection");
var GenericSet = require("./generic-set");
var Set, GlobalSet, CollectionsSet;


if((global.Set !== void 0) && (typeof global.Set.prototype.values === "function")) {

    GlobalSet = module.exports = global.Set;
    GlobalSet.Set = GlobalSet; // hack so require("set").Set will work in MontageJS

    GlobalSet.prototype.reduce = function (callback, basis /*, thisp*/) {
        var thisp = arguments[2];
        this.forEach(function(value) {
            basis = callback.call(thisp, basis, value, this);
        });
        return basis;
    };

    GlobalSet.prototype.reduceRight = function (callback, basis /*, thisp*/) {
        var thisp = arguments[2];
        var setIterator = this.values();
        var size = this.size;
        var reverseOrder = new Array(this.size);
        var value, i = size;
        // Fill 'reverseOrder' with values of Set in inverted order.
        while ((value = setIterator.next().value)) {
            reverseOrder[--i] = value;
        }
        // Iterate over reversed values and callback.
        while (i < size) {
            basis = callback.call(thisp, basis, reverseOrder[i++], this);
        }
        return basis;
    };

    GlobalSet.prototype.equals = function (that, equals) {
        var self = this;
        return (
            that && typeof that.reduce === "function" &&
            this.size === (that.size || that.length) &&
            that.reduce(function (equal, value) {
                return equal && self.has(value, equals);
            }, true)
        );
    };

    GlobalSet.prototype.constructClone = function (values) {
        return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);
    };

    GlobalSet.prototype.toJSON = function () {
        return this.entriesArray();
    };

    GlobalSet.prototype.one = function () {
        if (this.size > 0) {
            return this.values().next().value;
        }
        return undefined;
    };

    GlobalSet.prototype.pop = function () {
        if (this.size) {
            var setIterator = this.values(), aValue, value;
            while(aValue = setIterator.next().value) {
                value = aValue;
            }
            this["delete"](value,this.size-1);
            return value;
        }
    };

    GlobalSet.prototype.shift = function () {
        if (this.size) {
            var firstValue = this.values().next().value;
            this["delete"](firstValue,0);
            return firstValue;
        }
    };

    //Backward compatibility:
    Object.defineProperty(GlobalSet.prototype,"length",{
        get: function() {
            return this.size;
        },
        enumerable: true,
        configurable:true
    });

    GlobalSet.from = function (value) {
        var result = (new this);
        result.addEach(value);
        return result;
    };

    Object.addEach(GlobalSet.prototype, GenericCollection.prototype, false);
    Object.addEach(GlobalSet.prototype, GenericSet.prototype, false);

}



    var List = require("./_list");
    var FastSet = require("./_fast-set");
    var Iterator = require("./iterator");

    CollectionsSet = function CollectionsSet(values, equals, hash, getDefault) {
        return CollectionsSet._init(CollectionsSet, this, values, equals, hash, getDefault);
    }

    CollectionsSet._init = function (constructor, object, values, equals, hash, getDefault) {
        if (!(object instanceof constructor)) {
            return new constructor(values, equals, hash, getDefault);
        }
        equals = equals || Object.equals;
        hash = hash || Object.hash;
        getDefault = getDefault || Function.noop;
        object.contentEquals = equals;
        object.contentHash = hash;
        object.getDefault = getDefault;
        // a list of values in insertion order, used for all operations that depend
        // on iterating in insertion order
        object.order = new object.Order(undefined, equals);
        // a set of nodes from the order list, indexed by the corresponding value,
        // used for all operations that need to quickly seek  value in the list
        object.store = new object.Store(
            undefined,
            function (a, b) {
                return equals(a.value, b.value);
            },
            function (node) {
                return hash(node.value);
            }
        );
        object.length = 0;
        object.addEach(values);

    }

    CollectionsSet.Set = CollectionsSet; // hack so require("set").Set will work in MontageJS
    CollectionsSet.CollectionsSet = CollectionsSet;

    Object.addEach(CollectionsSet.prototype, GenericCollection.prototype);
    Object.addEach(CollectionsSet.prototype, GenericSet.prototype);

    CollectionsSet.from = GenericCollection.from;

    Object.defineProperty(CollectionsSet.prototype,"size",GenericCollection._sizePropertyDescriptor);

    //Overrides for consistency:
    // Set.prototype.forEach = GenericCollection.prototype.forEach;


    CollectionsSet.prototype.Order = List;
    CollectionsSet.prototype.Store = FastSet;

    CollectionsSet.prototype.constructClone = function (values) {
        return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);
    };

    CollectionsSet.prototype.has = function (value) {
        var node = new this.order.Node(value);
        return this.store.has(node);
    };

    CollectionsSet.prototype.get = function (value, equals) {
        if (equals) {
            throw new Error("Set#get does not support second argument: equals");
        }
        var node = new this.order.Node(value);
        node = this.store.get(node);
        if (node) {
            return node.value;
        } else {
            return this.getDefault(value);
        }
    };

    CollectionsSet.prototype.add = function (value) {
        var node = new this.order.Node(value);
        if (!this.store.has(node)) {
            var index = this.length;
            this.order.add(value);
            node = this.order.head.prev;
            this.store.add(node);
            this.length++;
            return true;
        }
        return false;
    };

    CollectionsSet.prototype["delete"] = function (value, equals) {
        if (equals) {
            throw new Error("Set#delete does not support second argument: equals");
        }
        var node = new this.order.Node(value);
        if (this.store.has(node)) {
            node = this.store.get(node);
            this.store["delete"](node); // removes from the set
            this.order.splice(node, 1); // removes the node from the list
            this.length--;
            return true;
        }
        return false;
    };

    CollectionsSet.prototype.pop = function () {
        if (this.length) {
            var result = this.order.head.prev.value;
            this["delete"](result);
            return result;
        }
    };

    CollectionsSet.prototype.shift = function () {
        if (this.length) {
            var result = this.order.head.next.value;
            this["delete"](result);
            return result;
        }
    };

    CollectionsSet.prototype.one = function () {
        if (this.length > 0) {
            return this.store.one().value;
        }
    };

    CollectionsSet.prototype.clear = function () {
        this.store.clear();
        this.order.clear();
        this.length = 0;
    };
    Object.defineProperty(CollectionsSet.prototype,"_clear", {
        value: CollectionsSet.prototype.clear
    });

    CollectionsSet.prototype.reduce = function (callback, basis /*, thisp*/) {
        var thisp = arguments[2];
        var list = this.order;
        var index = 0;
        return list.reduce(function (basis, value) {
            return callback.call(thisp, basis, value, index++, this);
        }, basis, this);
    };

    CollectionsSet.prototype.reduceRight = function (callback, basis /*, thisp*/) {
        var thisp = arguments[2];
        var list = this.order;
        var index = this.length - 1;
        return list.reduceRight(function (basis, value) {
            return callback.call(thisp, basis, value, index--, this);
        }, basis, this);
    };

    CollectionsSet.prototype.iterate = function () {
        return this.order.iterate();
    };

    CollectionsSet.prototype.values = function () {
        return new Iterator(this.valuesArray(), true);
    };

    CollectionsSet.prototype.log = function () {
        var set = this.store;
        return set.log.apply(set, arguments);
    };



if(!GlobalSet) {
    module.exports = CollectionsSet;
}
else {
    GlobalSet.prototype.valuesArray = GenericSet.prototype.valuesArray;
    GlobalSet.prototype.entriesArray = GenericSet.prototype.entriesArray;
    module.exports = GlobalSet;
    GlobalSet.CollectionsSet = CollectionsSet;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_fast-set":22,"./_list":23,"./generic-collection":27,"./generic-set":30,"./iterator":31,"./shim":38}],26:[function(require,module,exports){
"use strict";

require("./shim-object");
var GenericCollection = require("./generic-collection");
var GenericOrder = require("./generic-order");
var RangeChanges = require("./listen/range-changes");

// by Petka Antonov
// https://github.com/petkaantonov/deque/blob/master/js/deque.js
// Deque specifically uses
// http://en.wikipedia.org/wiki/Circular_buffer#Use_a_Fill_Count
// 1. Incrementally maintained length
// 2. Modulus avoided by using only powers of two for the capacity

module.exports = Deque;
function Deque(values, capacity) {
    if (!(this instanceof Deque)) {
        return new Deque(values, capacity);
    }
    this.capacity = this.snap(capacity);
    this.init();
    this.length = 0;
    this.front = 0;
    this.addEach(values);
}

Object.addEach(Deque.prototype, GenericCollection.prototype);
Object.addEach(Deque.prototype, GenericOrder.prototype);
Object.addEach(Deque.prototype, RangeChanges.prototype);

Deque.from = GenericCollection.from;

Deque.prototype.maxCapacity = (1 << 30) | 0;
Deque.prototype.minCapacity = 16;

Deque.prototype.constructClone = function (values) {
    return new this.constructor(values, this.capacity)
};

Deque.prototype.add = function (value) {
    this.push(value);
};

Deque.prototype.push = function (value /* or ...values */) {
    var argsLength = arguments.length;
    var length = this.length;

    if (this.dispatchesRangeChanges) {
        var plus = new Array(argsLength);
        for (var argIndex = 0; argIndex < argsLength; ++argIndex) {
            plus[argIndex] = arguments[argIndex];
        }
        var minus = [];
        this.dispatchBeforeRangeChange(plus, minus, length);
    }

    if (argsLength > 1) {
        var capacity = this.capacity;
        if (length + argsLength > capacity) {
            for (var argIndex = 0; argIndex < argsLength; ++argIndex) {
                this.ensureCapacity(length + 1);
                var j = (this.front + length) & (this.capacity - 1);
                this[j] = arguments[argIndex];
                length++;
                this.length = length;
            }
        }
        else {
            var j = this.front;
            for (var argIndex = 0; argIndex < argsLength; ++argIndex) {
                this[(j + length) & (capacity - 1)] = arguments[argIndex];
                j++;
            }
            this.length = length + argsLength;
        }

    } else if (argsLength === 1) {
        this.ensureCapacity(length + 1);
        var index = (this.front + length) & (this.capacity - 1);
        this[index] = value;
        this.length = length + 1;
    }

    if (this.dispatchesRangeChanges) {
        this.dispatchRangeChange(plus, minus, length);
    }

    return this.length;
};

Deque.prototype.pop = function () {
    var length = this.length;
    if (length === 0) {
        return;
    }
    var index = (this.front + length - 1) & (this.capacity - 1);
    var result = this[index];

    if (this.dispatchesRangeChanges) {
        this.dispatchBeforeRangeChange([], [result], length - 1);
    }

    this[index] = void 0;
    this.length = length - 1;

    if (this.dispatchesRangeChanges) {
        this.dispatchRangeChange([], [result], length - 1);
    }

    return result;
};

Deque.prototype.shift = function () {
    if (this.length !== 0) {
        var front = this.front;
        var result = this[front];

        if (this.dispatchesRangeChanges) {
            this.dispatchBeforeRangeChange([], [result], 0);
        }

        this[front] = void 0;
        this.front = (front + 1) & (this.capacity - 1);
        this.length--;

        if (this.dispatchesRangeChanges) {
            this.dispatchRangeChange([], [result], 0);
        }

        return result;
    }
};

Deque.prototype.unshift = function (value /* or ...values */) {
    var length = this.length;
    var argsLength = arguments.length;

    if (this.dispatchesRangeChanges) {
        var plus = new Array(argsLength);
        for (var argIndex = 0; argIndex < argsLength; ++argIndex) {
            plus[argIndex] = arguments[argIndex];
        }
        var minus = [];
        this.dispatchBeforeRangeChange(plus, minus, 0);
    }

    if (argsLength > 1) {
        var capacity = this.capacity;
        if (length + argsLength > capacity) {
            for (var argIndex = argsLength - 1; argIndex >= 0; argIndex--) {
                this.ensureCapacity(length + 1);
                var capacity = this.capacity;
                var index = (
                    (
                        (
                            ( this.front - 1 ) &
                            ( capacity - 1)
                        ) ^ capacity
                    ) - capacity
                );
                this[index] = arguments[argIndex];
                length++;
                this.front = index;
                this.length = length;
            }
        } else {
            var front = this.front;
            for (var argIndex = argsLength - 1; argIndex >= 0; argIndex--) {
                var index = (
                    (
                        (
                            (front - 1) &
                            (capacity - 1)
                        ) ^ capacity
                    ) - capacity
                );
                this[index] = arguments[argIndex];
                front = index;
            }
            this.front = front;
            this.length = length + argsLength;
        }
    } else if (argsLength === 1) {
        this.ensureCapacity(length + 1);
        var capacity = this.capacity;
        var index = (
            (
                (
                    (this.front - 1) &
                    (capacity - 1)
                ) ^ capacity
            ) - capacity
        );
        this[index] = value;
        this.length = length + 1;
        this.front = index;
    }

    if (this.dispatchesRangeChanges) {
        this.dispatchRangeChange(plus, minus, 0);
    }

    return this.length;
};

Deque.prototype.clear = function () {
    this.length = 0;
    this.front = 0;
    this.init();
};

Deque.prototype.ensureCapacity = function (capacity) {
    if (this.capacity < capacity) {
        this.grow(this.snap(this.capacity * 1.5 + 16));
    }
};

Deque.prototype.grow = function (capacity) {
    var oldFront = this.front;
    var oldCapacity = this.capacity;
    var oldContent = new Array(oldCapacity);
    var length = this.length;

    copy(this, 0, oldContent, 0, oldCapacity);
    this.capacity = capacity;
    this.init();
    this.front = 0;
    if (oldFront + length <= oldCapacity) {
        // Can perform direct linear copy.
        copy(oldContent, oldFront, this, 0, length);
    } else {
        // Cannot perform copy directly, perform as much as possible at the
        // end, and then copy the rest to the beginning of the buffer.
        var lengthBeforeWrapping = length - ((oldFront + length) & (oldCapacity - 1));
        copy(oldContent, oldFront, this, 0, lengthBeforeWrapping);
        copy(oldContent, 0, this, lengthBeforeWrapping, length - lengthBeforeWrapping);
    }
};

Deque.prototype.init = function () {
    for (var index = 0; index < this.capacity; ++index) {
        this[index] = "nil"; // TODO void 0
    }
};

Deque.prototype.snap = function (capacity) {
    if (typeof capacity !== "number") {
        return this.minCapacity;
    }
    return pow2AtLeast(
        Math.min(this.maxCapacity, Math.max(this.minCapacity, capacity))
    );
};

Deque.prototype.one = function () {
    if (this.length > 0) {
        return this[this.front];
    }
};

Deque.prototype.peek = function () {
    if (this.length === 0) {
        return;
    }
    return this[this.front];
};

Deque.prototype.poke = function (value) {
    if (this.length === 0) {
        return;
    }
    this[this.front] = value;
};

Deque.prototype.peekBack = function () {
    var length = this.length;
    if (length === 0) {
        return;
    }
    var index = (this.front + length - 1) & (this.capacity - 1);
    return this[index];
};

Deque.prototype.pokeBack = function (value) {
    var length = this.length;
    if (length === 0) {
        return;
    }
    var index = (this.front + length - 1) & (this.capacity - 1);
    this[index] = value;
};

Deque.prototype.get = function (index) {
    // Domain only includes integers
    if (index !== (index | 0)) {
        return;
    }
    // Support negative indicies
    if (index < 0) {
        index = index + this.length;
    }
    // Out of bounds
    if (index < 0 || index >= this.length) {
        return;
    }
    return this[(this.front + index) & (this.capacity - 1)];
};

Deque.prototype.indexOf = function (value, index) {
    // Default start index at beginning
    if (index == null) {
        index = 0;
    }
    // Support negative indicies
    if (index < 0) {
        index = index + this.length;
    }
    // Left to right walk
    var mask = this.capacity - 1;
    for (; index < this.length; index++) {
        var offset = (this.front + index) & mask;
        if (this[offset] === value) {
            return index;
        }
    }
    return -1;
};

Deque.prototype.lastIndexOf = function (value, index) {
    // Default start position at the end
    if (index == null) {
        index = this.length - 1;
    }
    // Support negative indicies
    if (index < 0) {
        index = index + this.length;
    }
    // Right to left walk
    var mask = this.capacity - 1;
    for (; index >= 0; index--) {
        var offset = (this.front + index) & mask;
        if (this[offset] === value) {
            return index;
        }
    }
    return -1;
}

var deprecatedWarnNonce = {};
function deprecatedWarn(msg, notOnce) {
    if (
        typeof console !== 'undefined' &&
            typeof console.warn === 'function' &&
                (notOnce !== true && deprecatedWarnNonce.hasOwnProperty(msg) === false)
    ) {
        console.warn(msg);
        deprecatedWarnNonce[msg]++;
    }
}

// TODO remove in v6 (not present in v2)
Deque.prototype.find = function () {
    deprecatedWarn('Deque#find function is deprecated please use Deque#findValue instead.');
    return this.findValue.apply(this, arguments);
};

Deque.prototype.findValue = function (value, equals, index) {
    equals = equals || Object.equals;
    // Default start index at beginning
    if (index == null) {
        index = 0;
    }
    // Support negative indicies
    if (index < 0) {
        index = index + this.length;
    }
    // Left to right walk
    var mask = this.capacity - 1;
    for (; index < this.length; index++) {
        var offset = (this.front + index) & mask;
        if (equals(value, this[offset])) {
            return index;
        }
    }
    return -1;
};

// TODO remove in v6 (not present in v2)
Deque.prototype.findLast = function () {
    deprecatedWarn('Deque#findLast function is deprecated please use Deque#findLastValue instead.');
    return this.findLastValue.apply(this, arguments);
};

Deque.prototype.findLastValue = function (value, equals, index) {
    equals = equals || Object.equals;
    // Default start position at the end
    if (index == null) {
        index = this.length - 1;
    }
    // Support negative indicies
    if (index < 0) {
        index = index + this.length;
    }
    // Right to left walk
    var mask = this.capacity - 1;
    for (; index >= 0; index--) {
        var offset = (this.front + index) & mask;
        if (equals(value, this[offset])) {
            return index;
        }
    }
    return -1;
};

Deque.prototype.has = function (value, equals) {
    equals = equals || Object.equals;
    // Left to right walk
    var mask = this.capacity - 1;
    for (var index = 0; index < this.length; index++) {
        var offset = (this.front + index) & mask;
        if (this[offset] === value) {
            return true;
        }
    }
    return false;
};

Deque.prototype.reduce = function (callback, basis /*, thisp*/) {
    // TODO account for missing basis argument
    var thisp = arguments[2];
    var mask = this.capacity - 1;
    for (var index = 0; index < this.length; index++) {
        var offset = (this.front + index) & mask;
        basis = callback.call(thisp, basis, this[offset], index, this);
    }
    return basis;
};

Deque.prototype.reduceRight = function (callback, basis /*, thisp*/) {
    // TODO account for missing basis argument
    var thisp = arguments[2];
    var mask = this.capacity - 1;
    for (var index = this.length - 1; index >= 0; index--) {
        var offset = (this.front + index) & mask;
        basis = callback.call(thisp, basis, this[offset], index, this);
    }
    return basis;
};

function copy(source, sourceIndex, target, targetIndex, length) {
    for (var index = 0; index < length; ++index) {
        target[index + targetIndex] = source[index + sourceIndex];
    }
}

function pow2AtLeast(n) {
    n = n >>> 0;
    n = n - 1;
    n = n | (n >> 1);
    n = n | (n >> 2);
    n = n | (n >> 4);
    n = n | (n >> 8);
    n = n | (n >> 16);
    return n + 1;
}

},{"./generic-collection":27,"./generic-order":29,"./listen/range-changes":33,"./shim-object":36}],27:[function(require,module,exports){
(function (global){
"use strict";

module.exports = GenericCollection;
function GenericCollection() {
    throw new Error("Can't construct. GenericCollection is a mixin.");
}

var DOMTokenList = global.DOMTokenList || function(){};

GenericCollection.EmptyArray = Object.freeze([]);

GenericCollection.prototype.addEach = function (values, mapFn, thisp) {
    //We want to eliminate everything but array like: Strings, Arrays, DOMTokenList
    if(values && (values instanceof Array || (values instanceof DOMTokenList) || values instanceof String)) {
        if(mapFn) {
            for (var i = 0; i < values.length; i++) {
                this.add(mapFn.call(thisp,values[i]), i);
            }
        } else {
            for (var i = 0; i < values.length; i++) {
                this.add(values[i], i);
            }
        }
    }
    else if (values && Object(values) === values) {
        if (typeof values.forEach === "function") {
            if(mapFn) {
                values.map(mapFn, thisp).forEach(this.add, this);
            } else {
                values.forEach(this.add, this);
            }
        } else if(typeof values.next === "function") {
            var value, i=0;
            if(mapFn) {
                while ((value = values.next().value)) {
                    this.add(mapFn.call(thisp,value), i++);
                }
            }
            else {
                while ((value = values.next().value)) {
                    this.add(value, i++);
                }
            }
        } else if (typeof values.length === "number") {
            // Array-like objects that do not implement forEach, ergo,
            // Arguments
            if(mapFn) {
                for (var i = 0; i < values.length; i++) {
                    this.add(mapFn.call(thisp,values[i]), i);
                }
            }
            else {
                for (var i = 0; i < values.length; i++) {
                    this.add(values[i], i);
                }
            }
        } else {
            if(mapFn) {
                Object.keys(values).forEach(function (key) {
                    this.add(mapFn.call(thisp,values[key]), key);
                }, this);
            } else {
                Object.keys(values).forEach(function (key) {
                    this.add(values[key], key);
                }, this);
            }
        }
    }
    return this;
};

// This is sufficiently generic for Map (since the value may be a key)
// and ordered collections (since it forwards the equals argument)
GenericCollection.prototype.deleteEach = function (values, equals) {
    values.forEach(function (value) {
        this["delete"](value, equals);
    }, this);
    return this;
};

// all of the following functions are implemented in terms of "reduce".
// some need "constructClone".

GenericCollection.prototype.forEach = function (callback /*, thisp*/) {
    var thisp = arguments[1];
    return this.reduce(function (undefined, value, key, object, depth) {
        callback.call(thisp, value, key, object, depth);
    }, undefined);
};

GenericCollection.prototype.map = function (callback /*, thisp*/) {
    var thisp = arguments[1];
    var result = [];
    this.reduce(function (undefined, value, key, object, depth) {
        result.push(callback.call(thisp, value, key, object, depth));
    }, undefined);
    return result;
};

GenericCollection.prototype.enumerate = function (start) {
    if (start == null) {
        start = 0;
    }
    var result = [];
    this.reduce(function (undefined, value) {
        result.push([start++, value]);
    }, undefined);
    return result;
};

GenericCollection.prototype.group = function (callback, thisp, equals) {
    equals = equals || Object.equals;
    var groups = [];
    var keys = [];
    this.forEach(function (value, key, object) {
        var key = callback.call(thisp, value, key, object);
        var index = keys.indexOf(key, equals);
        var group;
        if (index === -1) {
            group = [];
            groups.push([key, group]);
            keys.push(key);
        } else {
            group = groups[index][1];
        }
        group.push(value);
    });
    return groups;
};

GenericCollection.prototype.toArray = function () {
    return this.map(Function.identity);
};

// this depends on stringable keys, which apply to Array and Iterator
// because they have numeric keys and all Maps since they may use
// strings as keys.  List, Set, and SortedSet have nodes for keys, so
// toObject would not be meaningful.
GenericCollection.prototype.toObject = function () {
    var object = {};
    this.reduce(function (undefined, value, key) {
        object[key] = value;
    }, undefined);
    return object;
};

GenericCollection.from = function () {
    return this.apply(this,arguments);
};

GenericCollection.prototype.filter = function (callback /*, thisp*/) {
    var thisp = arguments[1];
    var result = this.constructClone();
    this.reduce(function (undefined, value, key, object, depth) {
        if (callback.call(thisp, value, key, object, depth)) {
            result.add(value, key);
        }
    }, undefined);
    return result;
};

GenericCollection.prototype.every = function (callback /*, thisp*/) {
    var thisp = arguments[1];
    return this.reduce(function (result, value, key, object, depth) {
        return result && callback.call(thisp, value, key, object, depth);
    }, true);
};

GenericCollection.prototype.some = function (callback /*, thisp*/) {
    var thisp = arguments[1];
    return this.reduce(function (result, value, key, object, depth) {
        return result || callback.call(thisp, value, key, object, depth);
    }, false);
};

GenericCollection.prototype.all = function () {
    return this.every(Boolean);
};

GenericCollection.prototype.any = function () {
    return this.some(Boolean);
};

GenericCollection.prototype.min = function (compare) {
    compare = compare || this.contentCompare || Object.compare;
    var first = true;
    return this.reduce(function (result, value) {
        if (first) {
            first = false;
            return value;
        } else {
            return compare(value, result) < 0 ? value : result;
        }
    }, undefined);
};

GenericCollection.prototype.max = function (compare) {
    compare = compare || this.contentCompare || Object.compare;
    var first = true;
    return this.reduce(function (result, value) {
        if (first) {
            first = false;
            return value;
        } else {
            return compare(value, result) > 0 ? value : result;
        }
    }, undefined);
};

GenericCollection.prototype.sum = function (zero) {
    zero = zero === undefined ? 0 : zero;
    return this.reduce(function (a, b) {
        return a + b;
    }, zero);
};

GenericCollection.prototype.average = function (zero) {
    var sum = zero === undefined ? 0 : zero;
    var count = zero === undefined ? 0 : zero;
    this.reduce(function (undefined, value) {
        sum += value;
        count += 1;
    }, undefined);
    return sum / count;
};

GenericCollection.prototype.concat = function () {
    var result = this.constructClone(this);
    for (var i = 0; i < arguments.length; i++) {
        result.addEach(arguments[i]);
    }
    return result;
};

GenericCollection.prototype.flatten = function () {
    var self = this;
    return this.reduce(function (result, array) {
        array.forEach(function (value) {
            this.push(value);
        }, result, self);
        return result;
    }, []);
};

GenericCollection.prototype.zip = function () {
    var table = Array.prototype.slice.call(arguments);
    table.unshift(this);
    return Array.unzip(table);
}

GenericCollection.prototype.join = function (delimiter) {
    return this.reduce(function (result, string) {
        // work-around for reduce that does not support no-basis form
        if (result === void 0) {
            return string;
        } else {
            return result + delimiter + string;
        }
    }, void 0);
};

GenericCollection.prototype.sorted = function (compare, by, order) {
    compare = compare || this.contentCompare || Object.compare;
    // account for comparators generated by Function.by
    if (compare.by) {
        by = compare.by;
        compare = compare.compare || this.contentCompare || Object.compare;
    } else {
        by = by || Function.identity;
    }
    if (order === undefined)
        order = 1;
    return this.map(function (item) {
        return {
            by: by(item),
            value: item
        };
    })
    .sort(function (a, b) {
        return compare(a.by, b.by) * order;
    })
    .map(function (pair) {
        return pair.value;
    });
};

GenericCollection.prototype.reversed = function () {
    return this.constructClone(this).reverse();
};

GenericCollection.prototype.clone = function (depth, memo) {
    if (depth === undefined) {
        depth = Infinity;
    } else if (depth === 0) {
        return this;
    }
    var clone = this.constructClone();
    this.forEach(function (value, key) {
        clone.add(Object.clone(value, depth - 1, memo), key);
    }, this);
    return clone;
};

GenericCollection.prototype.only = function () {
    if (this.length === 1) {
        return this.one();
    }
};

GenericCollection.prototype.iterator = function () {
    return this.iterate.apply(this, arguments);
};

GenericCollection._sizePropertyDescriptor = {
    get: function() {
        return this.length;
    },
    enumerable: false,
    configurable: true
};

Object.defineProperty(GenericCollection.prototype,"size",GenericCollection._sizePropertyDescriptor);

require("./shim-array");

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./shim-array":34}],28:[function(require,module,exports){
"use strict";

var Object = require("./shim-object");
var Iterator = require("./iterator");

module.exports = GenericMap;
function GenericMap() {
    throw new Error("Can't construct. GenericMap is a mixin.");
}

// all of these methods depend on the constructor providing a `store` set

GenericMap.prototype.isMap = true;

GenericMap.prototype.addEach = function (values) {
    var i;
    if (values && Object(values) === values) {
        if (typeof values.forEach === "function") {
            // copy map-alikes
            if (values.isMap === true) {
                values.forEach(function (value, key) {
                    this.set(key, value);
                }, this);
            // iterate key value pairs of other iterables
            } else {
                values.forEach(function (pair) {
                    this.set(pair[0], pair[1]);
                }, this);
            }
        } else if (typeof values.length === "number") {
            // Array-like objects that do not implement forEach, ergo,
            // Arguments
            for (i = 0; i < values.length; i++) {
                this.add(values[i], i);
            }
        } else {
            // copy other objects as map-alikes
            Object.keys(values).forEach(function (key) {
                this.set(key, values[key]);
            }, this);
        }
    } else if (values && typeof values.length === "number") {
        // String
        for (i = 0; i < values.length; i++) {
            this.add(values[i], i);
        }
    }
    return this;
};

GenericMap.prototype.get = function (key, defaultValue) {
    var item = this.store.get(new this.Item(key));
    if (item) {
        return item.value;
    } else if (arguments.length > 1) {
        console.log("Use of a second argument as default value is deprecated to match standards");
        return defaultValue;
    } else {
        return this.getDefault(key);
    }
};

GenericMap.prototype.set = function (key, value) {
    var item = new this.Item(key, value);
    var found = this.store.get(item);
    var grew = false;
    if (found) { // update
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange(key, found.value);
        }
        found.value = value;
        if (this.dispatchesMapChanges) {
            this.dispatchMapChange(key, value);
        }
    } else { // create
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange(key, undefined);
        }
        if (this.store.add(item)) {
            this.length++;
            grew = true;
        }
        if (this.dispatchesMapChanges) {
            this.dispatchMapChange(key, value);
        }
    }
    return this;
};

GenericMap.prototype.add = function (value, key) {
    return this.set(key, value);
};

GenericMap.prototype.has = function (key) {
    return this.store.has(new this.Item(key));
};

GenericMap.prototype['delete'] = function (key) {
    var item = new this.Item(key);
    if (this.store.has(item)) {
        var from = this.store.get(item).value;
        if (this.dispatchesMapChanges) {
            this.dispatchBeforeMapChange(key, from);
        }
        this.store["delete"](item);
        this.length--;
        if (this.dispatchesMapChanges) {
            this.dispatchMapChange(key, undefined);
        }
        return true;
    }
    return false;
};

GenericMap.prototype.clear = function () {
    var keys, key;
    if (this.dispatchesMapChanges) {
        this.forEach(function (value, key) {
            this.dispatchBeforeMapChange(key, value);
        }, this);
        keys = this.keysArray();
    }
    this.store.clear();
    this.length = 0;
    if (this.dispatchesMapChanges) {
        for(var i=0;(key = keys[i]);i++) {
            this.dispatchMapChange(key);
        }
        // keys.forEach(function (key) {
        //     this.dispatchMapChange(key);
        // }, this);
    }
};

GenericMap.prototype.reduce = function (callback, basis, thisp) {
    return this.store.reduce(function (basis, item) {
        return callback.call(thisp, basis, item.value, item.key, this);
    }, basis, this);
};

GenericMap.prototype.reduceRight = function (callback, basis, thisp) {
    return this.store.reduceRight(function (basis, item) {
        return callback.call(thisp, basis, item.value, item.key, this);
    }, basis, this);
};

GenericMap.prototype.keysArray = function () {
    return this.map(function (value, key) {
        return key;
    });
};
GenericMap.prototype.keys = function () {
    return new Iterator(this.keysArray(), true);
};

GenericMap.prototype.valuesArray = function () {
    return this.map(Function.identity);
};
GenericMap.prototype.values = function () {
    return new Iterator(this.valuesArray(), true);
};

GenericMap.prototype.entriesArray = function () {
    return this.map(function (value, key) {
        return [key, value];
    });
};
GenericMap.prototype.entries = function () {
    return new Iterator(this.entriesArray(), true);
};

// XXX deprecated
GenericMap.prototype.items = function () {
    return this.entriesArray();
};

GenericMap.prototype.equals = function (that, equals) {
    equals = equals || Object.equals;
    if (this === that) {
        return true;
    } else if (that && typeof that.every === "function") {
        return that.length === this.length && that.every(function (value, key) {
            return equals(this.get(key), value);
        }, this);
    } else {
        var keys = Object.keys(that);
        return keys.length === this.length && Object.keys(that).every(function (key) {
            return equals(this.get(key), that[key]);
        }, this);
    }
};

GenericMap.prototype.toJSON = function () {
    return this.entriesArray();
};


GenericMap.prototype.Item = Item;

function Item(key, value) {
    this.key = key;
    this.value = value;
}

Item.prototype.equals = function (that) {
    return Object.equals(this.key, that.key) && Object.equals(this.value, that.value);
};

Item.prototype.compare = function (that) {
    return Object.compare(this.key, that.key);
};

},{"./iterator":31,"./shim-object":36}],29:[function(require,module,exports){

var Object = require("./shim-object");

module.exports = GenericOrder;
function GenericOrder() {
    throw new Error("Can't construct. GenericOrder is a mixin.");
}

GenericOrder.prototype.equals = function (that, equals) {
    equals = equals || this.contentEquals || Object.equals;

    if (this === that) {
        return true;
    }
    if (!that) {
        return false;
    }

    var self = this;
    return (
        this.length === that.length &&
        this.zip(that).every(function (pair) {
            return equals(pair[0], pair[1]);
        })
    );
};

GenericOrder.prototype.compare = function (that, compare) {
    compare = compare || this.contentCompare || Object.compare;

    if (this === that) {
        return 0;
    }
    if (!that) {
        return 1;
    }

    var length = Math.min(this.length, that.length);
    var comparison = this.zip(that).reduce(function (comparison, pair, index) {
        if (comparison === 0) {
            if (index >= length) {
                return comparison;
            } else {
                return compare(pair[0], pair[1]);
            }
        } else {
            return comparison;
        }
    }, 0);
    if (comparison === 0) {
        return this.length - that.length;
    }
    return comparison;
};

GenericOrder.prototype.toJSON = function () {
    return this.toArray();
};

},{"./shim-object":36}],30:[function(require,module,exports){

module.exports = GenericSet;
function GenericSet() {
    throw new Error("Can't construct. GenericSet is a mixin.");
}

GenericSet.prototype.isSet = true;

GenericSet.prototype.union = function (that) {
    var union =  this.constructClone(this);
    union.addEach(that);
    return union;
};

GenericSet.prototype.intersection = function (that) {
    return this.constructClone(this.filter(function (value) {
        return that.has(value);
    }));
};

GenericSet.prototype.difference = function (that) {
    var union =  this.constructClone(this);
    union.deleteEach(that);
    return union;
};

GenericSet.prototype.symmetricDifference = function (that) {
    var union = this.union(that);
    var intersection = this.intersection(that);
    return union.difference(intersection);
};

GenericSet.prototype.deleteAll = function (value) {
    // deleteAll is equivalent to delete for sets since they guarantee that
    // only one value exists for an equivalence class, but deleteAll returns
    // the count of deleted values instead of whether a value was deleted.
    return +this["delete"](value);
};

GenericSet.prototype.equals = function (that, equals) {
    var self = this;
    return (
        that && typeof that.reduce === "function" &&
        this.length === that.length &&
        that.reduce(function (equal, value) {
            return equal && self.has(value, equals);
        }, true)
    );
};

GenericSet.prototype.forEach = function (callback /*, thisp*/) {
    var thisp = arguments[1];
    return this.reduce(function (undefined, value, key, object, depth) {
        //ECMASCRIPT Sets send value twice in callback to forEach
        callback.call(thisp, value, value, object, depth);
    }, undefined);
};


GenericSet.prototype.toJSON = function () {
    return this.toArray();
};

// W3C DOMTokenList API overlap (does not handle variadic arguments)

GenericSet.prototype.contains = function (value) {
    return this.has(value);
};

GenericSet.prototype.remove = function (value) {
    return this["delete"](value);
};

GenericSet.prototype.toggle = function (value) {
    if (this.has(value)) {
        this["delete"](value);
    } else {
        this.add(value);
    }
};

var _valuesArrayFunction = function(value,key) {return value;};
GenericSet.prototype.valuesArray = function() {
    return this.map(_valuesArrayFunction);
}
var _entriesArrayFunction = function(value,key) {return [key,value];};
GenericSet.prototype.entriesArray = function() {
    return this.map(_entriesArrayFunction);
}

},{}],31:[function(require,module,exports){
"use strict";

module.exports = Iterator;

var Object = require("./shim-object");
var GenericCollection = require("./generic-collection");

// upgrades an iterable to a Iterator
function Iterator(iterable, standardMode) {

    /*
        standardMode should be passed as true by a collection that uses Iterator
        to provide a polyfill of standard iterations methods like entries() and values(),
        as Collection's iterator behaves differently than standards ones when it comes to sparse arrays.
        without passing standardMode, new Iterator instances will behave as intended independently of standards.
    */
    var values = standardMode && iterable && iterable.values && iterable.values();
    if(values && typeof values.next === "function" ) {
        return values;
    }

    if (!(this instanceof Iterator)) {
        return new Iterator(iterable);
    }

    if (Array.isArray(iterable) || typeof iterable === "string")
        return Iterator.iterate(iterable);

    iterable = Object(iterable);

    if (iterable instanceof Iterator) {
        return iterable;
    } else if (iterable.next) {
        this.next = function () {
            return iterable.next();
        };
    } else if (iterable.iterate) {
        var iterator = iterable.iterate();
        this.next = function () {
            return iterator.next();
        };
    } else if (Object.prototype.toString.call(iterable) === "[object Function]") {
        this.next = iterable;
    } else {
        throw new TypeError("Can't iterate " + iterable);
    }

}

Iterator.prototype.forEach = GenericCollection.prototype.forEach;
Iterator.prototype.map = GenericCollection.prototype.map;
Iterator.prototype.filter = GenericCollection.prototype.filter;
Iterator.prototype.every = GenericCollection.prototype.every;
Iterator.prototype.some = GenericCollection.prototype.some;
Iterator.prototype.any = GenericCollection.prototype.any;
Iterator.prototype.all = GenericCollection.prototype.all;
Iterator.prototype.min = GenericCollection.prototype.min;
Iterator.prototype.max = GenericCollection.prototype.max;
Iterator.prototype.sum = GenericCollection.prototype.sum;
Iterator.prototype.average = GenericCollection.prototype.average;
Iterator.prototype.flatten = GenericCollection.prototype.flatten;
Iterator.prototype.zip = GenericCollection.prototype.zip;
Iterator.prototype.enumerate = GenericCollection.prototype.enumerate;
Iterator.prototype.sorted = GenericCollection.prototype.sorted;
Iterator.prototype.group = GenericCollection.prototype.group;
Iterator.prototype.reversed = GenericCollection.prototype.reversed;
Iterator.prototype.toArray = GenericCollection.prototype.toArray;
Iterator.prototype.toObject = GenericCollection.prototype.toObject;
Iterator.prototype.iterator = GenericCollection.prototype.iterator;

Iterator.prototype.__iterationObject = null;
Object.defineProperty(Iterator.prototype,"_iterationObject", {
    get: function() {
        return this.__iterationObject || (this.__iterationObject = { done: false, value:void 0});
    }
});


// this is a bit of a cheat so flatten and such work with the generic
// reducible
Iterator.prototype.constructClone = function (values) {
    var clone = [];
    clone.addEach(values);
    return clone;
};

Iterator.prototype.mapIterator = function (callback /*, thisp*/) {
    var self = Iterator(this),
        thisp = arguments[1],
        i = 0;

    if (Object.prototype.toString.call(callback) != "[object Function]")
        throw new TypeError();

    return new self.constructor(function () {
        if(self._iterationObject.done !== true) {
            var callbackValue = callback.call(thisp, self.next().value, i++, self);
            self._iterationObject.value = callbackValue;
        }
        return self._iterationObject;
    });
};

Iterator.prototype.filterIterator = function (callback /*, thisp*/) {
    var self = Iterator(this),
        thisp = arguments[1],
        i = 0;

    if (Object.prototype.toString.call(callback) != "[object Function]")
        throw new TypeError();

    return new self.constructor(function () {
        var nextEntry;
        while (true) {
            nextEntry = self.next();
            if(nextEntry.done !== true) {
                if (callback.call(thisp, nextEntry.value, i++, self))
                    return nextEntry;
            }
            else {
                //done true and value undefined at this point
                return nextEntry;
            }
        }
    });
};

Iterator.prototype.reduce = function (callback /*, initial, thisp*/) {
    var self = Iterator(this),
        result = arguments[1],
        thisp = arguments[2],
        i = 0,
        nextEntry;

    if (Object.prototype.toString.call(callback) != "[object Function]")
        throw new TypeError();

    // first iteration unrolled
    nextEntry = self.next();
    if(nextEntry.done === true) {
        if (arguments.length > 1) {
            return arguments[1]; // initial
        } else {
            throw TypeError("cannot reduce a value from an empty iterator with no initial value");
        }
    }
    if (arguments.length > 1) {
        result = callback.call(thisp, result, nextEntry.value, i, self);
    } else {
        result = nextEntry.value;
    }
    i++;
    // remaining entries
    while (true) {
        nextEntry = self.next();
        if(nextEntry.done === true) {
            return result;
        }
        result = callback.call(thisp, result, nextEntry.value, i, self);
        i++;
    }

};

Iterator.prototype.concat = function () {
    return Iterator.concat(
        Array.prototype.concat.apply(this, arguments)
    );
};

Iterator.prototype.dropWhile = function (callback /*, thisp */) {
    var self = Iterator(this),
        thisp = arguments[1],
        stopped = false,
        stopValue,
        nextEntry,
        i = 0;

    if (Object.prototype.toString.call(callback) != "[object Function]")
        throw new TypeError();

    while (true) {
        nextEntry = self.next();
        if(nextEntry.done === true) {
            break;
        }
        if (!callback.call(thisp, nextEntry.value, i, self)) {
            stopped = true;
            stopValue = nextEntry.value;
            break;
        }
        i++;
    }

    if (stopped) {
        return self.constructor([stopValue]).concat(self);
    } else {
        return self.constructor([]);
    }
};

Iterator.prototype.takeWhile = function (callback /*, thisp*/) {
    var self = Iterator(this),
        thisp = arguments[1],
        nextEntry,
        i = 0;

    if (Object.prototype.toString.call(callback) != "[object Function]")
        throw new TypeError();

    return new self.constructor(function () {
        if(self._iterationObject.done !== true) {
            var value = self.next().value;
            if(callback.call(thisp, value, i++, self)) {
                self._iterationObject.value = value;
            }
            else {
                self._iterationObject.done = true;
                self._iterationObject.value = void 0;
            }
        }
        return self._iterationObject;
    });

};

Iterator.prototype.zipIterator = function () {
    return Iterator.unzip(
        Array.prototype.concat.apply(this, arguments)
    );
};

Iterator.prototype.enumerateIterator = function (start) {
    return Iterator.count(start).zipIterator(this);
};

// creates an iterator for Array and String
Iterator.iterate = function (iterable) {
    var start;
    start = 0;
    return new Iterator(function () {
        // advance to next owned entry
        if (typeof iterable === "object") {
            while (!(start in iterable)) {
                // deliberately late bound
                if (start >= iterable.length) {
                    this._iterationObject.done = true;
                    this._iterationObject.value = void 0;
                    break;
                }
                else start += 1;
            }
        } else if (start >= iterable.length) {
            this._iterationObject.done = true;
            this._iterationObject.value = void 0;
        }

        if(!this._iterationObject.done) {
            this._iterationObject.value = iterable[start];
            start += 1;
        }
        return this._iterationObject;
    });
};

Iterator.cycle = function (cycle, times) {
    var next;
    if (arguments.length < 2)
        times = Infinity;
    //cycle = Iterator(cycle).toArray();
    return new Iterator(function () {
        var iteration, nextEntry;

        if(next) {
            nextEntry = next();
        }

        if(!next || nextEntry.done === true) {
            if (times > 0) {
                times--;
                iteration = Iterator.iterate(cycle);
                nextEntry = (next = iteration.next.bind(iteration))();
            }
            else {
                this._iterationObject.done = true;
                nextEntry = this._iterationObject;            }
        }
        return nextEntry;
    });
};

Iterator.concat = function (iterators) {
    iterators = Iterator(iterators);
    var next;
    return new Iterator(function (){
        var iteration, nextEntry;
        if(next) nextEntry = next();
        if(!nextEntry || nextEntry.done === true) {
            nextEntry = iterators.next();
            if(nextEntry.done === false) {
                iteration = Iterator(nextEntry.value);
                next = iteration.next.bind(iteration);
                return next();
            }
            else {
                return nextEntry;
            }
        }
        else return nextEntry;
    });
};

Iterator.unzip = function (iterators) {
    iterators = Iterator(iterators).map(Iterator);
    if (iterators.length === 0)
        return new Iterator([]);
    return new Iterator(function () {
        var stopped, nextEntry;
        var result = iterators.map(function (iterator) {
            nextEntry = iterator.next();
            if (nextEntry.done === true ) {
                stopped = true;
            }
            return nextEntry.value;
        });
        if (stopped) {
            this._iterationObject.done = true;
            this._iterationObject.value = void 0;
        }
        else {
            this._iterationObject.value = result;
        }
        return this._iterationObject;
    });
};

Iterator.zip = function () {
    return Iterator.unzip(
        Array.prototype.slice.call(arguments)
    );
};

Iterator.chain = function () {
    return Iterator.concat(
        Array.prototype.slice.call(arguments)
    );
};

Iterator.range = function (start, stop, step) {
    if (arguments.length < 3) {
        step = 1;
    }
    if (arguments.length < 2) {
        stop = start;
        start = 0;
    }
    start = start || 0;
    step = step || 1;
    return new Iterator(function () {
        if (start >= stop) {
            this._iterationObject.done = true;
            this._iterationObject.value = void 0;
        }
        var result = start;
        start += step;
        this._iterationObject.value = result;

        return this._iterationObject;
    });
};

Iterator.count = function (start, step) {
    return Iterator.range(start, Infinity, step);
};

Iterator.repeat = function (value, times) {
    return new Iterator.range(times).mapIterator(function () {
        return value;
    });
};

},{"./generic-collection":27,"./shim-object":36}],32:[function(require,module,exports){
/*
    Copyright (c) 2016, Montage Studio Inc. All Rights Reserved.
    3-Clause BSD License
    https://github.com/montagejs/montage/blob/master/LICENSE.md
*/

var Map = require("../_map");

var ObjectChangeDescriptor = module.exports.ObjectChangeDescriptor = function ObjectChangeDescriptor(name) {
    this.name = name;
    this.isActive = false;
    this._willChangeListeners = null;
    this._changeListeners = null;
	return this;
}

Object.defineProperties(ObjectChangeDescriptor.prototype,{
    name: {
		value:null,
		writable: true
	},
    isActive: {
		value:false,
		writable: true
	},
	_willChangeListeners: {
		value:null,
		writable: true
	},
	willChangeListeners: {
		get: function() {
			return this._willChangeListeners || (this._willChangeListeners = new this.willChangeListenersRecordConstructor(this.name));
		}
	},
	_changeListeners: {
		value:null,
		writable: true
	},
    changeListeners: {
		get: function() {
			return this._changeListeners || (this._changeListeners = new this.changeListenersRecordConstructor(this.name));
		}
	},
    changeListenersRecordConstructor: {
        value: ChangeListenersRecord,
        writable: true
    },
    willChangeListenersRecordConstructor: {
        value: WillChangeListenersRecord,
        writable: true
    }

});

var ListenerGhost = module.exports.ListenerGhost = Object.create(null);
var ChangeListenerSpecificHandlerMethodName = new Map();

 module.exports.ChangeListenersRecord = ChangeListenersRecord;
function ChangeListenersRecord(name) {
    var specificHandlerMethodName = ChangeListenerSpecificHandlerMethodName.get(name);
    if(!specificHandlerMethodName) {
        specificHandlerMethodName = "handle";
        specificHandlerMethodName += name;
        specificHandlerMethodName += "Change";
        ChangeListenerSpecificHandlerMethodName.set(name,specificHandlerMethodName);
    }
    this._current = null;
    this._current = null;
    this.specificHandlerMethodName = specificHandlerMethodName;
    return this;
}

Object.defineProperties(ChangeListenersRecord.prototype,{
    _current: {
		value: null,
		writable: true
	},
	current: {
		get: function() {
            // if(this._current) {
            //     console.log(this.constructor.name," with ",this._current.length," listeners: ", this._current);
            // }
            return this._current;
            //return this._current || (this._current = []);
		},
        set: function(value) {
            this._current = value;
        }
	},
    ListenerGhost: {
        value:ListenerGhost,
        writable: true
    },
    ghostCount: {
        value:0,
        writable: true
    },
    maxListenerGhostRatio: {
        value:0.3,
        writable: true
    },
    listenerGhostFilter: {
        value: function listenerGhostFilter(value) {
          return value !== this.ListenerGhost;
      }
    },
    removeCurrentGostListenersIfNeeded: {
        value: function() {
            if(this._current && this.ghostCount/this._current.length>this.maxListenerGhostRatio) {
                this.ghostCount = 0;
                this._current = this._current.filter(this.listenerGhostFilter,this);
            }
            return this._current;
        }
    },
    dispatchBeforeChange: {
        value: false,
        writable: true
    },
    genericHandlerMethodName: {
		value: "handlePropertyChange",
        writable: true
	}
});

module.exports.WillChangeListenersRecord = WillChangeListenersRecord;
var WillChangeListenerSpecificHandlerMethodName = new Map();
function WillChangeListenersRecord(name) {
    var specificHandlerMethodName = WillChangeListenerSpecificHandlerMethodName.get(name);
    if(!specificHandlerMethodName) {
        specificHandlerMethodName = "handle";
        specificHandlerMethodName += name;
        specificHandlerMethodName += "WillChange";
        WillChangeListenerSpecificHandlerMethodName.set(name,specificHandlerMethodName);
    }
    this.specificHandlerMethodName = specificHandlerMethodName;
	return this;
}
WillChangeListenersRecord.prototype = new ChangeListenersRecord();
WillChangeListenersRecord.prototype.constructor = WillChangeListenersRecord;
WillChangeListenersRecord.prototype.genericHandlerMethodName = "handlePropertyWillChange";

},{"../_map":24}],33:[function(require,module,exports){
"use strict";

//TODO:
// Remove Dict and use native Map as much as possible here
//Use ObjectChangeDescriptor to avoid creating useless arrays and benefit from similar gains made in property-changes


var WeakMap = require("../weak-map"),
    Map = require("../_map"),
    ChangeDescriptor = require("./change-descriptor"),
    ObjectChangeDescriptor = ChangeDescriptor.ObjectChangeDescriptor,
    ChangeListenersRecord = ChangeDescriptor.ChangeListenersRecord,
    ListenerGhost = ChangeDescriptor.ListenerGhost;

var rangeChangeDescriptors = new WeakMap(); // {isActive, willChangeListeners, changeListeners}


//
function RangeChangeDescriptor(name) {
    this.name = name;
    this.isActive = false;
    this._willChangeListeners = null;
    this._changeListeners = null;
};

RangeChangeDescriptor.prototype = new ObjectChangeDescriptor();
RangeChangeDescriptor.prototype.constructor = RangeChangeDescriptor;

RangeChangeDescriptor.prototype.changeListenersRecordConstructor = RangeChangeListenersRecord;
RangeChangeDescriptor.prototype.willChangeListenersRecordConstructor = RangeWillChangeListenersRecord;
Object.defineProperty(RangeChangeDescriptor.prototype,"active",{
    get: function() {
        return this._active || (this._active = this._current ? this._current.slice():[]);
    }
});


var RangeChangeListenersSpecificHandlerMethodName = new Map();

function RangeChangeListenersRecord(name) {
    var specificHandlerMethodName = RangeChangeListenersSpecificHandlerMethodName.get(name);
    if(!specificHandlerMethodName) {
        specificHandlerMethodName = "handle";
        specificHandlerMethodName += name.slice(0, 1).toUpperCase();
        specificHandlerMethodName += name.slice(1);
        specificHandlerMethodName += "RangeChange";
        RangeChangeListenersSpecificHandlerMethodName.set(name,specificHandlerMethodName);
    }
    this.specificHandlerMethodName = specificHandlerMethodName;
	return this;
}
RangeChangeListenersRecord.prototype = new ChangeListenersRecord();
RangeChangeListenersRecord.prototype.constructor = RangeChangeListenersRecord;

var RangeWillChangeListenersSpecificHandlerMethodName = new Map();

function RangeWillChangeListenersRecord(name) {
    var specificHandlerMethodName = RangeWillChangeListenersSpecificHandlerMethodName.get(name);
    if(!specificHandlerMethodName) {
        specificHandlerMethodName = "handle";
        specificHandlerMethodName += name.slice(0, 1).toUpperCase();
        specificHandlerMethodName += name.slice(1);
        specificHandlerMethodName += "RangeWillChange";
        RangeWillChangeListenersSpecificHandlerMethodName.set(name,specificHandlerMethodName);
    }
    this.specificHandlerMethodName = specificHandlerMethodName;
    return this;
}
RangeWillChangeListenersRecord.prototype = new ChangeListenersRecord();
RangeWillChangeListenersRecord.prototype.constructor = RangeWillChangeListenersRecord;

module.exports = RangeChanges;
function RangeChanges() {
    throw new Error("Can't construct. RangeChanges is a mixin.");
}

RangeChanges.prototype.getAllRangeChangeDescriptors = function () {
    if (!rangeChangeDescriptors.has(this)) {
        rangeChangeDescriptors.set(this, new Map());
    }
    return rangeChangeDescriptors.get(this);
};

RangeChanges.prototype.getRangeChangeDescriptor = function (token) {
    var tokenChangeDescriptors = this.getAllRangeChangeDescriptors();
    token = token || "";
    if (!tokenChangeDescriptors.has(token)) {
        tokenChangeDescriptors.set(token, new RangeChangeDescriptor(token));
    }
    return tokenChangeDescriptors.get(token);
};

var ObjectsDispatchesRangeChanges = new WeakMap(),
    dispatchesRangeChangesGetter = function() {
        return ObjectsDispatchesRangeChanges.get(this);
    },
    dispatchesRangeChangesSetter = function(value) {
        return ObjectsDispatchesRangeChanges.set(this,value);
    },
    dispatchesChangesMethodName = "dispatchesRangeChanges",
    dispatchesChangesPropertyDescriptor = {
        get: dispatchesRangeChangesGetter,
        set: dispatchesRangeChangesSetter,
        configurable: true,
        enumerable: false
    };

RangeChanges.prototype.addRangeChangeListener = function addRangeChangeListener(listener, token, beforeChange) {
    // a concession for objects like Array that are not inherently observable
    if (!this.isObservable && this.makeObservable) {
        this.makeObservable();
    }

    var descriptor = this.getRangeChangeDescriptor(token);

    var listeners;
    if (beforeChange) {
        listeners = descriptor.willChangeListeners;
    } else {
        listeners = descriptor.changeListeners;
    }

    // even if already registered
    if(!listeners._current) {
        listeners._current = listener;
    }
    else if(!Array.isArray(listeners._current)) {
        listeners._current = [listeners._current,listener]
    }
    else {
        listeners._current.push(listener);
    }

    if(Object.getOwnPropertyDescriptor((this.__proto__||Object.getPrototypeOf(this)),dispatchesChangesMethodName) === void 0) {
        Object.defineProperty((this.__proto__||Object.getPrototypeOf(this)), dispatchesChangesMethodName, dispatchesChangesPropertyDescriptor);
    }
    this.dispatchesRangeChanges = true;

    var self = this;
    return function cancelRangeChangeListener() {
        if (!self) {
            // TODO throw new Error("Range change listener " + JSON.stringify(token) + " has already been canceled");
            return;
        }
        self.removeRangeChangeListener(listener, token, beforeChange);
        self = null;
    };
};


RangeChanges.prototype.removeRangeChangeListener = function (listener, token, beforeChange) {
    var descriptor = this.getRangeChangeDescriptor(token);

    var listeners;
    if (beforeChange) {
        listeners = descriptor._willChangeListeners;
    } else {
        listeners = descriptor._changeListeners;
    }

    if(listeners._current) {
        if(listeners._current === listener) {
            listeners._current = null;
        }
        else {
            var index = listeners._current.lastIndexOf(listener);
            if (index === -1) {
                throw new Error("Can't remove range change listener: does not exist: token " + JSON.stringify(token));
            }
            else {
                if(descriptor.isActive) {
                    listeners.ghostCount = listeners.ghostCount+1
                    listeners._current[index]=ListenerGhost
                }
                else {
                    listeners._current.spliceOne(index);
                }
            }
        }
    }

};

RangeChanges.prototype.dispatchRangeChange = function (plus, minus, index, beforeChange) {
    var descriptors = this.getAllRangeChangeDescriptors(),
        descriptor,
        mapIter  = descriptors.values(),
        listeners,
        tokenName,
        i,
        countI,
        listener,
        currentListeners,
        Ghost;

    descriptors.dispatchBeforeChange = beforeChange;

     while (descriptor = mapIter.next().value) {

        if (descriptor.isActive) {
            return;
        }

        // before or after
        listeners = beforeChange ? descriptor._willChangeListeners : descriptor._changeListeners;
        if(listeners && listeners._current) {
            tokenName = listeners.specificHandlerMethodName;
            if(Array.isArray(listeners._current)) {
                if(listeners._current.length) {
                    // notably, defaults to "handleRangeChange" or "handleRangeWillChange"
                    // if token is "" (the default)

                    descriptor.isActive = true;
                    // dispatch each listener
                    try {
                            //removeGostListenersIfNeeded returns listeners.current or a new filtered one when conditions are met
                            currentListeners = listeners.removeCurrentGostListenersIfNeeded();
                            Ghost = ListenerGhost;
                        for(i=0, countI = currentListeners.length;i<countI;i++) {
                            if ((listener = currentListeners[i]) !== Ghost) {
                                if (listener[tokenName]) {
                                    listener[tokenName](plus, minus, index, this, beforeChange);
                                } else if (listener.call) {
                                    listener.call(this, plus, minus, index, this, beforeChange);
                                } else {
                                    throw new Error("Handler " + listener + " has no method " + tokenName + " and is not callable");
                                }
                            }
                        }
                    } finally {
                        descriptor.isActive = false;
                    }
                }
            }
            else {
                descriptor.isActive = true;
                // dispatch each listener
                try {
                    listener = listeners._current;
                    if (listener[tokenName]) {
                        listener[tokenName](plus, minus, index, this, beforeChange);
                    } else if (listener.call) {
                        listener.call(this, plus, minus, index, this, beforeChange);
                    } else {
                        throw new Error("Handler " + listener + " has no method " + tokenName + " and is not callable");
                    }
                } finally {
                    descriptor.isActive = false;
                }

            }
        }

    }
};

RangeChanges.prototype.addBeforeRangeChangeListener = function (listener, token) {
    return this.addRangeChangeListener(listener, token, true);
};

RangeChanges.prototype.removeBeforeRangeChangeListener = function (listener, token) {
    return this.removeRangeChangeListener(listener, token, true);
};

RangeChanges.prototype.dispatchBeforeRangeChange = function (plus, minus, index) {
    return this.dispatchRangeChange(plus, minus, index, true);
};

},{"../_map":24,"../weak-map":40,"./change-descriptor":32}],34:[function(require,module,exports){
"use strict";

/*
    Based in part on extras from Motorola Mobility’s Montage
    Copyright (c) 2012, Motorola Mobility LLC. All Rights Reserved.
    3-Clause BSD License
    https://github.com/motorola-mobility/montage/blob/master/LICENSE.md
*/

var Function = require("./shim-function");
var GenericCollection = require("./generic-collection");
var GenericOrder = require("./generic-order");
var WeakMap = require("./weak-map");

module.exports = Array;

var array_splice = Array.prototype.splice;
var array_slice = Array.prototype.slice;

Array.empty = [];

if (Object.freeze) {
    Object.freeze(Array.empty);
}

Array.nativeFrom = Array.from;

var isSymbolDefined = typeof Symbol !== "undefined";
Array.from = function (values, mapFn, thisArg) {
    if (isSymbolDefined && values && typeof values[Symbol.iterator] === "function") {
        return Array.nativeFrom(values, mapFn, thisArg);
    }
    //Now we add support for values that implement forEach:
    var array = [];
    array.addEach(values);
    return array;
};

Array.unzip = function (table) {
    var transpose = [];
    var length = Infinity;
    // compute shortest row
    for (var i = 0; i < table.length; i++) {
        var row = table[i];
        table[i] = row.toArray();
        if (row.length < length) {
            length = row.length;
        }
    }
    for (var i = 0; i < table.length; i++) {
        var row = table[i];
        for (var j = 0; j < row.length; j++) {
            if (j < length && j in row) {
                transpose[j] = transpose[j] || [];
                transpose[j][i] = row[j];
            }
        }
    }
    return transpose;
};

function define(key, value) {
    Object.defineProperty(Array.prototype, key, {
        value: value,
        writable: true,
        configurable: true,
        enumerable: false
    });
}

define("addEach", GenericCollection.prototype.addEach);
define("deleteEach", GenericCollection.prototype.deleteEach);
define("toArray", GenericCollection.prototype.toArray);
define("toObject", GenericCollection.prototype.toObject);
define("all", GenericCollection.prototype.all);
define("any", GenericCollection.prototype.any);
define("min", GenericCollection.prototype.min);
define("max", GenericCollection.prototype.max);
define("sum", GenericCollection.prototype.sum);
define("average", GenericCollection.prototype.average);
define("only", GenericCollection.prototype.only);
define("flatten", GenericCollection.prototype.flatten);
define("zip", GenericCollection.prototype.zip);
define("enumerate", GenericCollection.prototype.enumerate);
define("group", GenericCollection.prototype.group);
define("sorted", GenericCollection.prototype.sorted);
define("reversed", GenericCollection.prototype.reversed);

define("constructClone", function (values) {
    var clone = new this.constructor();
    clone.addEach(values);
    return clone;
});

define("has", function (value, equals) {
    return this.findValue(value, equals) !== -1;
});

define("get", function (index, defaultValue) {
    if (+index !== index) {
        throw new Error("Indicies must be numbers");
    } else if (!index in this) {
        return defaultValue;
    } else {
        return this[index];
    }
});

define("set", function (index, value) {
    this[index] = value;
    return true;
});

define("add", function (value) {
    this.push(value);
    return true;
});

define("delete", function (value, equals) {
    var index = this.findValue(value, equals);
    if (index !== -1) {
        this.spliceOne(index);
        return true;
    }
    return false;
});

define("deleteAll", function (value, equals) {
    equals = equals || this.contentEquals || Object.equals;
    var count = 0;
    for (var index = 0; index < this.length;) {
        if (equals(value, this[index])) {
            this.swap(index, 1);
            count++;
        } else {
            index++;
        }
    }
    return count;
});

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
// https://tc39.github.io/ecma262/#sec-array.prototype.find
if (!Array.prototype.find) {
    define("find", function(predicate) {
        // 1. Let O be ? ToObject(this value).
        if (this == null) {
            throw new TypeError('"this" is null or not defined');
        }

        var o = Object(this);

        // 2. Let len be ? ToLength(? Get(O, "length")).
        var len = o.length >>> 0;

        // 3. If IsCallable(predicate) is false, throw a TypeError exception.
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }

        // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
        var thisArg = arguments[1];

        // 5. Let k be 0.
        var k = 0;

        // 6. Repeat, while k < len
        while (k < len) {
            // a. Let Pk be ! ToString(k).
            // b. Let kValue be ? Get(O, Pk).
            // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
            // d. If testResult is true, return kValue.
            var kValue = o[k];
            if (predicate.call(thisArg, kValue, k, o)) {
                return kValue;
            }
            // e. Increase k by 1.
            k++;
        }
    });
}

// TODO remove in v6 (not present in v2)
var deprecatedWarnNonce = {};
function deprecatedWarn(msg, notOnce) {
    if (
        typeof console !== 'undefined' &&
            typeof console.warn === 'function' &&
                (notOnce !== true && deprecatedWarnNonce.hasOwnProperty(msg) === false)
    ) {
        console.warn(msg);
        deprecatedWarnNonce[msg]++;
    }
}

// Save Array.prototype.find in order to support legacy and display warning.
// TODO remove in v6 (not present in v2)
var ArrayFindPrototype = Object.getOwnPropertyDescriptor(Array.prototype, 'find').value;
define("find", function (value, equals, index) {
    if (
        typeof arguments[0] === 'function' &&
            this instanceof Array
    ) {
        return ArrayFindPrototype.apply(this, arguments);
    } else {
        deprecatedWarn('Array#find usage is deprecated please use Array#findValue');
        return this.findValue.apply(this, arguments);
    }
});

define("findValue", function (value, equals, index) {
    if (index) {
        throw new Error("Array#findValue does not support third argument: index");
    }
    equals = equals || this.contentEquals || Object.equals;
    for (var index = 0; index < this.length; index++) {
        if (index in this && equals(value, this[index])) {
            return index;
        }
    }
    return -1;
});

// TODO remove in v6 (not present in v2)
define("findLast", function (value, equals) {
    deprecatedWarn('Array#findLast function is deprecated please use Array#findLastValue instead.');
    return this.findLastValue.apply(this, arguments);
});

define("findLastValue", function (value, equals) {
    equals = equals || this.contentEquals || Object.equals;
    var index = this.length;
    do {
        index--;
        if (index in this && equals(this[index], value)) {
            return index;
        }
    } while (index > 0);
    return -1;
});

define("swap", function (start, length, plus) {
    var args, plusLength, i, j, returnValue;
    if (start > this.length) {
        this.length = start;
    }
    if (typeof plus !== "undefined") {
        args = [start, length];
        if (!Array.isArray(plus)) {
            plus = array_slice.call(plus);
        }
        i = 0;
        plusLength = plus.length;
        // 1000 is a magic number, presumed to be smaller than the remaining
        // stack length. For swaps this small, we take the fast path and just
        // use the underlying Array splice. We could measure the exact size of
        // the remaining stack using a try/catch around an unbounded recursive
        // function, but this would defeat the purpose of short-circuiting in
        // the common case.
        if (plusLength < 1000) {
            for (i; i < plusLength; i++) {
                args[i+2] = plus[i];
            }
            return array_splice.apply(this, args);
        } else {
            // Avoid maximum call stack error.
            // First delete the desired entries.
            returnValue = array_splice.apply(this, args);
            // Second batch in 1000s.
            for (i; i < plusLength;) {
                args = [start+i, 0];
                for (j = 2; j < 1002 && i < plusLength; j++, i++) {
                    args[j] = plus[i];
                }
                array_splice.apply(this, args);
            }
            return returnValue;
        }
    // using call rather than apply to cut down on transient objects
    } else if (typeof length !== "undefined") {
        return array_splice.call(this, start, length);
    }  else if (typeof start !== "undefined") {
        return array_splice.call(this, start);
    } else {
        return [];
    }
});

define("peek", function () {
    return this[0];
});

define("poke", function (value) {
    if (this.length > 0) {
        this[0] = value;
    }
});

define("peekBack", function () {
    if (this.length > 0) {
        return this[this.length - 1];
    }
});

define("pokeBack", function (value) {
    if (this.length > 0) {
        this[this.length - 1] = value;
    }
});

define("one", function () {
    for (var i in this) {
        if (Object.owns(this, i)) {
            return this[i];
        }
    }
});

if (!Array.prototype.clear) {
    define("clear", function () {
        this.length = 0;
        return this;
    });
}

define("compare", function (that, compare) {
    compare = compare || Object.compare;
    var i;
    var length;
    var lhs;
    var rhs;
    var relative;

    if (this === that) {
        return 0;
    }

    if (!that || !Array.isArray(that)) {
        return GenericOrder.prototype.compare.call(this, that, compare);
    }

    length = (this.length < that.length) ? this.length : that.length;

    for (i = 0; i < length; i++) {
        if (i in this) {
            if (!(i in that)) {
                return -1;
            } else {
                lhs = this[i];
                rhs = that[i];
                relative = compare(lhs, rhs);
                if (relative) {
                    return relative;
                }
            }
        } else if (i in that) {
            return 1;
        }
    }

    return this.length - that.length;
});

define("equals", function (that, equals) {
    equals = equals || Object.equals;
    var i = 0;
    var length = this.length;
    var left;
    var right;

    if (this === that) {
        return true;
    }
    if (!that || !Array.isArray(that)) {
        return GenericOrder.prototype.equals.call(this, that);
    }

    if (length !== that.length) {
        return false;
    } else {
        for (; i < length; ++i) {
            if (i in this) {
                if (!(i in that)) {
                    return false;
                }
                left = this[i];
                right = that[i];
                if (!equals(left, right)) {
                    return false;
                }
            } else {
                if (i in that) {
                    return false;
                }
            }
        }
    }
    return true;
});

define("clone", function (depth, memo) {
    if (depth == null) {
        depth = Infinity;
    } else if (depth === 0) {
        return this;
    }
    memo = memo || new WeakMap();
    if (memo.has(this)) {
        return memo.get(this);
    }
    var clone = new Array(this.length);
    memo.set(this, clone);
    for (var i in this) {
        clone[i] = Object.clone(this[i], depth - 1, memo);
    };
    return clone;
});

define("iterate", function (start, end) {
    return new ArrayIterator(this, start, end);
});

if(Array.prototype.spliceOne === void 0) {
    define("spliceOne", function (index,itemToAdd) {
        var len=this.length;
        if (!len) { return }
        if(arguments.length === 1) {
            while (index<len) {
                this[index] = this[index+1];
                index++
            }
            this.length--;
        }
        else {
            this[index] = itemToAdd;
        }
    });
}

define("Iterator", ArrayIterator);

function ArrayIterator(array, start, end) {
    this.array = array;
    this.start = start == null ? 0 : start;
    this.end = end;
}

ArrayIterator.prototype.__iterationObject = null;
Object.defineProperty(ArrayIterator.prototype,"_iterationObject", {
    get: function() {
        return this.__iterationObject || (this.__iterationObject = { done: false, value:null});
    }
});

ArrayIterator.prototype.next = function () {
    if (this.start === (this.end == null ? this.array.length : this.end)) {
        this._iterationObject.done = true;
        this._iterationObject.value = void 0;
    } else {
        this._iterationObject.value = this.array[this.start++];
    }
    return this._iterationObject;
};

},{"./generic-collection":27,"./generic-order":29,"./shim-function":35,"./weak-map":40}],35:[function(require,module,exports){

module.exports = Function;

/**
    A utility to reduce unnecessary allocations of <code>function () {}</code>
    in its many colorful variations.  It does nothing and returns
    <code>undefined</code> thus makes a suitable default in some circumstances.

    @function external:Function.noop
*/
Function.noop = function () {
};

/**
    A utility to reduce unnecessary allocations of <code>function (x) {return
    x}</code> in its many colorful but ultimately wasteful parameter name
    variations.

    @function external:Function.identity
    @param {Any} any value
    @returns {Any} that value
*/
Function.identity = function (value) {
    return value;
};

/**
    A utility for creating a comparator function for a particular aspect of a
    figurative class of objects.

    @function external:Function.by
    @param {Function} relation A function that accepts a value and returns a
    corresponding value to use as a representative when sorting that object.
    @param {Function} compare an alternate comparator for comparing the
    represented values.  The default is <code>Object.compare</code>, which
    does a deep, type-sensitive, polymorphic comparison.
    @returns {Function} a comparator that has been annotated with
    <code>by</code> and <code>compare</code> properties so
    <code>sorted</code> can perform a transform that reduces the need to call
    <code>by</code> on each sorted object to just once.
 */
Function.by = function (by , compare) {
    compare = compare || Object.compare;
    by = by || Function.identity;
    var compareBy = function (a, b) {
        return compare(by(a), by(b));
    };
    compareBy.compare = compare;
    compareBy.by = by;
    return compareBy;
};

// TODO document
Function.get = function (key) {
    return function (object) {
        return Object.get(object, key);
    };
};


},{}],36:[function(require,module,exports){
"use strict";

var WeakMap = require("./weak-map");

require("./shim-function");

module.exports = Object;

/*
    Based in part on extras from Motorola Mobility’s Montage
    Copyright (c) 2012, Motorola Mobility LLC. All Rights Reserved.
    3-Clause BSD License
    https://github.com/motorola-mobility/montage/blob/master/LICENSE.md
*/

/**
    Defines extensions to intrinsic <code>Object</code>.
    @see [Object class]{@link external:Object}
*/

/**
    A utility object to avoid unnecessary allocations of an empty object
    <code>{}</code>.  This object is frozen so it is safe to share.

    @object external:Object.empty
*/
Object.empty = Object.freeze(Object.create(null));

/**
    Returns whether the given value is an object, as opposed to a value.
    Unboxed numbers, strings, true, false, undefined, and null are not
    objects.  Arrays are objects.

    @function external:Object.isObject
    @param {Any} value
    @returns {Boolean} whether the given value is an object
*/
Object.isObject = function (object) {
    return Object(object) === object;
};

/**
    Returns the value of an any value, particularly objects that
    implement <code>valueOf</code>.

    <p>Note that, unlike the precedent of methods like
    <code>Object.equals</code> and <code>Object.compare</code> would suggest,
    this method is named <code>Object.getValueOf</code> instead of
    <code>valueOf</code>.  This is a delicate issue, but the basis of this
    decision is that the JavaScript runtime would be far more likely to
    accidentally call this method with no arguments, assuming that it would
    return the value of <code>Object</code> itself in various situations,
    whereas <code>Object.equals(Object, null)</code> protects against this case
    by noting that <code>Object</code> owns the <code>equals</code> property
    and therefore does not delegate to it.

    @function external:Object.getValueOf
    @param {Any} value a value or object wrapping a value
    @returns {Any} the primitive value of that object, if one exists, or passes
    the value through
*/
Object.getValueOf = function (value) {
    if (value && typeof value.valueOf === "function") {
        value = value.valueOf();
    }
    return value;
};

var hashMap = new WeakMap();
Object.hash = function (object) {
    if (object && typeof object.hash === "function") {
        return "" + object.hash();
    } else if (Object(object) === object) {
        if (!hashMap.has(object)) {
            hashMap.set(object, Math.random().toString(36).slice(2));
        }
        return hashMap.get(object);
    } else {
        return "" + object;
    }
};

/**
    A shorthand for <code>Object.prototype.hasOwnProperty.call(object,
    key)</code>.  Returns whether the object owns a property for the given key.
    It does not consult the prototype chain and works for any string (including
    "hasOwnProperty") except "__proto__".

    @function external:Object.owns
    @param {Object} object
    @param {String} key
    @returns {Boolean} whether the object owns a property wfor the given key.
*/
var owns = Object.prototype.hasOwnProperty;
Object.owns = function (object, key) {
    return owns.call(object, key);
};

/**
    A utility that is like Object.owns but is also useful for finding
    properties on the prototype chain, provided that they do not refer to
    methods on the Object prototype.  Works for all strings except "__proto__".

    <p>Alternately, you could use the "in" operator as long as the object
    descends from "null" instead of the Object.prototype, as with
    <code>Object.create(null)</code>.  However,
    <code>Object.create(null)</code> only works in fully compliant EcmaScript 5
    JavaScript engines and cannot be faithfully shimmed.

    <p>If the given object is an instance of a type that implements a method
    named "has", this function defers to the collection, so this method can be
    used to generically handle objects, arrays, or other collections.  In that
    case, the domain of the key depends on the instance.

    @param {Object} object
    @param {String} key
    @returns {Boolean} whether the object, or any of its prototypes except
    <code>Object.prototype</code>
    @function external:Object.has
*/
Object.has = function (object, key) {
    if (typeof object !== "object") {
        throw new Error("Object.has can't accept non-object: " + typeof object);
    }
    // forward to mapped collections that implement "has"
    if (object && typeof object.has === "function") {
        return object.has(key);
    // otherwise report whether the key is on the prototype chain,
    // as long as it is not one of the methods on object.prototype
    } else if (typeof key === "string") {
        return key in object && object[key] !== Object.prototype[key];
    } else {
        throw new Error("Key must be a string for Object.has on plain objects");
    }
};

/**
    Gets the value for a corresponding key from an object.

    <p>Uses Object.has to determine whether there is a corresponding value for
    the given key.  As such, <code>Object.get</code> is capable of retriving
    values from the prototype chain as long as they are not from the
    <code>Object.prototype</code>.

    <p>If there is no corresponding value, returns the given default, which may
    be <code>undefined</code>.

    <p>If the given object is an instance of a type that implements a method
    named "get", this function defers to the collection, so this method can be
    used to generically handle objects, arrays, or other collections.  In that
    case, the domain of the key depends on the implementation.  For a `Map`,
    for example, the key might be any object.

    @param {Object} object
    @param {String} key
    @param {Any} value a default to return, <code>undefined</code> if omitted
    @returns {Any} value for key, or default value
    @function external:Object.get
*/
Object.get = function (object, key, value) {
    if (typeof object !== "object") {
        throw new Error("Object.get can't accept non-object: " + typeof object);
    }
    // forward to mapped collections that implement "get"
    if (object && typeof object.get === "function") {
        return object.get(key, value);
    } else if (Object.has(object, key)) {
        return object[key];
    } else {
        return value;
    }
};

/**
    Sets the value for a given key on an object.

    <p>If the given object is an instance of a type that implements a method
    named "set", this function defers to the collection, so this method can be
    used to generically handle objects, arrays, or other collections.  As such,
    the key domain varies by the object type.

    @param {Object} object
    @param {String} key
    @param {Any} value
    @returns <code>undefined</code>
    @function external:Object.set
*/
Object.set = function (object, key, value) {
    if (object && typeof object.set === "function") {
        object.set(key, value);
    } else {
        object[key] = value;
    }
};

Object.addEach = function (target, source, overrides) {
    var overridesExistingProperty = arguments.length === 3 ? overrides : true;
    if (!source) {
    } else if (typeof source.forEach === "function" && !source.hasOwnProperty("forEach")) {
        // copy map-alikes
        if (source.isMap === true) {
            source.forEach(function (value, key) {
                target[key] = value;
            });
        // iterate key value pairs of other iterables
        } else {
            source.forEach(function (pair) {
                target[pair[0]] = pair[1];
            });
        }
    } else if (typeof source.length === "number") {
        // arguments, strings
        for (var index = 0; index < source.length; index++) {
            target[index] = source[index];
        }
    } else {
        // copy other objects as map-alikes
        for(var keys = Object.keys(source), i = 0, key;(key = keys[i]); i++) {
            if(overridesExistingProperty || !Object.owns(target,key)) {
                target[key] = source[key];
            }
        }
    }
    return target;
};


/*
var defineEach = function defineEach(target, prototype) {
    // console.log("Map defineEach: ",Object.keys(prototype));
    var proto = Map.prototype;
    for (var name in prototype) {
        if(!proto.hasOwnProperty(name)) {
            Object.defineProperty(proto, name, {
                value: prototype[name],
                writable: writable,
                configurable: configurable,
                enumerable: enumerable
            });
        }
    }
}
*/
Object.defineEach = function (target, source, overrides, configurable, enumerable, writable) {
    var overridesExistingProperty = arguments.length === 3 ? overrides : true;
    if (!source) {
    } else if (typeof source.forEach === "function" && !source.hasOwnProperty("forEach")) {
        // copy map-alikes
        if (source.isMap === true) {
            source.forEach(function (value, key) {
                Object.defineProperty(target, key, {
                    value: value,
                    writable: writable,
                    configurable: configurable,
                    enumerable: enumerable
                });
            });
        // iterate key value pairs of other iterables
        } else {
            source.forEach(function (pair) {
                Object.defineProperty(target, pair[0], {
                    value: pair[1],
                    writable: writable,
                    configurable: configurable,
                    enumerable: enumerable
                });

            });
        }
    } else if (typeof source.length === "number") {
        // arguments, strings
        for (var index = 0; index < source.length; index++) {
            Object.defineProperty(target, index, {
                value: source[index],
                writable: writable,
                configurable: configurable,
                enumerable: enumerable
            });

        }
    } else {
        // copy other objects as map-alikes
        for(var keys = Object.keys(source), i = 0, key;(key = keys[i]); i++) {
            if(overridesExistingProperty || !Object.owns(target,key)) {
                Object.defineProperty(target, key, {
                    value: source[key],
                    writable: writable,
                    configurable: configurable,
                    enumerable: enumerable
                });

            }
        }
    }
    return target;
};

/**
    Iterates over the owned properties of an object.

    @function external:Object.forEach
    @param {Object} object an object to iterate.
    @param {Function} callback a function to call for every key and value
    pair in the object.  Receives <code>value</code>, <code>key</code>,
    and <code>object</code> as arguments.
    @param {Object} thisp the <code>this</code> to pass through to the
    callback
*/
Object.forEach = function (object, callback, thisp) {

    var keys = Object.keys(object), i = 0, iKey;
    for(;(iKey = keys[i]);i++) {
        callback.call(thisp, object[iKey], iKey, object);
    }

};

/**
    Iterates over the owned properties of a map, constructing a new array of
    mapped values.

    @function external:Object.map
    @param {Object} object an object to iterate.
    @param {Function} callback a function to call for every key and value
    pair in the object.  Receives <code>value</code>, <code>key</code>,
    and <code>object</code> as arguments.
    @param {Object} thisp the <code>this</code> to pass through to the
    callback
    @returns {Array} the respective values returned by the callback for each
    item in the object.
*/
Object.map = function (object, callback, thisp) {
    var keys = Object.keys(object), i = 0, result = [], iKey;
    for(;(iKey = keys[i]);i++) {
        result.push(callback.call(thisp, object[iKey], iKey, object));
    }
    return result;
};

/**
    Returns the values for owned properties of an object.

    @function external:Object.map
    @param {Object} object
    @returns {Array} the respective value for each owned property of the
    object.
*/
Object.values = function (object) {
    return Object.map(object, Function.identity);
};

// TODO inline document concat
Object.concat = function () {
    var object = {};
    for (var i = 0; i < arguments.length; i++) {
        Object.addEach(object, arguments[i]);
    }
    return object;
};

Object.from = Object.concat;

/**
    Returns whether two values are identical.  Any value is identical to itself
    and only itself.  This is much more restictive than equivalence and subtly
    different than strict equality, <code>===</code> because of edge cases
    including negative zero and <code>NaN</code>.  Identity is useful for
    resolving collisions among keys in a mapping where the domain is any value.
    This method does not delgate to any method on an object and cannot be
    overridden.
    @see http://wiki.ecmascript.org/doku.php?id=harmony:egal
    @param {Any} this
    @param {Any} that
    @returns {Boolean} whether this and that are identical
    @function external:Object.is
*/
Object.is = function (x, y) {
    if (x === y) {
        // 0 === -0, but they are not identical
        return x !== 0 || 1 / x === 1 / y;
    }
    // NaN !== NaN, but they are identical.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is a NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN("foo") => true
    return x !== x && y !== y;
};

/**
    Performs a polymorphic, type-sensitive deep equivalence comparison of any
    two values.

    <p>As a basic principle, any value is equivalent to itself (as in
    identity), any boxed version of itself (as a <code>new Number(10)</code> is
    to 10), and any deep clone of itself.

    <p>Equivalence has the following properties:

    <ul>
        <li><strong>polymorphic:</strong>
            If the given object is an instance of a type that implements a
            methods named "equals", this function defers to the method.  So,
            this function can safely compare any values regardless of type,
            including undefined, null, numbers, strings, any pair of objects
            where either implements "equals", or object literals that may even
            contain an "equals" key.
        <li><strong>type-sensitive:</strong>
            Incomparable types are not equal.  No object is equivalent to any
            array.  No string is equal to any other number.
        <li><strong>deep:</strong>
            Collections with equivalent content are equivalent, recursively.
        <li><strong>equivalence:</strong>
            Identical values and objects are equivalent, but so are collections
            that contain equivalent content.  Whether order is important varies
            by type.  For Arrays and lists, order is important.  For Objects,
            maps, and sets, order is not important.  Boxed objects are mutally
            equivalent with their unboxed values, by virtue of the standard
            <code>valueOf</code> method.
    </ul>
    @param this
    @param that
    @returns {Boolean} whether the values are deeply equivalent
    @function external:Object.equals
*/
Object.equals = function (a, b, equals, memo) {
    equals = equals || Object.equals;
    //console.log("Object.equals: a:",a, "b:",b, "equals:",equals);
    // unbox objects, but do not confuse object literals
    a = Object.getValueOf(a);
    b = Object.getValueOf(b);
    if (a === b)
        return true;
    if (Object.isObject(a)) {
        memo = memo || new WeakMap();
        if (memo.has(a)) {
            return true;
        }
        memo.set(a, true);
    }
    if (Object.isObject(a) && typeof a.equals === "function") {
        return a.equals(b, equals, memo);
    }
    // commutative
    if (Object.isObject(b) && typeof b.equals === "function") {
        return b.equals(a, equals, memo);
    }
    if (Object.isObject(a) && Object.isObject(b)) {
        if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {
            for (var name in a) {
                if (!equals(a[name], b[name], equals, memo)) {
                    return false;
                }
            }
            for (var name in b) {
                if (!(name in a) || !equals(b[name], a[name], equals, memo)) {
                    return false;
                }
            }
            return true;
        }
    }
    // NaN !== NaN, but they are equal.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is a NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN("foo") => true
    // We have established that a !== b, but if a !== a && b !== b, they are
    // both NaN.
    if (a !== a && b !== b)
        return true;
    if (!a || !b)
        return a === b;
    return false;
};

// Because a return value of 0 from a `compare` function  may mean either
// "equals" or "is incomparable", `equals` cannot be defined in terms of
// `compare`.  However, `compare` *can* be defined in terms of `equals` and
// `lessThan`.  Again however, more often it would be desirable to implement
// all of the comparison functions in terms of compare rather than the other
// way around.

/**
    Determines the order in which any two objects should be sorted by returning
    a number that has an analogous relationship to zero as the left value to
    the right.  That is, if the left is "less than" the right, the returned
    value will be "less than" zero, where "less than" may be any other
    transitive relationship.

    <p>Arrays are compared by the first diverging values, or by length.

    <p>Any two values that are incomparable return zero.  As such,
    <code>equals</code> should not be implemented with <code>compare</code>
    since incomparability is indistinguishable from equality.

    <p>Sorts strings lexicographically.  This is not suitable for any
    particular international setting.  Different locales sort their phone books
    in very different ways, particularly regarding diacritics and ligatures.

    <p>If the given object is an instance of a type that implements a method
    named "compare", this function defers to the instance.  The method does not
    need to be an owned property to distinguish it from an object literal since
    object literals are incomparable.  Unlike <code>Object</code> however,
    <code>Array</code> implements <code>compare</code>.

    @param {Any} left
    @param {Any} right
    @returns {Number} a value having the same transitive relationship to zero
    as the left and right values.
    @function external:Object.compare
*/
Object.compare = function (a, b) {
    // unbox objects, but do not confuse object literals
    // mercifully handles the Date case
    a = Object.getValueOf(a);
    b = Object.getValueOf(b);
    if (a === b)
        return 0;
    var aType = typeof a;
    var bType = typeof b;
    if (aType === "number" && bType === "number")
        return a - b;
    if (aType === "string" && bType === "string")
        return a < b ? -Infinity : Infinity;
        // the possibility of equality elimiated above
    if (a && typeof a.compare === "function")
        return a.compare(b);
    // not commutative, the relationship is reversed
    if (b && typeof b.compare === "function")
        return -b.compare(a);
    return 0;
};

/**
    Creates a deep copy of any value.  Values, being immutable, are
    returned without alternation.  Forwards to <code>clone</code> on
    objects and arrays.

    @function external:Object.clone
    @param {Any} value a value to clone
    @param {Number} depth an optional traversal depth, defaults to infinity.
    A value of <code>0</code> means to make no clone and return the value
    directly.
    @param {Map} memo an optional memo of already visited objects to preserve
    reference cycles.  The cloned object will have the exact same shape as the
    original, but no identical objects.  Te map may be later used to associate
    all objects in the original object graph with their corresponding member of
    the cloned graph.
    @returns a copy of the value
*/
Object.clone = function (value, depth, memo) {
    value = Object.getValueOf(value);
    memo = memo || new WeakMap();
    if (depth === undefined) {
        depth = Infinity;
    } else if (depth === 0) {
        return value;
    }
    if (Object.isObject(value)) {
        if (!memo.has(value)) {
            if (value && typeof value.clone === "function") {
                memo.set(value, value.clone(depth, memo));
            } else {
                var prototype = Object.getPrototypeOf(value);
                if (prototype === null || prototype === Object.prototype) {
                    var clone = Object.create(prototype);
                    memo.set(value, clone);
                    for (var key in value) {
                        clone[key] = Object.clone(value[key], depth - 1, memo);
                    }
                } else {
                    throw new Error("Can't clone " + value);
                }
            }
        }
        return memo.get(value);
    }
    return value;
};

/**
    Removes all properties owned by this object making the object suitable for
    reuse.

    @function external:Object.clear
    @returns this
*/
Object.clear = function (object) {
    if (object && typeof object.clear === "function") {
        object.clear();
    } else {
        var keys = Object.keys(object),
            i = keys.length;
        while (i) {
            i--;
            delete object[keys[i]];
        }
    }
    return object;
};

},{"./shim-function":35,"./weak-map":40}],37:[function(require,module,exports){

/**
    accepts a string; returns the string with regex metacharacters escaped.
    the returned string can safely be used within a regex to match a literal
    string. escaped characters are [, ], {, }, (, ), -, *, +, ?, ., \, ^, $,
    |, #, [comma], and whitespace.
*/
if (!RegExp.escape) {
    var special = /[-[\]{}()*+?.\\^$|,#\s]/g;
    RegExp.escape = function (string) {
        return string.replace(special, "\\$&");
    };
}


},{}],38:[function(require,module,exports){

var Array = require("./shim-array");
var Object = require("./shim-object");
var Function = require("./shim-function");
var RegExp = require("./shim-regexp");


},{"./shim-array":34,"./shim-function":35,"./shim-object":36,"./shim-regexp":37}],39:[function(require,module,exports){
"use strict";

module.exports = TreeLog;

function TreeLog() {
}

TreeLog.ascii = {
    intersection: "+",
    through: "-",
    branchUp: "+",
    branchDown: "+",
    fromBelow: ".",
    fromAbove: "'",
    fromBoth: "+",
    strafe: "|"
};

TreeLog.unicodeRound = {
    intersection: "\u254b",
    through: "\u2501",
    branchUp: "\u253b",
    branchDown: "\u2533",
    fromBelow: "\u256d", // round corner
    fromAbove: "\u2570", // round corner
    fromBoth: "\u2523",
    strafe: "\u2503"
};

TreeLog.unicodeSharp = {
    intersection: "\u254b",
    through: "\u2501",
    branchUp: "\u253b",
    branchDown: "\u2533",
    fromBelow: "\u250f", // sharp corner
    fromAbove: "\u2517", // sharp corner
    fromBoth: "\u2523",
    strafe: "\u2503"
};


},{}],40:[function(require,module,exports){

module.exports = (typeof WeakMap !== 'undefined') ? WeakMap : require("weak-map");

},{"weak-map":114}],41:[function(require,module,exports){
(function (process){
/**
 * @fileoverview Flag parsing library for node.js.  See ../README.md for info.
 *
 * @author dan@pupi.us (Daniel Pupius)
 */

var util = require('util');


/**
 * An object containing a map of flag objects.  If different modules are
 * importing different versions of the library we want them to use the same
 * FLAGS object.  This does mean that the flags library needs to be backwards
 * compatible.  This is a pretty ugly solution, should look for a better one.
 * @type {!Object}
 */
if (typeof GLOBAL_FLAGS == 'undefined') {
  var registerFlags = true;
  GLOBAL_FLAGS = {};
}
var FLAGS = exports.FLAGS = GLOBAL_FLAGS;


/**
 * If true, then the process will be nicely exit on a parse error.  If false,
 * an Error will be thrown.  Set to false in tests.
 * @type {boolean}
 */
exports.exitOnError = true;


/**
 * Allows an app to add extra usage information that will be shown in the help
 * message, above the flags.
 * @type {string}
 */
exports.usageInfo = 'Usage: node ' +
    (process.argv[1] || '').split('/').pop() + ' [options]';


/**
 * Defines a string flag.  e.g. --servername=bob
 * @param {string} name The flag name, should be [a-zA-Z0-9]+.
 * @param {string=} opt_default The default value, should the flag not be
 *     explicitly specified.
 * @param {string=} opt_description Optional description to use in help text.
 * @return {!Flag} The flag object.
 */
exports.defineString = function(name, opt_default, opt_description) {
  return addFlag(name, new Flag(name, opt_default, opt_description));
};


/**
 * Defines a boolean flag.   e.g. --turnonlights
 * @param {string} name The flag name, should be [a-zA-Z0-9]+.
 * @param {boolean=} opt_default The default value, should the flag not be
 *     explicitly specified.
 * @param {string=} opt_description Optional description to use in help text.
 * @return {!BooleanFlag} The flag object.
 */
exports.defineBoolean = function(name, opt_default, opt_description) {
  return addFlag(name, new BooleanFlag(name, opt_default, opt_description));
};


/**
 * Defines an integer flag.  e.g.  --age=12
 * @param {string} name The flag name, should be [a-zA-Z0-9]+.
 * @param {number=} opt_default The default value, should the flag not be
 *     explicitly specified.
 * @param {string=} opt_description Optional description to use in help text.
 * @return {!IntegerFlag} The flag object.
 */
exports.defineInteger = function(name, opt_default, opt_description) {
  return addFlag(name, new IntegerFlag(name, opt_default, opt_description));
};


/**
 * Defines a number flag.  e.g. --number=1.345
 * @param {string} name The flag name, should be [a-zA-Z0-9]+.
 * @param {number=} opt_default The default value, should the flag not be
 *     explicitly specified.
 * @param {string=} opt_description Optional description to use in help text.
 * @return {!NumberFlag} The flag object.
 */
exports.defineNumber = function(name, opt_default, opt_description) {
  return addFlag(name, new NumberFlag(name, opt_default, opt_description));
};


/**
 * Defines a string list flag.  e.g. --anmial=frog,bat,chicken 
 * @param {string} name The flag name, should be [a-zA-Z0-9]+.
 * @param {!Array.<string>=} opt_default The default value, should the flag not
 *     be explicitly specified.
 * @param {string=} opt_description Optional description to use in help text.
 * @return {!StringListFlag} The flag object.
 */
exports.defineStringList = function(name, opt_default, opt_description) {
  return addFlag(name, new StringListFlag(name, opt_default, opt_description));
};


/**
 * Defines a multi string flag.  e.g. --allowedip=127.0.0.1 --allowedip=127.0.0.2
 * @param {string} name The flag name, should be [a-zA-Z0-9]+.
 * @param {!Array.<string>=} opt_default The default value, should the flag not
 *     be explicitly specified.
 * @param {string=} opt_description Optional description to use in help text.
 * @return {!MultiStringFlag} The flag object.
 */
exports.defineMultiString = function(name, opt_default, opt_description) {
  return addFlag(name, new MultiStringFlag(name, opt_default, opt_description));
};


/**
 * Dumps the help text to the console.
 */
exports.help = function() {
  if (exports.usageInfo) {
    console.log(exports.usageInfo + '\n');
  }
  console.log('Options:');
  for (var flag in FLAGS) {
    if (!FLAGS[flag].isSecret) {
      console.log(FLAGS[flag].toHelpString());
    }
  }
};


/**
 * Resets the flag values.
 */
exports.reset = function() {
  parseCalled = false;
  FLAGS = exports.FLAGS = GLOBAL_FLAGS = {};
  registerInternalFlags();
};


/**
 * Gets the current value of the given flag.
 * @param {string} name The flag name.
 * @return {*}
 */
exports.get = function(name) {
  if (!FLAGS[name]) throw Error('Unknown flag "' + name + '"');
  return FLAGS[name].get(name);
};


/**
 * Gets whether or not the flag was set.
 * @param {string} name The flag name.
 * @return {boolean}
 */
exports.isSet = function(name) {
    if (!FLAGS[name]) throw Error('Unknown flag "' + name + '"');
    return FLAGS[name].isSet;
};

/**
 * Parses process.argv for flags.  Idempotent if called multiple times.
 * @param {Array.<string>=} opt_args Optional arguments array to use instead of
 *     process.argv.
 * @param {boolean} opt_ignoreUnrecognized Don't throw errors if unrecognized
 *    flags are encountered.
 */
exports.parse = function(opt_args, opt_ignoreUnrecognized) {
  var args = opt_args || process.argv.slice(2);
  if (parseCalled) return;
  
  var parsedFlags = {};
  var lastflag = null;
  for (var i = 0; i < args.length; i++) {
    var arg = args[i];
    
    // Terminate any flag processing
    if (arg == '--') {
      break;
    
    // Handle a typical long form flag --foo or --foo=bar.
    } else if (arg.substr(0, 2) == '--') {
      var flag = arg.substr(2);
      var value = null;
      if (flag.indexOf('=') > -1) {
        var parts = flag.split('=');
        flag = parts[0];
        value = parts.slice(1).join('=');
      }
      
      // Hacky munging of the args to handle space separated flags.
      if (value == null && args[i + 1] && args[i + 1].substr(0, 2) != '--') {
        args[i] = args[i] + ' ' + args[i + 1];
        value = args[i + 1];
        args.splice(i + 1, 1);
      }
      
      // Special case boolean flags of the form '--noflagname'.
      if (!FLAGS[flag] && value == null && flag.substr(0, 2) == 'no') {
        flag = flag.substr(2);
        value = '0';
      }
      
      if (FLAGS[flag]) {
        try {
          FLAGS[flag].set(value);
        } catch (e) {
          throwFlagParseError(args, i, e.message);
        }
      } else if (!opt_ignoreUnrecognized) {
        throwFlagParseError(args, i, 'Unrecognized flag name "' + arg + '"');
      }
    
    // For now we only handle simple flags like --foo=bar, so fail out.
    } else {
      throwFlagParseError(args, i, 'Invalid argument "' + arg + '"');
    }
  }
  
  parseCalled = true;
  
  // Intercept the --help flag.
  if (FLAGS.help.get()) {
    exports.help();
    process.exit(0);
  }
  
  if (i != args.length) {
    return args.slice(i + 1);
  } else {
    return [];
  }
};


// Private helpers
//==================

var parseCalled = false;


function throwFlagParseError(args, i, msg) {
  // Show a nice error message with the offending arg underlined.
  var msg = 'FLAG PARSING ERROR: ' + msg + '\n  ' +
      args.join(' ') + '\n ' +
      new Array(args.slice(0, i).join(' ').length + 2).join(' ') +
      new Array(args[i].length + 1).join('^');

  if (exports.exitOnError) {
    console.error(msg);
    process.exit(1);
  } else {
    throw Error(msg);
  }  
}


function addFlag(name, flag) {
  if (parseCalled) throw Error('Can not register new flags after parse()');
  if (FLAGS[name]) throw Error('Flag already defined: "' + flag + '"')
  FLAGS[name] = flag;
  return flag;
}


function wrapText(text, maxLen) {
  var lines = text.split('\n');
  var out = [];
  for (var i = 0; i < lines.length; i++) {
    // Adjust the maxLength for to take into account the lack of indent on the
    // first line.
    var maxLenx = maxLen + (out.length == 0 ? 4 : 0);
    var line = lines[i];
    if (line.length < maxLenx) {
      // Line doesn't exceed length so just push it.
      out.push(line)
    } else {
      // Wrap the line on spaces.
      // TODO : Would be nice to split URLs and long phrases that have no
      // natural spaces.
      var current = wrapLine(line, ' ', maxLenx, out);
      if (current != '') {
        out.push(current);
      }
    }
  }
  return out.join('\n    ');
}


function wrapLine(line, delimiter, maxLen, out) {
  var parts = line.split(delimiter);
  var current = '';
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    var next = current + part + delimiter; 
    if (next.length > maxLen) {
      out.push(current);
      current = part + delimiter;
    } else {
      current = next;
    }
  }
  return current;
}


/**
 * @constructor
 */
function Flag(name, defaultValue, description) {
  this.name = name;
  this.defaultValue = defaultValue;
  this.description = description;
  this.currentValue = null;
  this.validator = null;
  this.isSecret = false;
  this.isSet = false;
}


Flag.prototype.setDefault = function(defaultValue) {
  this.defaultValue = defaultValue;
  return this;
};


Flag.prototype.setDescription = function(description) {
  this.description = description;
  return this;
};


Flag.prototype.setValidator = function(validator) {
  this.validator = validator;
  return this;
};


Flag.prototype.setSecret = function(isSecret) {
  this.isSecret = isSecret;
  return this; 
};


Flag.prototype.set = function(input) {
  if (this.isSet) {
    throw Error('Flag already set');
  }
  if (this.validator) this.validator.call(null, input);
  this.currentValue = this.parseInput(input);
  this.isSet = true;
};


Flag.prototype.get = function() {
  return this.isSet ? this.currentValue : this.defaultValue;
};


Flag.prototype.parseInput = function(inp) {
  return inp;
};


Flag.prototype.toHelpString = function() {
  return wrapText('  --' + this.name + ': ' + this.description, 70) + '\n' +
      '    (default: ' + JSON.stringify(this.defaultValue) + ')';
};


/**
 * @constructor
 */
function BooleanFlag() {
  BooleanFlag.super_.apply(this, arguments);
}
util.inherits(BooleanFlag, Flag);


BooleanFlag.prototype.parseInput = function(inp) {
  if (inp === null) {
    return true;
  }
  inp = inp.toLowerCase();
  if (inp === '1' || inp === 'true' || inp == 't') {
    return true;
  } else if (inp === '0' || inp === 'false' || inp == 'f') {
    return false;
  } else {
    throw Error('Invalid Boolean flag "' + inp + '"')
  }
};


BooleanFlag.prototype.get = function() {
  return !!BooleanFlag.super_.prototype.get.call(this);
};


BooleanFlag.prototype.toHelpString = function() {
  return wrapText('  --[no]' + this.name + ': ' + this.description, 70) + '\n' +
      '    (default: ' + JSON.stringify(this.defaultValue) + ')';
};



/**
 * @constructor
 */
function IntegerFlag() {
  IntegerFlag.super_.apply(this, arguments);
}
util.inherits(IntegerFlag, Flag);


IntegerFlag.prototype.parseInput = function(inp) {
  if (isNaN(inp) || parseInt(inp, 10) !== Number(inp)) {
    throw Error('Invalid Integer flag "' + inp + '"');
  }
  return Number(inp);
};


IntegerFlag.prototype.toHelpString = function() {
  return IntegerFlag.super_.prototype.toHelpString.call(this) +
      '\n    (an integer)';
};


/**
 * @constructor
 */
function NumberFlag() {
  NumberFlag.super_.apply(this, arguments);
}
util.inherits(NumberFlag, Flag);


NumberFlag.prototype.parseInput = function(inp) {
  if (isNaN(inp)) {
    throw Error('Invalid Number flag "' + inp + '"');
  }
  return Number(inp);
};


NumberFlag.prototype.toHelpString = function() {
  return NumberFlag.super_.prototype.toHelpString.call(this) +
      '\n    (a number)';
};



/**
 * @constructor
 */
function StringListFlag() {
  StringListFlag.super_.apply(this, arguments);
}
util.inherits(StringListFlag, Flag);


StringListFlag.prototype.parseInput = function(inp) {
  return inp.split(',');
};



/**
 * @constructor
 */
function MultiStringFlag() {
  MultiStringFlag.super_.apply(this, arguments);
  this.currentValue = [];
}
util.inherits(MultiStringFlag, Flag);


MultiStringFlag.prototype.set = function(input) {
  if (this.validator) this.validator.call(null, input);
  this.currentValue.push(input);
  this.isSet = true;
};



// Internal flags
//=================

function registerInternalFlags() {
  exports.defineBoolean('help').
      setDescription('Shows this help text.').
      setSecret(true);
  // TODO: --flagsfile  
}

if (registerFlags) {
  registerInternalFlags();
}

}).call(this,require('_process'))
},{"_process":7,"util":10}],42:[function(require,module,exports){
var gamejs = require('../gamejs');

/**
 * @fileoverview Playing sounds with the html5 audio tag. Audio files must be preloaded
 * with the usual `gamejs.preload()` function. Ogg, wav and webm supported.
 *
 */

var CACHE = {};

/**
 * need to export preloading status for require
 * @ignore
 */
var _PRELOADING = false;

/**
 * @ignore
 */
var NUM_CHANNELS = 8;

/**
 * Sets the number of available channels for the mixer. The default value is 8.
 */
exports.setNumChannels = function(count) {
   NUM_CHANNELS = parseInt(count, 10) || NUM_CHANNELS;
};

exports.getNumChannels = function() {
   return NUM_CHANNELS;
};

/**
 * put all audios on page in cache
 * if same domain as current page, remove common href-prefix
 * @ignore
 */
exports.init = function() {
   var audios = Array.prototype.slice.call(document.getElementsByTagName("audio"), 0);
   addToCache(audios);
   return;
};

/**
 * Preload the audios into cache
 * @param {String[]} List of audio URIs to load
 * @returns {Function} which returns 0-1 for preload progress
 * @ignore
 */
exports.preload = function(audioUrls, showProgressOrImage) {
   var countTotal = 0;
   var countLoaded = 0;

   function incrementLoaded() {
      countLoaded++;
      if (countLoaded == countTotal) {
         _PRELOADING = false;
      }
   }

   function getProgress() {
      return countTotal > 0 ? countLoaded / countTotal : 1;
   }

   function successHandler() {
      addToCache(this);
      incrementLoaded();
   }
   function errorHandler() {
      incrementLoaded();
      throw new Error('Error loading ' + this.src);
   }

   for (var key in audioUrls) {
      if (key.indexOf('wav') == -1 && key.indexOf('ogg') == -1 && key.indexOf('webm') == -1) {
         continue;
      }
      countTotal++;
      var audio = new Audio();
      audio.addEventListener('canplay', successHandler, true);
      audio.addEventListener('error', errorHandler, true);
      audio.src = audioUrls[key];
      audio.gamejsKey = key;
      audio.load();
   }
   if (countTotal > 0) {
      _PRELOADING = true;
   }
   return getProgress;
};

/**
 * @ignore
 */
exports.isPreloading = function() {
   return _PRELOADING;
};

/**
 * @param {dom.ImgElement} audios the <audio> elements to put into cache
 * @ignore
 */
function addToCache(audios) {
   if (!(audios instanceof Array)) {
      audios = [audios];
   }

   var docLoc = document.location.href;
   audios.forEach(function(audio) {
      CACHE[audio.gamejsKey] = audio;
   });
   return;
}

/**
 * Sounds can be played back.
 * @constructor
 * @param {String|dom.AudioElement} uriOrAudio the uri of <audio> dom element
 *                of the sound
 */
exports.Sound = function Sound(uriOrAudio) {
   var cachedAudio;
   if (typeof uriOrAudio === 'string') {
      cachedAudio = CACHE[uriOrAudio];
   } else {
      cachedAudio = uriOrAudio;
   }
   if (!cachedAudio) {
      // TODO sync audio loading
      throw new Error('Missing "' + uriOrAudio + '", gamejs.preload() all audio files before loading');
   }

   var channels = [];
   var i = NUM_CHANNELS;
   while (i-->0) {
      var audio = new Audio();
      audio.preload = "auto";
      audio.loop = false;
      audio.src = cachedAudio.src;
      channels.push(audio);
   }
   /**
    * start the sound
    * @param {Boolean} loop whether the audio should loop for ever or not
    */
   this.play = function(loop) {
      channels.some(function(audio) {
         if (audio.ended || audio.paused) {
            audio.loop = !!loop;
            audio.play();
            return true;
         }
         return false;
      });
   };

   /**
    * Stop the sound.
    * This will stop the playback of this Sound on any active Channels.
    */
   this.stop = function() {
      channels.forEach(function(audio) {
         audio.stop();
      });
   };

   /**
    * Set volume of this sound
    * @param {Number} value volume from 0 to 1
    */
   this.setVolume = function(value) {
      channels.forEach(function(audio) {
         audio.volume = value;
      });
   };

   /**
    * @returns {Number} the sound's volume from 0 to 1
    */
   this.getVolume = function() {
      return channels[0].volume;
   };

   /**
    * @returns {Number} Duration of this sound in seconds
    */
   this.getLength = function() {
      return channels[0].duration;
   };

   return this;
};

},{"../gamejs":"gamejs"}],43:[function(require,module,exports){
var Surface = require('./graphics').Surface;

/**
 * @fileoverview Methods to create, access and manipulate the display Surface.
 *
 * You can just grab the canvas element whether it exists in the DOM or not (GameJs
 * will create it if necessary):
 *
 *     var display = gamejs.display.getSurface();
 *
 * If you need to resize the canvas - although it is recommended to style it with CSS - you can
 * call the `setMode()` function, which conviniently returns the new display surface:
 *
 *     newDisplay = gamejs.display.setMode([800, 600]);
 *
 * ### Browser window gets resized
 *
 * When the canvas size is configured with CSS, the display surface might change when
 * the browser window is resized. GameJs will internally deal with this and recreate
 * the the display surface with the new size.
 *
 * You will typically not have to worry about this but if you want to get informed
 * about a display resize, you can register a callback with `gamejs.event.onDisplayResize`.
 *
 *
 * ### Flags
 *
 * For advanced uses you can set a few modes which additionally change how the display
 * behaves with regards to pixel smoothing and whether you want a fullscreen canvas with
 * or withouth the mouse pointer locked inside the window (for endless mouse movement in
 * all directions).
 *
 *
 * `gamejs.display.setMode()` understands three flags:
 *
 *   * gamejs.display.FULLSCREEN
 *   * gamejs.display.DISABLE_SMOOTHING
 *   * gamejs.display.POINTERLOCK (implies FULLSCREEN)
 *
 * For example:
 *      // disable smoothing
 *      gamejs.display.setMode([800, 600], gamejs.display.DISABLE_SMOOTHING);
 *      // disable smoothing and fullscreen
 *      gamejs.display.setMode(
               [800, 600],
               gamejs.display.DISABLE_SMOOTHING | gamejs.display.FULLSCREEN
         );
 *
 * ### Fullscreen mode
 *
 * When `setMode()` is called with the fullscreen flag then the fullscreen mode can be enabled by the
 * player by clicking on the DOM element with id "gjs-fullscreen-toggle". Browser security requires
 * that a user enables fullscreen with a "gesture" (e.g., clicking a button) and we can not enable fullscreen
 * in code.
 *
 * Fullscreen mode can be exited by many keys, e.g., anything window manager related (ALT-TAB) or ESC. A lot
 * of keys will trigger a browser information popup explaining how fullscreen mode can be exited.
 *
 * The following keys are "whitelisted" in fullscreen mode and will not trigger such a browser popup:
 *
 *  * left arrow, right arrow, up arrow, down arrow
 *  * space
 *  * shift, control, alt
 *  * page up, page down
 *  * home, end, tab, meta
 *
 *
 * ### Relevant DOM node ids accessed by this module
 *
 * You can provide your own tags with those ids
 *
 *   * gjs-canvas - the display surface
 *   * gjs-loader - loading bar
 *   * gjs-fullscreen-toggle a clickable element to enable fullscreen
 *   * gjs-canvas-wrapper this wrapper is added when in fullscreen mode
 *
 */

var CANVAS_ID = "gjs-canvas";
var LOADER_ID = "gjs-loader";
var SURFACE = null;

/**
 * Pass this flag to `gamejs.display.setMode(resolution, flags)` to disable
 * pixel smoothing; this is, for example, useful for retro-style, low resolution graphics
 * where you don't want the browser to smooth them when scaling & drawing.
 */
var DISABLE_SMOOTHING = exports.DISABLE_SMOOTHING = 2;
var FULLSCREEN = exports.FULLSCREEN = 4;
var POINTERLOCK = exports.POINTERLOCK = 8;

var _flags = 0;

/**
 * @returns {document.Element} the canvas dom element
 * @ignore
 */
var getCanvas = exports._getCanvas = function() {
   var displayCanvas = document.getElementById(CANVAS_ID);
   if (!displayCanvas) {
      displayCanvas = document.createElement("canvas");
      displayCanvas.setAttribute("id", CANVAS_ID);
      document.body.appendChild(displayCanvas);
   }
   return displayCanvas;
};


var getFullScreenToggle = function() {
   var fullScreenButton = document.getElementById('gjs-fullscreen-toggle');
   if (!fullScreenButton) {
      // before canvas
      fullScreenButton = document.createElement('button');
      fullScreenButton.innerHTML = 'Fullscreen';
      fullScreenButton.id = 'gjs-fullscreen-toggle';
      var canvas = getCanvas();
      canvas.parentNode.insertBefore(fullScreenButton, canvas);
      canvas.parentNode.insertBefore(document.createElement('br'), canvas);

   }
   return fullScreenButton;
};

var fullScreenChange = function(event) {
   var gjsEvent ={
      type: isFullScreen() ? require('./event').DISPLAY_FULLSCREEN_ENABLED :
                        require('./event').DISPLAY_FULLSCREEN_DISABLED

   };
   if (isFullScreen()) {
      if (_flags & POINTERLOCK) {
         enablePointerLock();
      }
   }
   require('./event')._triggerCallbacks(gjsEvent);
};

exports.hasPointerLock = function() {
   return !!(document.pointerLockElement ||
      document.webkitFullscreenElement ||
      document.mozFullscreenElement ||
      document.mozFullScreenElement);
};

function onResize(event) {
   var canvas = getCanvas();
   SURFACE._canvas.width = canvas.clientWidth;
   SURFACE._canvas.height = canvas.clientHeight;
   require('./event')._triggerCallbacks({
      type: require('./event').DISPLAY_RESIZE
   });
}

/**
 * Create the master Canvas plane.
 * @ignore
 */
exports.init = function() {
   // create canvas element if not yet present
   var canvas = getCanvas();
   if (!canvas.getAttribute('tabindex')) {
      // to be focusable, tabindex must be set
      canvas.setAttribute("tabindex", 1);
      canvas.focus();
   }
   // remove loader if any;
   var $loader = document.getElementById(LOADER_ID);
   if ($loader) {
      $loader.style.display = "none";
   }
   var $displaySurface = document.getElementById(CANVAS_ID);
   if ($displaySurface) {
      $displaySurface.style.display = 'block';
   }
   // hook into resize
   window.addEventListener("resize", onResize, false);
   return;
};

var isFullScreen = exports.isFullscreen = function() {
   return (document.fullScreenElement || document.mozFullScreen || document.webkitIsFullScreen || document.webkitDisplayingFullscreen);
};

/**
 * Switches the display window normal browser mode and fullscreen.
 * @ignore
 * @returns {Boolean} true if operation was successfull, false otherwise
 */
var enableFullScreen = function(event) {
   var wrapper = getCanvas();
   wrapper.requestFullScreen = wrapper.requestFullScreen || wrapper.mozRequestFullScreen || wrapper.webkitRequestFullScreen;
   if (!wrapper.requestFullScreen) {
      return false;
   }
   // @xbrowser chrome allows keboard input onl if ask for it (why oh why?)
   if (Element.ALLOW_KEYBOARD_INPUT) {
      wrapper.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
   } else {
      wrapper.requestFullScreen();
   }
   return true;
};

var enablePointerLock = function() {
   var wrapper = getCanvas();
   wrapper.requestPointerLock = wrapper.requestPointerLock || wrapper.mozRequestPointerLock || wrapper.webkitRequestPointerLock;
   if (wrapper.requestPointerLock) {
      wrapper.requestPointerLock();
   }
};

/** @ignore **/
exports._hasFocus = function() {
   return document.activeElement == getCanvas();
};

/**
 * Set the width and height of the Display. Conviniently this will
 * return the actual display Surface - the same as calling [gamejs.display.getSurface()](#getSurface)
 * later on.
 * @param {Array} dimensions [width, height] of the display surface
 * @param {Number} flags gamejs.display.DISABLE_SMOOTHING | gamejs.display.FULLSCREEN | gamejs.display.POINTERLOCK
 */
exports.setMode = function(dimensions, flags) {
   SURFACE = null;
   var canvas = getCanvas();
   canvas.width = canvas.clientWidth = dimensions[0];
   canvas.height = canvas.clientHeight = dimensions[1];

   _flags = _flags || flags;
   // @ xbrowser firefox allows pointerlock only if fullscreen
   if (_flags & POINTERLOCK) {
      _flags = _flags | FULLSCREEN;
   }
   if (_flags & FULLSCREEN) {
      // attach fullscreen toggle checkbox
      var fullScreenToggle = getFullScreenToggle();
      fullScreenToggle.removeEventListener('click', enableFullScreen, false);
      fullScreenToggle.addEventListener('click', enableFullScreen, false);
      // @@ xbrowser
      document.removeEventListener('fullScreenchange',fullScreenChange, false);
      document.removeEventListener('webkitfullscreenchange',fullScreenChange, false);
      document.removeEventListener('mozfullscreenchange',fullScreenChange, false);
      document.addEventListener('fullscreenchange', fullScreenChange, false);
      document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
      document.addEventListener('mozfullscreenchange', fullScreenChange, false);
   }
   return getSurface(dimensions);
};

/**
 * Set the Caption of the Display (document.title)
 * @param {String} title the title of the app
 * @param {gamejs.Image} icon FIXME implement favicon support
 */
exports.setCaption = function(title, icon) {
   document.title = title;
};

/** @ignore **/
exports._isSmoothingEnabled = function() {
   return !(_flags & DISABLE_SMOOTHING);
};

/**
 * The Display (the canvas element) is most likely not in the top left corner
 * of the browser due to CSS styling. To calculate the mouseposition within the
 * canvas we need this offset.
 * @see gamejs/event
 * @ignore
 *
 * @returns {Array} [x, y] offset of the canvas
 */

exports._getCanvasOffset = function() {
   var boundRect = getCanvas().getBoundingClientRect();
   return [boundRect.left, boundRect.top];
};

/**
 * Drawing on the Surface returned by `getSurface()` will draw on the screen.
 * @returns {gamejs.Surface} the display Surface
 */
var getSurface = exports.getSurface = function(dimensions) {
   if (SURFACE === null) {
      var canvas = getCanvas();
      if (dimensions === undefined) {
         dimensions = [canvas.clientWidth, canvas.clientHeight];
      }
      SURFACE = new Surface(dimensions);
      SURFACE._canvas = canvas;
      SURFACE._canvas.width = dimensions[0];
      SURFACE._canvas.height = dimensions[1];
      SURFACE._context = canvas.getContext('2d');
      if (!(_flags & DISABLE_SMOOTHING)) {
         SURFACE._smooth();
      } else {
         SURFACE._noSmooth();
      }
   }
   return SURFACE;
};

},{"./event":44,"./graphics":46}],44:[function(require,module,exports){
var display = require('./display');
var Callback = require('./utils/callback').Callback;

/**
 * @fileoverview
 * Deal with mouse and keyboard events.
 *
 * You can either handle all events in one callback with `gamejs.event.onEvent()`:
 *
 *     gamejs.onEvent(function(event) {
 *        if (event.type === gamejs.event.MOUSE_UP) {
 *          gamejs.logging.info(event.pos, event.button);
 *        } else if (event.type === gamejs.event.KEY_UP) {
 *          gamejs.logging.info(event.key);
 *        }
 *     });
 *
 * Or recieve more specific callbacks, e.g. only for `KEY\_UP` with  `gamejs.event.onKeyUp()`:
 *
 *     gamejs.onKeyUp(function(event) {
 *          gamejs.logging.info(event.key);
 *     });
 *
 * All events passed to your callback are instances of `gamejs.event.Event` and have a `type` property to help
 * you distinguish between the different events. This `type` property is set to one of those constants:
 *
 *  * gamejs.event.MOUSE\_UP
 *  * gamejs.event.MOUSE\_MOTION
 *  * gamejs.event.MOUSE\_DOWN
 *  * gamejs.event.KEY\_UP
 *  * gamejs.event.KEY\_DOWN
 *  * gamejs.event.DISPLAY\_FULLSCREEN\_ENABLED
 *  * gamejs.event.DISPLAY\_FULLSCREEN\_DISABLED
 *  * gamejs.event.QUIT
 *  * gamejs.event.MOUSE_WHEEL
 *  * gamejs.event.TOUCH\_DOWN
 *  * gamejs.event.TOUCH\_UP
 *  * gamejs.event.TOUCH\_MOTION
 *
 * ### Keyboard constants
 *
 * There are also a lot of keyboard constants for ASCII. Those are all prefixed with `K\_`, e.g. `gamejs.event.K\_a` would be the "a"
 * key and `gamejs.event.K_SPACE` is the spacebar.
 *
 * ## Touch events
 *
 * Touch events do not have a single position but for all `TOUCH\_*` events you get an array of
 * `touches`, which each have their own `pos` attribute and a unique `identifier` for tracking
 * this touch across multiple `TOUCH\_MOTION` events.
 *
 * ## User defined events
 *
 * All user defined events can have the value of `gamejs.event.USEREVENT` or higher.
 * Make sure your custom event ids follow this system.
 *
 * @example
 *     gamejs.onEvent(function(event) {
 *        if (event.type === gamejs.event.MOUSE_UP) {
 *          gamejs.logging.log(event.pos, event.button);
 *        } else if (event.type === gamejs.event.KEY_UP) {
 *          gamejs.logging.log(event.key);
 *        }
 *     });
 *
 */

var _CALLBACKS = [];

/** @ignore **/
var _triggerCallbacks = exports._triggerCallbacks = function() {
  var args = arguments;
  _CALLBACKS.forEach(function(cb) {
    if (cb.type === 'all' || args[0].type === cb.type) {
      cb.callback.apply(cb.scope, args);
    }
  });
};

/*
exports.onQuit(callback)
exports.onVisiblityChange(callback)
*/

/**
 * Pass a callback function to be called when Fullscreen is enabled or disabled.
 * Inspect `event.type` to distinguis between entering and exiting fullscreen.
 *
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onFullscreen = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
   _CALLBACKS.push({
      callback: callback,
      scope: scope,
      type: exports.DISPLAY_FULLSCREEN_ENABLED
   });
   _CALLBACKS.push({
      callback: callback,
      scope: scope,
      type: exports.DISPLAY_FULLSCREEN_DISABLED
   });
};

/**
 * The function passsed to `onEvent` will be called whenever
 * any event (mouse, keyboard, etc) was triggered.
 *
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onEvent = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: 'all'
  });
};


/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onDisplayResize = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   };

  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.DISPLAY_RESIZE
  });
}

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onMouseMotion = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.MOUSE_MOTION
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onMouseUp = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.MOUSE_UP
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onMouseDown = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.MOUSE_DOWN
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onTouchMotion = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.TOUCH_MOTION
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onTouchUp = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.TOUCH_UP
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onTouchDown = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.TOUCH_DOWN
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onKeyDown = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.KEY_DOWN
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onKeyUp = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.KEY_UP
  });
};

// key constants
exports.K_UP = 38;
exports.K_DOWN = 40;
exports.K_RIGHT = 39;
exports.K_LEFT = 37;

exports.K_SPACE = 32;
exports.K_BACKSPACE = 8;
exports.K_TAB = 9;
exports.K_ENTER = 13;
exports.K_SHIFT = 16;
exports.K_CTRL = 17;
exports.K_ALT = 18;
exports.K_ESC = 27;

exports.K_0 = 48;
exports.K_1 = 49;
exports.K_2 = 50;
exports.K_3 = 51;
exports.K_4 = 52;
exports.K_5 = 53;
exports.K_6 = 54;
exports.K_7 = 55;
exports.K_8 = 56;
exports.K_9 = 57;
exports.K_a = 65;
exports.K_b = 66;
exports.K_c = 67;
exports.K_d = 68;
exports.K_e = 69;
exports.K_f = 70;
exports.K_g = 71;
exports.K_h = 72;
exports.K_i = 73;
exports.K_j = 74;
exports.K_k = 75;
exports.K_l = 76;
exports.K_m = 77;
exports.K_n = 78;
exports.K_o = 79;
exports.K_p = 80;
exports.K_q = 81;
exports.K_r = 82;
exports.K_s = 83;
exports.K_t = 84;
exports.K_u = 85;
exports.K_v = 86;
exports.K_w = 87;
exports.K_x = 88;
exports.K_y = 89;
exports.K_z = 90;

exports.K_KP1 = 97;
exports.K_KP2 = 98;
exports.K_KP3 = 99;
exports.K_KP4 = 100;
exports.K_KP5 = 101;
exports.K_KP6 = 102;
exports.K_KP7 = 103;
exports.K_KP8 = 104;
exports.K_KP9 = 105;

// event type constants
exports.NOEVENT = 0;
exports.NUMEVENTS = 32000;

exports.DISPLAY_FULLSCREEN_ENABLED = 300;
exports.DISPLAY_FULLSCREEN_DISABLED = 301;
exports.DISPLAY_RESIZE = 302;

exports.QUIT = 0;
exports.KEY_DOWN = 1;
exports.KEY_UP = 2;
exports.MOUSE_MOTION = 3;
exports.MOUSE_UP = 4;
exports.MOUSE_DOWN = 5;
exports.MOUSE_WHEEL = 6;
exports.TOUCH_UP = 7;
exports.TOUCH_DOWN = 8;
exports.TOUCH_MOTION = 9;
exports.USEREVENT = 2000;



/**
 * Properties of the `event` object argument passed to the callbacks.
 * @class
 */

exports.Event = function() {
    /**
     * The type of the event. e.g., gamejs.event.QUIT, KEYDOWN, MOUSEUP.
     */
    this.type = null;
    /**
     * key the keyCode of the key. compare with gamejs.event.K_a, gamejs.event.K_b,...
     */
    this.key = null;
    /**
     * relative movement for a mousemove event
     */
    this.rel = null;
    /**
     * the number of the mousebutton pressed
     */
    this.button = null;
    /**
     * pos the position of the event for mouse events
     */
    this.pos = null;
};

/**
 * @ignore
 */
exports.init = function() {

   var lastPos = [];

   // anonymous functions as event handlers = memory leak, see MDC:elementAddEventListener

   function onMouseDown (ev) {
      var canvasOffset = display._getCanvasOffset();
      _triggerCallbacks({
         'type': exports.MOUSE_DOWN,
         'pos': [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],
         'button': ev.button,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });
   }

   function onMouseUp (ev) {
      var canvasOffset = display._getCanvasOffset();
      _triggerCallbacks({
         'type':exports.MOUSE_UP,
         'pos': [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],
         'button': ev.button,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });
   }

   function onKeyDown (ev) {
      var key = ev.keyCode || ev.which;
      _triggerCallbacks({
         'type': exports.KEY_DOWN,
         'key': key,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });

      // if the display has focus, we surpress default action
      // for most keys
      if (display._hasFocus() && (!ev.ctrlKey && !ev.metaKey &&
         ((key >= exports.K_LEFT && key <= exports.K_DOWN) ||
         (key >= exports.K_0    && key <= exports.K_z) ||
         (key >= exports.K_KP1  && key <= exports.K_KP9) ||
         key === exports.K_SPACE ||
         key === exports.K_TAB ||
         key === exports.K_ENTER)) ||
         key === exports.K_ALT ||
         key === exports.K_BACKSPACE) {
        ev.preventDefault();
      }
   }

   function onKeyUp (ev) {
      _triggerCallbacks({
         'type': exports.KEY_UP,
         'key': ev.keyCode,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });
   }

   function onMouseMove (ev) {
      var canvasOffset = display._getCanvasOffset();
      var currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];
      var relativePos = [];
      if (lastPos.length) {
         relativePos = [
            lastPos[0] - currentPos[0],
            lastPos[1] - currentPos[1]
         ];
      }
      _triggerCallbacks({
         'type': exports.MOUSE_MOTION,
         'pos': currentPos,
         'rel': relativePos,
         'buttons': null, // FIXME, fixable?
         'timestamp': ev.timeStamp,
         'movement': [ev.movementX       ||
                      ev.mozMovementX    ||
                      ev.webkitMovementX || 0,
                      ev.movementY       ||
                      ev.mozMovementY    ||
                      ev.webkitMovementY || 0
                      ]
      });
      lastPos = currentPos;
      return;
   }

   function onMouseScroll(ev) {
      var canvasOffset = display._getCanvasOffset();
      var currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];
      _triggerCallbacks({
         type: exports.MOUSE_WHEEL,
         pos: currentPos,
         delta: ev.detail || (- ev.wheelDeltaY / 40)
      });
      return;
   }

   function onBeforeUnload (ev) {
      _triggerCallbacks({
         'type': exports.QUIT
      });
      return;
   };

   // convert a w3c touch event into gamejs event
   function w3cTouchConvert(touchList) {
      var canvasOffset = display._getCanvasOffset();
      var tList = [];
      for (var i = 0; i < touchList.length; i++) {
         var touchEvent = touchList.item(i);
         tList.push({
            identifier: touchEvent.identifier,
            pos: [touchEvent.clientX - canvasOffset[0], touchEvent.clientY - canvasOffset[1]]
         });
      }
      return tList;
   }

   function onTouchDown(ev) {
      var canvasOffset = display._getCanvasOffset();
      var changedTouches = w3cTouchConvert(ev.changedTouches);
      _triggerCallbacks({
         'type': exports.TOUCH_DOWN,
         'touches': changedTouches
      });
   };

   function onTouchUp(ev) {
      var changedTouches = w3cTouchConvert(ev.changedTouches);
      _triggerCallbacks({
         'type': exports.TOUCH_UP,
         'touches': changedTouches,
      });
   }
   function onTouchMotion(ev) {
      var changedTouches = w3cTouchConvert(ev.changedTouches);
      _triggerCallbacks({
         'type': exports.TOUCH_MOTION,
         'touches': changedTouches
      });
      ev.preventDefault();
   }

   // IE does not support addEventListener on document itself
   // FX events don't reach body if mouse outside window or on menubar
   var canvas = display._getCanvas();
   document.addEventListener('mousedown', onMouseDown, false);
   document.addEventListener('mouseup', onMouseUp, false);
   document.addEventListener('keydown', onKeyDown, false);
   document.addEventListener('keyup', onKeyUp, false);
   document.addEventListener('mousemove', onMouseMove, false);
   canvas.addEventListener('mousewheel', onMouseScroll, false);
   // MOZFIX
   // https://developer.mozilla.org/en/Code_snippets/Miscellaneous#Detecting_mouse_wheel_events
   canvas.addEventListener('DOMMouseScroll', onMouseScroll, false);
   canvas.addEventListener('beforeunload', onBeforeUnload, false);
   // touchs
   canvas.addEventListener("touchstart", onTouchDown, false);
   canvas.addEventListener("touchend", onTouchUp, false);
   canvas.addEventListener("touchcancel", onTouchUp, false);
   canvas.addEventListener("touchleave", onTouchUp, false);
   canvas.addEventListener("touchmove", onTouchMotion, false);

};

},{"./display":43,"./utils/callback":63}],45:[function(require,module,exports){
var Surface = require('./graphics').Surface;
var objects = require('./utils/objects');

/**
 * @fileoverview Methods for creating Font objects which can render text
 * to a Surface.
 *
 * @example
 * var font = new Font('20px monospace');
 * // render text - this returns a surface with the text written on it.
 * var helloSurface = font.render('Hello World')
 */

/**
 * Create a Font to draw on the screen. The Font allows you to
 * `render()` text. Rendering text returns a Surface which
 * in turn can be put on screen.
 *
 * @constructor
 * @property {Number} fontHeight the line height of this Font
 *
 * @param {String} fontSettings a css font definition, e.g., "20px monospace"
 * @param {STring} backgroundColor valid #rgb string, "#ff00cc"
 */
var Font = exports.Font = function(fontSettings, backgroundColor) {
    /**
     * @ignore
     */
   this.sampleSurface = new Surface([10,10]);
   this.sampleSurface.context.font = fontSettings;
   this.sampleSurface.context.textAlign = 'start';
   // http://diveintohtml5.org/canvas.html#text
   this.sampleSurface.context.textBaseline = 'bottom';
   this.backgroundColor = backgroundColor || false;
   return this;
};

/**
 * Returns a Surface with the given text on it.
 * @param {String} text the text to render
 * @param {String} color a valid #RGB String, "#ffcc00"
 * @returns {gamejs.Surface} Surface with the rendered text on it.
 */
Font.prototype.render = function(text, color) {
   var dims = this.size(text);
   var surface = new Surface(dims);
   var ctx = surface.context;
   ctx.save();
   if ( this.backgroundColor ) {
       ctx.fillStyle = this.backgroundColor;
       ctx.fillRect(0, 0, surface.rect.width, surface.rect.height);
   }
   ctx.font = this.sampleSurface.context.font;
   ctx.textBaseline = this.sampleSurface.context.textBaseline;
   ctx.textAlign = this.sampleSurface.context.textAlign;
   ctx.fillStyle = ctx.strokeStyle = color || "#000000";
   ctx.fillText(text, 0, surface.rect.height, surface.rect.width);
   ctx.restore();
   return surface;
};

/**
 * Determine the width and height of the given text if rendered
 * with this Font.
 * @param {String} text the text to measure
 * @returns {Array} the [width, height] of the text if rendered with this Font
 */
Font.prototype.size = function(text) {
   var metrics = this.sampleSurface.context.measureText(text);
   // FIXME measuretext is buggy, make extra wide
   return [metrics.width, this.fontHeight];
};

/**
 * Height of the font in pixels.
 */
objects.accessors(Font.prototype, {
   'fontHeight': {
      get: function() {
         // Returns an approximate line height of the text
         // »This version of the specification does not provide a way to obtain
         // the bounding box dimensions of the text.«
         // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-measuretext
         return this.sampleSurface.context.measureText('M').width * 1.5;
      }
   }

});

},{"./graphics":46,"./utils/objects":64}],46:[function(require,module,exports){
/**
 * @fileoverview
 * This module holds the important `Surface` class which is the general container for image data.
 *
 *     var surface = new gamejs.graphics.Surface([width, height]);
 *
 * The functions
 * to draw geometric lines like circles, lines, rectangles, etc. are also all in this module:
 *
 *     gamejs.graphics.line(surface, '#ff0000', centerPoint, radius);
 *
 * Each Surface instance has methods to create *a new* rotated, flipped, scaled, etc. instance of itself:
 *
 *     // the original `surface` remains untouched by the
 *     // filp operation. A new Surface instance
 *     // is returned by `flip()`.
 *     var horizontalFlippedSurface = surface.flip(true);
 *
 * If you want to put images (png, jpg) on the screen, also see the `gamejs.image` module and `gamejs.preload()`.
 *
 * There are several ways to specify colors. Whenever the docs says "valid #RGB string"
 * you can pass in any of the following formats: `"#ff00ff"`, `"rgb(255, 0, 255)"` or `"rgba(255, 0, 255, 1)"`.
 *
 * @see gamejs/image
 */
var gamejs = require('../gamejs');
var Rect = gamejs.Rect;
var objects = require('./utils/objects');

/**
 * transform functions
 */
var matrix = require('./math/matrix');
var vectors = require('./math/vectors');

/**
 * A Surface represents a bitmap image with a fixed width and height. The
 * most important feature of a Surface is that they can be `blitted`
 * onto each other.
 *
 * @example
 * new gamejs.graphics.Surface([width, height]);
 * new gamejs.graphics.Surface(width, height);
 * new gamejs.graphics.Surface(rect);
 * @constructor
 *
 * @param {Array} dimensions Array holding width and height
 */
var Surface = exports.Surface = function() {
   var args = gamejs.normalizeRectArguments.apply(this, arguments);
   var width = args.left;
   var height = args.top;
   // unless argument is rect:
   if (arguments.length == 1 && arguments[0] instanceof Rect) {
      width = args.width;
      height = args.height;
   }
   // only for rotatation & scale
   /** @ignore */
   this._matrix = matrix.identity();
   /** @ignore */
    this._canvas = document.createElement("canvas");
    this._canvas.width = width;
    this._canvas.height = height;
    /** @ignore */
    this._blitAlpha = 1.0;

   /** @ignore */
   this._context = this._canvas.getContext('2d');
   // using exports is weird but avoids circular require
   if (gamejs.display._isSmoothingEnabled()) {
      this._smooth();
   } else {
      this._noSmooth();
   }
   return this;
};

/** @ignore */
Surface.prototype._noSmooth = function() {
    // disable image scaling
    // see https://developer.mozilla.org/en/Canvas_tutorial/Using_images#Controlling_image_scaling_behavior
    // and https://github.com/jbuck/processing-js/commit/65de16a8340c694cee471a2db7634733370b941c
    this.context.mozImageSmoothingEnabled = false;
  this.context.webkitImageSmoothingEnabled = false;
   return;
};
/** @ignore */
Surface.prototype._smooth = function() {
  this.context.mozImageSmoothingEnabled = true;
  this.context.webkitImageSmoothingEnabled = true;

};

/**
 * Blits another Surface on this Surface. The destination where to blit to
 * can be given (or it defaults to the top left corner) as well as the
 * Area from the Surface which should be blitted (e.g., for cutting out parts of
 * a Surface).
 *
 * @example
 * // blit flower in top left corner of display
 * displaySurface.blit(flowerSurface);
 *
 * // position flower at 10/10 of display
 * displaySurface.blit(flowerSurface, [10, 10])
 *
 * // ... `dest` can also be a rect whose topleft position is taken:
 * displaySurface.blit(flowerSurface, new gamejs.Rect([10, 10]);
 *
 * // only blit half of the flower onto the display
 * var flowerRect = flowerSurface.rect;
 * flowerRect = new gamejs.Rect([0,0], [flowerRect.width/2, flowerRect.height/2])
 * displaySurface.blit(flowerSurface, [0,0], flowerRect);
 *
 * @param {gamejs.graphics.Surface} src The Surface which will be blitted onto this one
 * @param {gamejs.Rect|Array} dst the Destination x, y position in this Surface.
 *            If a Rect is given, it's top and left values are taken. If this argument
 *            is not supplied the blit happens at [0,0].
 * @param {gamesjs.Rect|Array} area the Area from the passed Surface which
 *            should be blitted onto this Surface.
 * @param {Number} compositionOperation how the source and target surfaces are composited together; one of: source-atop, source-in, source-out, source-over (default), destination-atop, destination-in, destination-out, destination-over, lighter, copy, xor; for an explanation of these values see: http://dev.w3.org/html5/2dcontext/#dom-context-2d-globalcompositeoperation
 * @returns {gamejs.Rect} Rect actually repainted FIXME actually return something?
 */
Surface.prototype.blit = function(src, dest, area, compositeOperation) {

   var rDest, rArea;

   if (dest instanceof Rect) {
      rDest = dest.clone();
      var srcSize = src.getSize();
      if (!rDest.width) {
         rDest.width = srcSize[0];
      }
      if (!rDest.height) {
         rDest.height = srcSize[1];
      }
    } else if (dest && dest instanceof Array && dest.length == 2) {
      rDest = new Rect(dest, src.getSize());
    } else {
      rDest = new Rect([0,0], src.getSize());
    }
   compositeOperation = compositeOperation || 'source-over';

   // area within src to be drawn
   if (area instanceof Rect) {
      rArea = area;
   } else if (area && area instanceof Array && area.length == 2) {
      var size = src.getSize();
      rArea = new Rect(area, [size[0] - area[0], size[1] - area[1]]);
   } else {
      rArea = new Rect([0,0], src.getSize());
   }

   if (isNaN(rDest.left) || isNaN(rDest.top) || isNaN(rDest.width) || isNaN(rDest.height)) {
      throw new Error('[blit] bad parameters, destination is ' + rDest);
   }

   this.context.save();
   this.context.globalCompositeOperation = compositeOperation;
   this.context.globalAlpha = src._blitAlpha;
   this.context.drawImage(src.canvas, rArea.left, rArea.top, rArea.width, rArea.height, rDest.left, rDest.top, rDest.width, rDest.height);
   this.context.restore();
   return;
};

/**
 * @returns {Number[]} the width and height of the Surface
 */
Surface.prototype.getSize = function() {
   return [this.canvas.width, this.canvas.height];
};

/**
 * Obsolte, only here for compatibility.
 * @deprecated
 * @ignore
 * @returns {gamejs.Rect} a Rect of the size of this Surface
 */
Surface.prototype.getRect = function() {
   return new Rect([0,0], this.getSize());
};

/**
 * Fills the whole Surface with a color. Usefull for erasing a Surface.
 * @param {String} CSS color string, e.g. '#0d120a' or '#0f0' or 'rgba(255, 0, 0, 0.5)'
 * @param {gamejs.Rect} a Rect of the area to fill (defauts to entire surface if not specified)
 */
Surface.prototype.fill = function(color, rect) {
   this.context.save();
   this.context.fillStyle = color || "#000000";
   if (rect === undefined) {
       rect = new Rect(0, 0, this.canvas.width, this.canvas.height);
    }

   this.context.fillRect(rect.left, rect.top, rect.width, rect.height);
   this.context.restore();
   return;
};

/**
 * Clear the surface.
 */
Surface.prototype.clear = function(rect) {
   var size = this.getSize();
   rect = rect || new Rect(0, 0, size[0], size[1]);
   this.context.clearRect(rect.left, rect.top, rect.width, rect.height);
   return;
};

objects.accessors(Surface.prototype, {
   /**
    * @type gamejs.Rect
    */
   'rect': {
      get: function() {
         return this.getRect();
      }
   },
   /**
    * @ignore
    */
   'context': {
      get: function() {
         return this._context;
      }
   },
   'canvas': {
      get: function() {
         return this._canvas;
      }
   }
});

/**
 * @returns {gamejs.graphics.Surface} a clone of this surface
 */
Surface.prototype.clone = function() {
  var newSurface = new Surface(this.getRect());
  newSurface.blit(this);
  return newSurface;
};

/**
 * @returns {Number} current alpha value
 */
Surface.prototype.getAlpha = function() {
   return (1 - this._blitAlpha);
};

/**
 * Set the alpha value for the whole Surface. When blitting the Surface on
 * a destination, the pixels will be drawn slightly transparent.
 * @param {Number} alpha value in range 0.0 - 1.0
 * @returns {Number} current alpha value
 */
Surface.prototype.setAlpha = function(alpha) {
   if (isNaN(alpha) || alpha < 0 || alpha > 1) {
      return;
   }

   this._blitAlpha = (1 - alpha);
   return (1 - this._blitAlpha);
};

/**
 * The data must be represented in left-to-right order, row by row top to bottom,
 * starting with the top left, with each pixel's red, green, blue, and alpha components
 * being given in that order for each pixel.
 * @see http://dev.w3.org/html5/2dcontext/#canvaspixelarray
 * @returns {ImageData} an object holding the pixel image data {data, width, height}
 */
Surface.prototype.getImageData = function() {
   var size = this.getSize();
   return this.context.getImageData(0, 0, size[0], size[1]);
};



// FIXME all draw functions must return a minimal rect containing the drawn shape

/**
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color valid #RGB string, e.g., "#ff0000"
 * @param {Array} startPos [x, y] position of line start
 * @param {Array} endPos [x, y] position of line end
 * @param {Number} width of the line, defaults to 1
 */
exports.line = function(surface, color, startPos, endPos, width) {
   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = color;
   ctx.lineWidth = width || 1;
   ctx.moveTo(startPos[0], startPos[1]);
   ctx.lineTo(endPos[0], endPos[1]);
   ctx.stroke();
   ctx.restore();
   return;
};

/**
 * Draw connected lines. Use this instead of indiviudal line() calls for
 * better performance
 *
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB string, "#ff0000"
 * @param {Boolean} closed if true the last and first point are connected
 * @param {Array} pointlist holding array [x,y] arrays of points
 * @param {Number} width width of the lines, defaults to 1
 */
exports.lines = function(surface, color, closed, pointlist, width) {
   closed = closed || false;
   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   ctx.lineWidth = width || 1;
   pointlist.forEach(function(point, idx) {
      if (idx === 0) {
         ctx.moveTo(point[0], point[1]);
      } else {
         ctx.lineTo(point[0], point[1]);
      }
   });
   if (closed) {
      ctx.lineTo(pointlist[0][0], pointlist[0][1]);
   }
   ctx.stroke();
   ctx.restore();
   return;
};

/**
 * Draw a circle on Surface
 *
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {Array} pos [x, y] position of the circle center
 * @param {Number} radius of the circle
 * @param {Number} width width of the circle, if not given or 0 the circle is filled
 */
exports.circle = function(surface, color, pos, radius, width) {
   if (isNaN(radius)) {
      throw new Error('[circle] radius required argument');
   }
   if (!pos || !(pos instanceof Array)) {
      throw new Error('[circle] pos must be given & array' + pos);
   }

   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   ctx.lineWidth = width || 1;
   ctx.arc(pos[0], pos[1], radius, 0, 2*Math.PI, true);
   if (width === undefined || width === 0) {
      ctx.fill();
   } else {
      ctx.stroke();
   }
   ctx.restore();
   return;
};

/**
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {gamejs.Rect} rect the position and dimension attributes of this Rect will be used
 * @param {Number} width the width of line drawing the Rect, if 0 or not given the Rect is filled.
 */
exports.rect = function(surface, color, rect, width) {
   var ctx =surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   if (isNaN(width) || width === 0) {
      ctx.fillRect(rect.left, rect.top, rect.width, rect.height);
   } else {
      ctx.lineWidth = width || 1;
      ctx.strokeRect(rect.left, rect.top, rect.width, rect.height);
   }
   ctx.restore();
};

/**
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {Array} pos [x, y] position of the circle center
 * @param {Number} startAngle, both angles in radians
 * @param {Number} stopAngle
 * @param {Number} radius
 * @param {Number} width the width of line, if 0 or not given the arc is filled.
 */
exports.arc= function(surface, color, pos, startAngle, stopAngle, radius, width) {
   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   ctx.arc(pos[0], pos[1],
            radius,
            startAngle, stopAngle,
            false
         );
   if (isNaN(width) || width === 0) {
      ctx.fill();
   } else {
      ctx.lineWidth = width || 1;
      ctx.stroke();
   }
   ctx.restore();
};

/**
 * Draw a polygon on the surface. The pointlist argument are the vertices
 * for the polygon.
 *
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {Array} pointlist array of vertices [x, y] of the polygon
 * @param {Number} width the width of line, if 0 or not given the polygon is filled.
 */
exports.polygon = function(surface, color, pointlist, width) {
   var ctx = surface.context;
   ctx.save();
   ctx.fillStyle = ctx.strokeStyle = color;
   ctx.beginPath();
   pointlist.forEach(function(point, idx) {
      if (idx === 0) {
         ctx.moveTo(point[0], point[1]);
      } else {
         ctx.lineTo(point[0], point[1]);
      }
   });
   ctx.closePath();
   if (isNaN(width) || width === 0) {
      ctx.fill();
   } else {
      ctx.lineWidth = width || 1;
      ctx.stroke();
   }
   ctx.restore();
};

/**
 * Draw a quadratic curve with one control point on the surface.
 * The control point position defines the shape of the quadratic curve.
 *
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color valid #RGB string, e.g., "#ff0000"
 * @param {Array} startPos [x, y] the start position for the quadratic curve
 * @param {Array} endPos [x, y] the end position for the quadratic curve
 * @param {Array} controlPos [x, y] position of the control point
 * @param {Number} width of the quadratic curve, defaults to 1
 */
exports.quadraticCurve = function(surface, color, startPos, endPos, controlPos, width) {
   if (!startPos || !(startPos instanceof Array)) {
      throw new Error('[quadratic_curve] startPos must be defined!');
   }
   if (!endPos || !(endPos instanceof Array)) {
      throw new Error('[quadratic_curve] endPos must be defined!');
   }
   if (!controlPos || !(controlPos instanceof Array)) {
      throw new Error('[quadratic_curve] controlPos must be defined!');
   }

   var ctx = surface.context;
   ctx.save();
   ctx.fillStyle = ctx.strokeStyle = color;
   ctx.lineWidth = width || 1;

   ctx.beginPath();
   ctx.moveTo(startPos[0], startPos[1]);
   ctx.quadraticCurveTo(controlPos[0], controlPos[1], endPos[0], endPos[1]);
   ctx.stroke();

   ctx.restore();
};

/**
 * Draw a bezier curve with two control points on the surface.
 * The control point positions define the shape of the bezier curve.
 *
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color valid #RGB string, e.g., "#ff0000"
 * @param {Array} startPos [x, y] the start position for the bezier curve
 * @param {Array} endPos [x, y] the end position for the bezier curve
 * @param {Array} ct1Pos [x, y] position of the first control point
 * @param {Array} ct2Pos [x, y] position of the second control point
 * @param {Number} width of the bezier curve, defaults to 1
 */
exports.bezierCurve = function(surface, color, startPos, endPos, ct1Pos, ct2Pos, width) {
   if (!startPos || !(startPos instanceof Array)) {
      throw new Error('[bezier_curve] startPos must be defined!');
   }
   if (!endPos || !(endPos instanceof Array)) {
      throw new Error('[bezier_curve] endPos must be defined!');
   }
   if (!ct1Pos || !(ct1Pos instanceof Array)) {
      throw new Error('[bezier_curve] ct1Pos must be defined!');
   }
   if (!ct2Pos || !(ct2Pos instanceof Array)) {
      throw new Error('[bezier_curve] ct2Pos must be defined!');
   }
   var ctx = surface.context;
   ctx.save();
   ctx.fillStyle = ctx.strokeStyle = color;
   ctx.lineWidth = width || 1;

   ctx.beginPath();
   ctx.moveTo(startPos[0], startPos[1]);
   ctx.bezierCurveTo(ct1Pos[0], ct1Pos[1], ct2Pos[0], ct2Pos[1], endPos[0], endPos[1]);
   ctx.stroke();

   ctx.restore();
};

/**
 * Returns a new surface which holds this surface rotate by angle degrees.
 * Unless rotating by 90 degree increments, the image will be padded larger to hold the new size.
 * @param {angel} angle Clockwise angle by which to rotate
 * @returns {Surface} new, rotated surface
 */
Surface.prototype.rotate = function (angle) {
   var origSize = this.getSize();
   var radians = (angle * Math.PI / 180);
   var newSize = origSize;
   // find new bounding box
   if (angle % 360 !== 0) {
      var rect = this.getRect();
      var points = [
         [-rect.width/2, rect.height/2],
         [rect.width/2, rect.height/2],
         [-rect.width/2, -rect.height/2],
         [rect.width/2, -rect.height/2]
      ];
      var rotPoints = points.map(function(p) {
         return vectors.rotate(p, radians);
      });
      var xs = rotPoints.map(function(p) { return p[0]; });
      var ys = rotPoints.map(function(p) { return p[1]; });
      var left = Math.min.apply(Math, xs);
      var right = Math.max.apply(Math, xs);
      var bottom = Math.min.apply(Math, ys);
      var top = Math.max.apply(Math, ys);
      newSize = [right-left, top-bottom];
   }
   var newSurface = new Surface(newSize);
   var m = matrix.translate(this._matrix, origSize[0]/2, origSize[1]/2);
   m = matrix.rotate(m, radians);
   m = matrix.translate(m, -origSize[0]/2, -origSize[1]/2);
   var offset = [(newSize[0] - origSize[0]) / 2, (newSize[1] - origSize[1]) / 2];
   newSurface.context.save();
   newSurface.context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
   newSurface.blit(this, offset);
   newSurface.context.restore();
   return newSurface;
};

/**
 * Returns a new surface holding the scaled surface.
 * @param {Array} dimensions new [width, height] of surface after scaling
 * @returns {Surface} new, scaled surface
 */
Surface.prototype.scale = function(dims) {
   var width = dims[0];
   var height = dims[1];
   if (width <= 0 || height <= 0) {
      throw new Error('[gamejs.transform.scale] Invalid arguments for height and width', [width, height]);
   }
   var oldDims = this.getSize();
   var ws = width / oldDims[0];
   var hs = height / oldDims[1];
   var newSurface = new Surface([width, height]);
   var originalMatrix = this._matrix.slice(0);
   var m = matrix.scale(matrix.identity(), [ws, hs]);
   newSurface.context.save();
   newSurface.context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
   newSurface.blit(this);
   newSurface.context.restore();
   return newSurface;
};

/**
 * Flip a Surface either vertically, horizontally or both. This returns
 * a new Surface (i.e: nondestructive).
 * @param {Boolean} flipHorizontal
 * @param {Boolean} flipVertical
 * @returns {Surface} new, flipped surface
 */
Surface.prototype.flip = function(flipHorizontal, flipVertical) {
   var dims = this.getSize();
   var newSurface = new Surface(dims);
   var scaleX = 1;
   var scaleY = 1;
   var xPos = 0;
   var yPos = 0;
   if (flipHorizontal === true) {
      scaleX = -1;
      xPos = -dims[0];
   }
   if (flipVertical === true) {
      scaleY = -1;
      yPos = -dims[1];
   }
   newSurface.context.save();
   newSurface.context.scale(scaleX, scaleY);
   newSurface.context.drawImage(this.canvas, xPos, yPos);
   newSurface.context.restore();
   return newSurface;
};


/**
 * Directly copy values from an array into a Surface.
 *
 * This is faster than blitting the `surface` property on a SurfaceArray
 *
 * The array must be the same dimensions as the Surface and will completely
 * replace all pixel values.
 * @param {gamejs.graphics.Surface} surface
 * @param {gamejs.graphics.Surfacearray.SurfaceArray} surfaceArray
 */
exports.blitArray = function(surface, surfaceArray) {
   surface.context.putImageData(surfaceArray.imageData, 0, 0);
   return;
};

/**
 * Fast pixel access. The SurfaceArray can be constructed with a surface whose values
 * are then used to initialize the pixel array.
 *
 * The surface passed as argument is not modified by the SurfaceArray.
 *
 * If an array is used to construct SurfaceArray, the array must describe
 * the dimensions of the SurfaceArray [width, height].
 *
 * @example
 *
 *   // create array from display surface
 *   var srfArray = new SurfaceArray(display);
 *   // direct pixel access
 *   srfArray.set(50, 100, [255, 0, 0, 100]);
 *   console.log(srfArray.get(30, 50));
 *   // blit modified array back to display surface
 *   blitArray(display, srfArray);
 *
 * @param {gamejs.graphics.Surface|Array} surfaceOrDimensions
 * @see http://dev.w3.org/html5/2dcontext/#pixel-manipulation
 */
var SurfaceArray = exports.SurfaceArray = function(surfaceOrDimensions) {
   var size = null;
   var data = null;
   var imageData = null;

   /**
    * Set rgba value at position x, y.
    *
    * For performance reasons this function has only one signature
    * being Number, Number, Array[4].
    *
    * @param {Number} x x position of pixel
    * @param {Number} y y position of pixel
    * @param {Array} rgba [red, green, blue, alpha] values [255, 255, 255, 255] (alpha, the last argument defaults to 255)
    * @throws Error if x, y out of range
    */
   this.set = function(x, y, rgba) {
      var offset = (x * 4) + (y * size[0] * 4);
      /** faster without
      if (offset + 3 >= data.length || x < 0 || y < 0) {
         throw new Error('x, y out of range', x, y);
      }
      **/
      data[offset] = rgba[0];
      data[offset+1] = rgba[1];
      data[offset+2] = rgba[2];
      data[offset+3] = rgba[3] === undefined ? 255 : rgba[3];
      return;
   };

   /**
    * Get rgba value at position xy,
    * @param {Number} x
    * @param {Number} y
    * @returns {Array} [red, green, blue, alpha]
    */
   this.get = function(x, y) {
      var offset = (x * 4) + (y * size[0] * 4);
      return [
         data[offset],
         data[offset+1],
         data[offset+2],
         data[offset+3]
      ];
   };

   /**
    * a new gamejs.graphics.Surface on every access, representing
    * the current state of the SurfaceArray.
    * @type {gamejs.graphics.Surface}
    */
   // for jsdoc only
   this.surface = null;

   objects.accessors(this, {
      surface: {
         get: function() {
            var s = new gamejs.graphics.Surface(size);
            s.context.putImageData(imageData, 0, 0);
            return s;
         }
      },
      imageData: {
         get: function() {
            return imageData;
         }
      }
   });

   this.getSize = function() {
      return size;
   };

   /**
    * constructor
    */
   if (surfaceOrDimensions instanceof Array) {
      size = surfaceOrDimensions;
      imageData = gamejs.display.getSurface().context.createImageData(size[0], size[1]);
      data = imageData.data;
   } else {
      size = surfaceOrDimensions.getSize();
      imageData = surfaceOrDimensions.getImageData(0, 0, size[0], size[1]);
      data = imageData.data;
   }
   return this;
};

},{"../gamejs":"gamejs","./math/matrix":52,"./math/vectors":55,"./utils/objects":64}],47:[function(require,module,exports){
/**
 * @fileoverview Make synchronous http requests to your game's serverside component.
 *
 * If you configure a ajax base URL you can make http requests to your
 * server using those functions.

 * The most high-level functions are `load()` and `save()` which take
 * and return a JavaScript object, which they will send to / recieve from
 * the server-side in JSON format.
 *
 *
 */

/**
 * Response object returned by http functions `get` and `post`. This
 * class is not instantiable.
 *
 * @param{String} responseText
 * @param {String} responseXML
 * @param {Number} status
 * @param {String} statusText
 */
exports.Response = function() {
   /**
    * @param {String} header
    */
   this.getResponseHeader = function(header)  {
   };
   throw new Error('response class not instantiable');
};

/**
 * Make http request to server-side
 * @param {String} method http method
 * @param {String} url
 * @param {String|Object} data
 * @param {String|Object} type "Accept" header value
 * @return {Response} response
 */
var ajax = exports.ajax = function(method, url, data, type) {
   data = data || null;
   var response = new XMLHttpRequest();
   response.open(method, url, false);
   if (type) {
      response.setRequestHeader("Accept", type);
   }
   if (data instanceof Object) {
      data = JSON.stringify(data);
      response.setRequestHeader('Content-Type', 'application/json');
   }
   response.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
   response.send(data);
   return response;
};

/**
 * Make http GET request to server-side
 * @param {String} url
 */
var get = exports.get = function(url) {
   return ajax('GET', url);
};

/**
 * Make http POST request to server-side
 * @param {String} url
 * @param {String|Object} data
 * @param {String|Object} type "Accept" header value
 * @returns {Response}
 */
var post = exports.post = function(url, data, type) {
   return ajax('POST', url, data, type);
};

function stringify(response) {
   /* jshint ignore:start */
   return eval('(' + response.responseText + ')');
   /* jshint ignore:end */
}

function ajaxBaseHref() {
    return (window.$g && window.$g.ajaxBaseHref) || './';
}

/**
 * Load an object from the server-side.
 * @param {String} url
 * @return {Object} the object loaded from the server
 */
exports.load = function(url) {
   return stringify(get(ajaxBaseHref() + url));
};

/**
 * Send an object to a server-side function.
 * @param {String} url
 * @param {String|Object} data
 * @param {String|Object} type "Accept" header value
 * @returns {Object} the response object
 */
exports.save = function(url, data, type) {
   return stringify(post(ajaxBaseHref() + url, {payload: data}, type));
};

},{}],48:[function(require,module,exports){
var gamejs = require('../gamejs');

/**
 * @fileoverview Load images as Surfaces.
 *
 * Sounds & Images are loaded relative to your game's html page
 * (the html which includes the GameJs code) or relative to the
 * property `window.$g.resourceBaseHref`
 * if it is set.
 *
 *
 */

var CACHE = {};

/**
 * need to export preloading status for require
 * @ignore
 */
var _PRELOADING = false;

/**
 * Load image and return it on a Surface.
 *
 * All images must be preloaded before they can be used.
 * @example

 *     gamejs.preload(["./images/ship.png", "./images/sunflower.png"]);
 *     // ...later...
 *     display.blit(gamejs.image.load('images/ship.png'))
 *
 * @param {String|dom.Image} uriOrImage resource uri for image
 * @returns {gamejs.graphics.Surface} surface with the image on it.
 */
exports.load = function(key) {
   var img;
   if (typeof key === 'string') {
      img = CACHE[key];
      if (!img) {
			throw new Error('Missing "' + key + '", gamejs.preload() all images before trying to load them.');
      }
   } else {
      img = key;
   }
   var canvas = document.createElement('canvas');
   // IEFIX missing html5 feature naturalWidth/Height
   canvas.width = img.naturalWidth || img.width;
   canvas.height = img.naturalHeight || img.height;
   var context = canvas.getContext('2d');
   context.drawImage(img, 0, 0);
   img.getSize = function() { return [img.naturalWidth, img.naturalHeight]; };
   var surface = new gamejs.graphics.Surface(img.getSize());
   // NOTE hack setting protected _canvas directly
   surface._canvas = canvas;
   surface._context = context;
   return surface;
};


/**
 * add all images on the currrent page into cache
 * @ignore
 */
exports.init = function() {
   return;
};

/**
 * preload the given img URIs
 * @returns {Function} which returns 0-1 for preload progress
 * @ignore
 */
exports.preload = function(imgIdents) {

   var countLoaded = 0;
   var countTotal = 0;

   function incrementLoaded() {
      countLoaded++;
      if (countLoaded == countTotal) {
         _PRELOADING = false;
      }
      if (countLoaded % 10 === 0) {
         gamejs.logging.debug('gamejs.image: preloaded  ' + countLoaded + ' of ' + countTotal);
      }
   }

   function getProgress() {
      return countTotal > 0 ? countLoaded / countTotal : 1;
   }

   function successHandler() {
      addToCache(this);
      incrementLoaded();
   }
   function errorHandler() {
      incrementLoaded();
      throw new Error('Error loading ' + this.src);
   }

   var key;
   for (key in imgIdents) {
      var lowerKey = key.toLowerCase();
      if (lowerKey.indexOf('.png') == -1 &&
            lowerKey.indexOf('.jpg') == -1 &&
            lowerKey.indexOf('.jpeg') == -1 &&
            lowerKey.indexOf('.svg') == -1 &&
            lowerKey.indexOf('.gif') == -1) {
         continue;
      }
      var img = new Image();
      img.addEventListener('load', successHandler, true);
      img.addEventListener('error', errorHandler, true);
      img.src = imgIdents[key];
      img.gamejsKey = key;
      countTotal++;
   }
   if (countTotal > 0) {
      _PRELOADING = true;
   }
   return getProgress;
};

/**
 * add the given <img> dom elements into the cache.
 * @private
 */
var addToCache = function(img) {
   CACHE[img.gamejsKey] = img;
   return;
};

},{"../gamejs":"gamejs"}],49:[function(require,module,exports){

/**
 * @fileoverview Static methods for logging and setting the log level. All logging functions (`info()`, `debug()`, etc.) take
 * any number of arguments and will print them in one line.
 *
 */

var DEBUG_LEVELS = ['debug', 'info', 'warn', 'error', 'fatal'];
var debugLevel = 2;
var gamejs = require('../gamejs');

/**
 * set logLevel as string or number
 *   * 0 = info
 *   * 1 = warn
 *   * 2 = error
 *   * 3 = fatal
 *
 * @example
 * gamejs.setLogLevel(0); // debug
 * gamejs.setLogLevel('error'); // equal to setLogLevel(2)
 */
exports.setLogLevel = function(logLevel) {
   if (typeof logLevel === 'string' && DEBUG_LEVELS.indexOf(logLevel)) {
      debugLevel = DEBUG_LEVELS.indexOf(logLevel);
   } else if (typeof logLevel === 'number') {
      debugLevel = logLevel;
   } else {
      throw new Error('invalid logLevel ', logLevel, ' Must be one of: ', DEBUG_LEVELS);
   }
   return debugLevel;
};

/**
 * Log a msg to the console if console is enable
 * @param {String} message,... the msg to log
 */
var log = exports.log = function() {

   if (gamejs.thread.inWorker === true) {
      gamejs.thread._logMessage.apply(null, arguments);
      return;
   }

   // IEFIX can't call apply on console
   var args = Array.prototype.slice.apply(arguments, [0]);
   args.unshift(Date.now());
   if (window.console !== undefined && console.log.apply) {
      console.log.apply(console, args);
   }
};
/**
 * @param {String} message,... to log
 */
exports.debug = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('debug')) {
      log.apply(this, arguments);
   }
};
/**
 * @param {String} message,... to log
 */
exports.info = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('info')) {
      log.apply(this, arguments);
   }
};
/**
 * @param {String} message,... to log
 */
exports.warn = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('warn')) {
      log.apply(this, arguments);
   }
};
/**
 * @param {String} message,... to log
 */
exports.error = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('error')) {
      log.apply(this, arguments);
   }
};
/**
 * @param {String} message to log
 */
exports.fatal = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('fatal')) {
      log.apply(this, arguments);
   }
};

},{"../gamejs":"gamejs"}],50:[function(require,module,exports){
/**
 * @fileoverview Degrees and radians.
 *
 */

/**
 *
 * absolute angle to relative angle, in degrees
 * @param {Number} absolute angle in degrees
 * @returns {Number} relative angle in degrees
 */
exports.normaliseDegrees=function(degrees){
    degrees=degrees % 360;
    if(degrees<0) {
        degrees+=360;
    }
    return degrees;
};

/**
 *
 * absolute angle to relative angle, in radians
 * @param {Number} absolute angle in radians
 * @returns {Number} relative angle in radians
 */
exports.normaliseRadians=function(radians){
    radians=radians % (2*Math.PI);
    if(radians<0) {
        radians+=(2*Math.PI);
    }
    return radians;
};

/**
 *
 * convert radians to degrees
 * @param {Number} radians
 * @returns {Number} degrees
 */
exports.degrees=function(radians) {
    return radians*(180/Math.PI);
};

/**
 *
 * convert degrees to radians
 * @param {Number} degrees
 * @returns {Number} radians
 */
exports.radians=function(degrees) {
    return degrees*(Math.PI/180);
};

},{}],51:[function(require,module,exports){
/**
 * @fileoverview Binary Heap implementation from Eloquent JavaScript
 *
 * @see http://eloquentjavascript.net/appendix2.html
 */
var BinaryHeap = exports.BinaryHeap = function(scoreFunction){
   /**
    * @ignore
    */
   this.content = [];
   /**
    * @ignore
    */
   this.scoreFunction = scoreFunction;
   return this;
};

/**
 * Add element to heap.
 * @param {Object} element
 */
BinaryHeap.prototype.push = function(element) {
   this.content.push(element);
   this.sinkDown(this.content.length - 1);
   return;
};

/**
 * Return first element from heap.
 * @param {Object} element
 * @returns {Object} element
 */
BinaryHeap.prototype.pop = function() {
   // Store the first element so we can return it later.
   var result = this.content[0];
   // Get the element at the end of the array.
   var end = this.content.pop();
   // If there are any elements left, put the end element at the
   // start, and let it bubble up.
   if (this.content.length > 0) {
      this.content[0] = end;
      this.bubbleUp(0);
   }
   return result;
};

/**
 * Remove the given element from the heap.
 * @param {Object} element
 * @throws {Error} if node not found
 * @returns true if the node was round and removed or fals otherwise
 */
BinaryHeap.prototype.remove = function(node) {
   // To remove a value, we must search through the array to find
   // it.
   var isFound = this.content.some(function(cNode, idx) {
      if (cNode == node) {
         var end = this.content.pop();
         if (idx != this.content.length) {
            this.content[idx] = end;
            if (this.scoreFunction(end) < this.scoreFunction(node)) {
               this.sinkDown(idx);
            } else {
               this.bubbleUp(idx);
            }
         }
         return true;
      }
      return false;
   }, this);
   return isFound;
};

/**
 * Number of elements in heap.
 */
BinaryHeap.prototype.size = function() {
   return this.content.length;
};

/**
 * @ignore
 */
BinaryHeap.prototype.sinkDown = function(idx) {
   // Fetch the element that has to be sunk
   var element = this.content[idx];
   // When at 0, an element can not sink any further.
   while (idx > 0) {
      // Compute the parent element's index, and fetch it.
      var parentIdx = Math.floor((idx + 1) / 2) - 1;
      var parent = this.content[parentIdx];
      // Swap the elements if the parent is greater.
      if (this.scoreFunction(element) < this.scoreFunction(parent)) {
         this.content[parentIdx] = element;
         this.content[idx] = parent;
         // Update 'n' to continue at the new position.
         idx = parentIdx;
      // Found a parent that is less, no need to sink any further.
      } else {
         break;
      }
   }
   return;
};

/**
 * @ignore
 */
BinaryHeap.prototype.bubbleUp = function(idx) {
   // Look up the target element and its score.
   var length = this.content.length;
   var element = this.content[idx];
   var elemScore = this.scoreFunction(element);

   while(true) {
      // Compute the indices of the child elements.
      var child2Idx = (idx + 1) * 2;
      var child1Idx= child2Idx - 1;
      // This is used to store the new position of the element,
      // if any.
      var swapIdx = null;
      // If the first child exists (is inside the array)...
      var child1Score;
      if (child1Idx < length) {
         // Look it up and compute its score.
         var child1 = this.content[child1Idx];
         child1Score = this.scoreFunction(child1);
         // If the score is less than our element's, we need to swap.
         if (child1Score < elemScore) {
            swapIdx = child1Idx;
         }
      }
      // Do the same checks for the other child.
      if (child2Idx < length) {
         var child2 = this.content[child2Idx];
         var child2Score = this.scoreFunction(child2);
         if (child2Score < (swapIdx === null ? elemScore : child1Score)) {
            swapIdx = child2Idx;
         }
      }

      // If the element needs to be moved, swap it, and continue.
      if (swapIdx !== null) {
         this.content[idx] = this.content[swapIdx];
         this.content[swapIdx] = element;
         idx = swapIdx;
      // Otherwise, we are done.
      } else {
         break;
      }
   }
   return;
};

},{}],52:[function(require,module,exports){
/**
 * @fileoverview Matrix manipulation, used by GameJs itself. You
 * probably do not need this unless you manipulate a Context's transformation
 * matrix yourself.
 */

// correct way to do scale, rotate, translate
// *  gamejs.utils.matrix will be used in gamejs.transforms, modifing the surfaces.matrix
// * this matrix must be applied to the context in Surface.draw()

/**
 * @returns {Array} [1, 0, 0, 1, 0, 0]
 */
var identiy = exports.identity = function () {
   return [1, 0, 0, 1, 0, 0];
};

/**
 * @param {Array} matrix
 * @param {Array} matrix
 * @returns {Array} matrix sum
 */
var add = exports.add = function(m1, m2) {
   return [
      m1[0] + m2[0],
      m1[1] + m2[1],
      m1[2] + m2[2],
      m1[3] + m2[3],
      m1[4] + m2[4],
      m1[5] + m2[5],
      m1[6] + m2[6]
   ];
};

/**
 * @param {Array} matrix A
 * @param {Array} matrix B
 * @returns {Array} matrix product
 */
var multiply = exports.multiply = function(m1, m2) {
   return [
      m1[0] * m2[0] + m1[2] * m2[1],
      m1[1] * m2[0] + m1[3] * m2[1],
      m1[0] * m2[2] + m1[2] * m2[3],
      m1[1] * m2[2] + m1[3] * m2[3],
      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
   ];
};

/**
 * @param {Array} matrix
 * @param {Number} dx
 * @param {Number} dy
 * @returns {Array} translated matrix
 */
var translate = exports.translate = function(m1, dx, dy) {
   return multiply(m1, [1, 0, 0, 1, dx, dy]);
};

/**
 * @param {Array} matrix
 * @param {Number} angle in radians
 * @returns {Array} rotated matrix
 */
var rotate = exports.rotate = function(m1, angle) {
   // radians
   var sin = Math.sin(angle);
   var cos = Math.cos(angle);
   return multiply(m1, [cos, sin, -sin, cos, 0, 0]);
};

/**
 * @param {Array} matrix
 * @returns {Number} rotation in radians
 */
var rotation = exports.rotation = function(m1) {
      return Math.atan2(m1[1], m1[0]);
};

/**
 * @param {Array} matrix
 * @param {Array} vector [a, b]
 * @returns {Array} scaled matrix
 */
var scale = exports.scale = function(m1, svec) {
   var sx = svec[0];
   var sy = svec[1];
   return multiply(m1, [sx, 0, 0, sy, 0, 0]);
};

},{}],53:[function(require,module,exports){
/**
 * @fileoverview
 * A noise generator comparable to Perlin noise, which is useful
 * for generating procedural content.
 *
 * This implementation provides 2D and 3D noise:
 *
 *    var simplex = new Simplex();
 *    simplex.get(2, 4);
 *    simple.get3d(1, 2, 4);
 *
 * You can optionally
 * pass a seedable pseudo-random number generator to its constructor. This
 * generator object is assumed to have a `random()` method; `Math` is used
 * per default:
 *
 *     var Alea = require('gamejs/math/random').Alea;
 *     var simplex = new Simplex(new Alea());
 *
 * Also see `gamejs/math/random` for a seedable pseudo random number generator
 *
 * @see gamejs/utils/prng
 */

// Ported to JS by by zz85 <https://github.com/zz85> from Stefan
// Gustavson's java implementation
// <http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf>
// Read Stefan's excellent paper for details on how this code works.
//
// Sean McCullough banksean@gmail.com

/**
 * @param {Object} randomNumberGenerator the random number generator to use; most provide `random()` method
 * @usage
 *  var simplex = new gamejs.noise.Simplex();
 *  simplex.get(x, y);
 *  // or for 3d noise
 *  simple.get(x, y, y);
 */

var Simplex = exports.Simplex = function(r) {
  if (r === undefined) {
    r = Math;
  }
  /** @ignore */
  this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
               [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
               [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
  /** @ignore */
  this.p = [];
  var i;
  for (i=0; i<256; i++) {
   this.p[i] = Math.floor(r.random()*256);
  }
  // To remove the need for index wrapping, double the permutation table length
  /** @ignore */
  this.perm = [];
  for(i=0; i<512; i++) {
    this.perm[i]=this.p[i & 255];
  }

  // A lookup table to traverse the simplex around a given point in 4D.
  // Details can be found where this table is used, in the 4D noise method.
  /** @ignore */
  this.simplex = [
    [0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],
    [0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],
    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],
    [1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],
    [1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],
    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],
    [2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],
    [2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]];
};

/** @ignore */
Simplex.prototype.dot = function(g, x, y) {
   return g[0]*x + g[1]*y;
};

/**
 * @param {Number} x
 * @param {Number} y
 * @returns {Number} noise for given position, in range [-1, 1]
 */
Simplex.prototype.get = function(xin, yin) {
  var n0, n1, n2; // Noise contributions from the three corners
  // Skew the input space to determine which simplex cell we're in
  var F2 = 0.5*(Math.sqrt(3.0)-1.0);
  var s = (xin+yin)*F2; // Hairy factor for 2D
  var i = Math.floor(xin+s);
  var j = Math.floor(yin+s);
  var G2 = (3.0-Math.sqrt(3.0))/6.0;
  var t = (i+j)*G2;
  var X0 = i-t; // Unskew the cell origin back to (x,y) space
  var Y0 = j-t;
  var x0 = xin-X0; // The x,y distances from the cell origin
  var y0 = yin-Y0;
  // For the 2D case, the simplex shape is an equilateral triangle.
  // Determine which simplex we are in.
  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
  if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
  else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)
  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
  // c = (3-sqrt(3))/6
  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
  var y1 = y0 - j1 + G2;
  var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
  var y2 = y0 - 1.0 + 2.0 * G2;
  // Work out the hashed gradient indices of the three simplex corners
  var ii = i & 255;
  var jj = j & 255;
  var gi0 = this.perm[ii+this.perm[jj]] % 12;
  var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;
  var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
  // Calculate the contribution from the three corners
  var t0 = 0.5 - x0*x0-y0*y0;
  if(t0<0) {
    n0 = 0.0;
  } else {
    t0 *= t0;
    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
  }
  var t1 = 0.5 - x1*x1-y1*y1;
  if(t1<0) {
    n1 = 0.0;
  } else {
    t1 *= t1;
    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
  }
  var t2 = 0.5 - x2*x2-y2*y2;
  if(t2<0) {
    n2 = 0.0;
  } else {
    t2 *= t2;
    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
  }
  // Add contributions from each corner to get the final noise value.
  // The result is scaled to return values in the interval [-1,1].
  return 70.0 * (n0 + n1 + n2);
};


/**
 * @param {Number} x
 * @param {Number} y
 * @param {Number} y
 * @returns {Number} noise for given position, in range [-1, 1]
 */
Simplex.prototype.get3d = function(xin, yin, zin) {
  var n0, n1, n2, n3; // Noise contributions from the four corners
  // Skew the input space to determine which simplex cell we're in
  var F3 = 1.0/3.0;
  var s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D
  var i = Math.floor(xin+s);
  var j = Math.floor(yin+s);
  var k = Math.floor(zin+s);
  var G3 = 1.0/6.0; // Very nice and simple unskew factor, too
  var t = (i+j+k)*G3;
  var X0 = i-t; // Unskew the cell origin back to (x,y,z) space
  var Y0 = j-t;
  var Z0 = k-t;
  var x0 = xin-X0; // The x,y,z distances from the cell origin
  var y0 = yin-Y0;
  var z0 = zin-Z0;
  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
  // Determine which simplex we are in.
  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
  if(x0>=y0) {
    if(y0>=z0)
      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order
      else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order
      else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order
    }
  else { // x0<y0
    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order
    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order
    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order
  }
  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
  // c = 1/6.
  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
  var y1 = y0 - j1 + G3;
  var z1 = z0 - k1 + G3;
  var x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords
  var y2 = y0 - j2 + 2.0*G3;
  var z2 = z0 - k2 + 2.0*G3;
  var x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords
  var y3 = y0 - 1.0 + 3.0*G3;
  var z3 = z0 - 1.0 + 3.0*G3;
  // Work out the hashed gradient indices of the four simplex corners
  var ii = i & 255;
  var jj = j & 255;
  var kk = k & 255;
  var gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12;
  var gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12;
  var gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12;
  var gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12;
  // Calculate the contribution from the four corners
  var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
  if(t0<0) {
    n0 = 0.0;
  } else {
    t0 *= t0;
    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0);
  }
  var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
  if(t1<0) {
    n1 = 0.0;
  } else {
    t1 *= t1;
    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1);
  }
  var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
  if(t2<0) {
    n2 = 0.0;
  } else {
    t2 *= t2;
    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2);
  }
  var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
  if(t3<0) {
    n3 = 0.0;
  } else {
    t3 *= t3;
    n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3);
  }
  // Add contributions from each corner to get the final noise value.
  // The result is scaled to stay just inside [-1,1]
  return 32.0*(n0 + n1 + n2 + n3);
};

},{}],54:[function(require,module,exports){
/**
 * @fileoverview A seedable random-number generator.
 *
 * A generator is initialized by GameJs and can be used with the
 * static functions of this module:
 *
 *    gamejs.random.choose([1,2,4]);
 *    // integet between and including 2 and 5
 *    gamejs.random.integer(2, 5);
 *
 * You can re-initialize this generator with a different seed by
 * calling `gamejs.utils.prng.init(seed)` after which the static
 * functions in this module will use the new seed.
 *
 * @usage
 *  var prng = require('gamejs/math/random');
 *  prng.random(); // 0.6765871671959758
 *  prng.integer(2, 10); // 5
 *  prng.choose([1,2,3,4,5]); // 3
 */
// From http://baagoe.com/en/RandomMusings/javascript/
// Johannes Baagøe <baagoe@baagoe.com>, 2010
// API modified by Simon Oberhammer <simon@nekapuzer.at>, 2012
// discussion of the used algorithms <http://baagoe.org/en/w/index.php/Better_random_numbers_for_javascript>


/** @ignore **/
var Mash = function Mash() {
  var n = 0xefc8249d;
  this.hash = function(data) {
    data = data.toString();
    var i;
    for (i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  this.version = 'Mash 0.9';
  return this;
};

/**
 * A seedable pseudo-random number generator.
 * @param {Number|String} seed the seed for generating the numbers
 *
 * @usage
 *  var prng = require('gamejs/math/random');
 *  var seed = 'gamejs';
 *  var alea = new prng.Alea(seed);
 *  alea.random(); // 0.6765871671959758
 *  alea.random(); // 0.15881546027958393
 *
 *  // generator with the same seed will generate the same sequence
 *  // of numbers:
 *  var aleaTwo = new prng.Alea(seed);
 *  aleaTwo.random(); // 0.6765871671959758
 *  aleaTwo.random(); // 0.15881546027958393
 */
var Alea = exports.Alea = function Alea() {
   var args = Array.prototype.slice.call(arguments);
   var s0 = 0;
   var s1 = 0;
   var s2 = 0;
   var c = 1;
   if (args.length === 0 || !args[0]) {
     args = [Date.now()];
   }
   var mash = new Mash();
   s0 = mash.hash(' ');
   s1 = mash.hash(' ');
   s2 = mash.hash(' ');

   var i;
   for (i = 0; i < args.length; i++) {
     s0 -= mash.hash(args[i]);
     if (s0 < 0) {
       s0 += 1;
     }
     s1 -= mash.hash(args[i]);
     if (s1 < 0) {
       s1 += 1;
     }
     s2 -= mash.hash(args[i]);
     if (s2 < 0) {
       s2 += 1;
     }
   }
   mash = null;

   /**
    * @returns {Number} the next random number as determined by the seed
    */
   this.random = function() {
     var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
     s0 = s1;
     s1 = s2;
     s2 = t - (c = t | 0);
     return s2;
   };
   this.integer = function(min, max) {
     return min + parseInt(this.random() * (max-min+1), 10);
   };
   this.vector = function(min, max) {
      return [this.integer(min[0], max[0]), this.integer(min[1], max[1])];
   };
   this.choose = function(items) {
      return items[this.integer(0, items.length-1)];
   };
   return this;
};

// alea instance per gamejs instance
var alea = null;

/**
 * @param {Number} min
 * @param {Number} max
 * @returns {Number} random integer between min and max
 */
var integer = exports.integer = function(min, max){
    return alea.integer(min, max);
};

/**
 * @param {Array} minVector 2 integers, the minimum vector
 * @param {Array} maxVector 2 integers, the maximum vector
 * @returns {Array} a random vector [min[0]<=x<=max[0], min[1]<=y<=max[1]]
 */
exports.vector = function(min, max){
    return alea.vector(min, max);
};

/**
 * @param {Array} items
 * @returns {Object} random item from items list
 */
exports.choose = function(items){
    return alea.choose(items);
};

/**
 * @returns {Number} next random float between 0 and 1
 */
exports.random = function() {
  return alea.random();
};

/**
 * Re-initialize the per instance random number generator used
 * in the static functions on this module (e.g. vector())
 * @param {Number|String} seed
 */
exports.init = function(seed) {
  alea = new Alea(seed);
};
},{}],55:[function(require,module,exports){
/**
 * Vector operations.

 */
var angles = require('./angles');

/**
 * @param {Array} origin point [b0, b1]
 * @param {Array} target point [b0, b1]
 * @returns {Number} distance between two points
 */
exports.distance = function(a, b) {
   return len(subtract(a, b));
};

/**
 * subtracts vectors [a0, a1] - [a0, a1]
 * @param {Array} a
 * @param {Array} b
 * @returns {Array} vector
 */
var subtract = exports.subtract = function(a, b) {
   return [a[0] - b[0], a[1] - b[1]];
};

/**
 * adds vectors [a0, a1] - [a0, a1]
 * @param {Array} a vector
 * @param {Array} b vector
 * @returns {Array} vector
 */
var add = exports.add = function(a, b) {
   return [a[0] + b[0], a[1] + b[1]];
};

/**
 * multiply vector with scalar or other vector
 * @param {Array} vector [v0, v1]
 * @param {Number|Array} vector or number
 * @returns {Number|Array} result
 */
var multiply = exports.multiply = function(a, s) {
   if (typeof s === 'number') {
      return [a[0] * s, a[1] * s];
   }

   return [a[0] * s[0], a[1] * s[1]];
};

/**
 * @param {Array} a vector
 * @param {Number} s
 */
exports.divide = function(a, s) {
   if (typeof s === 'number') {
      return [a[0] / s, a[1] / s];
   }
   throw new Error('only divide by scalar supported');
};

/**
 * @param {Array} vector [v0, v1]
 * @returns {Number} length of vector
 */
var len = exports.len = function(v) {
   return Math.sqrt(v[0]*v[0] + v[1]*v[1]);
};

/**
 *
 * normalize vector to unit vector
 * @param {Array} vector [v0, v1]
 * @returns {Array} unit vector [v0, v1]
 */
var unit = exports.unit = function(v) {
   var l = len(v);
   if(l) {
      return [v[0] / l, v[1] / l];
   }
   return [0, 0];
};

/**
 *
 * rotate vector
 * @param {Array} vector [v0, v1]
 * @param {Number} angle to rotate vector by, radians. can be negative
 * @returns {Array} rotated vector [v0, v1]
 */
exports.rotate=function(v, angle){
   angle=angles.normaliseRadians(angle);
   return [v[0]* Math.cos(angle)-v[1]*Math.sin(angle),
           v[0]* Math.sin(angle)+v[1]*Math.cos(angle)];

};

/**
 *
 * calculate vector dot product
 * @param {Array} vector [v0, v1]
 * @param {Array} vector [v0, v1]
 * @returns {Number} dot product of v1 and v2
 */
var dot = exports.dot=function(v1, v2){
   return (v1[0] * v2[0]) + (v1[1] * v2[1]);
};

/**
 *
 * calculate angle between vectors
 * @param {Array} vector [v0, v1]
 * @param {Array} vector [v0, v1]
 * @returns {Number} angle between v1 and v2 in radians
 */
exports.angle=function(v1, v2){
   var perpDot = v1[0] * v2[1] - v1[1] * v2[0];
   return Math.atan2(perpDot, dot(v1,v2));
};

/**
 * @returns {Array} vector with max length as specified.
 */
exports.truncate = function(v, maxLength) {
   if (len(v) > maxLength) {
      return multiply(unit(v), maxLength);
   }
   return v;
};


/**
 * @returns the center of multipled 2d points
 * @param {Array} first point
 * @param {Array} second point
 * @param {Array} ...
 */
exports.centroid = function() {
   var args = Array.prototype.slice.apply(arguments, [0]);
   var c = [0,0];
   args.forEach(function(p) {
      c[0] += parseInt(p[0], 10);
      c[1] += parseInt(p[1], 10);
   });
   var len = args.length;
   return [
      c[0] / len,
      c[1] / len
   ];
};

},{"./angles":50}],56:[function(require,module,exports){
/**
 * @fileoverview
 * A* path finding algorithm
 *
 * Use the `findRoute(map, from, to, [timeout])` function to get the linked list
 * leading `from` a point `to` another on the given `map`.
 *
 * The map must implement the interface `gamejs.pathfinding.Map`. This
 * class already holds an example implementation for debugging use.
 *
 * Optionally, the search is cancelled after `timeout` in millseconds.
 *
 * If there is no route `null` is returned.
 *
 * @see http://en.wikipedia.org/wiki/A*_search_algorithm
 * @see http://eloquentjavascript.net/chapter7.html
 */
var BinaryHeap = require('./math/binaryheap').BinaryHeap;

/**
 * helper function for A*
 */
function ReachedList(hashFn) {
   var list = {};

   this.store = function(point, route) {
      list[hashFn(point)] = route;
      return;
   };

   this.find = function(point) {
      return list[hashFn(point)];
   };
   return this;
}


/** A* search function.
 *
 * This function expects a `Map` implementation and the origin and destination
 * points given. If there is a path between the two it will return the optimal
 * path as a linked list. If there is no path it will return null.
 *
 * The linked list is in reverse order: the first item is the destination and
 * the path to the origin follows.
 *
 * @param {Map} map map instance, must follow interface defined in {Map}
 * @param {Array} origin
 * @param {Array} destination
 * @param {Number} timeout milliseconds after which search should be canceled
 * @returns {Object} the linked list leading from `to` to `from` (sic!).
 **/
exports.findRoute = function(map, from, to, timeout) {
   var open = new BinaryHeap(routeScore);
   var hashFn = typeof map.hash === 'function' ? map.hash : defaultHash;
   var reached = new ReachedList(hashFn);

   function routeScore(route) {
      if (route.score === undefined) {
         route.score = map.estimatedDistance(route.point, to) + route.length;
      }
      return route.score;
   }
   function addOpenRoute(route) {
      open.push(route);
      reached.store(route.point, route);
   }

   function processNewPoints(direction) {
      var known = reached.find(direction);
      var newLength = route.length + map.actualDistance(route.point, direction);
      if (!known || known.length > newLength){
         if (known) {
            open.remove(known);
         }
         addOpenRoute({
            point: direction,
            from: route,
            length: newLength
         });
      }
   }
   var startMs = Date.now();
   var route = null;
   addOpenRoute({
      point: from,
      from: null,
      length: 0
   });
   var equalsFn = typeof map.equals === 'function' ? map.equals : defaultEquals;
   while (open.size() > 0 && (!timeout || Date.now() - startMs < timeout)) {
      route = open.pop();
      if (equalsFn(to, route.point)) {
         return route;
      }
      map.adjacent(route.point).forEach(processNewPoints);
   } // end while
   return null;
};

var defaultEquals = function(a, b) {
   return a[0] === b[0] && a[1] === b[1];
};

var defaultHash = function(a) {
   return a[0] + '-' + a[1];
};

/**
 * This is the interface for a Map that can be passed to the `findRoute()`
 * function. `Map` is not instantiable - see the unit tests for an example
 * implementation of Map.
 */
var Map = exports.Map = function() {
   throw new Error('not instantiable, this is an interface');
};

/**
 * @param {Array} origin
 * @returns {Array} list of points accessible from given Point
 */
Map.prototype.adjacent = function(origin) {
};

/**
 * @param {Object} a one of the points ot test for equality
 * @param {Object} b ... the other point
 * @returns Wheter the two points are equal.
 */
Map.prototype.equals = defaultEquals;

/**
 * @param {Object} a point
 * @returns {String} hash for the point
 */
Map.prototype.hash = defaultHash;

/**
 * Estimated lower bound distance between two points.
 * @param {Object} pointA
 * @param {Object} pointB
 * @returns {Number} the estimated distance between two points
 */
Map.prototype.estimatedDistance = function(pointA, pointB) {
   return 1;
};

/**
 * Actual distance between two points.
 * @param {Object} pointA
 * @param {Object} pointB
 * @returns {Number} the actual distance between two points
 */
Map.prototype.actualDistance = function(pointA, pointB) {
   return 1;
};

},{"./math/binaryheap":51}],57:[function(require,module,exports){
var gamejs = require('../gamejs');
var objects = require('./utils/objects');

/**
 * @fileoverview Image mask. Usefull for pixel perfect collision detection:
 *
 * @example
 * var unitMask = new Maks(unitSurface, collisionThresholdAlphaValue);
 * var spearMask = new Maks(unitSurface, collisionThresholdAlphaValue);
 * var collide = unitMask.overlap(spearMask);
 */


/**
 * Creates an image mask from the given Surface. The alpha of each pixel is checked
 * to see if it is greater than the given threshold. If it is greater then
 * that pixel is set as not colliding.
 *
 * @param {Surface} surface used for image mask
 * @param {Number} threshold 0 to 255. defaults to: 255, fully transparent
 *
 */
var Mask = exports.Mask = function(surface, threshold) {
   /**
    * @ignore
    */
   this._bits = [];

   threshold = (threshold && (255 - threshold)) || 255;
   var imgData = surface.getImageData().data;
   var dims = surface.getSize();
   /**
    * @ignore
    */
   this.width = dims[0];
   /**
    * @ignore
    */
   this.height = dims[1];

   var i,j;
   for (i=0;i<this.width;i++) {
      this._bits[i] = [];
      for (j=0;j<this.height;j++) {
         this._bits[i][j] = false;
      }
   }
   for (i=0;i<imgData.length;i += 4) {
      // y: pixel # / width
      var y = parseInt((i / 4) / dims[0], 10);
      // x: pixel # % width
      var x = parseInt((i / 4) % dims[0], 10);
      var alpha = imgData[i+3];
      if (alpha >= threshold) {
         this.setAt(x, y);
      }
   }
   return;
};

/**
 * @param {gamejs.mask.Mask} otherMask
 * @param {Array} offset [x,y]
 * @returns the overlapping rectangle or null if there is no overlap;
 */
Mask.prototype.overlapRect = function(otherMask, offset) {
   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }
   // bounding box intersect
   if (!brect.collideRect(arect)) {
      return null;
   }
   var xStart = Math.max(arect.left, brect.left);
   var xEnd = Math.min(arect.right, brect.right);

   var yStart = Math.max(arect.top, brect.top);
   var yEnd = Math.min(arect.bottom, brect.bottom);

   return new gamejs.Rect([xStart, yStart], [xEnd - xStart, yEnd - yStart]);
};

/**
 *
 * @returns True if the otherMask overlaps with this map.
 * @param {Mask} otherMask
 * @param {Array} offset
 */
Mask.prototype.overlap = function(otherMask, offset) {
   var overlapRect = this.overlapRect(otherMask, offset);
   if (overlapRect === null) {
      return false;
   }

   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }

   var count = 0;
   var x,y;
   for (y=overlapRect.top; y<=overlapRect.bottom; y++) {
      for (x=overlapRect.left; x<=overlapRect.right; x++) {
         if (this.getAt(x - arect.left, y - arect.top) &&
             otherMask.getAt(x - brect.left, y - brect.top)) {
             return true;
         }
      }
   }
   // NOTE this should not happen because either we bailed out
   // long ago because the rects do not overlap or there is an
   // overlap and we should not have gotten this far.
   // throw new Error("Maks.overlap: overlap detected but could not create mask for it.");
   return false;
};

/**
 * @param {gamejs.mask.Mask} otherMask
 * @param {Array} offset [x,y]
 * @returns the number of overlapping pixels
 */
Mask.prototype.overlapArea = function(otherMask, offset) {
   var overlapRect = this.overlapRect(otherMask, offset);
   if (overlapRect === null) {
      return 0;
   }

   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }

   var count = 0;
   var x,y;
   for (y=overlapRect.top; y<=overlapRect.bottom; y++) {
      for (x=overlapRect.left; x<=overlapRect.right; x++) {
         if (this.getAt(x - arect.left, y - arect.top) &&
             otherMask.getAt(x - brect.left, y - brect.top)) {
             count++;
         }
      }
   }
   return count;
};

/**
 * @param {gamejs.mask.Mask} otherMask
 * @param {Array} offset [x,y]
 * @returns a mask of the overlapping pixels
 */
Mask.prototype.overlapMask = function(otherMask, offset) {
   var overlapRect = this.overlapRect(otherMask, offset);
   if (overlapRect === null) {
      return 0;
   }

   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }

   var mask = new Mask(new gamejs.graphics.Surface([overlapRect.width, overlapRect.height]));
   var x,y;
   for (y=overlapRect.top; y<=overlapRect.bottom; y++) {
      for (x=overlapRect.left; x<=overlapRect.right; x++) {
         if (this.getAt(x - arect.left, y - arect.top) &&
             otherMask.getAt(x - brect.left, y - brect.top)) {
             mask.setAt(x, y);
         }
      }
   }
   return mask;
};

/**
 * Set bit at position.
 * @param {Number} x
 * @param {Number} y
 */
Mask.prototype.setAt = function(x, y) {
   this._bits[x][y] = true;
};

/**
 * Get bit at position.
 *
 * @param {Number} x
 * @param {Number} y
 */
Mask.prototype.getAt = function(x, y) {
   x = parseInt(x, 10);
   y = parseInt(y, 10);
   if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
      return false;
   }
   return this._bits[x][y];
};


/**
 * Flip the bits in this map.
 */
Mask.prototype.invert = function() {
   this._bits = this._bits.map(function(row) {
      return row.map(function(b) {
         return !b;
      });
   });
};

/**
 * @returns {Array} the dimensions of the map
 */
Mask.prototype.getSize = function() {
   return [this.width, this.height];
};

objects.accessors(Mask.prototype, {
   /**
    * Rect of this Mask.
    */
   'rect': {
      get: function() {
         return new gamejs.Rect([0, 0], [this.width, this.height]);
      }
   },
   /**
    * @returns {Number} number of set pixels in this mask.
    */
   'length': {
      get: function() {
         var c = 0;
         this._bits.forEach(function(row) {
            row.forEach(function(b) {
               if (b) {
                  c++;
               }
            });
         });
         return c;
      }
   }
});

},{"../gamejs":"gamejs","./utils/objects":64}],58:[function(require,module,exports){
var gamejs = require('../gamejs');
var uri = require('./utils/uri');
var Callback = require('./utils/callback').Callback;

/**
 * ignore
 */
var _EVENTS = exports._EVENTS = {
   RESULT: 1001,
   ALIVE: 1002,
   LOG: 1004
};

/**
 * @fileoverview
 *
 * gamejs.worker makes it more convinient to work with W3C WebWorkers by providing a way to run
 * CommonJs modules inside of them. GameJs also provides the typically `gamejs.ready()` and
 * event loop to facilitate communication between workers and the main application.
 *
 * See the `examples/workers` directory for a running example.
 *
 * Create a worker with the main module "foo-worker" (see below for how the worker's module looks like):
 *
 *     var fooWorker = new Worker('./foo-worker');
 *     // Send a message to your worker.
 *     // The Message doesn't have to be a string but it
 *     // must be `JSON.stringify()`-able
 *     fooWorker.post("foobar");
 *
 * You can also recieve messages from the worker:
 *
 *     // recieve events from the worker
 *     fooWorker.onEvent(function(event) {
 *         if(event.timestamp > ...)
 *      });
 *
 * And this is how the above referenced "foo-worker" module would looke like. As usual, we need a
 * `gamejs.ready()` to get started and within that we bind an event handler:
 *
 *     var gamejs = require('gamejs');
 *     gamejs.ready(function() {
 *         gamejs.event.onEvent(function(event) {
 *              var plaintext = fastCrack(event.password)
 *              ....
 *          });
 *     });
 *
 * Our event worker could do expensive calculations (seperate and not blocking the main game) when
 * recieving an event. Once the result is caculated, it can be sent back to the main application
 * with `gamejs.thread.post()`:
 *
 *     gamejs.thread.post({
 *        info: "important message from worker",
 *        timestamp: 12232435234
 *      });
 *
 * The main application would in turn recieve an event posted like this from `fooWorker.onEvent`, as seen above.
 *
 * This module is useful for expensive algorithms where the result does not have to available instantiously
 * (e.g., path-finding) or for continous logic which can be
 * calculated seperately from the rendering loop, and which only needs to feed back into the model of the rendering every
 * now and then (e.g. physics) The main draw back of the `Worker` model is that
 * you can only communicate with them via text messages (typically JSON.stringify()ed messages).
 */

/**
 * true if this GameJs instance is being executed within a WebWorker
 * @type Boolean
 */
var inWorker = exports.inWorker = (this.importScripts !== undefined);

/**
 * executed in scope of worker
 * @ignore
 */
exports._ready = function() {
   self.onmessage = function(event) {
      gamejs.event._triggerCallbacks(event.data);
   };
   self.postMessage({
     type: _EVENTS.ALIVE
   });
};

/**
 * Send an event back to the main script.
 * @param {Object} data to be sent back to main script
 */
exports.post = function(data) {
  if (inWorker) {
    self.postMessage({
       type: _EVENTS.RESULT,
       data: data
    });
  } else {
    throw new Error('gamejs.postMessage only available in a thread/worker module');
  }
};

/**
 * Send message to main context for logging
 * @ignore
 **/
exports._logMessage = function() {
   var args = [];
   Array.prototype.forEach.call(arguments, function(a) {
     args.push(a);
   });
   self.postMessage({
      type: _EVENTS.LOG,
      arguments: args
   });
};


/**
  * executed in scope of worker before user's main module
  * @ignore
  */
var workerPrefix = function workerPrefix() {
   __scripts.forEach(function(script) {
      try {
         importScripts(script);
      } catch (e) {
         // can't help the worker
      }
   });
};

/**
 * Setup a worker which has `require()` defined
 * @ignore
 **/
var create = function(workerModuleId) {
   var moduleRoot = uri.resolve(document.location.href, window.require.getModuleRoot());
   var initialScripts = [];
   Array.prototype.slice.apply(document.getElementsByTagName('script'), [0]).forEach(function(script) {
      if (script.src) {
         initialScripts.push(script.src);
      }
   });

   var URL = window.URL || window.webkitURL;
   var prefixString = workerPrefix.toString();
   // don't be afraid...
   prefixString = prefixString.substring(prefixString.indexOf("{") + 1, prefixString.lastIndexOf("}"));
   var blob = new Blob([
      'var __scripts = ["' + initialScripts.join('","') + '"];',
      prefixString,
      ';self.require.setModuleRoot("' + moduleRoot + '");',
      'self.require.run("'+ workerModuleId +'");'
   ], {type: 'application\/javascript'});

   var blobURL = URL.createObjectURL(blob);
   return new Worker(blobURL);
};

/**
 * The `Worker` constructor takes only one argument: a module id. This module
 * will be executed inside the newly created Worker. It is effectively the
 * main module of the Worker.
 *
 * Inside a Worker, you can use `require()` to import other scripts or
 * GameJs modules.
 *
 * **Note:** A Worker does not have access to the browser's `document`. So
 * a lot of GameJs modules - everything related to drawing to the canvas -
 * do not work in the Worker.
 *
 * You can use `gamejs.time.*`, `gamejs.utils.*`, `gamejs.event.*` and probably others
 * (as well as any module you write yourself for this purpose, of course).
 *
 * @param {String} moduleId The Worker's main module id. The main module will be executed in the worker
 */
exports.Worker = function(moduleId) {
   // FIXME id should be unchangeable
   /**
    * Unique id of this worker
    * @property {Number}
    */
   var id = this.id = guid(moduleId);
   var worker = create(moduleId);
   var deadQueue = [];
   var alive = false;
   var self  = this;
   var _CALLBACKS = [];
   var _ERROR_CALLBACKS = [];

   function triggerCallbacks(callbacks, event) {
      callbacks.forEach(function(c) {
         c.trigger(event);
      });
   }

   worker.onmessage = function(event) {
      if (event.data.type === _EVENTS.ALIVE) {
         // if worker says he is alive -> send him the event queue so far
         alive = true;
         deadQueue.forEach(function(data) {
            self.post(data);
         });
      } else if (event.data.type === _EVENTS.LOG) {
         gamejs.logging.log.apply(null, [id].concat(event.data.arguments));
      } else {
         triggerCallbacks(_CALLBACKS, event.data.data);
      }
   };
   worker.onerror = function(event) {
      gamejs.logging.error('Error in worker "' + id + '" line ' + event.lineno + ': ', event.message);
      triggerCallbacks(_ERROR_CALLBACKS, {
         data: event.data,
         worker: self,
         event: event
      });
   };

   this.onEvent = function(fn, scope) {
      _CALLBACKS.push(new Callback(fn, scope));
   };

   this.onError = function(fn, scope) {
      _ERROR_CALLBACKS.push(new Callback(fn, scope));
   };

   /**
    * Send a message to the worker
    *
    * @param {Object} data Payload object which gets sent to the Worker
    */
   this.post = function(data) {
      if (alive) {
         worker.postMessage(data);
      } else {
         deadQueue.push(data);
      }
   };
   return this;
};

/**
 * not a real GUID
 * @ignore
 */
function guid(moduleId) {
   var S4 = function() {
      return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
   };
   return moduleId + '@' + (S4()+S4());
}
},{"../gamejs":"gamejs","./utils/callback":63,"./utils/uri":66}],59:[function(require,module,exports){
var gamejs = require('../gamejs');
var objects = require('./utils/objects');
var xml = require('./utils/xml');
var base64 = require('./utils/base64');
var uri = require('./utils/uri');

/**
 * @fileoverview
 * This is a loader for the general purpose tile map editor "Tiled".
 *
 * This module can load all ".tmx" files even if additionally base64 encoded
 * (can be configured in Tiled).
 *
 * This module loads the whole map definition, including the TileSets with
 * all necessary images. For an example on how to render a map loaded with
 * this module, see `examples/tiledmap`.
 *
 * You will typically create a Map instance with `Map(url)` and deal
 * with the layers, tilesets, etc. through the Map instance
 * instead of loading & creating them yourself.
 *
 * Only orthogonol maps are supported (no isometric maps).
 *
 * @see http://www.mapeditor.org/
 * @see https://github.com/bjorn/tiled/wiki/TMX-Map-Format
 */

/**
 * My code is inspired by:
 *   * https://bitbucket.org/maikg/tiled2cocos/
 *   * https://github.com/obiot/melonJS/
 *
 */

/**
 * A Tiled Map holds all layers defined in the tmx file as well
 * as the necessary tiles to render the map.
 * @param {String} url Relative or absolute URL to the tmx file
 */
var Map = exports.Map = function(url) {

   url = uri.resolve(document.location.href, url);
   var xmlDoc = xml.Document.fromURL(url);
   var mapNode = xmlDoc.element('map');

   /**
    * Width of a single tile in pixels
    * @type Number
    */
   this.tileWidth = mapNode.attribute('tilewidth');
   /**
    * Height of a single tile in pixels
    * @type Number
    */
   this.tileHeight = mapNode.attribute('tileheight');
   /**
    * Width of the map in tiles
    * @type Number
    */
   this.width = mapNode.attribute('width');
   /**
    * Height of the map in tiles
    * @type Number
    */
   this.height = mapNode.attribute('height');

   var orientation = mapNode.attribute('orientation');
   if (orientation !== 'orthogonal') {
      throw new Error('only orthogonol maps supported');
   }

   /**
    * Custom properties of the map
    */
   this.properties = {};
   setProperties(this.properties, mapNode);

   /**
    * All tiles of this map.
    * @type {TileSet}
    */
   this.tiles = new TileSets(mapNode, url);
   this.layers = loadLayers(mapNode);
   return this;
};

/**
 * A Tile. Can not be instantiated. Get a Tile by calling `getTile(gid)`
 * on a `TileSets` instance.
 */
var Tile = exports.Tile = function() {
   /**
    * @type {gamejs.graphics.Surface}
    */
   this.surface = null;
   /**
    * @type {Object}
    */
   this.properties = null;
   throw new Error('Can not be instantiated.');
};

/**
 * A TileSets instance holds all tilesets of a map. This class
 * makes it easy to get the image for a certain tile ID. You usually
 * don't care about in which specific TileSet an image is so this
 * class holds them all and deals with the lookup.
 *
 * You don't usually create a `TileSets` instance yourself, instead
 * it is automatically created and attached to a `Map`.
 */
var TileSets = exports.TileSets = function(mapNode, mapUrl) {
   var tileSets = [];

   /**
    * Retrieve the image for a tile ID (gid).
    *
    * @param {Number} gid global tile id to retrieve
    * @returns {gamejs.graphics.Surface} the Surface for the gid
    */
   this.getSurface = function(gid) {
      var tile = this.getTile(gid);
      return tile && tile.surface || null;
   };

   /**
    * @param {Number} gid global tile id
    * @returns {Object} the custom properties of this tile
    */
   this.getProperties = function(gid) {
      var tile = this.getTile(gid);
      return tile && tile.properties || {};
   };

   /**
    * @param {Number} gid global tile id
    * @returns {Object} the Tile object for this gid
    */
   this.getTile = function(gid) {
      var tile = null;
      tileSets.some(function(tileSet, idx) {
         if (tileSet.firstGid <= gid) {
            tile = tileSet.tiles[gid - tileSet.firstGid];
            return true;
         }
         return false;
      }, this);
      return tile;
   };

   var loadTileSet = function(tileSetNode) {
      var tiles = [];
      var tileWidth = tileSetNode.attribute('tilewidth');
      var tileHeight = tileSetNode.attribute('tileheight');
      var spacing = tileSetNode.attribute('spacing') || 0;
      // broken in tiled?
      var margin = 0;

      var imageNode = tileSetNode.element('image');
      var imageAtlasFile = imageNode.attribute('source');
      var imageUrl = uri.makeRelative(uri.resolve(mapUrl, imageAtlasFile));
      var atlas = gamejs.image.load(imageUrl);
      // FIXME set transparency if imageNode.attribute('trans') is set

      var tileNodes = tileSetNode.elements('tile');
      var dims = atlas.getSize();
      var imgSize = new gamejs.Rect([0,0], [tileWidth, tileHeight]);
      var idx = 0;
      var y = 0;
      while (y + tileHeight <= dims[1]) {
         var x = 0;
         while (x + tileWidth <= dims[0]) {
            var tileImage = new gamejs.graphics.Surface(tileWidth, tileHeight);
            var rect = new gamejs.Rect([x, y], [tileWidth, tileHeight]);
            tileImage.blit(atlas, imgSize, rect);
            var tileProperties = {};
            /* jshint ignore:start */
            // function within loop
            tileNodes.some(function(tileNode) {
               if (tileNode.attribute('id') === idx) {
                  setProperties(tileProperties, tileNode);
                  return true;
               }
            }, this);
            /* jshint ignore:end */
            tiles.push({
               surface: tileImage,
               properties: tileProperties
            });
            x += tileWidth + spacing;
            idx++;
         }
         y += tileHeight + spacing;
      }
      return tiles;
   };

   /**
    *
    * constructor
    **/
   mapNode.elements('tileset').forEach(function(tileSetNode) {
      var firstGid = tileSetNode.attribute('firstgid');
      var externalSource = tileSetNode.attribute('source');
      if (externalSource) {
         var tileSetDocument = xml.Document.fromURL(uri.resolve(mapUrl, externalSource));
         tileSetNode = tileSetDocument.element('tileset');
      }
      tileSets.push({
         tiles: loadTileSet(tileSetNode),
         firstGid: firstGid
      });
   });
   tileSets.reverse();

   return this;
};

/**
 * loadLayers
 */
var H_FLIP = 0x80000000;
var V_FLIP = 0x40000000;
var loadLayers = function(mapNode) {
   var layers = [];

   var getGids = function(layerNode) {
      var dataNode = layerNode.element('data');
      var encoding = dataNode.attribute('encoding');
      var compression = dataNode.attribute('compression');
      var data = "";
      dataNode.children().forEach(function(textNode) {
         data += textNode.value();
      });
      var byteData = [];
      if (encoding === 'base64') {
         if (compression) {
            throw new Error('Compression of map data unsupported');
         }
         byteData = base64.decodeAsArray(data, 4);
      } else if (encoding === 'csv') {
         data.trim().split('\n').forEach(function(row) {
            row.split(',', width).forEach(function(entry) {
               byteData.push(parseInt(entry, 10));
            });
         });
      } else {
         // FIXME individual XML tile elements
         throw new Error('individual tile format not supported');
      }
      return byteData;
   };

   var width = mapNode.attribute('width');
   var height = mapNode.attribute('height');
   mapNode.elements('layer').forEach(function(layerNode) {
      // create empty gid matrix
      var gidMatrix = [];
      var i = height;
      while (i-->0) {
         var j = width;
         gidMatrix[i] = [];
         while (j-->0) {
            gidMatrix[i][j] = 0;
         }
      }

      getGids(layerNode).forEach(function(gid, idx) {
         // FIXME flipX/Y currently ignored
         var flipX = gid & H_FLIP;
         var flipY = gid & V_FLIP;
         // clear flags
         gid &= ~(H_FLIP | V_FLIP);
         gidMatrix[parseInt(idx / width, 10)][parseInt(idx % width, 10)] = gid;
      });
      layers.push({
         gids: gidMatrix,
         opacity: layerNode.attribute('opacity'),
         visible: layerNode.attribute('visible'),
         properties: setProperties({}, layerNode)
      });
   });
   return layers;
};

/**
 * set generic <properties><property name="" value="">... on given object
 */
var setProperties = function(object, node) {
   var props = node.element('properties');
   if (!props) {
      return;
   }
   props.elements('property').forEach(function(propertyNode) {
      var name = propertyNode.attribute('name');
      var value = propertyNode.attribute('value');
      object[name] = value;
   });
   return object;
};


/**
 * FIXME explain viewRect (change it to sroll!) and image, mapImage and how to update, redraw
 */
var MapView = exports.MapView = function(map) {

    this.timeout = 0;

    this.layerViews = map.layers.map(function(layer) {
      return new LayerView(layer, {
         tileWidth: map.tileWidth,
         tileHeight: map.tileHeight,
         width: map.width,
         height: map.height,
         tiles: map.tiles
      });
    });
    this.viewRect = new gamejs.Rect([0,0], [map.width * map.tileWidth, map.height*map.tileWidth]);
    this.image = new gamejs.graphics.Surface([this.viewRect.width, this.viewRect.height]);
    this.mapImage = this.image.clone();
    this.redraw();
    return this;
};

MapView.prototype.redraw = function() {
    this.layerViews.forEach(function(layer) {
        layer.draw(this.mapImage);
    }, this);
};

MapView.prototype.draw = function(display, offset) {
  display.blit(this.mapImage, offset || [0,0], this.viewRect);
};



/**
 * LayerView
 * Renders the layer to a big surface.
 */
var LayerView = exports.LayerView = function(layer, opts) {

   this.draw = function(display) {
      display.blit(this.surface);
   };
   /**
    * constructor
    */
   this.surface = new gamejs.graphics.Surface(opts.width * opts.tileWidth, opts.height * opts.tileHeight);
   this.surface.setAlpha(layer.opacity);

   /**
    * Note how below we look up the "gid" of the tile images in the TileSet from the Map
    * ('opt.tiles') to get the actual Surfaces.
    */
   layer.gids.forEach(function(row, i) {
      row.forEach(function(gid, j) {
         if (gid ===0) {
            return;
         }

         var tileSurface = opts.tiles.getSurface(gid);
         if (tileSurface) {
            this.surface.blit(tileSurface,
               new gamejs.Rect([j * opts.tileWidth, i * opts.tileHeight], [opts.tileWidth, opts.tileHeight])
            );
         } else {
            gamejs.log('no gid ', gid, i, j, 'layer', i);
         }
      }, this);
   }, this);
   return this;
};


},{"../gamejs":"gamejs","./utils/base64":62,"./utils/objects":64,"./utils/uri":66,"./utils/xml":67}],60:[function(require,module,exports){
/**
 * @fileoverview
 * Only used by GameJs internally to provide a game loop.
 * @ignore
 */

var Callback = require('./utils/callback').Callback;

var TIMER_LASTCALL = null;
var STARTTIME = null;

/** @ignore **/
var _CALLBACKS = exports._CALLBACKS = [];
// `window` is not accessible in webworker (would lead to TypeError)
// @@ this cross-browser fuckery has to go away ASAP.
var reqAnimationFrame = typeof(window) != 'undefined' ?
                        window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        null : null;

var reqAniFrameRecursive = function() {
   perInterval();
   reqAnimationFrame(reqAniFrameRecursive);
};

var triggerCallbacks = function(msDuration) {
   _CALLBACKS.forEach(function(c) {
      c.trigger(msDuration);
   });
};

/**
 * @ignore
 */
exports.init = function() {
   STARTTIME = Date.now();

   if (reqAnimationFrame) {
      reqAnimationFrame(reqAniFrameRecursive);
   } else {
      setInterval(perInterval, 10);
   }
   return;
};

var perInterval = function() {
   var msNow = Date.now();
   triggerCallbacks(msNow - (TIMER_LASTCALL || msNow));
   TIMER_LASTCALL = msNow;
   return;
};

},{"./utils/callback":63}],61:[function(require,module,exports){
/**
 * @fileoverview Utility functions for working with Obiects
 * @param {Object} item
 * @param {Array} array
 * @param {Object} returns removed item or null
 */

exports.remove = function(item, array) {
   var index = array.indexOf(item);
   if (index !== -1) {
      return array.splice(array.indexOf(item), 1);
   }
   return null;
};

/**
 * Shuffles the array *in place*.
 * @see http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
 */
exports.shuffle = function(array) {
    var len = array.length -1;
    for (var i = len; i > 0; i--) {
        var idx = parseInt(Math.random() * (i + 1), 10);
        var item = array[i];
        array[i] = array[idx];
        array[idx] = item;
    }
    return array;
};

},{}],62:[function(require,module,exports){
/**
 * @fileoverview
 * Base64 encode / decode
 * @author http://www.webtoolkit.info
 */


var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

/**
 * Decodes a base64 encoded string to a string.
 */
var decode = exports.decode = function(input) {
   var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
   input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

   while (i < input.length) {
      enc1 = keyStr.indexOf(input.charAt(i++));
      enc2 = keyStr.indexOf(input.charAt(i++));
      enc3 = keyStr.indexOf(input.charAt(i++));
      enc4 = keyStr.indexOf(input.charAt(i++));

      chr1 = (enc1 << 2) | (enc2 >> 4);
      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
      chr3 = ((enc3 & 3) << 6) | enc4;

      output.push(String.fromCharCode(chr1));

      if (enc3 != 64) {
         output.push(String.fromCharCode(chr2));
      }
      if (enc4 != 64) {
         output.push(String.fromCharCode(chr3));
      }
   }

   output = output.join('');
   return output;
};

/**
 * Decodes a base64 encoded string into a byte array
 * @param {String} input
 * @param {Array} bytes bytes per character, defaults to 1
 */
exports.decodeAsArray = function(input, bytes) {
   bytes = bytes || 1;
   var decoded = decode(input);
   var len = decoded.length / bytes;
   var array = [];
   var i,j;
   for (i=0; i< len; i++) {
      array[i] = 0;
      for (j = bytes - 1; j >=0; --j) {
         array[i] += decoded.charCodeAt((i * bytes) + j) << (j <<3 );
      }
   }
   return array;
}
;
},{}],63:[function(require,module,exports){
/**
 * @fileoverview
 * Manage a callback with invocation scope. This is used internally by GameJs but might be useful for others.
 */

/**
 * @param {Function} callback
 * @param {Object} scope with which the callback will be triggered
 */
var Callback = exports.Callback = function(fn, scope) {
	this.fn = fn;
	this.fnScope = scope || {};
	return this;
};
/**
 * Any arguments passed to `trigger` will be passed to the callback.
 */
Callback.prototype.trigger = function() {
	this.fn.apply(this.fnScope, arguments);
};
},{}],64:[function(require,module,exports){
/**
 * @fileoverview Utility functions for working with Objects
 */

/**
 * Put a prototype into the prototype chain of another prototype.
 * @param {Object} subClass
 * @param {Object} superClass
 */
exports.extend = function(subClass, superClass) {
   if (subClass === undefined) {
      throw new Error('unknown subClass');
   }
   if (superClass === undefined) {
      throw new Error('unknown superClass');
   }
   var F;
   /* jshint ignore:start */
   F = new Function();
   /* jshint ignore:start */
   F.prototype = superClass.prototype;
   /* jshint ignore:end */
   subClass.prototype = new F();
   subClass.prototype.constructor = subClass;
   subClass.superClass = superClass.prototype;
   subClass.superConstructor = superClass;
   return;
};

/**
 * Creates a new object as the as the keywise union of the provided objects.
 * Whenever a key exists in a later object that already existed in an earlier
 * object, the according value of the earlier object takes precedence.
 * @param {Object} obj... The objects to merge
 */
exports.merge = function() {
   var result = {};
   var i, property;
      for (i = arguments.length; i > 0; --i) {
         var obj = arguments[i - 1];
         for (property in obj) {
            result[property] = obj[property];
         }
      }
   return result;
};

/**
 * fallback for Object.keys
 * @param {Object} obj
 * @returns {Array} list of own properties
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys
 */
var keys = exports.keys = function(obj) {
   if (Object.keys) {
      return Object.keys(obj);
   }

   var ret=[],p;
   for (p in obj) {
      if(Object.prototype.hasOwnProperty.call(obj, p)) {
         ret.push(p);
      }
   }
   return ret;
};

/**
 * Create object accessors
 * @param {Object} object The object on which to define the property
 * @param {String} name name of the property
 * @param {Function} get
 * @param {Function} set
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperty
 */
var accessor = exports.accessor = function(object, name, get, set) {
   // ECMA5
   if (Object.defineProperty !== undefined) {
      Object.defineProperty(object, name, {
         get: get,
         set: set
      });
   // non-standard
   } else if (Object.prototype.__defineGetter__ !== undefined) {
      object.__defineGetter__(name, get);
      if (set) {
         object.__defineSetter__(name, set);
      }
   }
	return;
};

/**
 * @param {Object} object The object on which to define or modify properties.
 * @param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified.
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperties
 */
exports.accessors = function(object, props) {
   keys(props).forEach(function(propKey) {
      accessor(object, propKey, props[propKey].get, props[propKey].set);
   });
   return;
};

},{}],65:[function(require,module,exports){
/**
 * @fileoverview Working with strings
 */

/**
 * Get the longest common segment that two strings
 * have in common, starting at the beginning of the string
 * @param {String} str1 a string
 * @param {String} str2 another string
 * @returns {String} the longest common segment
 */
exports.getCommonPrefix = function getCommonPrefix(str1, str2) {
    if (str1 === null || str2 === null) {
        return null;
    } else if (str1.length > str2.length && str1.indexOf(str2) === 0) {
        return str2;
    } else if (str2.length > str1.length && str2.indexOf(str1) === 0) {
        return str1;
    }
    var length = Math.min(str1.length, str2.length);
    var i;
    for (i = 0; i < length; i++) {
        if (str1[i] != str2[i]) {
            return str1.slice(0, i);
        }
    }
    return str1.slice(0, length);
};
},{}],66:[function(require,module,exports){
/**
 * @fileoverview Utilies for URI handling.
 *
 */

var URI_REGEX = new RegExp(
    '^' +
    '(?:' +
      '([^:/?#.]+)' +                     // scheme - ignore special characters
                                          // used by other URL parts such as :,
                                          // ?, /, #, and .
    ':)?' +
    '(?://' +
      '(?:([^/?#]*)@)?' +                 // userInfo
      '([\\w\\d\\-\\u0100-\\uffff.%]*)' + // domain - restrict to letters,
                                          // digits, dashes, dots, percent
                                          // escapes, and unicode characters.
      '(?::([0-9]+))?' +                  // port
    ')?' +
    '([^?#]+)?' +                         // path
    '(?:\\?([^#]*))?' +                   // query
    '(?:#(.*))?' +                        // fragment
    '$');

/**
 * Resolve path against URI.
 *
 * @param {String} uri
 * @param {String} path to resolve
 */
var resolve = exports.resolve = function(uri, path) {
   var m = match(uri);
   var n = match(path);
   var host = m[1] + '://' + m[3];
   if (n[1]) {
      return path;
   }
   if (m[4]) {
      host = host + ":" + m[4];
   }
   var absolutePath = m[5];
   if (path.charAt(0) !== '/') {
      var lastSlashIndex = absolutePath.lastIndexOf('/');
      absolutePath = absolutePath.substr(0, lastSlashIndex + 1) + path;
   } else {
      absolutePath = path;
   }
   return host + removeDotSegments(absolutePath);

};

/**
 * Try to match an URI against a regex returning the following
 * capture groups:
 *     $1 = http              scheme
 *     $2 = <undefined>       userInfo -\
 *     $3 = www.ics.uci.edu   domain     | authority
 *     $4 = <undefined>       port     -/
 *     $5 = /pub/ietf/uri/    path
 *     $6 = <undefined>       query without ?
 *     $7 = Related           fragment without #
 *
 * @param {String} uri
 */
var match = exports.match = function(uri) {
   return uri.match(URI_REGEX);
};

/**
 * Make an absolute URI relative to document.location.href
 * @param {String} uri
 * @returns The relative URI or the unchanged URI if it's not
 * possible to make it relative to the path of document.location.href.
 */
var makeRelative = exports.makeRelative = function(uri) {
   var docLocPath = resolve(document.location.href, './');
   if (uri.indexOf(docLocPath) === 0) {
      uri = './' + uri.substring(docLocPath.length);
   }
   return uri;
};

/**
 * Removes dot segments in given path component
 */
var removeDotSegments = function(path) {
   if (path == '..' || path == '.') {
      return '';
   }
   var leadingSlash = path.indexOf('/') > -1;

   var segments = path.split('/');
   var out = [];

   var pos;
   for (pos = 0; pos < segments.length; ) {
      var segment = segments[pos++];

      if (segment == '.') {
         if (leadingSlash && pos == segments.length) {
            out.push('');
         }
      } else if (segment == '..') {
         if (out.length > 1 || out.length !== 1 && out[0] !== '') {
            out.pop();
         }
         if (leadingSlash && pos == segments.length) {
            out.push('');
         }
      } else {
         out.push(segment);
         leadingSlash = true;
      }
   }
   return out.join('/');
};

},{}],67:[function(require,module,exports){
/**
 * @fileoverview
 *
 * Provides facilities for parsing a xml String.
 *
 * You will typically get a `gamejs.xml.Document` instance
 * by loading the data with one of the two static
 * `Document.fromString(string)` or `Document.fromUrl(url)`.

 * Querying for `elements(name)` or `children()` will return a
 * new `gamejs.xml.Document` matching your result (or null).
 *
 * Use `attributes(name)` and `value()` to get the data stored
 * in the XML Document.
 */

/**
 * XMLParser
 */
var Parser = exports.Parser = function() {

   var xmlDoc = null;
   var parser = new DOMParser();

   this.parseFromString = function(xmlString) {
      xmlDoc = parser.parseFromString(xmlString, 'text/xml');
      return xmlDoc;
   };

   return this;
};

/**
 * Instantiate with the static functions `Document.fromString()` and `fromURL()`.
 */
var Document = exports.Document = function(xmlDocument) {
   if (!xmlDocument || (!xmlDocument instanceof XMLDocument) ) {
      throw new Error('Need a valid xmlDocument.');
   }
   /** @ignore **/
   this._xmlDocument = xmlDocument;
   return this;
};

/**
 * Returns the first element in the current document whose tag-name matches
 * the given 'name'.
 * @returns gamejs.xml.Document
 */
Document.prototype.element = function(name) {
   var elem = this._xmlDocument.getElementsByTagName(name)[0];
   return elem && new Document(elem) || null;
};

/**
 * Returns all elements in the current document whose tag-name matches
 * the given 'name'.
 * @returns an Array of gamejs.xml.Document
 */
Document.prototype.elements = function(name) {
   var elems = this._xmlDocument.getElementsByTagName(name);
   return Array.prototype.slice.apply(elems, [0]).map(function(elem) {
      return new Document(elem);
   });
};

/**
 * Returns the attribute value of this document.
 *
 * @returns String
 */
Document.prototype.attribute = function(name) {
   var attributeValue = this._xmlDocument.getAttribute(name);
   attributeValue = attributeValue ? attributeValue.trim() : null;
   if (attributeValue === null) {
      return null;
   }
   if (attributeValue.toLowerCase() === 'true') {
      return true;
   }
   if (attributeValue.toLowerCase() === 'false') {
      return false;
   }
   var attributeIntValue = parseInt(attributeValue, 10);
   var attributeFloatValue = parseFloat(attributeValue, 10);
   if (!isNaN(attributeIntValue)) {
      if (attributeFloatValue !== attributeIntValue) {
         return attributeFloatValue;
      }
      return attributeIntValue;
   }
   return attributeValue;
};

/**
 * Returns the nodevalue of the current xml document
 * @returns String
 */
Document.prototype.value = function() {
   return this._xmlDocument.nodeValue;
};

/**
 * Returns all children of this xml document
 * @returns Array of gamejs.xml.Document
 */
Document.prototype.children = function() {
   return Array.prototype.slice.apply(this._xmlDocument.childNodes, [0]).map(function(cNode) {
      return new Document(cNode);
   });
};

/**
 * @returns gamejs.xml.Document
 */
Document.fromString = function(xmlString) {
   var parser = new DOMParser();
   var xmlDoc = parser.parseFromString(xmlString, 'text/xml');
   return new Document(xmlDoc);
};

/**
 * @returns gamejs.xml.Document
 */
Document.fromURL = function(url) {
   var response = new XMLHttpRequest();
   response.open('GET', url, false);
   response.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
   response.setRequestHeader('Content-Type', 'text/xml');
   response.overrideMimeType('text/xml');
   response.send();
   return new Document(response.responseXML);
};

},{}],68:[function(require,module,exports){
(function (global,Buffer){
var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.findInternal=function(a,b,c){a instanceof String&&(a=String(a));for(var d=a.length,e=0;e<d;e++){var f=a[e];if(b.call(c,f,e,a))return{i:e,v:f}}return{i:-1,v:void 0}};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;
$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};$jscomp.getGlobal=function(a){return"undefined"!=typeof window&&window===a?a:"undefined"!=typeof global&&null!=global?global:a};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.polyfill=function(a,b,c,d){if(b){c=$jscomp.global;a=a.split(".");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e]}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b})}};$jscomp.polyfill("Array.prototype.findIndex",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).i}},"es6","es3");
$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return a+""};
$jscomp.polyfill("String.prototype.endsWith",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,a,"endsWith");a+="";void 0===c&&(c=b.length);c=Math.max(0,Math.min(c|0,b.length));for(var e=a.length;0<e&&0<c;)if(b[--c]!=a[--e])return!1;return 0>=e}},"es6","es3");$jscomp.polyfill("Array.prototype.find",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).v}},"es6","es3");
$jscomp.polyfill("String.prototype.startsWith",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,a,"startsWith");a+="";var e=b.length,f=a.length;c=Math.max(0,Math.min(c|0,b.length));for(var g=0;g<f&&c<e;)if(b[c++]!=a[g++])return!1;return g>=f}},"es6","es3");
$jscomp.polyfill("String.prototype.repeat",function(a){return a?a:function(a){var b=$jscomp.checkStringArgs(this,null,"repeat");if(0>a||1342177279<a)throw new RangeError("Invalid count value");a|=0;for(var d="";a;)if(a&1&&(d+=b),a>>>=1)b+=b;return d}},"es6","es3");var COMPILED=!0,goog=goog||{};goog.global=this||self;goog.isDef=function(a){return void 0!==a};goog.isString=function(a){return"string"==typeof a};goog.isBoolean=function(a){return"boolean"==typeof a};
goog.isNumber=function(a){return"number"==typeof a};goog.exportPath_=function(a,b,c){a=a.split(".");c=c||goog.global;a[0]in c||"undefined"==typeof c.execScript||c.execScript("var "+a[0]);for(var d;a.length&&(d=a.shift());)!a.length&&goog.isDef(b)?c[d]=b:c=c[d]&&c[d]!==Object.prototype[d]?c[d]:c[d]={}};
goog.define=function(a,b){if(!COMPILED){var c=goog.global.CLOSURE_UNCOMPILED_DEFINES,d=goog.global.CLOSURE_DEFINES;c&&void 0===c.nodeType&&Object.prototype.hasOwnProperty.call(c,a)?b=c[a]:d&&void 0===d.nodeType&&Object.prototype.hasOwnProperty.call(d,a)&&(b=d[a])}return b};goog.FEATURESET_YEAR=2012;goog.DEBUG=!0;goog.LOCALE="en";goog.TRUSTED_SITE=!0;goog.STRICT_MODE_COMPATIBLE=!1;goog.DISALLOW_TEST_ONLY_CODE=COMPILED&&!goog.DEBUG;goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING=!1;
goog.provide=function(a){if(goog.isInModuleLoader_())throw Error("goog.provide cannot be used within a module.");if(!COMPILED&&goog.isProvided_(a))throw Error('Namespace "'+a+'" already declared.');goog.constructNamespace_(a)};goog.constructNamespace_=function(a,b){if(!COMPILED){delete goog.implicitNamespaces_[a];for(var c=a;(c=c.substring(0,c.lastIndexOf(".")))&&!goog.getObjectByName(c);)goog.implicitNamespaces_[c]=!0}goog.exportPath_(a,b)};
goog.getScriptNonce=function(a){if(a&&a!=goog.global)return goog.getScriptNonce_(a.document);null===goog.cspNonce_&&(goog.cspNonce_=goog.getScriptNonce_(goog.global.document));return goog.cspNonce_};goog.NONCE_PATTERN_=/^[\w+/_-]+[=]{0,2}$/;goog.cspNonce_=null;goog.getScriptNonce_=function(a){return(a=a.querySelector&&a.querySelector("script[nonce]"))&&(a=a.nonce||a.getAttribute("nonce"))&&goog.NONCE_PATTERN_.test(a)?a:""};goog.VALID_MODULE_RE_=/^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
goog.module=function(a){if(!goog.isString(a)||!a||-1==a.search(goog.VALID_MODULE_RE_))throw Error("Invalid module identifier");if(!goog.isInGoogModuleLoader_())throw Error("Module "+a+" has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
if(goog.moduleLoaderState_.moduleName)throw Error("goog.module may only be called once per module.");goog.moduleLoaderState_.moduleName=a;if(!COMPILED){if(goog.isProvided_(a))throw Error('Namespace "'+a+'" already declared.');delete goog.implicitNamespaces_[a]}};goog.module.get=function(a){return goog.module.getInternal_(a)};
goog.module.getInternal_=function(a){if(!COMPILED){if(a in goog.loadedModules_)return goog.loadedModules_[a].exports;if(!goog.implicitNamespaces_[a])return a=goog.getObjectByName(a),null!=a?a:null}return null};goog.ModuleType={ES6:"es6",GOOG:"goog"};goog.moduleLoaderState_=null;goog.isInModuleLoader_=function(){return goog.isInGoogModuleLoader_()||goog.isInEs6ModuleLoader_()};goog.isInGoogModuleLoader_=function(){return!!goog.moduleLoaderState_&&goog.moduleLoaderState_.type==goog.ModuleType.GOOG};
goog.isInEs6ModuleLoader_=function(){if(goog.moduleLoaderState_&&goog.moduleLoaderState_.type==goog.ModuleType.ES6)return!0;var a=goog.global.$jscomp;return a?"function"!=typeof a.getCurrentModulePath?!1:!!a.getCurrentModulePath():!1};
goog.module.declareLegacyNamespace=function(){if(!COMPILED&&!goog.isInGoogModuleLoader_())throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");if(!COMPILED&&!goog.moduleLoaderState_.moduleName)throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");goog.moduleLoaderState_.declareLegacyNamespace=!0};
goog.declareModuleId=function(a){if(!COMPILED){if(!goog.isInEs6ModuleLoader_())throw Error("goog.declareModuleId may only be called from within an ES6 module");if(goog.moduleLoaderState_&&goog.moduleLoaderState_.moduleName)throw Error("goog.declareModuleId may only be called once per module.");if(a in goog.loadedModules_)throw Error('Module with namespace "'+a+'" already exists.');}if(goog.moduleLoaderState_)goog.moduleLoaderState_.moduleName=a;else{var b=goog.global.$jscomp;if(!b||"function"!=typeof b.getCurrentModulePath)throw Error('Module with namespace "'+
a+'" has been loaded incorrectly.');b=b.require(b.getCurrentModulePath());goog.loadedModules_[a]={exports:b,type:goog.ModuleType.ES6,moduleId:a}}};goog.setTestOnly=function(a){if(goog.DISALLOW_TEST_ONLY_CODE)throw a=a||"",Error("Importing test-only code into non-debug environment"+(a?": "+a:"."));};goog.forwardDeclare=function(a){};
COMPILED||(goog.isProvided_=function(a){return a in goog.loadedModules_||!goog.implicitNamespaces_[a]&&goog.isDefAndNotNull(goog.getObjectByName(a))},goog.implicitNamespaces_={"goog.module":!0});goog.getObjectByName=function(a,b){a=a.split(".");b=b||goog.global;for(var c=0;c<a.length;c++)if(b=b[a[c]],!goog.isDefAndNotNull(b))return null;return b};goog.globalize=function(a,b){b=b||goog.global;for(var c in a)b[c]=a[c]};
goog.addDependency=function(a,b,c,d){!COMPILED&&goog.DEPENDENCIES_ENABLED&&goog.debugLoader_.addDependency(a,b,c,d)};goog.ENABLE_DEBUG_LOADER=!0;goog.logToConsole_=function(a){goog.global.console&&goog.global.console.error(a)};
goog.require=function(a){if(!COMPILED){goog.ENABLE_DEBUG_LOADER&&goog.debugLoader_.requested(a);if(goog.isProvided_(a)){if(goog.isInModuleLoader_())return goog.module.getInternal_(a)}else if(goog.ENABLE_DEBUG_LOADER){var b=goog.moduleLoaderState_;goog.moduleLoaderState_=null;try{goog.debugLoader_.load_(a)}finally{goog.moduleLoaderState_=b}}return null}};goog.requireType=function(a){return{}};goog.basePath="";goog.nullFunction=function(){};
goog.abstractMethod=function(){throw Error("unimplemented abstract method");};goog.addSingletonGetter=function(a){a.instance_=void 0;a.getInstance=function(){if(a.instance_)return a.instance_;goog.DEBUG&&(goog.instantiatedSingletons_[goog.instantiatedSingletons_.length]=a);return a.instance_=new a}};goog.instantiatedSingletons_=[];goog.LOAD_MODULE_USING_EVAL=!0;goog.SEAL_MODULE_EXPORTS=goog.DEBUG;goog.loadedModules_={};goog.DEPENDENCIES_ENABLED=!COMPILED&&goog.ENABLE_DEBUG_LOADER;goog.TRANSPILE="detect";
goog.ASSUME_ES_MODULES_TRANSPILED=!1;goog.TRANSPILE_TO_LANGUAGE="";goog.TRANSPILER="transpile.js";goog.hasBadLetScoping=null;goog.useSafari10Workaround=function(){if(null==goog.hasBadLetScoping){try{var a=!eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";')}catch(b){a=!1}goog.hasBadLetScoping=a}return goog.hasBadLetScoping};goog.workaroundSafari10EvalBug=function(a){return"(function(){"+a+"\n;})();\n"};
goog.loadModule=function(a){var b=goog.moduleLoaderState_;try{goog.moduleLoaderState_={moduleName:"",declareLegacyNamespace:!1,type:goog.ModuleType.GOOG};if(goog.isFunction(a))var c=a.call(void 0,{});else if(goog.isString(a))goog.useSafari10Workaround()&&(a=goog.workaroundSafari10EvalBug(a)),c=goog.loadModuleFromSource_.call(void 0,a);else throw Error("Invalid module definition");var d=goog.moduleLoaderState_.moduleName;if(goog.isString(d)&&d)goog.moduleLoaderState_.declareLegacyNamespace?goog.constructNamespace_(d,
c):goog.SEAL_MODULE_EXPORTS&&Object.seal&&"object"==typeof c&&null!=c&&Object.seal(c),goog.loadedModules_[d]={exports:c,type:goog.ModuleType.GOOG,moduleId:goog.moduleLoaderState_.moduleName};else throw Error('Invalid module name "'+d+'"');}finally{goog.moduleLoaderState_=b}};goog.loadModuleFromSource_=function(a){eval(a);return{}};goog.normalizePath_=function(a){a=a.split("/");for(var b=0;b<a.length;)"."==a[b]?a.splice(b,1):b&&".."==a[b]&&a[b-1]&&".."!=a[b-1]?a.splice(--b,2):b++;return a.join("/")};
goog.loadFileSync_=function(a){if(goog.global.CLOSURE_LOAD_FILE_SYNC)return goog.global.CLOSURE_LOAD_FILE_SYNC(a);try{var b=new goog.global.XMLHttpRequest;b.open("get",a,!1);b.send();return 0==b.status||200==b.status?b.responseText:null}catch(c){return null}};
goog.transpile_=function(a,b,c){var d=goog.global.$jscomp;d||(goog.global.$jscomp=d={});var e=d.transpile;if(!e){var f=goog.basePath+goog.TRANSPILER,g=goog.loadFileSync_(f);if(g){(function(){(0,eval)(g+"\n//# sourceURL="+f)}).call(goog.global);if(goog.global.$gwtExport&&goog.global.$gwtExport.$jscomp&&!goog.global.$gwtExport.$jscomp.transpile)throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: '+JSON.stringify(goog.global.$gwtExport));goog.global.$jscomp.transpile=
goog.global.$gwtExport.$jscomp.transpile;d=goog.global.$jscomp;e=d.transpile}}e||(e=d.transpile=function(a,b){goog.logToConsole_(b+" requires transpilation but no transpiler was found.");return a});return e(a,b,c)};
goog.typeOf=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b};goog.isNull=function(a){return null===a};goog.isDefAndNotNull=function(a){return null!=a};goog.isArray=function(a){return"array"==goog.typeOf(a)};goog.isArrayLike=function(a){var b=goog.typeOf(a);return"array"==b||"object"==b&&"number"==typeof a.length};goog.isDateLike=function(a){return goog.isObject(a)&&"function"==typeof a.getFullYear};goog.isFunction=function(a){return"function"==goog.typeOf(a)};
goog.isObject=function(a){var b=typeof a;return"object"==b&&null!=a||"function"==b};goog.getUid=function(a){return a[goog.UID_PROPERTY_]||(a[goog.UID_PROPERTY_]=++goog.uidCounter_)};goog.hasUid=function(a){return!!a[goog.UID_PROPERTY_]};goog.removeUid=function(a){null!==a&&"removeAttribute"in a&&a.removeAttribute(goog.UID_PROPERTY_);try{delete a[goog.UID_PROPERTY_]}catch(b){}};goog.UID_PROPERTY_="closure_uid_"+(1E9*Math.random()>>>0);goog.uidCounter_=0;goog.getHashCode=goog.getUid;
goog.removeHashCode=goog.removeUid;goog.cloneObject=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if("function"===typeof a.clone)return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog.cloneObject(a[c]);return b}return a};goog.bindNative_=function(a,b,c){return a.call.apply(a.bind,arguments)};
goog.bindJs_=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}};goog.bind=function(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?goog.bind=goog.bindNative_:goog.bind=goog.bindJs_;return goog.bind.apply(null,arguments)};
goog.partial=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}};goog.mixin=function(a,b){for(var c in b)a[c]=b[c]};goog.now=goog.TRUSTED_SITE&&Date.now||function(){return+new Date};
goog.globalEval=function(a){if(goog.global.execScript)goog.global.execScript(a,"JavaScript");else if(goog.global.eval){if(null==goog.evalWorksForGlobals_){try{goog.global.eval("var _evalTest_ = 1;")}catch(d){}if("undefined"!=typeof goog.global._evalTest_){try{delete goog.global._evalTest_}catch(d){}goog.evalWorksForGlobals_=!0}else goog.evalWorksForGlobals_=!1}if(goog.evalWorksForGlobals_)goog.global.eval(a);else{var b=goog.global.document,c=b.createElement("SCRIPT");c.type="text/javascript";c.defer=
!1;c.appendChild(b.createTextNode(a));b.head.appendChild(c);b.head.removeChild(c)}}else throw Error("goog.globalEval not available");};goog.evalWorksForGlobals_=null;
goog.getCssName=function(a,b){if("."==String(a).charAt(0))throw Error('className passed in goog.getCssName must not start with ".". You passed: '+a);var c=function(a){return goog.cssNameMapping_[a]||a},d=function(a){a=a.split("-");for(var b=[],d=0;d<a.length;d++)b.push(c(a[d]));return b.join("-")};d=goog.cssNameMapping_?"BY_WHOLE"==goog.cssNameMappingStyle_?c:d:function(a){return a};a=b?a+"-"+d(b):d(a);return goog.global.CLOSURE_CSS_NAME_MAP_FN?goog.global.CLOSURE_CSS_NAME_MAP_FN(a):a};
goog.setCssNameMapping=function(a,b){goog.cssNameMapping_=a;goog.cssNameMappingStyle_=b};!COMPILED&&goog.global.CLOSURE_CSS_NAME_MAPPING&&(goog.cssNameMapping_=goog.global.CLOSURE_CSS_NAME_MAPPING);goog.getMsg=function(a,b,c){c&&c.html&&(a=a.replace(/</g,"&lt;"));b&&(a=a.replace(/\{\$([^}]+)}/g,function(a,c){return null!=b&&c in b?b[c]:a}));return a};goog.getMsgWithFallback=function(a,b){return a};goog.exportSymbol=function(a,b,c){goog.exportPath_(a,b,c)};
goog.exportProperty=function(a,b,c){a[b]=c};goog.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.superClass_=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.base=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};
goog.base=function(a,b,c){var d=arguments.callee.caller;if(goog.STRICT_MODE_COMPATIBLE||goog.DEBUG&&!d)throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");if("undefined"!==typeof d.superClass_){for(var e=Array(arguments.length-1),f=1;f<arguments.length;f++)e[f-1]=arguments[f];return d.superClass_.constructor.apply(a,e)}if("string"!=typeof b&&"symbol"!=typeof b)throw Error("method names provided to goog.base must be a string or a symbol");
e=Array(arguments.length-2);for(f=2;f<arguments.length;f++)e[f-2]=arguments[f];f=!1;for(var g=a.constructor.prototype;g;g=Object.getPrototypeOf(g))if(g[b]===d)f=!0;else if(f)return g[b].apply(a,e);if(a[b]===d)return a.constructor.prototype[b].apply(a,e);throw Error("goog.base called from a method of one name to a method of a different name");};goog.scope=function(a){if(goog.isInModuleLoader_())throw Error("goog.scope is not supported within a module.");a.call(goog.global)};
COMPILED||(goog.global.COMPILED=COMPILED);goog.defineClass=function(a,b){var c=b.constructor,d=b.statics;c&&c!=Object.prototype.constructor||(c=function(){throw Error("cannot instantiate an interface (no constructor defined).");});c=goog.defineClass.createSealingConstructor_(c,a);a&&goog.inherits(c,a);delete b.constructor;delete b.statics;goog.defineClass.applyProperties_(c.prototype,b);null!=d&&(d instanceof Function?d(c):goog.defineClass.applyProperties_(c,d));return c};
goog.defineClass.SEAL_CLASS_INSTANCES=goog.DEBUG;goog.defineClass.createSealingConstructor_=function(a,b){if(!goog.defineClass.SEAL_CLASS_INSTANCES)return a;var c=!goog.defineClass.isUnsealable_(b),d=function(){var b=a.apply(this,arguments)||this;b[goog.UID_PROPERTY_]=b[goog.UID_PROPERTY_];this.constructor===d&&c&&Object.seal instanceof Function&&Object.seal(b);return b};return d};goog.defineClass.isUnsealable_=function(a){return a&&a.prototype&&a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]};
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");goog.defineClass.applyProperties_=function(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);for(var d=0;d<goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++)c=goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d],Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c])};
goog.tagUnsealableClass=function(a){!COMPILED&&goog.defineClass.SEAL_CLASS_INSTANCES&&(a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]=!0)};goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_="goog_defineClass_legacy_unsealable";
!COMPILED&&goog.DEPENDENCIES_ENABLED&&(goog.inHtmlDocument_=function(){var a=goog.global.document;return null!=a&&"write"in a},goog.isDocumentLoading_=function(){var a=goog.global.document;return a.attachEvent?"complete"!=a.readyState:"loading"==a.readyState},goog.findBasePath_=function(){if(goog.isDef(goog.global.CLOSURE_BASE_PATH)&&goog.isString(goog.global.CLOSURE_BASE_PATH))goog.basePath=goog.global.CLOSURE_BASE_PATH;else if(goog.inHtmlDocument_()){var a=goog.global.document,b=a.currentScript;
a=b?[b]:a.getElementsByTagName("SCRIPT");for(b=a.length-1;0<=b;--b){var c=a[b].src,d=c.lastIndexOf("?");d=-1==d?c.length:d;if("base.js"==c.substr(d-7,7)){goog.basePath=c.substr(0,d-7);break}}}},goog.findBasePath_(),goog.Transpiler=function(){this.requiresTranspilation_=null;this.transpilationTarget_=goog.TRANSPILE_TO_LANGUAGE},goog.Transpiler.prototype.createRequiresTranspilation_=function(){function a(a,b){e?d[a]=!0:b()?(c=a,d[a]=!1):e=d[a]=!0}function b(a){try{return!!eval(a)}catch(h){return!1}}
var c="es3",d={es3:!1},e=!1,f=goog.global.navigator&&goog.global.navigator.userAgent?goog.global.navigator.userAgent:"";a("es5",function(){return b("[1,].length==1")});a("es6",function(){return f.match(/Edge\/(\d+)(\.\d)*/i)?!1:b('(()=>{"use strict";class X{constructor(){if(new.target!=String)throw 1;this.x=42}}let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof String))throw 1;for(const a of[2,3]){if(a==2)continue;function f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()==3}})()')});
a("es7",function(){return b("2 ** 2 == 4")});a("es8",function(){return b("async () => 1, true")});a("es9",function(){return b("({...rest} = {}), true")});a("es_next",function(){return!1});return{target:c,map:d}},goog.Transpiler.prototype.needsTranspile=function(a,b){if("always"==goog.TRANSPILE)return!0;if("never"==goog.TRANSPILE)return!1;if(!this.requiresTranspilation_){var c=this.createRequiresTranspilation_();this.requiresTranspilation_=c.map;this.transpilationTarget_=this.transpilationTarget_||
c.target}if(a in this.requiresTranspilation_)return this.requiresTranspilation_[a]?!0:!goog.inHtmlDocument_()||"es6"!=b||"noModule"in goog.global.document.createElement("script")?!1:!0;throw Error("Unknown language mode: "+a);},goog.Transpiler.prototype.transpile=function(a,b){return goog.transpile_(a,b,this.transpilationTarget_)},goog.transpiler_=new goog.Transpiler,goog.protectScriptTag_=function(a){return a.replace(/<\/(SCRIPT)/ig,"\\x3c/$1")},goog.DebugLoader_=function(){this.dependencies_={};
this.idToPath_={};this.written_={};this.loadingDeps_=[];this.depsToLoad_=[];this.paused_=!1;this.factory_=new goog.DependencyFactory(goog.transpiler_);this.deferredCallbacks_={};this.deferredQueue_=[]},goog.DebugLoader_.prototype.bootstrap=function(a,b){function c(){d&&(goog.global.setTimeout(d,0),d=null)}var d=b;if(a.length){b=[];for(var e=0;e<a.length;e++){var f=this.getPathFromDeps_(a[e]);if(!f)throw Error("Unregonized namespace: "+a[e]);b.push(this.dependencies_[f])}f=goog.require;var g=0;for(e=
0;e<a.length;e++)f(a[e]),b[e].onLoad(function(){++g==a.length&&c()})}else c()},goog.DebugLoader_.prototype.loadClosureDeps=function(){this.depsToLoad_.push(this.factory_.createDependency(goog.normalizePath_(goog.basePath+"deps.js"),"deps.js",[],[],{},!1));this.loadDeps_()},goog.DebugLoader_.prototype.requested=function(a,b){(a=this.getPathFromDeps_(a))&&(b||this.areDepsLoaded_(this.dependencies_[a].requires))&&(b=this.deferredCallbacks_[a])&&(delete this.deferredCallbacks_[a],b())},goog.DebugLoader_.prototype.setDependencyFactory=
function(a){this.factory_=a},goog.DebugLoader_.prototype.load_=function(a){if(this.getPathFromDeps_(a)){var b=this,c=[],d=function(a){var e=b.getPathFromDeps_(a);if(!e)throw Error("Bad dependency path or symbol: "+a);if(!b.written_[e]){b.written_[e]=!0;a=b.dependencies_[e];for(e=0;e<a.requires.length;e++)goog.isProvided_(a.requires[e])||d(a.requires[e]);c.push(a)}};d(a);a=!!this.depsToLoad_.length;this.depsToLoad_=this.depsToLoad_.concat(c);this.paused_||a||this.loadDeps_()}else throw a="goog.require could not find: "+
a,goog.logToConsole_(a),Error(a);},goog.DebugLoader_.prototype.loadDeps_=function(){for(var a=this,b=this.paused_;this.depsToLoad_.length&&!b;)(function(){var c=!1,d=a.depsToLoad_.shift(),e=!1;a.loading_(d);var f={pause:function(){if(c)throw Error("Cannot call pause after the call to load.");b=!0},resume:function(){c?a.resume_():b=!1},loaded:function(){if(e)throw Error("Double call to loaded.");e=!0;a.loaded_(d)},pending:function(){for(var b=[],c=0;c<a.loadingDeps_.length;c++)b.push(a.loadingDeps_[c]);
return b},setModuleState:function(a){goog.moduleLoaderState_={type:a,moduleName:"",declareLegacyNamespace:!1}},registerEs6ModuleExports:function(a,b,c){c&&(goog.loadedModules_[c]={exports:b,type:goog.ModuleType.ES6,moduleId:c||""})},registerGoogModuleExports:function(a,b){goog.loadedModules_[a]={exports:b,type:goog.ModuleType.GOOG,moduleId:a}},clearModuleState:function(){goog.moduleLoaderState_=null},defer:function(b){if(c)throw Error("Cannot register with defer after the call to load.");a.defer_(d,
b)},areDepsLoaded:function(){return a.areDepsLoaded_(d.requires)}};try{d.load(f)}finally{c=!0}})();b&&this.pause_()},goog.DebugLoader_.prototype.pause_=function(){this.paused_=!0},goog.DebugLoader_.prototype.resume_=function(){this.paused_&&(this.paused_=!1,this.loadDeps_())},goog.DebugLoader_.prototype.loading_=function(a){this.loadingDeps_.push(a)},goog.DebugLoader_.prototype.loaded_=function(a){for(var b=0;b<this.loadingDeps_.length;b++)if(this.loadingDeps_[b]==a){this.loadingDeps_.splice(b,1);
break}for(b=0;b<this.deferredQueue_.length;b++)if(this.deferredQueue_[b]==a.path){this.deferredQueue_.splice(b,1);break}if(this.loadingDeps_.length==this.deferredQueue_.length&&!this.depsToLoad_.length)for(;this.deferredQueue_.length;)this.requested(this.deferredQueue_.shift(),!0);a.loaded()},goog.DebugLoader_.prototype.areDepsLoaded_=function(a){for(var b=0;b<a.length;b++){var c=this.getPathFromDeps_(a[b]);if(!c||!(c in this.deferredCallbacks_||goog.isProvided_(a[b])))return!1}return!0},goog.DebugLoader_.prototype.getPathFromDeps_=
function(a){return a in this.idToPath_?this.idToPath_[a]:a in this.dependencies_?a:null},goog.DebugLoader_.prototype.defer_=function(a,b){this.deferredCallbacks_[a.path]=b;this.deferredQueue_.push(a.path)},goog.LoadController=function(){},goog.LoadController.prototype.pause=function(){},goog.LoadController.prototype.resume=function(){},goog.LoadController.prototype.loaded=function(){},goog.LoadController.prototype.pending=function(){},goog.LoadController.prototype.registerEs6ModuleExports=function(a,
b,c){},goog.LoadController.prototype.setModuleState=function(a){},goog.LoadController.prototype.clearModuleState=function(){},goog.LoadController.prototype.defer=function(a){},goog.LoadController.prototype.areDepsLoaded=function(){},goog.Dependency=function(a,b,c,d,e){this.path=a;this.relativePath=b;this.provides=c;this.requires=d;this.loadFlags=e;this.loaded_=!1;this.loadCallbacks_=[]},goog.Dependency.prototype.getPathName=function(){var a=this.path,b=a.indexOf("://");0<=b&&(a=a.substring(b+3),b=
a.indexOf("/"),0<=b&&(a=a.substring(b+1)));return a},goog.Dependency.prototype.onLoad=function(a){this.loaded_?a():this.loadCallbacks_.push(a)},goog.Dependency.prototype.loaded=function(){this.loaded_=!0;var a=this.loadCallbacks_;this.loadCallbacks_=[];for(var b=0;b<a.length;b++)a[b]()},goog.Dependency.defer_=!1,goog.Dependency.callbackMap_={},goog.Dependency.registerCallback_=function(a){var b=Math.random().toString(32);goog.Dependency.callbackMap_[b]=a;return b},goog.Dependency.unregisterCallback_=
function(a){delete goog.Dependency.callbackMap_[a]},goog.Dependency.callback_=function(a,b){if(a in goog.Dependency.callbackMap_){for(var c=goog.Dependency.callbackMap_[a],d=[],e=1;e<arguments.length;e++)d.push(arguments[e]);c.apply(void 0,d)}else throw Error("Callback key "+a+" does not exist (was base.js loaded more than once?).");},goog.Dependency.prototype.load=function(a){if(goog.global.CLOSURE_IMPORT_SCRIPT)goog.global.CLOSURE_IMPORT_SCRIPT(this.path)?a.loaded():a.pause();else if(goog.inHtmlDocument_()){var b=
goog.global.document;if("complete"==b.readyState&&!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING){if(/\bdeps.js$/.test(this.path)){a.loaded();return}throw Error('Cannot write "'+this.path+'" after document load');}if(!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING&&goog.isDocumentLoading_()){var c=goog.Dependency.registerCallback_(function(b){goog.DebugLoader_.IS_OLD_IE_&&"complete"!=b.readyState||(goog.Dependency.unregisterCallback_(c),a.loaded())}),d=!goog.DebugLoader_.IS_OLD_IE_&&goog.getScriptNonce()?
' nonce="'+goog.getScriptNonce()+'"':"";d='<script src="'+this.path+'" '+(goog.DebugLoader_.IS_OLD_IE_?"onreadystatechange":"onload")+"=\"goog.Dependency.callback_('"+c+'\', this)" type="text/javascript" '+(goog.Dependency.defer_?"defer":"")+d+">\x3c/script>";b.write(goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createHTML(d):d)}else{var e=b.createElement("script");e.defer=goog.Dependency.defer_;e.async=!1;e.type="text/javascript";(d=goog.getScriptNonce())&&e.setAttribute("nonce",d);goog.DebugLoader_.IS_OLD_IE_?
(a.pause(),e.onreadystatechange=function(){if("loaded"==e.readyState||"complete"==e.readyState)a.loaded(),a.resume()}):e.onload=function(){e.onload=null;a.loaded()};e.src=goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createScriptURL(this.path):this.path;b.head.appendChild(e)}}else goog.logToConsole_("Cannot use default debug loader outside of HTML documents."),"deps.js"==this.relativePath?(goog.logToConsole_("Consider setting CLOSURE_IMPORT_SCRIPT before loading base.js, or setting CLOSURE_NO_DEPS to true."),
a.loaded()):a.pause()},goog.Es6ModuleDependency=function(a,b,c,d,e){goog.Dependency.call(this,a,b,c,d,e)},goog.inherits(goog.Es6ModuleDependency,goog.Dependency),goog.Es6ModuleDependency.prototype.load=function(a){function b(a,b){a=b?'<script type="module" crossorigin>'+b+"\x3c/script>":'<script type="module" crossorigin src="'+a+'">\x3c/script>';d.write(goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createHTML(a):a)}function c(a,b){var c=d.createElement("script");c.defer=!0;c.async=!1;c.type=
"module";c.setAttribute("crossorigin",!0);var e=goog.getScriptNonce();e&&c.setAttribute("nonce",e);b?c.textContent=goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createScript(b):b:c.src=goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createScriptURL(a):a;d.head.appendChild(c)}if(goog.global.CLOSURE_IMPORT_SCRIPT)goog.global.CLOSURE_IMPORT_SCRIPT(this.path)?a.loaded():a.pause();else if(goog.inHtmlDocument_()){var d=goog.global.document,e=this;if(goog.isDocumentLoading_()){var f=b;goog.Dependency.defer_=
!0}else f=c;var g=goog.Dependency.registerCallback_(function(){goog.Dependency.unregisterCallback_(g);a.setModuleState(goog.ModuleType.ES6)});f(void 0,'goog.Dependency.callback_("'+g+'")');f(this.path,void 0);var h=goog.Dependency.registerCallback_(function(b){goog.Dependency.unregisterCallback_(h);a.registerEs6ModuleExports(e.path,b,goog.moduleLoaderState_.moduleName)});f(void 0,'import * as m from "'+this.path+'"; goog.Dependency.callback_("'+h+'", m)');var k=goog.Dependency.registerCallback_(function(){goog.Dependency.unregisterCallback_(k);
a.clearModuleState();a.loaded()});f(void 0,'goog.Dependency.callback_("'+k+'")')}else goog.logToConsole_("Cannot use default debug loader outside of HTML documents."),a.pause()},goog.TransformedDependency=function(a,b,c,d,e){goog.Dependency.call(this,a,b,c,d,e);this.contents_=null;this.lazyFetch_=!goog.inHtmlDocument_()||!("noModule"in goog.global.document.createElement("script"))},goog.inherits(goog.TransformedDependency,goog.Dependency),goog.TransformedDependency.prototype.load=function(a){function b(){e.contents_=
goog.loadFileSync_(e.path);e.contents_&&(e.contents_=e.transform(e.contents_),e.contents_&&(e.contents_+="\n//# sourceURL="+e.path))}function c(){e.lazyFetch_&&b();if(e.contents_){f&&a.setModuleState(goog.ModuleType.ES6);try{var c=e.contents_;e.contents_=null;goog.globalEval(c);if(f)var d=goog.moduleLoaderState_.moduleName}finally{f&&a.clearModuleState()}f&&goog.global.$jscomp.require.ensure([e.getPathName()],function(){a.registerEs6ModuleExports(e.path,goog.global.$jscomp.require(e.getPathName()),
d)});a.loaded()}}function d(){var a=goog.global.document,b=goog.Dependency.registerCallback_(function(){goog.Dependency.unregisterCallback_(b);c()}),d='<script type="text/javascript">'+goog.protectScriptTag_('goog.Dependency.callback_("'+b+'");')+"\x3c/script>";a.write(goog.TRUSTED_TYPES_POLICY_?goog.TRUSTED_TYPES_POLICY_.createHTML(d):d)}var e=this;if(goog.global.CLOSURE_IMPORT_SCRIPT)b(),this.contents_&&goog.global.CLOSURE_IMPORT_SCRIPT("",this.contents_)?(this.contents_=null,a.loaded()):a.pause();
else{var f=this.loadFlags.module==goog.ModuleType.ES6;this.lazyFetch_||b();var g=1<a.pending().length,h=g&&goog.DebugLoader_.IS_OLD_IE_;g=goog.Dependency.defer_&&(g||goog.isDocumentLoading_());if(h||g)a.defer(function(){c()});else{var k=goog.global.document;h=goog.inHtmlDocument_()&&"ActiveXObject"in goog.global;if(f&&goog.inHtmlDocument_()&&goog.isDocumentLoading_()&&!h){goog.Dependency.defer_=!0;a.pause();var l=k.onreadystatechange;k.onreadystatechange=function(){"interactive"==k.readyState&&(k.onreadystatechange=
l,c(),a.resume());goog.isFunction(l)&&l.apply(void 0,arguments)}}else!goog.DebugLoader_.IS_OLD_IE_&&goog.inHtmlDocument_()&&goog.isDocumentLoading_()?d():c()}}},goog.TransformedDependency.prototype.transform=function(a){},goog.TranspiledDependency=function(a,b,c,d,e,f){goog.TransformedDependency.call(this,a,b,c,d,e);this.transpiler=f},goog.inherits(goog.TranspiledDependency,goog.TransformedDependency),goog.TranspiledDependency.prototype.transform=function(a){return this.transpiler.transpile(a,this.getPathName())},
goog.PreTranspiledEs6ModuleDependency=function(a,b,c,d,e){goog.TransformedDependency.call(this,a,b,c,d,e)},goog.inherits(goog.PreTranspiledEs6ModuleDependency,goog.TransformedDependency),goog.PreTranspiledEs6ModuleDependency.prototype.transform=function(a){return a},goog.GoogModuleDependency=function(a,b,c,d,e,f,g){goog.TransformedDependency.call(this,a,b,c,d,e);this.needsTranspile_=f;this.transpiler_=g},goog.inherits(goog.GoogModuleDependency,goog.TransformedDependency),goog.GoogModuleDependency.prototype.transform=
function(a){this.needsTranspile_&&(a=this.transpiler_.transpile(a,this.getPathName()));return goog.LOAD_MODULE_USING_EVAL&&goog.isDef(goog.global.JSON)?"goog.loadModule("+goog.global.JSON.stringify(a+"\n//# sourceURL="+this.path+"\n")+");":'goog.loadModule(function(exports) {"use strict";'+a+"\n;return exports});\n//# sourceURL="+this.path+"\n"},goog.DebugLoader_.IS_OLD_IE_=!(goog.global.atob||!goog.global.document||!goog.global.document.all),goog.DebugLoader_.prototype.addDependency=function(a,b,
c,d){b=b||[];a=a.replace(/\\/g,"/");var e=goog.normalizePath_(goog.basePath+a);d&&"boolean"!==typeof d||(d=d?{module:goog.ModuleType.GOOG}:{});c=this.factory_.createDependency(e,a,b,c,d,goog.transpiler_.needsTranspile(d.lang||"es3",d.module));this.dependencies_[e]=c;for(c=0;c<b.length;c++)this.idToPath_[b[c]]=e;this.idToPath_[a]=e},goog.DependencyFactory=function(a){this.transpiler=a},goog.DependencyFactory.prototype.createDependency=function(a,b,c,d,e,f){return e.module==goog.ModuleType.GOOG?new goog.GoogModuleDependency(a,
b,c,d,e,f,this.transpiler):f?new goog.TranspiledDependency(a,b,c,d,e,this.transpiler):e.module==goog.ModuleType.ES6?"never"==goog.TRANSPILE&&goog.ASSUME_ES_MODULES_TRANSPILED?new goog.PreTranspiledEs6ModuleDependency(a,b,c,d,e):new goog.Es6ModuleDependency(a,b,c,d,e):new goog.Dependency(a,b,c,d,e)},goog.debugLoader_=new goog.DebugLoader_,goog.loadClosureDeps=function(){goog.debugLoader_.loadClosureDeps()},goog.setDependencyFactory=function(a){goog.debugLoader_.setDependencyFactory(a)},goog.global.CLOSURE_NO_DEPS||
goog.debugLoader_.loadClosureDeps(),goog.bootstrap=function(a,b){goog.debugLoader_.bootstrap(a,b)});goog.TRUSTED_TYPES_POLICY_NAME="";goog.identity_=function(a){return a};goog.createTrustedTypesPolicy=function(a){var b=null;if("undefined"===typeof TrustedTypes||!TrustedTypes.createPolicy)return b;try{b=TrustedTypes.createPolicy(a,{createHTML:goog.identity_,createScript:goog.identity_,createScriptURL:goog.identity_,createURL:goog.identity_})}catch(c){goog.logToConsole_(c.message)}return b};
goog.TRUSTED_TYPES_POLICY_=goog.TRUSTED_TYPES_POLICY_NAME?goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME+"#base"):null;var jspb={BinaryConstants:{},ConstBinaryMessage:function(){},BinaryMessage:function(){}};jspb.BinaryConstants.FieldType={INVALID:-1,DOUBLE:1,FLOAT:2,INT64:3,UINT64:4,INT32:5,FIXED64:6,FIXED32:7,BOOL:8,STRING:9,GROUP:10,MESSAGE:11,BYTES:12,UINT32:13,ENUM:14,SFIXED32:15,SFIXED64:16,SINT32:17,SINT64:18,FHASH64:30,VHASH64:31};jspb.BinaryConstants.WireType={INVALID:-1,VARINT:0,FIXED64:1,DELIMITED:2,START_GROUP:3,END_GROUP:4,FIXED32:5};
jspb.BinaryConstants.FieldTypeToWireType=function(a){var b=jspb.BinaryConstants.FieldType,c=jspb.BinaryConstants.WireType;switch(a){case b.INT32:case b.INT64:case b.UINT32:case b.UINT64:case b.SINT32:case b.SINT64:case b.BOOL:case b.ENUM:case b.VHASH64:return c.VARINT;case b.DOUBLE:case b.FIXED64:case b.SFIXED64:case b.FHASH64:return c.FIXED64;case b.STRING:case b.MESSAGE:case b.BYTES:return c.DELIMITED;case b.FLOAT:case b.FIXED32:case b.SFIXED32:return c.FIXED32;default:return c.INVALID}};
jspb.BinaryConstants.INVALID_FIELD_NUMBER=-1;jspb.BinaryConstants.FLOAT32_EPS=1.401298464324817E-45;jspb.BinaryConstants.FLOAT32_MIN=1.1754943508222875E-38;jspb.BinaryConstants.FLOAT32_MAX=3.4028234663852886E38;jspb.BinaryConstants.FLOAT64_EPS=4.9E-324;jspb.BinaryConstants.FLOAT64_MIN=2.2250738585072014E-308;jspb.BinaryConstants.FLOAT64_MAX=1.7976931348623157E308;jspb.BinaryConstants.TWO_TO_20=1048576;jspb.BinaryConstants.TWO_TO_23=8388608;jspb.BinaryConstants.TWO_TO_31=2147483648;
jspb.BinaryConstants.TWO_TO_32=4294967296;jspb.BinaryConstants.TWO_TO_52=4503599627370496;jspb.BinaryConstants.TWO_TO_63=0x7fffffffffffffff;jspb.BinaryConstants.TWO_TO_64=1.8446744073709552E19;jspb.BinaryConstants.ZERO_HASH="\x00\x00\x00\x00\x00\x00\x00\x00";goog.dom={};goog.dom.NodeType={ELEMENT:1,ATTRIBUTE:2,TEXT:3,CDATA_SECTION:4,ENTITY_REFERENCE:5,ENTITY:6,PROCESSING_INSTRUCTION:7,COMMENT:8,DOCUMENT:9,DOCUMENT_TYPE:10,DOCUMENT_FRAGMENT:11,NOTATION:12};goog.debug={};goog.debug.Error=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,goog.debug.Error);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a));this.reportErrorToServer=!0};goog.inherits(goog.debug.Error,Error);goog.debug.Error.prototype.name="CustomError";goog.asserts={};goog.asserts.ENABLE_ASSERTS=goog.DEBUG;goog.asserts.AssertionError=function(a,b){goog.debug.Error.call(this,goog.asserts.subs_(a,b));this.messagePattern=a};goog.inherits(goog.asserts.AssertionError,goog.debug.Error);goog.asserts.AssertionError.prototype.name="AssertionError";goog.asserts.DEFAULT_ERROR_HANDLER=function(a){throw a;};goog.asserts.errorHandler_=goog.asserts.DEFAULT_ERROR_HANDLER;
goog.asserts.subs_=function(a,b){a=a.split("%s");for(var c="",d=a.length-1,e=0;e<d;e++)c+=a[e]+(e<b.length?b[e]:"%s");return c+a[d]};goog.asserts.doAssertFailure_=function(a,b,c,d){var e="Assertion failed";if(c){e+=": "+c;var f=d}else a&&(e+=": "+a,f=b);a=new goog.asserts.AssertionError(""+e,f||[]);goog.asserts.errorHandler_(a)};goog.asserts.setErrorHandler=function(a){goog.asserts.ENABLE_ASSERTS&&(goog.asserts.errorHandler_=a)};
goog.asserts.assert=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!a&&goog.asserts.doAssertFailure_("",null,b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertExists=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&null==a&&goog.asserts.doAssertFailure_("Expected to exist: %s.",[a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.fail=function(a,b){goog.asserts.ENABLE_ASSERTS&&goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1)))};goog.asserts.assertNumber=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isNumber(a)&&goog.asserts.doAssertFailure_("Expected number but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertString=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isString(a)&&goog.asserts.doAssertFailure_("Expected string but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertFunction=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isFunction(a)&&goog.asserts.doAssertFailure_("Expected function but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertObject=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isObject(a)&&goog.asserts.doAssertFailure_("Expected object but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertArray=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isArray(a)&&goog.asserts.doAssertFailure_("Expected array but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertBoolean=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isBoolean(a)&&goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertElement=function(a,b,c){!goog.asserts.ENABLE_ASSERTS||goog.isObject(a)&&a.nodeType==goog.dom.NodeType.ELEMENT||goog.asserts.doAssertFailure_("Expected Element but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertInstanceof=function(a,b,c,d){!goog.asserts.ENABLE_ASSERTS||a instanceof b||goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.",[goog.asserts.getType_(b),goog.asserts.getType_(a)],c,Array.prototype.slice.call(arguments,3));return a};goog.asserts.assertFinite=function(a,b,c){!goog.asserts.ENABLE_ASSERTS||"number"==typeof a&&isFinite(a)||goog.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.",[a],b,Array.prototype.slice.call(arguments,2));return a};
goog.asserts.assertObjectPrototypeIsIntact=function(){for(var a in Object.prototype)goog.asserts.fail(a+" should not be enumerable in Object.prototype.")};goog.asserts.getType_=function(a){return a instanceof Function?a.displayName||a.name||"unknown type name":a instanceof Object?a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a):null===a?"null":typeof a};goog.array={};goog.NATIVE_ARRAY_PROTOTYPES=goog.TRUSTED_SITE;goog.array.ASSUME_NATIVE_FUNCTIONS=2012<goog.FEATURESET_YEAR;goog.array.peek=function(a){return a[a.length-1]};goog.array.last=goog.array.peek;
goog.array.indexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.indexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(goog.isString(a))return goog.isString(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1};
goog.array.lastIndexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.lastIndexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.lastIndexOf.call(a,b,null==c?a.length-1:c)}:function(a,b,c){c=null==c?a.length-1:c;0>c&&(c=Math.max(0,a.length+c));if(goog.isString(a))return goog.isString(b)&&1==b.length?a.lastIndexOf(b,c):-1;for(;0<=c;c--)if(c in a&&a[c]===b)return c;return-1};
goog.array.forEach=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.forEach)?function(a,b,c){goog.asserts.assert(null!=a.length);Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)};goog.array.forEachRight=function(a,b,c){var d=a.length,e=goog.isString(a)?a.split(""):a;for(--d;0<=d;--d)d in e&&b.call(c,e[d],d,a)};
goog.array.filter=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.filter)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=goog.isString(a)?a.split(""):a,h=0;h<d;h++)if(h in g){var k=g[h];b.call(c,k,h,a)&&(e[f++]=k)}return e};
goog.array.map=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.map)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=goog.isString(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e};
goog.array.reduce=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduce)?function(a,b,c,d){goog.asserts.assert(null!=a.length);d&&(b=goog.bind(b,d));return Array.prototype.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEach(a,function(c,g){e=b.call(d,e,c,g,a)});return e};
goog.array.reduceRight=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduceRight)?function(a,b,c,d){goog.asserts.assert(null!=a.length);goog.asserts.assert(null!=b);d&&(b=goog.bind(b,d));return Array.prototype.reduceRight.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEachRight(a,function(c,g){e=b.call(d,e,c,g,a)});return e};
goog.array.some=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.some)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return!0;return!1};
goog.array.every=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.every)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0};goog.array.count=function(a,b,c){var d=0;goog.array.forEach(a,function(a,f,g){b.call(c,a,f,g)&&++d},c);return d};
goog.array.find=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};goog.array.findIndex=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return-1};goog.array.findRight=function(a,b,c){b=goog.array.findIndexRight(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};
goog.array.findIndexRight=function(a,b,c){var d=a.length,e=goog.isString(a)?a.split(""):a;for(--d;0<=d;d--)if(d in e&&b.call(c,e[d],d,a))return d;return-1};goog.array.contains=function(a,b){return 0<=goog.array.indexOf(a,b)};goog.array.isEmpty=function(a){return 0==a.length};goog.array.clear=function(a){if(!goog.isArray(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0};goog.array.insert=function(a,b){goog.array.contains(a,b)||a.push(b)};
goog.array.insertAt=function(a,b,c){goog.array.splice(a,c,0,b)};goog.array.insertArrayAt=function(a,b,c){goog.partial(goog.array.splice,a,c,0).apply(null,b)};goog.array.insertBefore=function(a,b,c){var d;2==arguments.length||0>(d=goog.array.indexOf(a,c))?a.push(b):goog.array.insertAt(a,b,d)};goog.array.remove=function(a,b){b=goog.array.indexOf(a,b);var c;(c=0<=b)&&goog.array.removeAt(a,b);return c};
goog.array.removeLast=function(a,b){b=goog.array.lastIndexOf(a,b);return 0<=b?(goog.array.removeAt(a,b),!0):!1};goog.array.removeAt=function(a,b){goog.asserts.assert(null!=a.length);return 1==Array.prototype.splice.call(a,b,1).length};goog.array.removeIf=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0<=b?(goog.array.removeAt(a,b),!0):!1};goog.array.removeAllIf=function(a,b,c){var d=0;goog.array.forEachRight(a,function(e,f){b.call(c,e,f,a)&&goog.array.removeAt(a,f)&&d++});return d};
goog.array.concat=function(a){return Array.prototype.concat.apply([],arguments)};goog.array.join=function(a){return Array.prototype.concat.apply([],arguments)};goog.array.toArray=function(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]};goog.array.clone=goog.array.toArray;goog.array.extend=function(a,b){for(var c=1;c<arguments.length;c++){var d=arguments[c];if(goog.isArrayLike(d)){var e=a.length||0,f=d.length||0;a.length=e+f;for(var g=0;g<f;g++)a[e+g]=d[g]}else a.push(d)}};
goog.array.splice=function(a,b,c,d){goog.asserts.assert(null!=a.length);return Array.prototype.splice.apply(a,goog.array.slice(arguments,1))};goog.array.slice=function(a,b,c){goog.asserts.assert(null!=a.length);return 2>=arguments.length?Array.prototype.slice.call(a,b):Array.prototype.slice.call(a,b,c)};
goog.array.removeDuplicates=function(a,b,c){b=b||a;var d=function(a){return goog.isObject(a)?"o"+goog.getUid(a):(typeof a).charAt(0)+a};c=c||d;d={};for(var e=0,f=0;f<a.length;){var g=a[f++],h=c(g);Object.prototype.hasOwnProperty.call(d,h)||(d[h]=!0,b[e++]=g)}b.length=e};goog.array.binarySearch=function(a,b,c){return goog.array.binarySearch_(a,c||goog.array.defaultCompare,!1,b)};goog.array.binarySelect=function(a,b,c){return goog.array.binarySearch_(a,b,!0,void 0,c)};
goog.array.binarySearch_=function(a,b,c,d,e){for(var f=0,g=a.length,h;f<g;){var k=f+g>>1;var l=c?b.call(e,a[k],k,a):b(d,a[k]);0<l?f=k+1:(g=k,h=!l)}return h?f:~f};goog.array.sort=function(a,b){a.sort(b||goog.array.defaultCompare)};goog.array.stableSort=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]={index:d,value:a[d]};var e=b||goog.array.defaultCompare;goog.array.sort(c,function(a,b){return e(a.value,b.value)||a.index-b.index});for(d=0;d<a.length;d++)a[d]=c[d].value};
goog.array.sortByKey=function(a,b,c){var d=c||goog.array.defaultCompare;goog.array.sort(a,function(a,c){return d(b(a),b(c))})};goog.array.sortObjectsByKey=function(a,b,c){goog.array.sortByKey(a,function(a){return a[b]},c)};goog.array.isSorted=function(a,b,c){b=b||goog.array.defaultCompare;for(var d=1;d<a.length;d++){var e=b(a[d-1],a[d]);if(0<e||0==e&&c)return!1}return!0};
goog.array.equals=function(a,b,c){if(!goog.isArrayLike(a)||!goog.isArrayLike(b)||a.length!=b.length)return!1;var d=a.length;c=c||goog.array.defaultCompareEquality;for(var e=0;e<d;e++)if(!c(a[e],b[e]))return!1;return!0};goog.array.compare3=function(a,b,c){c=c||goog.array.defaultCompare;for(var d=Math.min(a.length,b.length),e=0;e<d;e++){var f=c(a[e],b[e]);if(0!=f)return f}return goog.array.defaultCompare(a.length,b.length)};goog.array.defaultCompare=function(a,b){return a>b?1:a<b?-1:0};
goog.array.inverseDefaultCompare=function(a,b){return-goog.array.defaultCompare(a,b)};goog.array.defaultCompareEquality=function(a,b){return a===b};goog.array.binaryInsert=function(a,b,c){c=goog.array.binarySearch(a,b,c);return 0>c?(goog.array.insertAt(a,b,-(c+1)),!0):!1};goog.array.binaryRemove=function(a,b,c){b=goog.array.binarySearch(a,b,c);return 0<=b?goog.array.removeAt(a,b):!1};
goog.array.bucket=function(a,b,c){for(var d={},e=0;e<a.length;e++){var f=a[e],g=b.call(c,f,e,a);goog.isDef(g)&&(d[g]||(d[g]=[])).push(f)}return d};goog.array.toObject=function(a,b,c){var d={};goog.array.forEach(a,function(e,f){d[b.call(c,e,f,a)]=e});return d};goog.array.range=function(a,b,c){var d=[],e=0,f=a;c=c||1;void 0!==b&&(e=a,f=b);if(0>c*(f-e))return[];if(0<c)for(a=e;a<f;a+=c)d.push(a);else for(a=e;a>f;a+=c)d.push(a);return d};
goog.array.repeat=function(a,b){for(var c=[],d=0;d<b;d++)c[d]=a;return c};goog.array.flatten=function(a){for(var b=[],c=0;c<arguments.length;c++){var d=arguments[c];if(goog.isArray(d))for(var e=0;e<d.length;e+=8192){var f=goog.array.slice(d,e,e+8192);f=goog.array.flatten.apply(null,f);for(var g=0;g<f.length;g++)b.push(f[g])}else b.push(d)}return b};
goog.array.rotate=function(a,b){goog.asserts.assert(null!=a.length);a.length&&(b%=a.length,0<b?Array.prototype.unshift.apply(a,a.splice(-b,b)):0>b&&Array.prototype.push.apply(a,a.splice(0,-b)));return a};goog.array.moveItem=function(a,b,c){goog.asserts.assert(0<=b&&b<a.length);goog.asserts.assert(0<=c&&c<a.length);b=Array.prototype.splice.call(a,b,1);Array.prototype.splice.call(a,c,0,b[0])};
goog.array.zip=function(a){if(!arguments.length)return[];for(var b=[],c=arguments[0].length,d=1;d<arguments.length;d++)arguments[d].length<c&&(c=arguments[d].length);for(d=0;d<c;d++){for(var e=[],f=0;f<arguments.length;f++)e.push(arguments[f][d]);b.push(e)}return b};goog.array.shuffle=function(a,b){b=b||Math.random;for(var c=a.length-1;0<c;c--){var d=Math.floor(b()*(c+1)),e=a[c];a[c]=a[d];a[d]=e}};goog.array.copyByIndex=function(a,b){var c=[];goog.array.forEach(b,function(b){c.push(a[b])});return c};
goog.array.concatMap=function(a,b,c){return goog.array.concat.apply([],goog.array.map(a,b,c))};goog.crypt={};goog.crypt.stringToByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);255<e&&(b[c++]=e&255,e>>=8);b[c++]=e}return b};goog.crypt.byteArrayToString=function(a){if(8192>=a.length)return String.fromCharCode.apply(null,a);for(var b="",c=0;c<a.length;c+=8192){var d=goog.array.slice(a,c,c+8192);b+=String.fromCharCode.apply(null,d)}return b};
goog.crypt.byteArrayToHex=function(a,b){return goog.array.map(a,function(a){a=a.toString(16);return 1<a.length?a:"0"+a}).join(b||"")};goog.crypt.hexToByteArray=function(a){goog.asserts.assert(0==a.length%2,"Key string length must be multiple of 2");for(var b=[],c=0;c<a.length;c+=2)b.push(parseInt(a.substring(c,c+2),16));return b};
goog.crypt.stringToUtf8ByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(55296==(e&64512)&&d+1<a.length&&56320==(a.charCodeAt(d+1)&64512)?(e=65536+((e&1023)<<10)+(a.charCodeAt(++d)&1023),b[c++]=e>>18|240,b[c++]=e>>12&63|128):b[c++]=e>>12|224,b[c++]=e>>6&63|128),b[c++]=e&63|128)}return b};
goog.crypt.utf8ByteArrayToString=function(a){for(var b=[],c=0,d=0;c<a.length;){var e=a[c++];if(128>e)b[d++]=String.fromCharCode(e);else if(191<e&&224>e){var f=a[c++];b[d++]=String.fromCharCode((e&31)<<6|f&63)}else if(239<e&&365>e){f=a[c++];var g=a[c++],h=a[c++];e=((e&7)<<18|(f&63)<<12|(g&63)<<6|h&63)-65536;b[d++]=String.fromCharCode(55296+(e>>10));b[d++]=String.fromCharCode(56320+(e&1023))}else f=a[c++],g=a[c++],b[d++]=String.fromCharCode((e&15)<<12|(f&63)<<6|g&63)}return b.join("")};
goog.crypt.xorByteArray=function(a,b){goog.asserts.assert(a.length==b.length,"XOR array lengths must match");for(var c=[],d=0;d<a.length;d++)c.push(a[d]^b[d]);return c};goog.string={};goog.string.internal={};goog.string.internal.startsWith=function(a,b){return 0==a.lastIndexOf(b,0)};goog.string.internal.endsWith=function(a,b){var c=a.length-b.length;return 0<=c&&a.indexOf(b,c)==c};goog.string.internal.caseInsensitiveStartsWith=function(a,b){return 0==goog.string.internal.caseInsensitiveCompare(b,a.substr(0,b.length))};goog.string.internal.caseInsensitiveEndsWith=function(a,b){return 0==goog.string.internal.caseInsensitiveCompare(b,a.substr(a.length-b.length,b.length))};
goog.string.internal.caseInsensitiveEquals=function(a,b){return a.toLowerCase()==b.toLowerCase()};goog.string.internal.isEmptyOrWhitespace=function(a){return/^[\s\xa0]*$/.test(a)};goog.string.internal.trim=goog.TRUSTED_SITE&&String.prototype.trim?function(a){return a.trim()}:function(a){return/^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1]};goog.string.internal.caseInsensitiveCompare=function(a,b){a=String(a).toLowerCase();b=String(b).toLowerCase();return a<b?-1:a==b?0:1};
goog.string.internal.newLineToBr=function(a,b){return a.replace(/(\r\n|\r|\n)/g,b?"<br />":"<br>")};
goog.string.internal.htmlEscape=function(a,b){if(b)a=a.replace(goog.string.internal.AMP_RE_,"&amp;").replace(goog.string.internal.LT_RE_,"&lt;").replace(goog.string.internal.GT_RE_,"&gt;").replace(goog.string.internal.QUOT_RE_,"&quot;").replace(goog.string.internal.SINGLE_QUOTE_RE_,"&#39;").replace(goog.string.internal.NULL_RE_,"&#0;");else{if(!goog.string.internal.ALL_RE_.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(goog.string.internal.AMP_RE_,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(goog.string.internal.LT_RE_,
"&lt;"));-1!=a.indexOf(">")&&(a=a.replace(goog.string.internal.GT_RE_,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(goog.string.internal.QUOT_RE_,"&quot;"));-1!=a.indexOf("'")&&(a=a.replace(goog.string.internal.SINGLE_QUOTE_RE_,"&#39;"));-1!=a.indexOf("\x00")&&(a=a.replace(goog.string.internal.NULL_RE_,"&#0;"))}return a};goog.string.internal.AMP_RE_=/&/g;goog.string.internal.LT_RE_=/</g;goog.string.internal.GT_RE_=/>/g;goog.string.internal.QUOT_RE_=/"/g;goog.string.internal.SINGLE_QUOTE_RE_=/'/g;
goog.string.internal.NULL_RE_=/\x00/g;goog.string.internal.ALL_RE_=/[\x00&<>"']/;goog.string.internal.whitespaceEscape=function(a,b){return goog.string.internal.newLineToBr(a.replace(/  /g," &#160;"),b)};goog.string.internal.contains=function(a,b){return-1!=a.indexOf(b)};goog.string.internal.caseInsensitiveContains=function(a,b){return goog.string.internal.contains(a.toLowerCase(),b.toLowerCase())};
goog.string.internal.compareVersions=function(a,b){var c=0;a=goog.string.internal.trim(String(a)).split(".");b=goog.string.internal.trim(String(b)).split(".");for(var d=Math.max(a.length,b.length),e=0;0==c&&e<d;e++){var f=a[e]||"",g=b[e]||"";do{f=/(\d*)(\D*)(.*)/.exec(f)||["","","",""];g=/(\d*)(\D*)(.*)/.exec(g)||["","","",""];if(0==f[0].length&&0==g[0].length)break;c=0==f[1].length?0:parseInt(f[1],10);var h=0==g[1].length?0:parseInt(g[1],10);c=goog.string.internal.compareElements_(c,h)||goog.string.internal.compareElements_(0==
f[2].length,0==g[2].length)||goog.string.internal.compareElements_(f[2],g[2]);f=f[3];g=g[3]}while(0==c)}return c};goog.string.internal.compareElements_=function(a,b){return a<b?-1:a>b?1:0};goog.string.TypedString=function(){};goog.string.Const=function(a,b){this.stringConstValueWithSecurityContract__googStringSecurityPrivate_=a===goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_&&b||"";this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_=goog.string.Const.TYPE_MARKER_};goog.string.Const.prototype.implementsGoogStringTypedString=!0;goog.string.Const.prototype.getTypedStringValue=function(){return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_};
goog.string.Const.prototype.toString=function(){return"Const{"+this.stringConstValueWithSecurityContract__googStringSecurityPrivate_+"}"};goog.string.Const.unwrap=function(a){if(a instanceof goog.string.Const&&a.constructor===goog.string.Const&&a.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_===goog.string.Const.TYPE_MARKER_)return a.stringConstValueWithSecurityContract__googStringSecurityPrivate_;goog.asserts.fail("expected object of type Const, got '"+a+"'");return"type_error:Const"};
goog.string.Const.from=function(a){return new goog.string.Const(goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_,a)};goog.string.Const.TYPE_MARKER_={};goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_={};goog.string.Const.EMPTY=goog.string.Const.from("");goog.fs={};goog.fs.url={};goog.fs.url.createObjectUrl=function(a){return goog.fs.url.getUrlObject_().createObjectURL(a)};goog.fs.url.revokeObjectUrl=function(a){goog.fs.url.getUrlObject_().revokeObjectURL(a)};goog.fs.url.getUrlObject_=function(){var a=goog.fs.url.findUrlObject_();if(null!=a)return a;throw Error("This browser doesn't seem to support blob URLs");};
goog.fs.url.findUrlObject_=function(){return goog.isDef(goog.global.URL)&&goog.isDef(goog.global.URL.createObjectURL)?goog.global.URL:goog.isDef(goog.global.webkitURL)&&goog.isDef(goog.global.webkitURL.createObjectURL)?goog.global.webkitURL:goog.isDef(goog.global.createObjectURL)?goog.global:null};goog.fs.url.browserSupportsObjectUrls=function(){return null!=goog.fs.url.findUrlObject_()};goog.html={};goog.html.trustedtypes={};goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY=goog.TRUSTED_TYPES_POLICY_NAME?goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME+"#html"):null;goog.i18n={};goog.i18n.bidi={};goog.i18n.bidi.FORCE_RTL=!1;
goog.i18n.bidi.IS_RTL=goog.i18n.bidi.FORCE_RTL||("ar"==goog.LOCALE.substring(0,2).toLowerCase()||"fa"==goog.LOCALE.substring(0,2).toLowerCase()||"he"==goog.LOCALE.substring(0,2).toLowerCase()||"iw"==goog.LOCALE.substring(0,2).toLowerCase()||"ps"==goog.LOCALE.substring(0,2).toLowerCase()||"sd"==goog.LOCALE.substring(0,2).toLowerCase()||"ug"==goog.LOCALE.substring(0,2).toLowerCase()||"ur"==goog.LOCALE.substring(0,2).toLowerCase()||"yi"==goog.LOCALE.substring(0,2).toLowerCase())&&(2==goog.LOCALE.length||
"-"==goog.LOCALE.substring(2,3)||"_"==goog.LOCALE.substring(2,3))||3<=goog.LOCALE.length&&"ckb"==goog.LOCALE.substring(0,3).toLowerCase()&&(3==goog.LOCALE.length||"-"==goog.LOCALE.substring(3,4)||"_"==goog.LOCALE.substring(3,4))||7<=goog.LOCALE.length&&("-"==goog.LOCALE.substring(2,3)||"_"==goog.LOCALE.substring(2,3))&&("adlm"==goog.LOCALE.substring(3,7).toLowerCase()||"arab"==goog.LOCALE.substring(3,7).toLowerCase()||"hebr"==goog.LOCALE.substring(3,7).toLowerCase()||"nkoo"==goog.LOCALE.substring(3,
7).toLowerCase()||"rohg"==goog.LOCALE.substring(3,7).toLowerCase()||"thaa"==goog.LOCALE.substring(3,7).toLowerCase())||8<=goog.LOCALE.length&&("-"==goog.LOCALE.substring(3,4)||"_"==goog.LOCALE.substring(3,4))&&("adlm"==goog.LOCALE.substring(4,8).toLowerCase()||"arab"==goog.LOCALE.substring(4,8).toLowerCase()||"hebr"==goog.LOCALE.substring(4,8).toLowerCase()||"nkoo"==goog.LOCALE.substring(4,8).toLowerCase()||"rohg"==goog.LOCALE.substring(4,8).toLowerCase()||"thaa"==goog.LOCALE.substring(4,8).toLowerCase());
goog.i18n.bidi.Format={LRE:"\u202a",RLE:"\u202b",PDF:"\u202c",LRM:"\u200e",RLM:"\u200f"};goog.i18n.bidi.Dir={LTR:1,RTL:-1,NEUTRAL:0};goog.i18n.bidi.RIGHT="right";goog.i18n.bidi.LEFT="left";goog.i18n.bidi.I18N_RIGHT=goog.i18n.bidi.IS_RTL?goog.i18n.bidi.LEFT:goog.i18n.bidi.RIGHT;goog.i18n.bidi.I18N_LEFT=goog.i18n.bidi.IS_RTL?goog.i18n.bidi.RIGHT:goog.i18n.bidi.LEFT;
goog.i18n.bidi.toDir=function(a,b){return"number"==typeof a?0<a?goog.i18n.bidi.Dir.LTR:0>a?goog.i18n.bidi.Dir.RTL:b?null:goog.i18n.bidi.Dir.NEUTRAL:null==a?null:a?goog.i18n.bidi.Dir.RTL:goog.i18n.bidi.Dir.LTR};goog.i18n.bidi.ltrChars_="A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0900-\u1fff\u200e\u2c00-\ud801\ud804-\ud839\ud83c-\udbff\uf900-\ufb1c\ufe00-\ufe6f\ufefd-\uffff";goog.i18n.bidi.rtlChars_="\u0591-\u06ef\u06fa-\u08ff\u200f\ud802-\ud803\ud83a-\ud83b\ufb1d-\ufdff\ufe70-\ufefc";
goog.i18n.bidi.htmlSkipReg_=/<[^>]*>|&[^;]+;/g;goog.i18n.bidi.stripHtmlIfNeeded_=function(a,b){return b?a.replace(goog.i18n.bidi.htmlSkipReg_,""):a};goog.i18n.bidi.rtlCharReg_=new RegExp("["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.ltrCharReg_=new RegExp("["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.hasAnyRtl=function(a,b){return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.hasRtlChar=goog.i18n.bidi.hasAnyRtl;
goog.i18n.bidi.hasAnyLtr=function(a,b){return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.ltrRe_=new RegExp("^["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.rtlRe_=new RegExp("^["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.isRtlChar=function(a){return goog.i18n.bidi.rtlRe_.test(a)};goog.i18n.bidi.isLtrChar=function(a){return goog.i18n.bidi.ltrRe_.test(a)};goog.i18n.bidi.isNeutralChar=function(a){return!goog.i18n.bidi.isLtrChar(a)&&!goog.i18n.bidi.isRtlChar(a)};
goog.i18n.bidi.ltrDirCheckRe_=new RegExp("^[^"+goog.i18n.bidi.rtlChars_+"]*["+goog.i18n.bidi.ltrChars_+"]");goog.i18n.bidi.rtlDirCheckRe_=new RegExp("^[^"+goog.i18n.bidi.ltrChars_+"]*["+goog.i18n.bidi.rtlChars_+"]");goog.i18n.bidi.startsWithRtl=function(a,b){return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isRtlText=goog.i18n.bidi.startsWithRtl;
goog.i18n.bidi.startsWithLtr=function(a,b){return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isLtrText=goog.i18n.bidi.startsWithLtr;goog.i18n.bidi.isRequiredLtrRe_=/^http:\/\/.*/;goog.i18n.bidi.isNeutralText=function(a,b){a=goog.i18n.bidi.stripHtmlIfNeeded_(a,b);return goog.i18n.bidi.isRequiredLtrRe_.test(a)||!goog.i18n.bidi.hasAnyLtr(a)&&!goog.i18n.bidi.hasAnyRtl(a)};
goog.i18n.bidi.ltrExitDirCheckRe_=new RegExp("["+goog.i18n.bidi.ltrChars_+"][^"+goog.i18n.bidi.rtlChars_+"]*$");goog.i18n.bidi.rtlExitDirCheckRe_=new RegExp("["+goog.i18n.bidi.rtlChars_+"][^"+goog.i18n.bidi.ltrChars_+"]*$");goog.i18n.bidi.endsWithLtr=function(a,b){return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isLtrExitText=goog.i18n.bidi.endsWithLtr;
goog.i18n.bidi.endsWithRtl=function(a,b){return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a,b))};goog.i18n.bidi.isRtlExitText=goog.i18n.bidi.endsWithRtl;goog.i18n.bidi.rtlLocalesRe_=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;goog.i18n.bidi.isRtlLanguage=function(a){return goog.i18n.bidi.rtlLocalesRe_.test(a)};goog.i18n.bidi.bracketGuardTextRe_=/(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;
goog.i18n.bidi.guardBracketInText=function(a,b){b=(void 0===b?goog.i18n.bidi.hasAnyRtl(a):b)?goog.i18n.bidi.Format.RLM:goog.i18n.bidi.Format.LRM;return a.replace(goog.i18n.bidi.bracketGuardTextRe_,b+"$&"+b)};goog.i18n.bidi.enforceRtlInHtml=function(a){return"<"==a.charAt(0)?a.replace(/<\w+/,"$& dir=rtl"):"\n<span dir=rtl>"+a+"</span>"};goog.i18n.bidi.enforceRtlInText=function(a){return goog.i18n.bidi.Format.RLE+a+goog.i18n.bidi.Format.PDF};
goog.i18n.bidi.enforceLtrInHtml=function(a){return"<"==a.charAt(0)?a.replace(/<\w+/,"$& dir=ltr"):"\n<span dir=ltr>"+a+"</span>"};goog.i18n.bidi.enforceLtrInText=function(a){return goog.i18n.bidi.Format.LRE+a+goog.i18n.bidi.Format.PDF};goog.i18n.bidi.dimensionsRe_=/:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;goog.i18n.bidi.leftRe_=/left/gi;goog.i18n.bidi.rightRe_=/right/gi;goog.i18n.bidi.tempRe_=/%%%%/g;
goog.i18n.bidi.mirrorCSS=function(a){return a.replace(goog.i18n.bidi.dimensionsRe_,":$1 $4 $3 $2").replace(goog.i18n.bidi.leftRe_,"%%%%").replace(goog.i18n.bidi.rightRe_,goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_,goog.i18n.bidi.RIGHT)};goog.i18n.bidi.doubleQuoteSubstituteRe_=/([\u0591-\u05f2])"/g;goog.i18n.bidi.singleQuoteSubstituteRe_=/([\u0591-\u05f2])'/g;
goog.i18n.bidi.normalizeHebrewQuote=function(a){return a.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_,"$1\u05f4").replace(goog.i18n.bidi.singleQuoteSubstituteRe_,"$1\u05f3")};goog.i18n.bidi.wordSeparatorRe_=/\s+/;goog.i18n.bidi.hasNumeralsRe_=/[\d\u06f0-\u06f9]/;goog.i18n.bidi.rtlDetectionThreshold_=.4;
goog.i18n.bidi.estimateDirection=function(a,b){var c=0,d=0,e=!1;a=goog.i18n.bidi.stripHtmlIfNeeded_(a,b).split(goog.i18n.bidi.wordSeparatorRe_);for(b=0;b<a.length;b++){var f=a[b];goog.i18n.bidi.startsWithRtl(f)?(c++,d++):goog.i18n.bidi.isRequiredLtrRe_.test(f)?e=!0:goog.i18n.bidi.hasAnyLtr(f)?d++:goog.i18n.bidi.hasNumeralsRe_.test(f)&&(e=!0)}return 0==d?e?goog.i18n.bidi.Dir.LTR:goog.i18n.bidi.Dir.NEUTRAL:c/d>goog.i18n.bidi.rtlDetectionThreshold_?goog.i18n.bidi.Dir.RTL:goog.i18n.bidi.Dir.LTR};
goog.i18n.bidi.detectRtlDirectionality=function(a,b){return goog.i18n.bidi.estimateDirection(a,b)==goog.i18n.bidi.Dir.RTL};goog.i18n.bidi.setElementDirAndAlign=function(a,b){a&&(b=goog.i18n.bidi.toDir(b))&&(a.style.textAlign=b==goog.i18n.bidi.Dir.RTL?goog.i18n.bidi.RIGHT:goog.i18n.bidi.LEFT,a.dir=b==goog.i18n.bidi.Dir.RTL?"rtl":"ltr")};
goog.i18n.bidi.setElementDirByTextDirectionality=function(a,b){switch(goog.i18n.bidi.estimateDirection(b)){case goog.i18n.bidi.Dir.LTR:a.dir="ltr";break;case goog.i18n.bidi.Dir.RTL:a.dir="rtl";break;default:a.removeAttribute("dir")}};goog.i18n.bidi.DirectionalString=function(){};goog.html.TrustedResourceUrl=function(){this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_="";this.trustedURL_=null;this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString=!0;goog.html.TrustedResourceUrl.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_.toString()};
goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.TrustedResourceUrl.prototype.getDirection=function(){return goog.i18n.bidi.Dir.LTR};
goog.html.TrustedResourceUrl.prototype.cloneWithParams=function(a,b){var c=goog.html.TrustedResourceUrl.unwrap(this);c=goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(c);var d=c[3]||"";return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(c[1]+goog.html.TrustedResourceUrl.stringifyParams_("?",c[2]||"",a)+goog.html.TrustedResourceUrl.stringifyParams_("#",d,b))};
goog.DEBUG&&(goog.html.TrustedResourceUrl.prototype.toString=function(){return"TrustedResourceUrl{"+this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_+"}"});goog.html.TrustedResourceUrl.unwrap=function(a){return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(a).toString()};
goog.html.TrustedResourceUrl.unwrapTrustedScriptURL=function(a){if(a instanceof goog.html.TrustedResourceUrl&&a.constructor===goog.html.TrustedResourceUrl&&a.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;goog.asserts.fail("expected object of type TrustedResourceUrl, got '"+a+"' of type "+goog.typeOf(a));return"type_error:TrustedResourceUrl"};
goog.html.TrustedResourceUrl.unwrapTrustedURL=function(a){return a.trustedURL_?a.trustedURL_:goog.html.TrustedResourceUrl.unwrap(a)};
goog.html.TrustedResourceUrl.format=function(a,b){var c=goog.string.Const.unwrap(a);if(!goog.html.TrustedResourceUrl.BASE_URL_.test(c))throw Error("Invalid TrustedResourceUrl format: "+c);a=c.replace(goog.html.TrustedResourceUrl.FORMAT_MARKER_,function(a,e){if(!Object.prototype.hasOwnProperty.call(b,e))throw Error('Found marker, "'+e+'", in format string, "'+c+'", but no valid label mapping found in args: '+JSON.stringify(b));a=b[e];return a instanceof goog.string.Const?goog.string.Const.unwrap(a):
encodeURIComponent(String(a))});return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.TrustedResourceUrl.FORMAT_MARKER_=/%{(\w+)}/g;goog.html.TrustedResourceUrl.BASE_URL_=/^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i;goog.html.TrustedResourceUrl.URL_PARAM_PARSER_=/^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/;
goog.html.TrustedResourceUrl.formatWithParams=function(a,b,c,d){return goog.html.TrustedResourceUrl.format(a,b).cloneWithParams(c,d)};goog.html.TrustedResourceUrl.fromConstant=function(a){return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(a))};goog.html.TrustedResourceUrl.fromConstants=function(a){for(var b="",c=0;c<a.length;c++)b+=goog.string.Const.unwrap(a[c]);return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b)};
goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse=function(a){var b=new goog.html.TrustedResourceUrl;b.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScriptURL(a):a;goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY&&(b.trustedURL_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(a));return b};
goog.html.TrustedResourceUrl.stringifyParams_=function(a,b,c){if(null==c)return b;if(goog.isString(c))return c?a+encodeURIComponent(c):"";for(var d in c){var e=c[d];e=goog.isArray(e)?e:[e];for(var f=0;f<e.length;f++){var g=e[f];null!=g&&(b||(b=a),b+=(b.length>a.length?"&":"")+encodeURIComponent(d)+"="+encodeURIComponent(String(g)))}}return b};goog.html.SafeUrl=function(){this.privateDoNotAccessOrElseSafeUrlWrappedValue_="";this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.SafeUrl.INNOCUOUS_STRING="about:invalid#zClosurez";goog.html.SafeUrl.prototype.implementsGoogStringTypedString=!0;goog.html.SafeUrl.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString()};
goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.SafeUrl.prototype.getDirection=function(){return goog.i18n.bidi.Dir.LTR};goog.DEBUG&&(goog.html.SafeUrl.prototype.toString=function(){return"SafeUrl{"+this.privateDoNotAccessOrElseSafeUrlWrappedValue_+"}"});goog.html.SafeUrl.unwrap=function(a){return goog.html.SafeUrl.unwrapTrustedURL(a).toString()};
goog.html.SafeUrl.unwrapTrustedURL=function(a){if(a instanceof goog.html.SafeUrl&&a.constructor===goog.html.SafeUrl&&a.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeUrlWrappedValue_;goog.asserts.fail("expected object of type SafeUrl, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeUrl"};goog.html.SafeUrl.fromConstant=function(a){return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(a))};
goog.html.SAFE_MIME_TYPE_PATTERN_=/^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-wav|wav|webm)|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime))(?:;\w+=(?:\w+|"[\w;=]+"))*$/i;goog.html.SafeUrl.isSafeMimeType=function(a){return goog.html.SAFE_MIME_TYPE_PATTERN_.test(a)};goog.html.SafeUrl.fromBlob=function(a){a=goog.html.SAFE_MIME_TYPE_PATTERN_.test(a.type)?goog.fs.url.createObjectUrl(a):goog.html.SafeUrl.INNOCUOUS_STRING;return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.DATA_URL_PATTERN_=/^data:([^,]*);base64,[a-z0-9+\/]+=*$/i;goog.html.SafeUrl.fromDataUrl=function(a){a=a.replace(/(%0A|%0D)/g,"");var b=a.match(goog.html.DATA_URL_PATTERN_);b=b&&goog.html.SAFE_MIME_TYPE_PATTERN_.test(b[1]);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b?a:goog.html.SafeUrl.INNOCUOUS_STRING)};goog.html.SafeUrl.fromTelUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"tel:")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SIP_URL_PATTERN_=/^sip[s]?:[+a-z0-9_.!$%&'*\/=^`{|}~-]+@([a-z0-9-]+\.)+[a-z0-9]{2,63}$/i;goog.html.SafeUrl.fromSipUrl=function(a){goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(a))||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeUrl.fromFacebookMessengerUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"fb-messenger://share")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.fromWhatsAppUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"whatsapp://send")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeUrl.fromSmsUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"sms:")&&goog.html.SafeUrl.isSmsUrlBodyValid_(a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.isSmsUrlBodyValid_=function(a){var b=a.indexOf("#");0<b&&(a=a.substring(0,b));b=a.match(/[?&]body=/gi);if(!b)return!0;if(1<b.length)return!1;a=a.match(/[?&]body=([^&]*)/)[1];if(!a)return!0;try{decodeURIComponent(a)}catch(c){return!1}return/^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(a)};goog.html.SafeUrl.fromSshUrl=function(a){goog.string.internal.caseInsensitiveStartsWith(a,"ssh://")||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.sanitizeChromeExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^chrome-extension:\/\/([^\/]+)\//,a,b)};goog.html.SafeUrl.sanitizeFirefoxExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^moz-extension:\/\/([^\/]+)\//,a,b)};goog.html.SafeUrl.sanitizeEdgeExtensionUrl=function(a,b){return goog.html.SafeUrl.sanitizeExtensionUrl_(/^ms-browser-extension:\/\/([^\/]+)\//,a,b)};
goog.html.SafeUrl.sanitizeExtensionUrl_=function(a,b,c){(a=a.exec(b))?(a=a[1],-1==(c instanceof goog.string.Const?[goog.string.Const.unwrap(c)]:c.map(function(a){return goog.string.Const.unwrap(a)})).indexOf(a)&&(b=goog.html.SafeUrl.INNOCUOUS_STRING)):b=goog.html.SafeUrl.INNOCUOUS_STRING;return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b)};goog.html.SafeUrl.fromTrustedResourceUrl=function(a){return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.html.TrustedResourceUrl.unwrap(a))};
goog.html.SAFE_URL_PATTERN_=/^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;goog.html.SafeUrl.SAFE_URL_PATTERN=goog.html.SAFE_URL_PATTERN_;goog.html.SafeUrl.sanitize=function(a){if(a instanceof goog.html.SafeUrl)return a;a="object"==typeof a&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);goog.html.SAFE_URL_PATTERN_.test(a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.sanitizeAssertUnchanged=function(a,b){if(a instanceof goog.html.SafeUrl)return a;a="object"==typeof a&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);if(b&&/^data:/i.test(a)&&(b=goog.html.SafeUrl.fromDataUrl(a),b.getTypedStringValue()==a))return b;goog.asserts.assert(goog.html.SAFE_URL_PATTERN_.test(a),"%s does not match the safe URL pattern",a)||(a=goog.html.SafeUrl.INNOCUOUS_STRING);return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse=function(a){var b=new goog.html.SafeUrl;b.privateDoNotAccessOrElseSafeUrlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(a):a;return b};goog.html.SafeUrl.ABOUT_BLANK=goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse("about:blank");goog.html.SafeStyle=function(){this.privateDoNotAccessOrElseSafeStyleWrappedValue_="";this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.SafeStyle.prototype.implementsGoogStringTypedString=!0;goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
goog.html.SafeStyle.fromConstant=function(a){a=goog.string.Const.unwrap(a);if(0===a.length)return goog.html.SafeStyle.EMPTY;goog.asserts.assert(goog.string.internal.endsWith(a,";"),"Last character of style string is not ';': "+a);goog.asserts.assert(goog.string.internal.contains(a,":"),"Style string must contain at least one ':', to specify a \"name: value\" pair: "+a);return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeStyle.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeStyleWrappedValue_};goog.DEBUG&&(goog.html.SafeStyle.prototype.toString=function(){return"SafeStyle{"+this.privateDoNotAccessOrElseSafeStyleWrappedValue_+"}"});
goog.html.SafeStyle.unwrap=function(a){if(a instanceof goog.html.SafeStyle&&a.constructor===goog.html.SafeStyle&&a.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeStyleWrappedValue_;goog.asserts.fail("expected object of type SafeStyle, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeStyle"};goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse=function(a){return(new goog.html.SafeStyle).initSecurityPrivateDoNotAccessOrElse_(a)};
goog.html.SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeStyleWrappedValue_=a;return this};goog.html.SafeStyle.EMPTY=goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse("");goog.html.SafeStyle.INNOCUOUS_STRING="zClosurez";
goog.html.SafeStyle.create=function(a){var b="",c;for(c in a){if(!/^[-_a-zA-Z0-9]+$/.test(c))throw Error("Name allows only [-_a-zA-Z0-9], got: "+c);var d=a[c];null!=d&&(d=goog.isArray(d)?goog.array.map(d,goog.html.SafeStyle.sanitizePropertyValue_).join(" "):goog.html.SafeStyle.sanitizePropertyValue_(d),b+=c+":"+d+";")}return b?goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b):goog.html.SafeStyle.EMPTY};
goog.html.SafeStyle.sanitizePropertyValue_=function(a){if(a instanceof goog.html.SafeUrl)return'url("'+goog.html.SafeUrl.unwrap(a).replace(/</g,"%3c").replace(/[\\"]/g,"\\$&")+'")';a=a instanceof goog.string.Const?goog.string.Const.unwrap(a):goog.html.SafeStyle.sanitizePropertyValueString_(String(a));if(/[{;}]/.test(a))throw new goog.asserts.AssertionError("Value does not allow [{;}], got: %s.",[a]);return a};
goog.html.SafeStyle.sanitizePropertyValueString_=function(a){var b=a.replace(goog.html.SafeStyle.FUNCTIONS_RE_,"$1").replace(goog.html.SafeStyle.FUNCTIONS_RE_,"$1").replace(goog.html.SafeStyle.URL_RE_,"url");if(goog.html.SafeStyle.VALUE_RE_.test(b)){if(goog.html.SafeStyle.COMMENT_RE_.test(a))return goog.asserts.fail("String value disallows comments, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING;if(!goog.html.SafeStyle.hasBalancedQuotes_(a))return goog.asserts.fail("String value requires balanced quotes, got: "+
a),goog.html.SafeStyle.INNOCUOUS_STRING;if(!goog.html.SafeStyle.hasBalancedSquareBrackets_(a))return goog.asserts.fail("String value requires balanced square brackets and one identifier per pair of brackets, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING}else return goog.asserts.fail("String value allows only "+goog.html.SafeStyle.VALUE_ALLOWED_CHARS_+" and simple functions, got: "+a),goog.html.SafeStyle.INNOCUOUS_STRING;return goog.html.SafeStyle.sanitizeUrl_(a)};
goog.html.SafeStyle.hasBalancedQuotes_=function(a){for(var b=!0,c=!0,d=0;d<a.length;d++){var e=a.charAt(d);"'"==e&&c?b=!b:'"'==e&&b&&(c=!c)}return b&&c};goog.html.SafeStyle.hasBalancedSquareBrackets_=function(a){for(var b=!0,c=/^[-_a-zA-Z0-9]$/,d=0;d<a.length;d++){var e=a.charAt(d);if("]"==e){if(b)return!1;b=!0}else if("["==e){if(!b)return!1;b=!1}else if(!b&&!c.test(e))return!1}return b};goog.html.SafeStyle.VALUE_ALLOWED_CHARS_="[-,.\"'%_!# a-zA-Z0-9\\[\\]]";
goog.html.SafeStyle.VALUE_RE_=new RegExp("^"+goog.html.SafeStyle.VALUE_ALLOWED_CHARS_+"+$");goog.html.SafeStyle.URL_RE_=/\b(url\([ \t\n]*)('[ -&(-\[\]-~]*'|"[ !#-\[\]-~]*"|[!#-&*-\[\]-~]*)([ \t\n]*\))/g;goog.html.SafeStyle.FUNCTIONS_RE_=/\b(hsl|hsla|rgb|rgba|matrix|calc|minmax|fit-content|repeat|(rotate|scale|translate)(X|Y|Z|3d)?)\([-+*/0-9a-z.%\[\], ]+\)/g;goog.html.SafeStyle.COMMENT_RE_=/\/\*/;
goog.html.SafeStyle.sanitizeUrl_=function(a){return a.replace(goog.html.SafeStyle.URL_RE_,function(a,c,d,e){var b="";d=d.replace(/^(['"])(.*)\1$/,function(a,c,d){b=c;return d});a=goog.html.SafeUrl.sanitize(d).getTypedStringValue();return c+b+a+b+e})};goog.html.SafeStyle.concat=function(a){var b="",c=function(a){goog.isArray(a)?goog.array.forEach(a,c):b+=goog.html.SafeStyle.unwrap(a)};goog.array.forEach(arguments,c);return b?goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b):goog.html.SafeStyle.EMPTY};goog.html.SafeScript=function(){this.privateDoNotAccessOrElseSafeScriptWrappedValue_="";this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.SafeScript.prototype.implementsGoogStringTypedString=!0;goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeScript.fromConstant=function(a){a=goog.string.Const.unwrap(a);return 0===a.length?goog.html.SafeScript.EMPTY:goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(a)};
goog.html.SafeScript.fromConstantAndArgs=function(a,b){for(var c=[],d=1;d<arguments.length;d++)c.push(goog.html.SafeScript.stringify_(arguments[d]));return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("("+goog.string.Const.unwrap(a)+")("+c.join(", ")+");")};goog.html.SafeScript.fromJson=function(a){return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(goog.html.SafeScript.stringify_(a))};goog.html.SafeScript.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString()};
goog.DEBUG&&(goog.html.SafeScript.prototype.toString=function(){return"SafeScript{"+this.privateDoNotAccessOrElseSafeScriptWrappedValue_+"}"});goog.html.SafeScript.unwrap=function(a){return goog.html.SafeScript.unwrapTrustedScript(a).toString()};
goog.html.SafeScript.unwrapTrustedScript=function(a){if(a instanceof goog.html.SafeScript&&a.constructor===goog.html.SafeScript&&a.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeScriptWrappedValue_;goog.asserts.fail("expected object of type SafeScript, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeScript"};
goog.html.SafeScript.stringify_=function(a){return JSON.stringify(a).replace(/</g,"\\x3c")};goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse=function(a){return(new goog.html.SafeScript).initSecurityPrivateDoNotAccessOrElse_(a)};
goog.html.SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeScriptWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScript(a):a;return this};goog.html.SafeScript.EMPTY=goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("");goog.object={};goog.object.is=function(a,b){return a===b?0!==a||1/a===1/b:a!==a&&b!==b};goog.object.forEach=function(a,b,c){for(var d in a)b.call(c,a[d],d,a)};goog.object.filter=function(a,b,c){var d={},e;for(e in a)b.call(c,a[e],e,a)&&(d[e]=a[e]);return d};goog.object.map=function(a,b,c){var d={},e;for(e in a)d[e]=b.call(c,a[e],e,a);return d};goog.object.some=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return!0;return!1};
goog.object.every=function(a,b,c){for(var d in a)if(!b.call(c,a[d],d,a))return!1;return!0};goog.object.getCount=function(a){var b=0,c;for(c in a)b++;return b};goog.object.getAnyKey=function(a){for(var b in a)return b};goog.object.getAnyValue=function(a){for(var b in a)return a[b]};goog.object.contains=function(a,b){return goog.object.containsValue(a,b)};goog.object.getValues=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b};
goog.object.getKeys=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b};goog.object.getValueByKeys=function(a,b){var c=goog.isArrayLike(b),d=c?b:arguments;for(c=c?0:1;c<d.length;c++){if(null==a)return;a=a[d[c]]}return a};goog.object.containsKey=function(a,b){return null!==a&&b in a};goog.object.containsValue=function(a,b){for(var c in a)if(a[c]==b)return!0;return!1};goog.object.findKey=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d};
goog.object.findValue=function(a,b,c){return(b=goog.object.findKey(a,b,c))&&a[b]};goog.object.isEmpty=function(a){for(var b in a)return!1;return!0};goog.object.clear=function(a){for(var b in a)delete a[b]};goog.object.remove=function(a,b){var c;(c=b in a)&&delete a[b];return c};goog.object.add=function(a,b,c){if(null!==a&&b in a)throw Error('The object already contains the key "'+b+'"');goog.object.set(a,b,c)};goog.object.get=function(a,b,c){return null!==a&&b in a?a[b]:c};
goog.object.set=function(a,b,c){a[b]=c};goog.object.setIfUndefined=function(a,b,c){return b in a?a[b]:a[b]=c};goog.object.setWithReturnValueIfNotSet=function(a,b,c){if(b in a)return a[b];c=c();return a[b]=c};goog.object.equals=function(a,b){for(var c in a)if(!(c in b)||a[c]!==b[c])return!1;for(var d in b)if(!(d in a))return!1;return!0};goog.object.clone=function(a){var b={},c;for(c in a)b[c]=a[c];return b};
goog.object.unsafeClone=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if(goog.isFunction(a.clone))return a.clone();b="array"==b?[]:{};for(var c in a)b[c]=goog.object.unsafeClone(a[c]);return b}return a};goog.object.transpose=function(a){var b={},c;for(c in a)b[a[c]]=c;return b};goog.object.PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
goog.object.extend=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<goog.object.PROTOTYPE_FIELDS_.length;f++)c=goog.object.PROTOTYPE_FIELDS_[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};
goog.object.create=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.create.apply(null,arguments[0]);if(b%2)throw Error("Uneven number of arguments");for(var c={},d=0;d<b;d+=2)c[arguments[d]]=arguments[d+1];return c};goog.object.createSet=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.createSet.apply(null,arguments[0]);for(var c={},d=0;d<b;d++)c[arguments[d]]=!0;return c};
goog.object.createImmutableView=function(a){var b=a;Object.isFrozen&&!Object.isFrozen(a)&&(b=Object.create(a),Object.freeze(b));return b};goog.object.isImmutableView=function(a){return!!Object.isFrozen&&Object.isFrozen(a)};
goog.object.getAllPropertyNames=function(a,b,c){if(!a)return[];if(!Object.getOwnPropertyNames||!Object.getPrototypeOf)return goog.object.getKeys(a);for(var d={};a&&(a!==Object.prototype||b)&&(a!==Function.prototype||c);){for(var e=Object.getOwnPropertyNames(a),f=0;f<e.length;f++)d[e[f]]=!0;a=Object.getPrototypeOf(a)}return goog.object.getKeys(d)};goog.object.getSuperClass=function(a){return(a=Object.getPrototypeOf(a.prototype))&&a.constructor};goog.html.SafeStyleSheet=function(){this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_="";this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_};goog.html.SafeStyleSheet.prototype.implementsGoogStringTypedString=!0;goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};
goog.html.SafeStyleSheet.createRule=function(a,b){if(goog.string.internal.contains(a,"<"))throw Error("Selector does not allow '<', got: "+a);var c=a.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g,"");if(!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(c))throw Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and strings, got: "+a);if(!goog.html.SafeStyleSheet.hasBalancedBrackets_(c))throw Error("() and [] in selector must be balanced, got: "+a);b instanceof goog.html.SafeStyle||(b=goog.html.SafeStyle.create(b));
a=a+"{"+goog.html.SafeStyle.unwrap(b).replace(/</g,"\\3C ")+"}";return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeStyleSheet.hasBalancedBrackets_=function(a){for(var b={"(":")","[":"]"},c=[],d=0;d<a.length;d++){var e=a[d];if(b[e])c.push(b[e]);else if(goog.object.contains(b,e)&&c.pop()!=e)return!1}return 0==c.length};
goog.html.SafeStyleSheet.concat=function(a){var b="",c=function(a){goog.isArray(a)?goog.array.forEach(a,c):b+=goog.html.SafeStyleSheet.unwrap(a)};goog.array.forEach(arguments,c);return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b)};
goog.html.SafeStyleSheet.fromConstant=function(a){a=goog.string.Const.unwrap(a);if(0===a.length)return goog.html.SafeStyleSheet.EMPTY;goog.asserts.assert(!goog.string.internal.contains(a,"<"),"Forbidden '<' character in style sheet string: "+a);return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a)};goog.html.SafeStyleSheet.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_};
goog.DEBUG&&(goog.html.SafeStyleSheet.prototype.toString=function(){return"SafeStyleSheet{"+this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_+"}"});
goog.html.SafeStyleSheet.unwrap=function(a){if(a instanceof goog.html.SafeStyleSheet&&a.constructor===goog.html.SafeStyleSheet&&a.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;goog.asserts.fail("expected object of type SafeStyleSheet, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeStyleSheet"};
goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse=function(a){return(new goog.html.SafeStyleSheet).initSecurityPrivateDoNotAccessOrElse_(a)};goog.html.SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a){this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_=a;return this};goog.html.SafeStyleSheet.EMPTY=goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse("");goog.dom.tags={};goog.dom.tags.VOID_TAGS_={area:!0,base:!0,br:!0,col:!0,command:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0};goog.dom.tags.isVoidTag=function(a){return!0===goog.dom.tags.VOID_TAGS_[a]};goog.dom.HtmlElement=function(){};goog.dom.TagName=function(a){this.tagName_=a};goog.dom.TagName.prototype.toString=function(){return this.tagName_};goog.dom.TagName.A=new goog.dom.TagName("A");goog.dom.TagName.ABBR=new goog.dom.TagName("ABBR");goog.dom.TagName.ACRONYM=new goog.dom.TagName("ACRONYM");goog.dom.TagName.ADDRESS=new goog.dom.TagName("ADDRESS");goog.dom.TagName.APPLET=new goog.dom.TagName("APPLET");goog.dom.TagName.AREA=new goog.dom.TagName("AREA");goog.dom.TagName.ARTICLE=new goog.dom.TagName("ARTICLE");
goog.dom.TagName.ASIDE=new goog.dom.TagName("ASIDE");goog.dom.TagName.AUDIO=new goog.dom.TagName("AUDIO");goog.dom.TagName.B=new goog.dom.TagName("B");goog.dom.TagName.BASE=new goog.dom.TagName("BASE");goog.dom.TagName.BASEFONT=new goog.dom.TagName("BASEFONT");goog.dom.TagName.BDI=new goog.dom.TagName("BDI");goog.dom.TagName.BDO=new goog.dom.TagName("BDO");goog.dom.TagName.BIG=new goog.dom.TagName("BIG");goog.dom.TagName.BLOCKQUOTE=new goog.dom.TagName("BLOCKQUOTE");goog.dom.TagName.BODY=new goog.dom.TagName("BODY");
goog.dom.TagName.BR=new goog.dom.TagName("BR");goog.dom.TagName.BUTTON=new goog.dom.TagName("BUTTON");goog.dom.TagName.CANVAS=new goog.dom.TagName("CANVAS");goog.dom.TagName.CAPTION=new goog.dom.TagName("CAPTION");goog.dom.TagName.CENTER=new goog.dom.TagName("CENTER");goog.dom.TagName.CITE=new goog.dom.TagName("CITE");goog.dom.TagName.CODE=new goog.dom.TagName("CODE");goog.dom.TagName.COL=new goog.dom.TagName("COL");goog.dom.TagName.COLGROUP=new goog.dom.TagName("COLGROUP");
goog.dom.TagName.COMMAND=new goog.dom.TagName("COMMAND");goog.dom.TagName.DATA=new goog.dom.TagName("DATA");goog.dom.TagName.DATALIST=new goog.dom.TagName("DATALIST");goog.dom.TagName.DD=new goog.dom.TagName("DD");goog.dom.TagName.DEL=new goog.dom.TagName("DEL");goog.dom.TagName.DETAILS=new goog.dom.TagName("DETAILS");goog.dom.TagName.DFN=new goog.dom.TagName("DFN");goog.dom.TagName.DIALOG=new goog.dom.TagName("DIALOG");goog.dom.TagName.DIR=new goog.dom.TagName("DIR");goog.dom.TagName.DIV=new goog.dom.TagName("DIV");
goog.dom.TagName.DL=new goog.dom.TagName("DL");goog.dom.TagName.DT=new goog.dom.TagName("DT");goog.dom.TagName.EM=new goog.dom.TagName("EM");goog.dom.TagName.EMBED=new goog.dom.TagName("EMBED");goog.dom.TagName.FIELDSET=new goog.dom.TagName("FIELDSET");goog.dom.TagName.FIGCAPTION=new goog.dom.TagName("FIGCAPTION");goog.dom.TagName.FIGURE=new goog.dom.TagName("FIGURE");goog.dom.TagName.FONT=new goog.dom.TagName("FONT");goog.dom.TagName.FOOTER=new goog.dom.TagName("FOOTER");goog.dom.TagName.FORM=new goog.dom.TagName("FORM");
goog.dom.TagName.FRAME=new goog.dom.TagName("FRAME");goog.dom.TagName.FRAMESET=new goog.dom.TagName("FRAMESET");goog.dom.TagName.H1=new goog.dom.TagName("H1");goog.dom.TagName.H2=new goog.dom.TagName("H2");goog.dom.TagName.H3=new goog.dom.TagName("H3");goog.dom.TagName.H4=new goog.dom.TagName("H4");goog.dom.TagName.H5=new goog.dom.TagName("H5");goog.dom.TagName.H6=new goog.dom.TagName("H6");goog.dom.TagName.HEAD=new goog.dom.TagName("HEAD");goog.dom.TagName.HEADER=new goog.dom.TagName("HEADER");
goog.dom.TagName.HGROUP=new goog.dom.TagName("HGROUP");goog.dom.TagName.HR=new goog.dom.TagName("HR");goog.dom.TagName.HTML=new goog.dom.TagName("HTML");goog.dom.TagName.I=new goog.dom.TagName("I");goog.dom.TagName.IFRAME=new goog.dom.TagName("IFRAME");goog.dom.TagName.IMG=new goog.dom.TagName("IMG");goog.dom.TagName.INPUT=new goog.dom.TagName("INPUT");goog.dom.TagName.INS=new goog.dom.TagName("INS");goog.dom.TagName.ISINDEX=new goog.dom.TagName("ISINDEX");goog.dom.TagName.KBD=new goog.dom.TagName("KBD");
goog.dom.TagName.KEYGEN=new goog.dom.TagName("KEYGEN");goog.dom.TagName.LABEL=new goog.dom.TagName("LABEL");goog.dom.TagName.LEGEND=new goog.dom.TagName("LEGEND");goog.dom.TagName.LI=new goog.dom.TagName("LI");goog.dom.TagName.LINK=new goog.dom.TagName("LINK");goog.dom.TagName.MAIN=new goog.dom.TagName("MAIN");goog.dom.TagName.MAP=new goog.dom.TagName("MAP");goog.dom.TagName.MARK=new goog.dom.TagName("MARK");goog.dom.TagName.MATH=new goog.dom.TagName("MATH");goog.dom.TagName.MENU=new goog.dom.TagName("MENU");
goog.dom.TagName.MENUITEM=new goog.dom.TagName("MENUITEM");goog.dom.TagName.META=new goog.dom.TagName("META");goog.dom.TagName.METER=new goog.dom.TagName("METER");goog.dom.TagName.NAV=new goog.dom.TagName("NAV");goog.dom.TagName.NOFRAMES=new goog.dom.TagName("NOFRAMES");goog.dom.TagName.NOSCRIPT=new goog.dom.TagName("NOSCRIPT");goog.dom.TagName.OBJECT=new goog.dom.TagName("OBJECT");goog.dom.TagName.OL=new goog.dom.TagName("OL");goog.dom.TagName.OPTGROUP=new goog.dom.TagName("OPTGROUP");
goog.dom.TagName.OPTION=new goog.dom.TagName("OPTION");goog.dom.TagName.OUTPUT=new goog.dom.TagName("OUTPUT");goog.dom.TagName.P=new goog.dom.TagName("P");goog.dom.TagName.PARAM=new goog.dom.TagName("PARAM");goog.dom.TagName.PICTURE=new goog.dom.TagName("PICTURE");goog.dom.TagName.PRE=new goog.dom.TagName("PRE");goog.dom.TagName.PROGRESS=new goog.dom.TagName("PROGRESS");goog.dom.TagName.Q=new goog.dom.TagName("Q");goog.dom.TagName.RP=new goog.dom.TagName("RP");goog.dom.TagName.RT=new goog.dom.TagName("RT");
goog.dom.TagName.RTC=new goog.dom.TagName("RTC");goog.dom.TagName.RUBY=new goog.dom.TagName("RUBY");goog.dom.TagName.S=new goog.dom.TagName("S");goog.dom.TagName.SAMP=new goog.dom.TagName("SAMP");goog.dom.TagName.SCRIPT=new goog.dom.TagName("SCRIPT");goog.dom.TagName.SECTION=new goog.dom.TagName("SECTION");goog.dom.TagName.SELECT=new goog.dom.TagName("SELECT");goog.dom.TagName.SMALL=new goog.dom.TagName("SMALL");goog.dom.TagName.SOURCE=new goog.dom.TagName("SOURCE");goog.dom.TagName.SPAN=new goog.dom.TagName("SPAN");
goog.dom.TagName.STRIKE=new goog.dom.TagName("STRIKE");goog.dom.TagName.STRONG=new goog.dom.TagName("STRONG");goog.dom.TagName.STYLE=new goog.dom.TagName("STYLE");goog.dom.TagName.SUB=new goog.dom.TagName("SUB");goog.dom.TagName.SUMMARY=new goog.dom.TagName("SUMMARY");goog.dom.TagName.SUP=new goog.dom.TagName("SUP");goog.dom.TagName.SVG=new goog.dom.TagName("SVG");goog.dom.TagName.TABLE=new goog.dom.TagName("TABLE");goog.dom.TagName.TBODY=new goog.dom.TagName("TBODY");goog.dom.TagName.TD=new goog.dom.TagName("TD");
goog.dom.TagName.TEMPLATE=new goog.dom.TagName("TEMPLATE");goog.dom.TagName.TEXTAREA=new goog.dom.TagName("TEXTAREA");goog.dom.TagName.TFOOT=new goog.dom.TagName("TFOOT");goog.dom.TagName.TH=new goog.dom.TagName("TH");goog.dom.TagName.THEAD=new goog.dom.TagName("THEAD");goog.dom.TagName.TIME=new goog.dom.TagName("TIME");goog.dom.TagName.TITLE=new goog.dom.TagName("TITLE");goog.dom.TagName.TR=new goog.dom.TagName("TR");goog.dom.TagName.TRACK=new goog.dom.TagName("TRACK");goog.dom.TagName.TT=new goog.dom.TagName("TT");
goog.dom.TagName.U=new goog.dom.TagName("U");goog.dom.TagName.UL=new goog.dom.TagName("UL");goog.dom.TagName.VAR=new goog.dom.TagName("VAR");goog.dom.TagName.VIDEO=new goog.dom.TagName("VIDEO");goog.dom.TagName.WBR=new goog.dom.TagName("WBR");goog.labs={};goog.labs.userAgent={};goog.labs.userAgent.util={};goog.labs.userAgent.util.getNativeUserAgentString_=function(){var a=goog.labs.userAgent.util.getNavigator_();return a&&(a=a.userAgent)?a:""};goog.labs.userAgent.util.getNavigator_=function(){return goog.global.navigator};goog.labs.userAgent.util.userAgent_=goog.labs.userAgent.util.getNativeUserAgentString_();goog.labs.userAgent.util.setUserAgent=function(a){goog.labs.userAgent.util.userAgent_=a||goog.labs.userAgent.util.getNativeUserAgentString_()};
goog.labs.userAgent.util.getUserAgent=function(){return goog.labs.userAgent.util.userAgent_};goog.labs.userAgent.util.matchUserAgent=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.internal.contains(b,a)};goog.labs.userAgent.util.matchUserAgentIgnoreCase=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.internal.caseInsensitiveContains(b,a)};
goog.labs.userAgent.util.extractVersionTuples=function(a){for(var b=/(\w[\w ]+)\/([^\s]+)\s*(?:\((.*?)\))?/g,c=[],d;d=b.exec(a);)c.push([d[1],d[2],d[3]||void 0]);return c};goog.labs.userAgent.browser={};goog.labs.userAgent.browser.matchOpera_=function(){return goog.labs.userAgent.util.matchUserAgent("Opera")};goog.labs.userAgent.browser.matchIE_=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.browser.matchEdgeHtml_=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};goog.labs.userAgent.browser.matchEdgeChromium_=function(){return goog.labs.userAgent.util.matchUserAgent("Edg/")};
goog.labs.userAgent.browser.matchOperaChromium_=function(){return goog.labs.userAgent.util.matchUserAgent("OPR")};goog.labs.userAgent.browser.matchFirefox_=function(){return goog.labs.userAgent.util.matchUserAgent("Firefox")||goog.labs.userAgent.util.matchUserAgent("FxiOS")};
goog.labs.userAgent.browser.matchSafari_=function(){return goog.labs.userAgent.util.matchUserAgent("Safari")&&!(goog.labs.userAgent.browser.matchChrome_()||goog.labs.userAgent.browser.matchCoast_()||goog.labs.userAgent.browser.matchOpera_()||goog.labs.userAgent.browser.matchEdgeHtml_()||goog.labs.userAgent.browser.matchEdgeChromium_()||goog.labs.userAgent.browser.matchOperaChromium_()||goog.labs.userAgent.browser.matchFirefox_()||goog.labs.userAgent.browser.isSilk()||goog.labs.userAgent.util.matchUserAgent("Android"))};
goog.labs.userAgent.browser.matchCoast_=function(){return goog.labs.userAgent.util.matchUserAgent("Coast")};goog.labs.userAgent.browser.matchIosWebview_=function(){return(goog.labs.userAgent.util.matchUserAgent("iPad")||goog.labs.userAgent.util.matchUserAgent("iPhone"))&&!goog.labs.userAgent.browser.matchSafari_()&&!goog.labs.userAgent.browser.matchChrome_()&&!goog.labs.userAgent.browser.matchCoast_()&&!goog.labs.userAgent.browser.matchFirefox_()&&goog.labs.userAgent.util.matchUserAgent("AppleWebKit")};
goog.labs.userAgent.browser.matchChrome_=function(){return(goog.labs.userAgent.util.matchUserAgent("Chrome")||goog.labs.userAgent.util.matchUserAgent("CriOS"))&&!goog.labs.userAgent.browser.matchEdgeHtml_()};goog.labs.userAgent.browser.matchAndroidBrowser_=function(){return goog.labs.userAgent.util.matchUserAgent("Android")&&!(goog.labs.userAgent.browser.isChrome()||goog.labs.userAgent.browser.isFirefox()||goog.labs.userAgent.browser.isOpera()||goog.labs.userAgent.browser.isSilk())};
goog.labs.userAgent.browser.isOpera=goog.labs.userAgent.browser.matchOpera_;goog.labs.userAgent.browser.isIE=goog.labs.userAgent.browser.matchIE_;goog.labs.userAgent.browser.isEdge=goog.labs.userAgent.browser.matchEdgeHtml_;goog.labs.userAgent.browser.isEdgeChromium=goog.labs.userAgent.browser.matchEdgeChromium_;goog.labs.userAgent.browser.isOperaChromium=goog.labs.userAgent.browser.matchOperaChromium_;goog.labs.userAgent.browser.isFirefox=goog.labs.userAgent.browser.matchFirefox_;
goog.labs.userAgent.browser.isSafari=goog.labs.userAgent.browser.matchSafari_;goog.labs.userAgent.browser.isCoast=goog.labs.userAgent.browser.matchCoast_;goog.labs.userAgent.browser.isIosWebview=goog.labs.userAgent.browser.matchIosWebview_;goog.labs.userAgent.browser.isChrome=goog.labs.userAgent.browser.matchChrome_;goog.labs.userAgent.browser.isAndroidBrowser=goog.labs.userAgent.browser.matchAndroidBrowser_;goog.labs.userAgent.browser.isSilk=function(){return goog.labs.userAgent.util.matchUserAgent("Silk")};
goog.labs.userAgent.browser.getVersion=function(){function a(a){a=goog.array.find(a,d);return c[a]||""}var b=goog.labs.userAgent.util.getUserAgent();if(goog.labs.userAgent.browser.isIE())return goog.labs.userAgent.browser.getIEVersion_(b);b=goog.labs.userAgent.util.extractVersionTuples(b);var c={};goog.array.forEach(b,function(a){c[a[0]]=a[1]});var d=goog.partial(goog.object.containsKey,c);return goog.labs.userAgent.browser.isOpera()?a(["Version","Opera"]):goog.labs.userAgent.browser.isEdge()?a(["Edge"]):
goog.labs.userAgent.browser.isEdgeChromium()?a(["Edg"]):goog.labs.userAgent.browser.isChrome()?a(["Chrome","CriOS"]):(b=b[2])&&b[1]||""};goog.labs.userAgent.browser.isVersionOrHigher=function(a){return 0<=goog.string.internal.compareVersions(goog.labs.userAgent.browser.getVersion(),a)};
goog.labs.userAgent.browser.getIEVersion_=function(a){var b=/rv: *([\d\.]*)/.exec(a);if(b&&b[1])return b[1];b="";var c=/MSIE +([\d\.]+)/.exec(a);if(c&&c[1])if(a=/Trident\/(\d.\d)/.exec(a),"7.0"==c[1])if(a&&a[1])switch(a[1]){case "4.0":b="8.0";break;case "5.0":b="9.0";break;case "6.0":b="10.0";break;case "7.0":b="11.0"}else b="7.0";else b=c[1];return b};goog.html.SafeHtml=function(){this.privateDoNotAccessOrElseSafeHtmlWrappedValue_="";this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_=goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;this.dir_=null};goog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString=!0;goog.html.SafeHtml.prototype.getDirection=function(){return this.dir_};goog.html.SafeHtml.prototype.implementsGoogStringTypedString=!0;goog.html.SafeHtml.prototype.getTypedStringValue=function(){return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString()};
goog.DEBUG&&(goog.html.SafeHtml.prototype.toString=function(){return"SafeHtml{"+this.privateDoNotAccessOrElseSafeHtmlWrappedValue_+"}"});goog.html.SafeHtml.unwrap=function(a){return goog.html.SafeHtml.unwrapTrustedHTML(a).toString()};
goog.html.SafeHtml.unwrapTrustedHTML=function(a){if(a instanceof goog.html.SafeHtml&&a.constructor===goog.html.SafeHtml&&a.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_===goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)return a.privateDoNotAccessOrElseSafeHtmlWrappedValue_;goog.asserts.fail("expected object of type SafeHtml, got '"+a+"' of type "+goog.typeOf(a));return"type_error:SafeHtml"};
goog.html.SafeHtml.htmlEscape=function(a){if(a instanceof goog.html.SafeHtml)return a;var b="object"==typeof a,c=null;b&&a.implementsGoogI18nBidiDirectionalString&&(c=a.getDirection());a=b&&a.implementsGoogStringTypedString?a.getTypedStringValue():String(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.htmlEscape(a),c)};
goog.html.SafeHtml.htmlEscapePreservingNewlines=function(a){if(a instanceof goog.html.SafeHtml)return a;a=goog.html.SafeHtml.htmlEscape(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.newLineToBr(goog.html.SafeHtml.unwrap(a)),a.getDirection())};
goog.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces=function(a){if(a instanceof goog.html.SafeHtml)return a;a=goog.html.SafeHtml.htmlEscape(a);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.whitespaceEscape(goog.html.SafeHtml.unwrap(a)),a.getDirection())};goog.html.SafeHtml.from=goog.html.SafeHtml.htmlEscape;goog.html.SafeHtml.VALID_NAMES_IN_TAG_=/^[a-zA-Z0-9-]+$/;
goog.html.SafeHtml.URL_ATTRIBUTES_={action:!0,cite:!0,data:!0,formaction:!0,href:!0,manifest:!0,poster:!0,src:!0};goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_={APPLET:!0,BASE:!0,EMBED:!0,IFRAME:!0,LINK:!0,MATH:!0,META:!0,OBJECT:!0,SCRIPT:!0,STYLE:!0,SVG:!0,TEMPLATE:!0};goog.html.SafeHtml.create=function(a,b,c){goog.html.SafeHtml.verifyTagName(String(a));return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(a),b,c)};
goog.html.SafeHtml.verifyTagName=function(a){if(!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(a))throw Error("Invalid tag name <"+a+">.");if(a.toUpperCase()in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_)throw Error("Tag name <"+a+"> is not allowed for SafeHtml.");};
goog.html.SafeHtml.createIframe=function(a,b,c,d){a&&goog.html.TrustedResourceUrl.unwrap(a);var e={};e.src=a||null;e.srcdoc=b&&goog.html.SafeHtml.unwrap(b);a=goog.html.SafeHtml.combineAttributes(e,{sandbox:""},c);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",a,d)};
goog.html.SafeHtml.createSandboxIframe=function(a,b,c,d){if(!goog.html.SafeHtml.canUseSandboxIframe())throw Error("The browser does not support sandboxed iframes.");var e={};e.src=a?goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(a)):null;e.srcdoc=b||null;e.sandbox="";a=goog.html.SafeHtml.combineAttributes(e,{},c);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",a,d)};
goog.html.SafeHtml.canUseSandboxIframe=function(){return goog.global.HTMLIFrameElement&&"sandbox"in goog.global.HTMLIFrameElement.prototype};goog.html.SafeHtml.createScriptSrc=function(a,b){goog.html.TrustedResourceUrl.unwrap(a);a=goog.html.SafeHtml.combineAttributes({src:a},{},b);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script",a)};
goog.html.SafeHtml.createScript=function(a,b){for(var c in b){var d=c.toLowerCase();if("language"==d||"src"==d||"text"==d||"type"==d)throw Error('Cannot set "'+d+'" attribute');}c="";a=goog.array.concat(a);for(d=0;d<a.length;d++)c+=goog.html.SafeScript.unwrap(a[d]);a=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c,goog.i18n.bidi.Dir.NEUTRAL);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script",b,a)};
goog.html.SafeHtml.createStyle=function(a,b){b=goog.html.SafeHtml.combineAttributes({type:"text/css"},{},b);var c="";a=goog.array.concat(a);for(var d=0;d<a.length;d++)c+=goog.html.SafeStyleSheet.unwrap(a[d]);a=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c,goog.i18n.bidi.Dir.NEUTRAL);return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("style",b,a)};
goog.html.SafeHtml.createMetaRefresh=function(a,b){a=goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(a));(goog.labs.userAgent.browser.isIE()||goog.labs.userAgent.browser.isEdge())&&goog.string.internal.contains(a,";")&&(a="'"+a.replace(/'/g,"%27")+"'");return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("meta",{"http-equiv":"refresh",content:(b||0)+"; url="+a})};
goog.html.SafeHtml.getAttrNameAndValue_=function(a,b,c){if(c instanceof goog.string.Const)c=goog.string.Const.unwrap(c);else if("style"==b.toLowerCase())c=goog.html.SafeHtml.getStyleValue_(c);else{if(/^on/i.test(b))throw Error('Attribute "'+b+'" requires goog.string.Const value, "'+c+'" given.');if(b.toLowerCase()in goog.html.SafeHtml.URL_ATTRIBUTES_)if(c instanceof goog.html.TrustedResourceUrl)c=goog.html.TrustedResourceUrl.unwrap(c);else if(c instanceof goog.html.SafeUrl)c=goog.html.SafeUrl.unwrap(c);
else if(goog.isString(c))c=goog.html.SafeUrl.sanitize(c).getTypedStringValue();else throw Error('Attribute "'+b+'" on tag "'+a+'" requires goog.html.SafeUrl, goog.string.Const, or string, value "'+c+'" given.');}c.implementsGoogStringTypedString&&(c=c.getTypedStringValue());goog.asserts.assert(goog.isString(c)||goog.isNumber(c),"String or number value expected, got "+typeof c+" with value: "+c);return b+'="'+goog.string.internal.htmlEscape(String(c))+'"'};
goog.html.SafeHtml.getStyleValue_=function(a){if(!goog.isObject(a))throw Error('The "style" attribute requires goog.html.SafeStyle or map of style properties, '+typeof a+" given: "+a);a instanceof goog.html.SafeStyle||(a=goog.html.SafeStyle.create(a));return goog.html.SafeStyle.unwrap(a)};goog.html.SafeHtml.createWithDir=function(a,b,c,d){b=goog.html.SafeHtml.create(b,c,d);b.dir_=a;return b};
goog.html.SafeHtml.join=function(a,b){a=goog.html.SafeHtml.htmlEscape(a);var c=a.getDirection(),d=[],e=function(a){goog.isArray(a)?goog.array.forEach(a,e):(a=goog.html.SafeHtml.htmlEscape(a),d.push(goog.html.SafeHtml.unwrap(a)),a=a.getDirection(),c==goog.i18n.bidi.Dir.NEUTRAL?c=a:a!=goog.i18n.bidi.Dir.NEUTRAL&&c!=a&&(c=null))};goog.array.forEach(b,e);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(d.join(goog.html.SafeHtml.unwrap(a)),c)};
goog.html.SafeHtml.concat=function(a){return goog.html.SafeHtml.join(goog.html.SafeHtml.EMPTY,Array.prototype.slice.call(arguments))};goog.html.SafeHtml.concatWithDir=function(a,b){var c=goog.html.SafeHtml.concat(goog.array.slice(arguments,1));c.dir_=a;return c};goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_={};goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse=function(a,b){return(new goog.html.SafeHtml).initSecurityPrivateDoNotAccessOrElse_(a,b)};
goog.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_=function(a,b){this.privateDoNotAccessOrElseSafeHtmlWrappedValue_=goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY?goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createHTML(a):a;this.dir_=b;return this};
goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse=function(a,b,c){var d=null;var e="<"+a+goog.html.SafeHtml.stringifyAttributes(a,b);goog.isDefAndNotNull(c)?goog.isArray(c)||(c=[c]):c=[];goog.dom.tags.isVoidTag(a.toLowerCase())?(goog.asserts.assert(!c.length,"Void tag <"+a+"> does not allow content."),e+=">"):(d=goog.html.SafeHtml.concat(c),e+=">"+goog.html.SafeHtml.unwrap(d)+"</"+a+">",d=d.getDirection());(a=b&&b.dir)&&(d=/^(ltr|rtl|auto)$/i.test(a)?goog.i18n.bidi.Dir.NEUTRAL:
null);return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(e,d)};goog.html.SafeHtml.stringifyAttributes=function(a,b){var c="";if(b)for(var d in b){if(!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(d))throw Error('Invalid attribute name "'+d+'".');var e=b[d];goog.isDefAndNotNull(e)&&(c+=" "+goog.html.SafeHtml.getAttrNameAndValue_(a,d,e))}return c};
goog.html.SafeHtml.combineAttributes=function(a,b,c){var d={},e;for(e in a)goog.asserts.assert(e.toLowerCase()==e,"Must be lower case"),d[e]=a[e];for(e in b)goog.asserts.assert(e.toLowerCase()==e,"Must be lower case"),d[e]=b[e];for(e in c){var f=e.toLowerCase();if(f in a)throw Error('Cannot override "'+f+'" attribute, got "'+e+'" with value "'+c[e]+'"');f in b&&delete d[f];d[e]=c[e]}return d};
goog.html.SafeHtml.DOCTYPE_HTML=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!DOCTYPE html>",goog.i18n.bidi.Dir.NEUTRAL);goog.html.SafeHtml.EMPTY=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("",goog.i18n.bidi.Dir.NEUTRAL);goog.html.SafeHtml.BR=goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<br>",goog.i18n.bidi.Dir.NEUTRAL);goog.html.uncheckedconversions={};goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract=function(a,b,c){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(b,c||null)};
goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b)};
goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract=function(a,b){goog.asserts.assertString(goog.string.Const.unwrap(a),"must provide justification");goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a)),"must provide non-empty justification");return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b)};goog.dom.asserts={};goog.dom.asserts.assertIsLocation=function(a){if(goog.asserts.ENABLE_ASSERTS){var b=goog.dom.asserts.getWindow_(a);b&&(!a||!(a instanceof b.Location)&&a instanceof b.Element)&&goog.asserts.fail("Argument is not a Location (or a non-Element mock); got: %s",goog.dom.asserts.debugStringForType_(a))}return a};
goog.dom.asserts.assertIsElementType_=function(a,b){if(goog.asserts.ENABLE_ASSERTS){var c=goog.dom.asserts.getWindow_(a);c&&"undefined"!=typeof c[b]&&(a&&(a instanceof c[b]||!(a instanceof c.Location||a instanceof c.Element))||goog.asserts.fail("Argument is not a %s (or a non-Element, non-Location mock); got: %s",b,goog.dom.asserts.debugStringForType_(a)))}return a};goog.dom.asserts.assertIsHTMLAnchorElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLAnchorElement")};
goog.dom.asserts.assertIsHTMLButtonElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLButtonElement")};goog.dom.asserts.assertIsHTMLLinkElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLLinkElement")};goog.dom.asserts.assertIsHTMLImageElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLImageElement")};goog.dom.asserts.assertIsHTMLAudioElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLAudioElement")};
goog.dom.asserts.assertIsHTMLVideoElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLVideoElement")};goog.dom.asserts.assertIsHTMLInputElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLInputElement")};goog.dom.asserts.assertIsHTMLTextAreaElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLTextAreaElement")};goog.dom.asserts.assertIsHTMLCanvasElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLCanvasElement")};
goog.dom.asserts.assertIsHTMLEmbedElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLEmbedElement")};goog.dom.asserts.assertIsHTMLFormElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLFormElement")};goog.dom.asserts.assertIsHTMLFrameElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLFrameElement")};goog.dom.asserts.assertIsHTMLIFrameElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLIFrameElement")};
goog.dom.asserts.assertIsHTMLObjectElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLObjectElement")};goog.dom.asserts.assertIsHTMLScriptElement=function(a){return goog.dom.asserts.assertIsElementType_(a,"HTMLScriptElement")};
goog.dom.asserts.debugStringForType_=function(a){if(goog.isObject(a))try{return a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a)}catch(b){return"<object could not be stringified>"}else return void 0===a?"undefined":null===a?"null":typeof a};goog.dom.asserts.getWindow_=function(a){try{var b=a&&a.ownerDocument,c=b&&(b.defaultView||b.parentWindow);c=c||goog.global;if(c.Element&&c.Location)return c}catch(d){}return null};goog.functions={};goog.functions.constant=function(a){return function(){return a}};goog.functions.FALSE=function(){return!1};goog.functions.TRUE=function(){return!0};goog.functions.NULL=function(){return null};goog.functions.identity=function(a,b){return a};goog.functions.error=function(a){return function(){throw Error(a);}};goog.functions.fail=function(a){return function(){throw a;}};
goog.functions.lock=function(a,b){b=b||0;return function(){return a.apply(this,Array.prototype.slice.call(arguments,0,b))}};goog.functions.nth=function(a){return function(){return arguments[a]}};goog.functions.partialRight=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=Array.prototype.slice.call(arguments);b.push.apply(b,c);return a.apply(this,b)}};goog.functions.withReturnValue=function(a,b){return goog.functions.sequence(a,goog.functions.constant(b))};
goog.functions.equalTo=function(a,b){return function(c){return b?a==c:a===c}};goog.functions.compose=function(a,b){var c=arguments,d=c.length;return function(){var a;d&&(a=c[d-1].apply(this,arguments));for(var b=d-2;0<=b;b--)a=c[b].call(this,a);return a}};goog.functions.sequence=function(a){var b=arguments,c=b.length;return function(){for(var a,e=0;e<c;e++)a=b[e].apply(this,arguments);return a}};
goog.functions.and=function(a){var b=arguments,c=b.length;return function(){for(var a=0;a<c;a++)if(!b[a].apply(this,arguments))return!1;return!0}};goog.functions.or=function(a){var b=arguments,c=b.length;return function(){for(var a=0;a<c;a++)if(b[a].apply(this,arguments))return!0;return!1}};goog.functions.not=function(a){return function(){return!a.apply(this,arguments)}};
goog.functions.create=function(a,b){var c=function(){};c.prototype=a.prototype;c=new c;a.apply(c,Array.prototype.slice.call(arguments,1));return c};goog.functions.CACHE_RETURN_VALUE=!0;goog.functions.cacheReturnValue=function(a){var b=!1,c;return function(){if(!goog.functions.CACHE_RETURN_VALUE)return a();b||(c=a(),b=!0);return c}};goog.functions.once=function(a){var b=a;return function(){if(b){var a=b;b=null;a()}}};
goog.functions.debounce=function(a,b,c){var d=0;return function(e){goog.global.clearTimeout(d);var f=arguments;d=goog.global.setTimeout(function(){a.apply(c,f)},b)}};goog.functions.throttle=function(a,b,c){var d=0,e=!1,f=[],g=function(){d=0;e&&(e=!1,h())},h=function(){d=goog.global.setTimeout(g,b);a.apply(c,f)};return function(a){f=arguments;d?e=!0:h()}};goog.functions.rateLimit=function(a,b,c){var d=0,e=function(){d=0};return function(f){d||(d=goog.global.setTimeout(e,b),a.apply(c,arguments))}};goog.dom.safe={};goog.dom.safe.InsertAdjacentHtmlPosition={AFTERBEGIN:"afterbegin",AFTEREND:"afterend",BEFOREBEGIN:"beforebegin",BEFOREEND:"beforeend"};goog.dom.safe.insertAdjacentHtml=function(a,b,c){a.insertAdjacentHTML(b,goog.html.SafeHtml.unwrapTrustedHTML(c))};goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_={MATH:!0,SCRIPT:!0,STYLE:!0,SVG:!0,TEMPLATE:!0};
goog.dom.safe.isInnerHtmlCleanupRecursive_=goog.functions.cacheReturnValue(function(){if(goog.DEBUG&&"undefined"===typeof document)return!1;var a=document.createElement("div"),b=document.createElement("div");b.appendChild(document.createElement("div"));a.appendChild(b);if(goog.DEBUG&&!a.firstChild)return!1;b=a.firstChild.firstChild;a.innerHTML=goog.html.SafeHtml.unwrapTrustedHTML(goog.html.SafeHtml.EMPTY);return!b.parentElement});
goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse=function(a,b){if(goog.dom.safe.isInnerHtmlCleanupRecursive_())for(;a.lastChild;)a.removeChild(a.lastChild);a.innerHTML=goog.html.SafeHtml.unwrapTrustedHTML(b)};
goog.dom.safe.setInnerHtml=function(a,b){if(goog.asserts.ENABLE_ASSERTS){var c=a.tagName.toUpperCase();if(goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[c])throw Error("goog.dom.safe.setInnerHtml cannot be used to set content of "+a.tagName+".");}goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(a,b)};goog.dom.safe.setOuterHtml=function(a,b){a.outerHTML=goog.html.SafeHtml.unwrapTrustedHTML(b)};
goog.dom.safe.setFormElementAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLFormElement(a).action=goog.html.SafeUrl.unwrapTrustedURL(b)};goog.dom.safe.setButtonFormAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLButtonElement(a).formAction=goog.html.SafeUrl.unwrapTrustedURL(b)};
goog.dom.safe.setInputFormAction=function(a,b){b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);goog.dom.asserts.assertIsHTMLInputElement(a).formAction=goog.html.SafeUrl.unwrapTrustedURL(b)};goog.dom.safe.setStyle=function(a,b){a.style.cssText=goog.html.SafeStyle.unwrap(b)};goog.dom.safe.documentWrite=function(a,b){a.write(goog.html.SafeHtml.unwrapTrustedHTML(b))};
goog.dom.safe.setAnchorHref=function(a,b){goog.dom.asserts.assertIsHTMLAnchorElement(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.href=goog.html.SafeUrl.unwrapTrustedURL(b)};goog.dom.safe.setImageSrc=function(a,b){goog.dom.asserts.assertIsHTMLImageElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:image\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c)}a.src=goog.html.SafeUrl.unwrapTrustedURL(b)};
goog.dom.safe.setAudioSrc=function(a,b){goog.dom.asserts.assertIsHTMLAudioElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:audio\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c)}a.src=goog.html.SafeUrl.unwrapTrustedURL(b)};goog.dom.safe.setVideoSrc=function(a,b){goog.dom.asserts.assertIsHTMLVideoElement(a);if(!(b instanceof goog.html.SafeUrl)){var c=/^data:video\//i.test(b);b=goog.html.SafeUrl.sanitizeAssertUnchanged(b,c)}a.src=goog.html.SafeUrl.unwrapTrustedURL(b)};
goog.dom.safe.setEmbedSrc=function(a,b){goog.dom.asserts.assertIsHTMLEmbedElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b)};goog.dom.safe.setFrameSrc=function(a,b){goog.dom.asserts.assertIsHTMLFrameElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedURL(b)};goog.dom.safe.setIframeSrc=function(a,b){goog.dom.asserts.assertIsHTMLIFrameElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedURL(b)};
goog.dom.safe.setIframeSrcdoc=function(a,b){goog.dom.asserts.assertIsHTMLIFrameElement(a);a.srcdoc=goog.html.SafeHtml.unwrapTrustedHTML(b)};
goog.dom.safe.setLinkHrefAndRel=function(a,b,c){goog.dom.asserts.assertIsHTMLLinkElement(a);a.rel=c;goog.string.internal.caseInsensitiveContains(c,"stylesheet")?(goog.asserts.assert(b instanceof goog.html.TrustedResourceUrl,'URL must be TrustedResourceUrl because "rel" contains "stylesheet"'),a.href=goog.html.TrustedResourceUrl.unwrapTrustedURL(b)):a.href=b instanceof goog.html.TrustedResourceUrl?goog.html.TrustedResourceUrl.unwrapTrustedURL(b):b instanceof goog.html.SafeUrl?goog.html.SafeUrl.unwrapTrustedURL(b):
goog.html.SafeUrl.unwrapTrustedURL(goog.html.SafeUrl.sanitizeAssertUnchanged(b))};goog.dom.safe.setObjectData=function(a,b){goog.dom.asserts.assertIsHTMLObjectElement(a);a.data=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b)};goog.dom.safe.setScriptSrc=function(a,b){goog.dom.asserts.assertIsHTMLScriptElement(a);a.src=goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b);(b=goog.getScriptNonce())&&a.setAttribute("nonce",b)};
goog.dom.safe.setScriptContent=function(a,b){goog.dom.asserts.assertIsHTMLScriptElement(a);a.text=goog.html.SafeScript.unwrapTrustedScript(b);(b=goog.getScriptNonce())&&a.setAttribute("nonce",b)};goog.dom.safe.setLocationHref=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.href=goog.html.SafeUrl.unwrapTrustedURL(b)};
goog.dom.safe.assignLocation=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.assign(goog.html.SafeUrl.unwrapTrustedURL(b))};goog.dom.safe.replaceLocation=function(a,b){goog.dom.asserts.assertIsLocation(a);b=b instanceof goog.html.SafeUrl?b:goog.html.SafeUrl.sanitizeAssertUnchanged(b);a.replace(goog.html.SafeUrl.unwrapTrustedURL(b))};
goog.dom.safe.openInWindow=function(a,b,c,d,e){a=a instanceof goog.html.SafeUrl?a:goog.html.SafeUrl.sanitizeAssertUnchanged(a);return(b||goog.global).open(goog.html.SafeUrl.unwrapTrustedURL(a),c?goog.string.Const.unwrap(c):"",d,e)};goog.dom.safe.parseFromStringHtml=function(a,b){return goog.dom.safe.parseFromString(a,b,"text/html")};goog.dom.safe.parseFromString=function(a,b,c){return a.parseFromString(goog.html.SafeHtml.unwrapTrustedHTML(b),c)};
goog.dom.safe.createImageFromBlob=function(a){if(!/^image\/.*/g.test(a.type))throw Error("goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.");var b=goog.global.URL.createObjectURL(a);a=new goog.global.Image;a.onload=function(){goog.global.URL.revokeObjectURL(b)};goog.dom.safe.setImageSrc(a,goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Image blob URL."),b));return a};goog.string.DETECT_DOUBLE_ESCAPING=!1;goog.string.FORCE_NON_DOM_HTML_UNESCAPING=!1;goog.string.Unicode={NBSP:"\u00a0"};goog.string.startsWith=goog.string.internal.startsWith;goog.string.endsWith=goog.string.internal.endsWith;goog.string.caseInsensitiveStartsWith=goog.string.internal.caseInsensitiveStartsWith;goog.string.caseInsensitiveEndsWith=goog.string.internal.caseInsensitiveEndsWith;goog.string.caseInsensitiveEquals=goog.string.internal.caseInsensitiveEquals;
goog.string.subs=function(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")};goog.string.collapseWhitespace=function(a){return a.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"")};goog.string.isEmptyOrWhitespace=goog.string.internal.isEmptyOrWhitespace;goog.string.isEmptyString=function(a){return 0==a.length};goog.string.isEmpty=goog.string.isEmptyOrWhitespace;goog.string.isEmptyOrWhitespaceSafe=function(a){return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(a))};
goog.string.isEmptySafe=goog.string.isEmptyOrWhitespaceSafe;goog.string.isBreakingWhitespace=function(a){return!/[^\t\n\r ]/.test(a)};goog.string.isAlpha=function(a){return!/[^a-zA-Z]/.test(a)};goog.string.isNumeric=function(a){return!/[^0-9]/.test(a)};goog.string.isAlphaNumeric=function(a){return!/[^a-zA-Z0-9]/.test(a)};goog.string.isSpace=function(a){return" "==a};goog.string.isUnicodeChar=function(a){return 1==a.length&&" "<=a&&"~">=a||"\u0080"<=a&&"\ufffd">=a};
goog.string.stripNewlines=function(a){return a.replace(/(\r\n|\r|\n)+/g," ")};goog.string.canonicalizeNewlines=function(a){return a.replace(/(\r\n|\r|\n)/g,"\n")};goog.string.normalizeWhitespace=function(a){return a.replace(/\xa0|\s/g," ")};goog.string.normalizeSpaces=function(a){return a.replace(/\xa0|[ \t]+/g," ")};goog.string.collapseBreakingSpaces=function(a){return a.replace(/[\t\r\n ]+/g," ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g,"")};goog.string.trim=goog.string.internal.trim;
goog.string.trimLeft=function(a){return a.replace(/^[\s\xa0]+/,"")};goog.string.trimRight=function(a){return a.replace(/[\s\xa0]+$/,"")};goog.string.caseInsensitiveCompare=goog.string.internal.caseInsensitiveCompare;
goog.string.numberAwareCompare_=function(a,b,c){if(a==b)return 0;if(!a)return-1;if(!b)return 1;for(var d=a.toLowerCase().match(c),e=b.toLowerCase().match(c),f=Math.min(d.length,e.length),g=0;g<f;g++){c=d[g];var h=e[g];if(c!=h)return a=parseInt(c,10),!isNaN(a)&&(b=parseInt(h,10),!isNaN(b)&&a-b)?a-b:c<h?-1:1}return d.length!=e.length?d.length-e.length:a<b?-1:1};goog.string.intAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\D+/g)};
goog.string.floatAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\.\d+|\D+/g)};goog.string.numerateCompare=goog.string.floatAwareCompare;goog.string.urlEncode=function(a){return encodeURIComponent(String(a))};goog.string.urlDecode=function(a){return decodeURIComponent(a.replace(/\+/g," "))};goog.string.newLineToBr=goog.string.internal.newLineToBr;
goog.string.htmlEscape=function(a,b){a=goog.string.internal.htmlEscape(a,b);goog.string.DETECT_DOUBLE_ESCAPING&&(a=a.replace(goog.string.E_RE_,"&#101;"));return a};goog.string.E_RE_=/e/g;goog.string.unescapeEntities=function(a){return goog.string.contains(a,"&")?!goog.string.FORCE_NON_DOM_HTML_UNESCAPING&&"document"in goog.global?goog.string.unescapeEntitiesUsingDom_(a):goog.string.unescapePureXmlEntities_(a):a};
goog.string.unescapeEntitiesWithDocument=function(a,b){return goog.string.contains(a,"&")?goog.string.unescapeEntitiesUsingDom_(a,b):a};
goog.string.unescapeEntitiesUsingDom_=function(a,b){var c={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"'};var d=b?b.createElement("div"):goog.global.document.createElement("div");return a.replace(goog.string.HTML_ENTITY_PATTERN_,function(a,b){var e=c[a];if(e)return e;"#"==b.charAt(0)&&(b=Number("0"+b.substr(1)),isNaN(b)||(e=String.fromCharCode(b)));e||(goog.dom.safe.setInnerHtml(d,goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Single HTML entity."),
a+" ")),e=d.firstChild.nodeValue.slice(0,-1));return c[a]=e})};goog.string.unescapePureXmlEntities_=function(a){return a.replace(/&([^;]+);/g,function(a,c){switch(c){case "amp":return"&";case "lt":return"<";case "gt":return">";case "quot":return'"';default:return"#"!=c.charAt(0)||(c=Number("0"+c.substr(1)),isNaN(c))?a:String.fromCharCode(c)}})};goog.string.HTML_ENTITY_PATTERN_=/&([^;\s<&]+);?/g;goog.string.whitespaceEscape=function(a,b){return goog.string.newLineToBr(a.replace(/  /g," &#160;"),b)};
goog.string.preserveSpaces=function(a){return a.replace(/(^|[\n ]) /g,"$1"+goog.string.Unicode.NBSP)};goog.string.stripQuotes=function(a,b){for(var c=b.length,d=0;d<c;d++){var e=1==c?b:b.charAt(d);if(a.charAt(0)==e&&a.charAt(a.length-1)==e)return a.substring(1,a.length-1)}return a};goog.string.truncate=function(a,b,c){c&&(a=goog.string.unescapeEntities(a));a.length>b&&(a=a.substring(0,b-3)+"...");c&&(a=goog.string.htmlEscape(a));return a};
goog.string.truncateMiddle=function(a,b,c,d){c&&(a=goog.string.unescapeEntities(a));if(d&&a.length>b){d>b&&(d=b);var e=a.length-d;a=a.substring(0,b-d)+"..."+a.substring(e)}else a.length>b&&(d=Math.floor(b/2),e=a.length-d,a=a.substring(0,d+b%2)+"..."+a.substring(e));c&&(a=goog.string.htmlEscape(a));return a};goog.string.specialEscapeChars_={"\x00":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\x0B",'"':'\\"',"\\":"\\\\","<":"\\u003C"};goog.string.jsEscapeCache_={"'":"\\'"};
goog.string.quote=function(a){a=String(a);for(var b=['"'],c=0;c<a.length;c++){var d=a.charAt(c),e=d.charCodeAt(0);b[c+1]=goog.string.specialEscapeChars_[d]||(31<e&&127>e?d:goog.string.escapeChar(d))}b.push('"');return b.join("")};goog.string.escapeString=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=goog.string.escapeChar(a.charAt(c));return b.join("")};
goog.string.escapeChar=function(a){if(a in goog.string.jsEscapeCache_)return goog.string.jsEscapeCache_[a];if(a in goog.string.specialEscapeChars_)return goog.string.jsEscapeCache_[a]=goog.string.specialEscapeChars_[a];var b=a.charCodeAt(0);if(31<b&&127>b)var c=a;else{if(256>b){if(c="\\x",16>b||256<b)c+="0"}else c="\\u",4096>b&&(c+="0");c+=b.toString(16).toUpperCase()}return goog.string.jsEscapeCache_[a]=c};goog.string.contains=goog.string.internal.contains;goog.string.caseInsensitiveContains=goog.string.internal.caseInsensitiveContains;
goog.string.countOf=function(a,b){return a&&b?a.split(b).length-1:0};goog.string.removeAt=function(a,b,c){var d=a;0<=b&&b<a.length&&0<c&&(d=a.substr(0,b)+a.substr(b+c,a.length-b-c));return d};goog.string.remove=function(a,b){return a.replace(b,"")};goog.string.removeAll=function(a,b){b=new RegExp(goog.string.regExpEscape(b),"g");return a.replace(b,"")};goog.string.replaceAll=function(a,b,c){b=new RegExp(goog.string.regExpEscape(b),"g");return a.replace(b,c.replace(/\$/g,"$$$$"))};
goog.string.regExpEscape=function(a){return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")};goog.string.repeat=String.prototype.repeat?function(a,b){return a.repeat(b)}:function(a,b){return Array(b+1).join(a)};goog.string.padNumber=function(a,b,c){a=goog.isDef(c)?a.toFixed(c):String(a);c=a.indexOf(".");-1==c&&(c=a.length);return goog.string.repeat("0",Math.max(0,b-c))+a};goog.string.makeSafe=function(a){return null==a?"":String(a)};
goog.string.buildString=function(a){return Array.prototype.join.call(arguments,"")};goog.string.getRandomString=function(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^goog.now()).toString(36)};goog.string.compareVersions=goog.string.internal.compareVersions;goog.string.hashCode=function(a){for(var b=0,c=0;c<a.length;++c)b=31*b+a.charCodeAt(c)>>>0;return b};goog.string.uniqueStringCounter_=2147483648*Math.random()|0;
goog.string.createUniqueString=function(){return"goog_"+goog.string.uniqueStringCounter_++};goog.string.toNumber=function(a){var b=Number(a);return 0==b&&goog.string.isEmptyOrWhitespace(a)?NaN:b};goog.string.isLowerCamelCase=function(a){return/^[a-z]+([A-Z][a-z]*)*$/.test(a)};goog.string.isUpperCamelCase=function(a){return/^([A-Z][a-z]*)+$/.test(a)};goog.string.toCamelCase=function(a){return String(a).replace(/\-([a-z])/g,function(a,c){return c.toUpperCase()})};
goog.string.toSelectorCase=function(a){return String(a).replace(/([A-Z])/g,"-$1").toLowerCase()};goog.string.toTitleCase=function(a,b){b=goog.isString(b)?goog.string.regExpEscape(b):"\\s";return a.replace(new RegExp("(^"+(b?"|["+b+"]+":"")+")([a-z])","g"),function(a,b,e){return b+e.toUpperCase()})};goog.string.capitalize=function(a){return String(a.charAt(0)).toUpperCase()+String(a.substr(1)).toLowerCase()};
goog.string.parseInt=function(a){isFinite(a)&&(a=String(a));return goog.isString(a)?/^\s*-?0x/i.test(a)?parseInt(a,16):parseInt(a,10):NaN};goog.string.splitLimit=function(a,b,c){a=a.split(b);for(var d=[];0<c&&a.length;)d.push(a.shift()),c--;a.length&&d.push(a.join(b));return d};goog.string.lastComponent=function(a,b){if(b)"string"==typeof b&&(b=[b]);else return a;for(var c=-1,d=0;d<b.length;d++)if(""!=b[d]){var e=a.lastIndexOf(b[d]);e>c&&(c=e)}return-1==c?a:a.slice(c+1)};
goog.string.editDistance=function(a,b){var c=[],d=[];if(a==b)return 0;if(!a.length||!b.length)return Math.max(a.length,b.length);for(var e=0;e<b.length+1;e++)c[e]=e;for(e=0;e<a.length;e++){d[0]=e+1;for(var f=0;f<b.length;f++)d[f+1]=Math.min(d[f]+1,c[f+1]+1,c[f]+Number(a[e]!=b[f]));for(f=0;f<c.length;f++)c[f]=d[f]}return d[b.length]};goog.labs.userAgent.platform={};goog.labs.userAgent.platform.isAndroid=function(){return goog.labs.userAgent.util.matchUserAgent("Android")};goog.labs.userAgent.platform.isIpod=function(){return goog.labs.userAgent.util.matchUserAgent("iPod")};goog.labs.userAgent.platform.isIphone=function(){return goog.labs.userAgent.util.matchUserAgent("iPhone")&&!goog.labs.userAgent.util.matchUserAgent("iPod")&&!goog.labs.userAgent.util.matchUserAgent("iPad")};goog.labs.userAgent.platform.isIpad=function(){return goog.labs.userAgent.util.matchUserAgent("iPad")};
goog.labs.userAgent.platform.isIos=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpad()||goog.labs.userAgent.platform.isIpod()};goog.labs.userAgent.platform.isMacintosh=function(){return goog.labs.userAgent.util.matchUserAgent("Macintosh")};goog.labs.userAgent.platform.isLinux=function(){return goog.labs.userAgent.util.matchUserAgent("Linux")};goog.labs.userAgent.platform.isWindows=function(){return goog.labs.userAgent.util.matchUserAgent("Windows")};
goog.labs.userAgent.platform.isChromeOS=function(){return goog.labs.userAgent.util.matchUserAgent("CrOS")};goog.labs.userAgent.platform.isChromecast=function(){return goog.labs.userAgent.util.matchUserAgent("CrKey")};goog.labs.userAgent.platform.isKaiOS=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("KaiOS")};goog.labs.userAgent.platform.isGo2Phone=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("GAFP")};
goog.labs.userAgent.platform.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent(),b="";goog.labs.userAgent.platform.isWindows()?(b=/Windows (?:NT|Phone) ([0-9.]+)/,b=(a=b.exec(a))?a[1]:"0.0"):goog.labs.userAgent.platform.isIos()?(b=/(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/,b=(a=b.exec(a))&&a[1].replace(/_/g,".")):goog.labs.userAgent.platform.isMacintosh()?(b=/Mac OS X ([0-9_.]+)/,b=(a=b.exec(a))?a[1].replace(/_/g,"."):"10"):goog.labs.userAgent.platform.isKaiOS()?(b=/(?:KaiOS)\/(\S+)/i,
b=(a=b.exec(a))&&a[1]):goog.labs.userAgent.platform.isAndroid()?(b=/Android\s+([^\);]+)(\)|;)/,b=(a=b.exec(a))&&a[1]):goog.labs.userAgent.platform.isChromeOS()&&(b=/(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/,b=(a=b.exec(a))&&a[1]);return b||""};goog.labs.userAgent.platform.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(),a)};goog.reflect={};goog.reflect.object=function(a,b){return b};goog.reflect.objectProperty=function(a,b){return a};goog.reflect.sinkValue=function(a){goog.reflect.sinkValue[" "](a);return a};goog.reflect.sinkValue[" "]=goog.nullFunction;goog.reflect.canAccessProperty=function(a,b){try{return goog.reflect.sinkValue(a[b]),!0}catch(c){}return!1};goog.reflect.cache=function(a,b,c,d){d=d?d(b):b;return Object.prototype.hasOwnProperty.call(a,d)?a[d]:a[d]=c(b)};goog.labs.userAgent.engine={};goog.labs.userAgent.engine.isPresto=function(){return goog.labs.userAgent.util.matchUserAgent("Presto")};goog.labs.userAgent.engine.isTrident=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.engine.isEdge=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};
goog.labs.userAgent.engine.isWebKit=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit")&&!goog.labs.userAgent.engine.isEdge()};goog.labs.userAgent.engine.isGecko=function(){return goog.labs.userAgent.util.matchUserAgent("Gecko")&&!goog.labs.userAgent.engine.isWebKit()&&!goog.labs.userAgent.engine.isTrident()&&!goog.labs.userAgent.engine.isEdge()};
goog.labs.userAgent.engine.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent();if(a){a=goog.labs.userAgent.util.extractVersionTuples(a);var b=goog.labs.userAgent.engine.getEngineTuple_(a);if(b)return"Gecko"==b[0]?goog.labs.userAgent.engine.getVersionForKey_(a,"Firefox"):b[1];a=a[0];var c;if(a&&(c=a[2])&&(c=/Trident\/([^\s;]+)/.exec(c)))return c[1]}return""};
goog.labs.userAgent.engine.getEngineTuple_=function(a){if(!goog.labs.userAgent.engine.isEdge())return a[1];for(var b=0;b<a.length;b++){var c=a[b];if("Edge"==c[0])return c}};goog.labs.userAgent.engine.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(),a)};goog.labs.userAgent.engine.getVersionForKey_=function(a,b){return(a=goog.array.find(a,function(a){return b==a[0]}))&&a[1]||""};goog.userAgent={};goog.userAgent.ASSUME_IE=!1;goog.userAgent.ASSUME_EDGE=!1;goog.userAgent.ASSUME_GECKO=!1;goog.userAgent.ASSUME_WEBKIT=!1;goog.userAgent.ASSUME_MOBILE_WEBKIT=!1;goog.userAgent.ASSUME_OPERA=!1;goog.userAgent.ASSUME_ANY_VERSION=!1;goog.userAgent.BROWSER_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_GECKO||goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_OPERA;goog.userAgent.getUserAgentString=function(){return goog.labs.userAgent.util.getUserAgent()};
goog.userAgent.getNavigatorTyped=function(){return goog.global.navigator||null};goog.userAgent.getNavigator=function(){return goog.userAgent.getNavigatorTyped()};goog.userAgent.OPERA=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_OPERA:goog.labs.userAgent.browser.isOpera();goog.userAgent.IE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_IE:goog.labs.userAgent.browser.isIE();goog.userAgent.EDGE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_EDGE:goog.labs.userAgent.engine.isEdge();
goog.userAgent.EDGE_OR_IE=goog.userAgent.EDGE||goog.userAgent.IE;goog.userAgent.GECKO=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_GECKO:goog.labs.userAgent.engine.isGecko();goog.userAgent.WEBKIT=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_MOBILE_WEBKIT:goog.labs.userAgent.engine.isWebKit();goog.userAgent.isMobile_=function(){return goog.userAgent.WEBKIT&&goog.labs.userAgent.util.matchUserAgent("Mobile")};
goog.userAgent.MOBILE=goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.isMobile_();goog.userAgent.SAFARI=goog.userAgent.WEBKIT;goog.userAgent.determinePlatform_=function(){var a=goog.userAgent.getNavigatorTyped();return a&&a.platform||""};goog.userAgent.PLATFORM=goog.userAgent.determinePlatform_();goog.userAgent.ASSUME_MAC=!1;goog.userAgent.ASSUME_WINDOWS=!1;goog.userAgent.ASSUME_LINUX=!1;goog.userAgent.ASSUME_X11=!1;goog.userAgent.ASSUME_ANDROID=!1;goog.userAgent.ASSUME_IPHONE=!1;
goog.userAgent.ASSUME_IPAD=!1;goog.userAgent.ASSUME_IPOD=!1;goog.userAgent.ASSUME_KAIOS=!1;goog.userAgent.ASSUME_GO2PHONE=!1;goog.userAgent.PLATFORM_KNOWN_=goog.userAgent.ASSUME_MAC||goog.userAgent.ASSUME_WINDOWS||goog.userAgent.ASSUME_LINUX||goog.userAgent.ASSUME_X11||goog.userAgent.ASSUME_ANDROID||goog.userAgent.ASSUME_IPHONE||goog.userAgent.ASSUME_IPAD||goog.userAgent.ASSUME_IPOD;goog.userAgent.MAC=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_MAC:goog.labs.userAgent.platform.isMacintosh();
goog.userAgent.WINDOWS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_WINDOWS:goog.labs.userAgent.platform.isWindows();goog.userAgent.isLegacyLinux_=function(){return goog.labs.userAgent.platform.isLinux()||goog.labs.userAgent.platform.isChromeOS()};goog.userAgent.LINUX=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_LINUX:goog.userAgent.isLegacyLinux_();goog.userAgent.isX11_=function(){var a=goog.userAgent.getNavigatorTyped();return!!a&&goog.string.contains(a.appVersion||"","X11")};
goog.userAgent.X11=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_X11:goog.userAgent.isX11_();goog.userAgent.ANDROID=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_ANDROID:goog.labs.userAgent.platform.isAndroid();goog.userAgent.IPHONE=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPHONE:goog.labs.userAgent.platform.isIphone();goog.userAgent.IPAD=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();
goog.userAgent.IPOD=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPOD:goog.labs.userAgent.platform.isIpod();goog.userAgent.IOS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPHONE||goog.userAgent.ASSUME_IPAD||goog.userAgent.ASSUME_IPOD:goog.labs.userAgent.platform.isIos();goog.userAgent.KAIOS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_KAIOS:goog.labs.userAgent.platform.isKaiOS();goog.userAgent.GO2PHONE=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_GO2PHONE:goog.labs.userAgent.platform.isGo2Phone();
goog.userAgent.determineVersion_=function(){var a="",b=goog.userAgent.getVersionRegexResult_();b&&(a=b?b[1]:"");return goog.userAgent.IE&&(b=goog.userAgent.getDocumentMode_(),null!=b&&b>parseFloat(a))?String(b):a};
goog.userAgent.getVersionRegexResult_=function(){var a=goog.userAgent.getUserAgentString();if(goog.userAgent.GECKO)return/rv:([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.EDGE)return/Edge\/([\d\.]+)/.exec(a);if(goog.userAgent.IE)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.WEBKIT)return/WebKit\/(\S+)/.exec(a);if(goog.userAgent.OPERA)return/(?:Version)[ \/]?(\S+)/.exec(a)};goog.userAgent.getDocumentMode_=function(){var a=goog.global.document;return a?a.documentMode:void 0};
goog.userAgent.VERSION=goog.userAgent.determineVersion_();goog.userAgent.compare=function(a,b){return goog.string.compareVersions(a,b)};goog.userAgent.isVersionOrHigherCache_={};goog.userAgent.isVersionOrHigher=function(a){return goog.userAgent.ASSUME_ANY_VERSION||goog.reflect.cache(goog.userAgent.isVersionOrHigherCache_,a,function(){return 0<=goog.string.compareVersions(goog.userAgent.VERSION,a)})};goog.userAgent.isVersion=goog.userAgent.isVersionOrHigher;
goog.userAgent.isDocumentModeOrHigher=function(a){return Number(goog.userAgent.DOCUMENT_MODE)>=a};goog.userAgent.isDocumentMode=goog.userAgent.isDocumentModeOrHigher;goog.userAgent.DOCUMENT_MODE=function(){if(goog.global.document&&goog.userAgent.IE)return goog.userAgent.getDocumentMode_()}();goog.userAgent.product={};goog.userAgent.product.ASSUME_FIREFOX=!1;goog.userAgent.product.ASSUME_IPHONE=!1;goog.userAgent.product.ASSUME_IPAD=!1;goog.userAgent.product.ASSUME_ANDROID=!1;goog.userAgent.product.ASSUME_CHROME=!1;goog.userAgent.product.ASSUME_SAFARI=!1;
goog.userAgent.product.PRODUCT_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_OPERA||goog.userAgent.product.ASSUME_FIREFOX||goog.userAgent.product.ASSUME_IPHONE||goog.userAgent.product.ASSUME_IPAD||goog.userAgent.product.ASSUME_ANDROID||goog.userAgent.product.ASSUME_CHROME||goog.userAgent.product.ASSUME_SAFARI;goog.userAgent.product.OPERA=goog.userAgent.OPERA;goog.userAgent.product.IE=goog.userAgent.IE;goog.userAgent.product.EDGE=goog.userAgent.EDGE;
goog.userAgent.product.FIREFOX=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_FIREFOX:goog.labs.userAgent.browser.isFirefox();goog.userAgent.product.isIphoneOrIpod_=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpod()};goog.userAgent.product.IPHONE=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPHONE:goog.userAgent.product.isIphoneOrIpod_();
goog.userAgent.product.IPAD=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();goog.userAgent.product.ANDROID=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_ANDROID:goog.labs.userAgent.browser.isAndroidBrowser();goog.userAgent.product.CHROME=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_CHROME:goog.labs.userAgent.browser.isChrome();
goog.userAgent.product.isSafariDesktop_=function(){return goog.labs.userAgent.browser.isSafari()&&!goog.labs.userAgent.platform.isIos()};goog.userAgent.product.SAFARI=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_SAFARI:goog.userAgent.product.isSafariDesktop_();goog.crypt.base64={};goog.crypt.base64.DEFAULT_ALPHABET_COMMON_="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";goog.crypt.base64.ENCODED_VALS=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_+"+/=";goog.crypt.base64.ENCODED_VALS_WEBSAFE=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_+"-_.";goog.crypt.base64.Alphabet={DEFAULT:0,NO_PADDING:1,WEBSAFE:2,WEBSAFE_DOT_PADDING:3,WEBSAFE_NO_PADDING:4};goog.crypt.base64.paddingChars_="=.";
goog.crypt.base64.isPadding_=function(a){return goog.string.contains(goog.crypt.base64.paddingChars_,a)};goog.crypt.base64.byteToCharMaps_={};goog.crypt.base64.charToByteMap_=null;goog.crypt.base64.ASSUME_NATIVE_SUPPORT_=goog.userAgent.GECKO||goog.userAgent.WEBKIT&&!goog.userAgent.product.SAFARI||goog.userAgent.OPERA;goog.crypt.base64.HAS_NATIVE_ENCODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||"function"==typeof goog.global.btoa;
goog.crypt.base64.HAS_NATIVE_DECODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||!goog.userAgent.product.SAFARI&&!goog.userAgent.IE&&"function"==typeof goog.global.atob;
goog.crypt.base64.encodeByteArray=function(a,b){goog.asserts.assert(goog.isArrayLike(a),"encodeByteArray takes an array as a parameter");void 0===b&&(b=goog.crypt.base64.Alphabet.DEFAULT);goog.crypt.base64.init_();b=goog.crypt.base64.byteToCharMaps_[b];for(var c=[],d=0;d<a.length;d+=3){var e=a[d],f=d+1<a.length,g=f?a[d+1]:0,h=d+2<a.length,k=h?a[d+2]:0,l=e>>2;e=(e&3)<<4|g>>4;g=(g&15)<<2|k>>6;k&=63;h||(k=64,f||(g=64));c.push(b[l],b[e],b[g]||"",b[k]||"")}return c.join("")};
goog.crypt.base64.encodeString=function(a,b){return goog.crypt.base64.HAS_NATIVE_ENCODE_&&!b?goog.global.btoa(a):goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(a),b)};goog.crypt.base64.decodeString=function(a,b){if(goog.crypt.base64.HAS_NATIVE_DECODE_&&!b)return goog.global.atob(a);var c="";goog.crypt.base64.decodeStringInternal_(a,function(a){c+=String.fromCharCode(a)});return c};
goog.crypt.base64.decodeStringToByteArray=function(a,b){var c=[];goog.crypt.base64.decodeStringInternal_(a,function(a){c.push(a)});return c};
goog.crypt.base64.decodeStringToUint8Array=function(a){goog.asserts.assert(!goog.userAgent.IE||goog.userAgent.isVersionOrHigher("10"),"Browser does not support typed arrays");var b=a.length,c=3*b/4;c%3?c=Math.floor(c):goog.crypt.base64.isPadding_(a[b-1])&&(c=goog.crypt.base64.isPadding_(a[b-2])?c-2:c-1);var d=new Uint8Array(c),e=0;goog.crypt.base64.decodeStringInternal_(a,function(a){d[e++]=a});return d.subarray(0,e)};
goog.crypt.base64.decodeStringInternal_=function(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=goog.crypt.base64.charToByteMap_[c];if(null!=e)return e;if(!goog.string.isEmptyOrWhitespace(c))throw Error("Unknown base64 encoding at char: "+c);}return b}goog.crypt.base64.init_();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),h=c(64);if(64===h&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=h&&b(g<<6&192|h))}};
goog.crypt.base64.init_=function(){if(!goog.crypt.base64.charToByteMap_){goog.crypt.base64.charToByteMap_={};for(var a=goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split(""),b=["+/=","+/","-_=","-_.","-_"],c=0;5>c;c++){var d=a.concat(b[c].split(""));goog.crypt.base64.byteToCharMaps_[c]=d;for(var e=0;e<d.length;e++){var f=d[e],g=goog.crypt.base64.charToByteMap_[f];void 0===g?goog.crypt.base64.charToByteMap_[f]=e:goog.asserts.assert(g===e)}}}};jspb.utils={};jspb.utils.split64Low=0;jspb.utils.split64High=0;jspb.utils.splitUint64=function(a){var b=a>>>0;a=Math.floor((a-b)/jspb.BinaryConstants.TWO_TO_32)>>>0;jspb.utils.split64Low=b;jspb.utils.split64High=a};jspb.utils.splitInt64=function(a){var b=0>a;a=Math.abs(a);var c=a>>>0;a=Math.floor((a-c)/jspb.BinaryConstants.TWO_TO_32);a>>>=0;b&&(a=~a>>>0,c=(~c>>>0)+1,4294967295<c&&(c=0,a++,4294967295<a&&(a=0)));jspb.utils.split64Low=c;jspb.utils.split64High=a};
jspb.utils.splitZigzag64=function(a){var b=0>a;a=2*Math.abs(a);jspb.utils.splitUint64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;b&&(0==a?0==c?c=a=4294967295:(c--,a=4294967295):a--);jspb.utils.split64Low=a;jspb.utils.split64High=c};
jspb.utils.splitFloat32=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)0<1/a?(jspb.utils.split64High=0,jspb.utils.split64Low=0):(jspb.utils.split64High=0,jspb.utils.split64Low=2147483648);else if(isNaN(a))jspb.utils.split64High=0,jspb.utils.split64Low=2147483647;else if(a>jspb.BinaryConstants.FLOAT32_MAX)jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|2139095040)>>>0;else if(a<jspb.BinaryConstants.FLOAT32_MIN)a=Math.round(a/Math.pow(2,-149)),jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|
a)>>>0;else{var c=Math.floor(Math.log(a)/Math.LN2);a*=Math.pow(2,-c);a=Math.round(a*jspb.BinaryConstants.TWO_TO_23)&8388607;jspb.utils.split64High=0;jspb.utils.split64Low=(b<<31|c+127<<23|a)>>>0}};
jspb.utils.splitFloat64=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)jspb.utils.split64High=0<1/a?0:2147483648,jspb.utils.split64Low=0;else if(isNaN(a))jspb.utils.split64High=2147483647,jspb.utils.split64Low=4294967295;else if(a>jspb.BinaryConstants.FLOAT64_MAX)jspb.utils.split64High=(b<<31|2146435072)>>>0,jspb.utils.split64Low=0;else if(a<jspb.BinaryConstants.FLOAT64_MIN){var c=a/Math.pow(2,-1074);a=c/jspb.BinaryConstants.TWO_TO_32;jspb.utils.split64High=(b<<31|a)>>>0;jspb.utils.split64Low=c>>>0}else{c=
a;var d=0;if(2<=c)for(;2<=c&&1023>d;)d++,c/=2;else for(;1>c&&-1022<d;)c*=2,d--;c=a*Math.pow(2,-d);a=c*jspb.BinaryConstants.TWO_TO_20&1048575;c=c*jspb.BinaryConstants.TWO_TO_52>>>0;jspb.utils.split64High=(b<<31|d+1023<<20|a)>>>0;jspb.utils.split64Low=c}};
jspb.utils.splitHash64=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=a.charCodeAt(4),g=a.charCodeAt(5),h=a.charCodeAt(6);a=a.charCodeAt(7);jspb.utils.split64Low=b+(c<<8)+(d<<16)+(e<<24)>>>0;jspb.utils.split64High=f+(g<<8)+(h<<16)+(a<<24)>>>0};jspb.utils.joinUint64=function(a,b){return b*jspb.BinaryConstants.TWO_TO_32+(a>>>0)};
jspb.utils.joinInt64=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b>>>0,0==a&&(b=b+1>>>0));a=jspb.utils.joinUint64(a,b);return c?-a:a};jspb.utils.toZigzag64=function(a,b,c){var d=b>>31;return c(a<<1^d,(b<<1|a>>>31)^d)};jspb.utils.joinZigzag64=function(a,b){return jspb.utils.fromZigzag64(a,b,jspb.utils.joinInt64)};jspb.utils.fromZigzag64=function(a,b,c){var d=-(a&1);return c((a>>>1|b<<31)^d,b>>>1^d)};
jspb.utils.joinFloat32=function(a,b){b=2*(a>>31)+1;var c=a>>>23&255;a&=8388607;return 255==c?a?NaN:Infinity*b:0==c?b*Math.pow(2,-149)*a:b*Math.pow(2,c-150)*(a+Math.pow(2,23))};jspb.utils.joinFloat64=function(a,b){var c=2*(b>>31)+1,d=b>>>20&2047;a=jspb.BinaryConstants.TWO_TO_32*(b&1048575)+a;return 2047==d?a?NaN:Infinity*c:0==d?c*Math.pow(2,-1074)*a:c*Math.pow(2,d-1075)*(a+jspb.BinaryConstants.TWO_TO_52)};
jspb.utils.joinHash64=function(a,b){return String.fromCharCode(a>>>0&255,a>>>8&255,a>>>16&255,a>>>24&255,b>>>0&255,b>>>8&255,b>>>16&255,b>>>24&255)};jspb.utils.DIGITS="0123456789abcdef".split("");jspb.utils.ZERO_CHAR_CODE_=48;jspb.utils.A_CHAR_CODE_=97;
jspb.utils.joinUnsignedDecimalString=function(a,b){function c(a,b){a=a?String(a):"";return b?"0000000".slice(a.length)+a:a}if(2097151>=b)return""+(jspb.BinaryConstants.TWO_TO_32*b+a);var d=(a>>>24|b<<8)>>>0&16777215;b=b>>16&65535;a=(a&16777215)+6777216*d+6710656*b;d+=8147497*b;b*=2;1E7<=a&&(d+=Math.floor(a/1E7),a%=1E7);1E7<=d&&(b+=Math.floor(d/1E7),d%=1E7);return c(b,0)+c(d,b)+c(a,1)};
jspb.utils.joinSignedDecimalString=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b+(0==a?1:0)>>>0);a=jspb.utils.joinUnsignedDecimalString(a,b);return c?"-"+a:a};jspb.utils.hash64ToDecimalString=function(a,b){jspb.utils.splitHash64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;return b?jspb.utils.joinSignedDecimalString(a,c):jspb.utils.joinUnsignedDecimalString(a,c)};
jspb.utils.hash64ArrayToDecimalStrings=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]=jspb.utils.hash64ToDecimalString(a[d],b);return c};
jspb.utils.decimalStringToHash64=function(a){function b(a,b){for(var c=0;8>c&&(1!==a||0<b);c++)b=a*e[c]+b,e[c]=b&255,b>>>=8}function c(){for(var a=0;8>a;a++)e[a]=~e[a]&255}goog.asserts.assert(0<a.length);var d=!1;"-"===a[0]&&(d=!0,a=a.slice(1));for(var e=[0,0,0,0,0,0,0,0],f=0;f<a.length;f++)b(10,a.charCodeAt(f)-jspb.utils.ZERO_CHAR_CODE_);d&&(c(),b(1,1));return goog.crypt.byteArrayToString(e)};jspb.utils.splitDecimalString=function(a){jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a))};
jspb.utils.toHexDigit_=function(a){return String.fromCharCode(10>a?jspb.utils.ZERO_CHAR_CODE_+a:jspb.utils.A_CHAR_CODE_-10+a)};jspb.utils.fromHexCharCode_=function(a){return a>=jspb.utils.A_CHAR_CODE_?a-jspb.utils.A_CHAR_CODE_+10:a-jspb.utils.ZERO_CHAR_CODE_};jspb.utils.hash64ToHexString=function(a){var b=Array(18);b[0]="0";b[1]="x";for(var c=0;8>c;c++){var d=a.charCodeAt(7-c);b[2*c+2]=jspb.utils.toHexDigit_(d>>4);b[2*c+3]=jspb.utils.toHexDigit_(d&15)}return b.join("")};
jspb.utils.hexStringToHash64=function(a){a=a.toLowerCase();goog.asserts.assert(18==a.length);goog.asserts.assert("0"==a[0]);goog.asserts.assert("x"==a[1]);for(var b="",c=0;8>c;c++){var d=jspb.utils.fromHexCharCode_(a.charCodeAt(2*c+2)),e=jspb.utils.fromHexCharCode_(a.charCodeAt(2*c+3));b=String.fromCharCode(16*d+e)+b}return b};
jspb.utils.hash64ToNumber=function(a,b){jspb.utils.splitHash64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;return b?jspb.utils.joinInt64(a,c):jspb.utils.joinUint64(a,c)};jspb.utils.numberToHash64=function(a){jspb.utils.splitInt64(a);return jspb.utils.joinHash64(jspb.utils.split64Low,jspb.utils.split64High)};jspb.utils.countVarints=function(a,b,c){for(var d=0,e=b;e<c;e++)d+=a[e]>>7;return c-b-d};
jspb.utils.countVarintFields=function(a,b,c,d){var e=0;d=8*d+jspb.BinaryConstants.WireType.VARINT;if(128>d)for(;b<c&&a[b++]==d;)for(e++;;){var f=a[b++];if(0==(f&128))break}else for(;b<c;){for(f=d;128<f;){if(a[b]!=(f&127|128))return e;b++;f>>=7}if(a[b++]!=f)break;for(e++;f=a[b++],0!=(f&128););}return e};jspb.utils.countFixedFields_=function(a,b,c,d,e){var f=0;if(128>d)for(;b<c&&a[b++]==d;)f++,b+=e;else for(;b<c;){for(var g=d;128<g;){if(a[b++]!=(g&127|128))return f;g>>=7}if(a[b++]!=g)break;f++;b+=e}return f};
jspb.utils.countFixed32Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED32,4)};jspb.utils.countFixed64Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED64,8)};
jspb.utils.countDelimitedFields=function(a,b,c,d){var e=0;for(d=8*d+jspb.BinaryConstants.WireType.DELIMITED;b<c;){for(var f=d;128<f;){if(a[b++]!=(f&127|128))return e;f>>=7}if(a[b++]!=f)break;e++;for(var g=0,h=1;f=a[b++],g+=(f&127)*h,h*=128,0!=(f&128););b+=g}return e};jspb.utils.debugBytesToTextFormat=function(a){var b='"';if(a){a=jspb.utils.byteSourceToUint8Array(a);for(var c=0;c<a.length;c++)b+="\\x",16>a[c]&&(b+="0"),b+=a[c].toString(16)}return b+'"'};
jspb.utils.debugScalarToTextFormat=function(a){return"string"===typeof a?goog.string.quote(a):a.toString()};jspb.utils.stringToByteArray=function(a){for(var b=new Uint8Array(a.length),c=0;c<a.length;c++){var d=a.charCodeAt(c);if(255<d)throw Error("Conversion error: string contains codepoint outside of byte range");b[c]=d}return b};
jspb.utils.byteSourceToUint8Array=function(a){if(a.constructor===Uint8Array)return a;if(a.constructor===ArrayBuffer||"undefined"!=typeof Buffer&&a.constructor===Buffer||a.constructor===Array)return new Uint8Array(a);if(a.constructor===String)return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Type not convertible to Uint8Array.");return new Uint8Array(0)};jspb.BinaryDecoder=function(a,b,c){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1;a&&this.setBlock(a,b,c)};jspb.BinaryDecoder.instanceCache_=[];jspb.BinaryDecoder.alloc=function(a,b,c){if(jspb.BinaryDecoder.instanceCache_.length){var d=jspb.BinaryDecoder.instanceCache_.pop();a&&d.setBlock(a,b,c);return d}return new jspb.BinaryDecoder(a,b,c)};jspb.BinaryDecoder.prototype.free=function(){this.clear();100>jspb.BinaryDecoder.instanceCache_.length&&jspb.BinaryDecoder.instanceCache_.push(this)};
jspb.BinaryDecoder.prototype.clone=function(){return jspb.BinaryDecoder.alloc(this.bytes_,this.start_,this.end_-this.start_)};jspb.BinaryDecoder.prototype.clear=function(){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1};jspb.BinaryDecoder.prototype.getBuffer=function(){return this.bytes_};
jspb.BinaryDecoder.prototype.setBlock=function(a,b,c){this.bytes_=jspb.utils.byteSourceToUint8Array(a);this.start_=void 0!==b?b:0;this.end_=void 0!==c?this.start_+c:this.bytes_.length;this.cursor_=this.start_};jspb.BinaryDecoder.prototype.getEnd=function(){return this.end_};jspb.BinaryDecoder.prototype.setEnd=function(a){this.end_=a};jspb.BinaryDecoder.prototype.reset=function(){this.cursor_=this.start_};jspb.BinaryDecoder.prototype.getCursor=function(){return this.cursor_};
jspb.BinaryDecoder.prototype.setCursor=function(a){this.cursor_=a};jspb.BinaryDecoder.prototype.advance=function(a){this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_)};jspb.BinaryDecoder.prototype.atEnd=function(){return this.cursor_==this.end_};jspb.BinaryDecoder.prototype.pastEnd=function(){return this.cursor_>this.end_};jspb.BinaryDecoder.prototype.getError=function(){return this.error_||0>this.cursor_||this.cursor_>this.end_};
jspb.BinaryDecoder.prototype.readSplitVarint64=function(a){for(var b=128,c=0,d=0,e=0;4>e&&128<=b;e++)b=this.bytes_[this.cursor_++],c|=(b&127)<<7*e;128<=b&&(b=this.bytes_[this.cursor_++],c|=(b&127)<<28,d|=(b&127)>>4);if(128<=b)for(e=0;5>e&&128<=b;e++)b=this.bytes_[this.cursor_++],d|=(b&127)<<7*e+3;if(128>b)return a(c>>>0,d>>>0);goog.asserts.fail("Failed to read varint, encoding is invalid.");this.error_=!0};
jspb.BinaryDecoder.prototype.readSplitZigzagVarint64=function(a){return this.readSplitVarint64(function(b,c){return jspb.utils.fromZigzag64(b,c,a)})};jspb.BinaryDecoder.prototype.readSplitFixed64=function(a){var b=this.bytes_,c=this.cursor_;this.cursor_+=8;for(var d=0,e=0,f=c+7;f>=c;f--)d=d<<8|b[f],e=e<<8|b[f+4];return a(d,e)};jspb.BinaryDecoder.prototype.skipVarint=function(){for(;this.bytes_[this.cursor_]&128;)this.cursor_++;this.cursor_++};
jspb.BinaryDecoder.prototype.unskipVarint=function(a){for(;128<a;)this.cursor_--,a>>>=7;this.cursor_--};
jspb.BinaryDecoder.prototype.readUnsignedVarint32=function(){var a=this.bytes_;var b=a[this.cursor_+0];var c=b&127;if(128>b)return this.cursor_+=1,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+1];c|=(b&127)<<7;if(128>b)return this.cursor_+=2,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+2];c|=(b&127)<<14;if(128>b)return this.cursor_+=3,goog.asserts.assert(this.cursor_<=this.end_),c;b=a[this.cursor_+3];c|=(b&127)<<21;if(128>b)return this.cursor_+=4,goog.asserts.assert(this.cursor_<=
this.end_),c;b=a[this.cursor_+4];c|=(b&15)<<28;if(128>b)return this.cursor_+=5,goog.asserts.assert(this.cursor_<=this.end_),c>>>0;this.cursor_+=5;128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&128<=a[this.cursor_++]&&goog.asserts.assert(!1);goog.asserts.assert(this.cursor_<=this.end_);return c};jspb.BinaryDecoder.prototype.readSignedVarint32=jspb.BinaryDecoder.prototype.readUnsignedVarint32;jspb.BinaryDecoder.prototype.readUnsignedVarint32String=function(){return this.readUnsignedVarint32().toString()};
jspb.BinaryDecoder.prototype.readSignedVarint32String=function(){return this.readSignedVarint32().toString()};jspb.BinaryDecoder.prototype.readZigzagVarint32=function(){var a=this.readUnsignedVarint32();return a>>>1^-(a&1)};jspb.BinaryDecoder.prototype.readUnsignedVarint64=function(){return this.readSplitVarint64(jspb.utils.joinUint64)};jspb.BinaryDecoder.prototype.readUnsignedVarint64String=function(){return this.readSplitVarint64(jspb.utils.joinUnsignedDecimalString)};
jspb.BinaryDecoder.prototype.readSignedVarint64=function(){return this.readSplitVarint64(jspb.utils.joinInt64)};jspb.BinaryDecoder.prototype.readSignedVarint64String=function(){return this.readSplitVarint64(jspb.utils.joinSignedDecimalString)};jspb.BinaryDecoder.prototype.readZigzagVarint64=function(){return this.readSplitVarint64(jspb.utils.joinZigzag64)};jspb.BinaryDecoder.prototype.readZigzagVarintHash64=function(){return this.readSplitZigzagVarint64(jspb.utils.joinHash64)};
jspb.BinaryDecoder.prototype.readZigzagVarint64String=function(){return this.readSplitZigzagVarint64(jspb.utils.joinSignedDecimalString)};jspb.BinaryDecoder.prototype.readUint8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a};jspb.BinaryDecoder.prototype.readUint16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8};
jspb.BinaryDecoder.prototype.readUint32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return(a<<0|b<<8|c<<16|d<<24)>>>0};jspb.BinaryDecoder.prototype.readUint64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUint64(a,b)};
jspb.BinaryDecoder.prototype.readUint64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUnsignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readInt8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a<<24>>24};
jspb.BinaryDecoder.prototype.readInt16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return(a<<0|b<<8)<<16>>16};jspb.BinaryDecoder.prototype.readInt32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8|c<<16|d<<24};
jspb.BinaryDecoder.prototype.readInt64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinInt64(a,b)};jspb.BinaryDecoder.prototype.readInt64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinSignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readFloat=function(){var a=this.readUint32();return jspb.utils.joinFloat32(a,0)};
jspb.BinaryDecoder.prototype.readDouble=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinFloat64(a,b)};jspb.BinaryDecoder.prototype.readBool=function(){return!!this.bytes_[this.cursor_++]};jspb.BinaryDecoder.prototype.readEnum=function(){return this.readSignedVarint32()};
jspb.BinaryDecoder.prototype.readString=function(a){var b=this.bytes_,c=this.cursor_;a=c+a;for(var d=[],e="";c<a;){var f=b[c++];if(128>f)d.push(f);else if(192>f)continue;else if(224>f){var g=b[c++];d.push((f&31)<<6|g&63)}else if(240>f){g=b[c++];var h=b[c++];d.push((f&15)<<12|(g&63)<<6|h&63)}else if(248>f){g=b[c++];h=b[c++];var k=b[c++];f=(f&7)<<18|(g&63)<<12|(h&63)<<6|k&63;f-=65536;d.push((f>>10&1023)+55296,(f&1023)+56320)}8192<=d.length&&(e+=String.fromCharCode.apply(null,d),d.length=0)}e+=goog.crypt.byteArrayToString(d);
this.cursor_=c;return e};jspb.BinaryDecoder.prototype.readStringWithLength=function(){var a=this.readUnsignedVarint32();return this.readString(a)};jspb.BinaryDecoder.prototype.readBytes=function(a){if(0>a||this.cursor_+a>this.bytes_.length)return this.error_=!0,goog.asserts.fail("Invalid byte length!"),new Uint8Array(0);var b=this.bytes_.subarray(this.cursor_,this.cursor_+a);this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_);return b};jspb.BinaryDecoder.prototype.readVarintHash64=function(){return this.readSplitVarint64(jspb.utils.joinHash64)};
jspb.BinaryDecoder.prototype.readFixedHash64=function(){var a=this.bytes_,b=this.cursor_,c=a[b+0],d=a[b+1],e=a[b+2],f=a[b+3],g=a[b+4],h=a[b+5],k=a[b+6];a=a[b+7];this.cursor_+=8;return String.fromCharCode(c,d,e,f,g,h,k,a)};jspb.BinaryReader=function(a,b,c){this.decoder_=jspb.BinaryDecoder.alloc(a,b,c);this.fieldCursor_=this.decoder_.getCursor();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null};jspb.BinaryReader.instanceCache_=[];
jspb.BinaryReader.alloc=function(a,b,c){if(jspb.BinaryReader.instanceCache_.length){var d=jspb.BinaryReader.instanceCache_.pop();a&&d.decoder_.setBlock(a,b,c);return d}return new jspb.BinaryReader(a,b,c)};jspb.BinaryReader.prototype.alloc=jspb.BinaryReader.alloc;
jspb.BinaryReader.prototype.free=function(){this.decoder_.clear();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;100>jspb.BinaryReader.instanceCache_.length&&jspb.BinaryReader.instanceCache_.push(this)};jspb.BinaryReader.prototype.getFieldCursor=function(){return this.fieldCursor_};jspb.BinaryReader.prototype.getCursor=function(){return this.decoder_.getCursor()};
jspb.BinaryReader.prototype.getBuffer=function(){return this.decoder_.getBuffer()};jspb.BinaryReader.prototype.getFieldNumber=function(){return this.nextField_};jspb.BinaryReader.prototype.getWireType=function(){return this.nextWireType_};jspb.BinaryReader.prototype.isEndGroup=function(){return this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP};jspb.BinaryReader.prototype.getError=function(){return this.error_||this.decoder_.getError()};
jspb.BinaryReader.prototype.setBlock=function(a,b,c){this.decoder_.setBlock(a,b,c);this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID};jspb.BinaryReader.prototype.reset=function(){this.decoder_.reset();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID};jspb.BinaryReader.prototype.advance=function(a){this.decoder_.advance(a)};
jspb.BinaryReader.prototype.nextField=function(){if(this.decoder_.atEnd())return!1;if(this.getError())return goog.asserts.fail("Decoder hit an error"),!1;this.fieldCursor_=this.decoder_.getCursor();var a=this.decoder_.readUnsignedVarint32(),b=a>>>3;a&=7;if(a!=jspb.BinaryConstants.WireType.VARINT&&a!=jspb.BinaryConstants.WireType.FIXED32&&a!=jspb.BinaryConstants.WireType.FIXED64&&a!=jspb.BinaryConstants.WireType.DELIMITED&&a!=jspb.BinaryConstants.WireType.START_GROUP&&a!=jspb.BinaryConstants.WireType.END_GROUP)return goog.asserts.fail("Invalid wire type: %s (at position %s)",
a,this.fieldCursor_),this.error_=!0,!1;this.nextField_=b;this.nextWireType_=a;return!0};jspb.BinaryReader.prototype.unskipHeader=function(){this.decoder_.unskipVarint(this.nextField_<<3|this.nextWireType_)};jspb.BinaryReader.prototype.skipMatchingFields=function(){var a=this.nextField_;for(this.unskipHeader();this.nextField()&&this.getFieldNumber()==a;)this.skipField();this.decoder_.atEnd()||this.unskipHeader()};
jspb.BinaryReader.prototype.skipVarintField=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.VARINT?(goog.asserts.fail("Invalid wire type for skipVarintField"),this.skipField()):this.decoder_.skipVarint()};jspb.BinaryReader.prototype.skipDelimitedField=function(){if(this.nextWireType_!=jspb.BinaryConstants.WireType.DELIMITED)goog.asserts.fail("Invalid wire type for skipDelimitedField"),this.skipField();else{var a=this.decoder_.readUnsignedVarint32();this.decoder_.advance(a)}};
jspb.BinaryReader.prototype.skipFixed32Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED32?(goog.asserts.fail("Invalid wire type for skipFixed32Field"),this.skipField()):this.decoder_.advance(4)};jspb.BinaryReader.prototype.skipFixed64Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED64?(goog.asserts.fail("Invalid wire type for skipFixed64Field"),this.skipField()):this.decoder_.advance(8)};
jspb.BinaryReader.prototype.skipGroup=function(){var a=this.nextField_;do{if(!this.nextField()){goog.asserts.fail("Unmatched start-group tag: stream EOF");this.error_=!0;break}if(this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP){this.nextField_!=a&&(goog.asserts.fail("Unmatched end-group tag"),this.error_=!0);break}this.skipField()}while(1)};
jspb.BinaryReader.prototype.skipField=function(){switch(this.nextWireType_){case jspb.BinaryConstants.WireType.VARINT:this.skipVarintField();break;case jspb.BinaryConstants.WireType.FIXED64:this.skipFixed64Field();break;case jspb.BinaryConstants.WireType.DELIMITED:this.skipDelimitedField();break;case jspb.BinaryConstants.WireType.FIXED32:this.skipFixed32Field();break;case jspb.BinaryConstants.WireType.START_GROUP:this.skipGroup();break;default:goog.asserts.fail("Invalid wire encoding for field.")}};
jspb.BinaryReader.prototype.registerReadCallback=function(a,b){null===this.readCallbacks_&&(this.readCallbacks_={});goog.asserts.assert(!this.readCallbacks_[a]);this.readCallbacks_[a]=b};jspb.BinaryReader.prototype.runReadCallback=function(a){goog.asserts.assert(null!==this.readCallbacks_);a=this.readCallbacks_[a];goog.asserts.assert(a);return a(this)};
jspb.BinaryReader.prototype.readAny=function(a){this.nextWireType_=jspb.BinaryConstants.FieldTypeToWireType(a);var b=jspb.BinaryConstants.FieldType;switch(a){case b.DOUBLE:return this.readDouble();case b.FLOAT:return this.readFloat();case b.INT64:return this.readInt64();case b.UINT64:return this.readUint64();case b.INT32:return this.readInt32();case b.FIXED64:return this.readFixed64();case b.FIXED32:return this.readFixed32();case b.BOOL:return this.readBool();case b.STRING:return this.readString();
case b.GROUP:goog.asserts.fail("Group field type not supported in readAny()");case b.MESSAGE:goog.asserts.fail("Message field type not supported in readAny()");case b.BYTES:return this.readBytes();case b.UINT32:return this.readUint32();case b.ENUM:return this.readEnum();case b.SFIXED32:return this.readSfixed32();case b.SFIXED64:return this.readSfixed64();case b.SINT32:return this.readSint32();case b.SINT64:return this.readSint64();case b.FHASH64:return this.readFixedHash64();case b.VHASH64:return this.readVarintHash64();
default:goog.asserts.fail("Invalid field type in readAny()")}return 0};jspb.BinaryReader.prototype.readMessage=function(a,b){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var c=this.decoder_.getEnd(),d=this.decoder_.readUnsignedVarint32();d=this.decoder_.getCursor()+d;this.decoder_.setEnd(d);b(a,this);this.decoder_.setCursor(d);this.decoder_.setEnd(c)};
jspb.BinaryReader.prototype.readGroup=function(a,b,c){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.START_GROUP);goog.asserts.assert(this.nextField_==a);c(b,this);this.error_||this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP||(goog.asserts.fail("Group submessage did not end with an END_GROUP tag"),this.error_=!0)};
jspb.BinaryReader.prototype.getFieldDecoder=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32(),b=this.decoder_.getCursor(),c=b+a;a=jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(),b,a);this.decoder_.setCursor(c);return a};jspb.BinaryReader.prototype.readInt32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32()};
jspb.BinaryReader.prototype.readInt32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32String()};jspb.BinaryReader.prototype.readInt64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};jspb.BinaryReader.prototype.readInt64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64String()};
jspb.BinaryReader.prototype.readUint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readUint32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32String()};jspb.BinaryReader.prototype.readUint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64()};
jspb.BinaryReader.prototype.readUint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64String()};jspb.BinaryReader.prototype.readSint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint32()};jspb.BinaryReader.prototype.readSint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64()};
jspb.BinaryReader.prototype.readSint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64String()};jspb.BinaryReader.prototype.readFixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readUint32()};jspb.BinaryReader.prototype.readFixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64()};
jspb.BinaryReader.prototype.readFixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64String()};jspb.BinaryReader.prototype.readSfixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32()};jspb.BinaryReader.prototype.readSfixed32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32().toString()};
jspb.BinaryReader.prototype.readSfixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64()};jspb.BinaryReader.prototype.readSfixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64String()};jspb.BinaryReader.prototype.readFloat=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readFloat()};
jspb.BinaryReader.prototype.readDouble=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readDouble()};jspb.BinaryReader.prototype.readBool=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return!!this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readEnum=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};
jspb.BinaryReader.prototype.readString=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readString(a)};jspb.BinaryReader.prototype.readBytes=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readBytes(a)};
jspb.BinaryReader.prototype.readVarintHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readVarintHash64()};jspb.BinaryReader.prototype.readSintHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarintHash64()};jspb.BinaryReader.prototype.readSplitVarint64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSplitVarint64(a)};
jspb.BinaryReader.prototype.readSplitZigzagVarint64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSplitVarint64(function(b,c){return jspb.utils.fromZigzag64(b,c,a)})};jspb.BinaryReader.prototype.readFixedHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readFixedHash64()};
jspb.BinaryReader.prototype.readSplitFixed64=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readSplitFixed64(a)};jspb.BinaryReader.prototype.readPackedField_=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var b=this.decoder_.readUnsignedVarint32();b=this.decoder_.getCursor()+b;for(var c=[];this.decoder_.getCursor()<b;)c.push(a.call(this.decoder_));return c};
jspb.BinaryReader.prototype.readPackedInt32=function(){return this.readPackedField_(this.decoder_.readSignedVarint32)};jspb.BinaryReader.prototype.readPackedInt32String=function(){return this.readPackedField_(this.decoder_.readSignedVarint32String)};jspb.BinaryReader.prototype.readPackedInt64=function(){return this.readPackedField_(this.decoder_.readSignedVarint64)};jspb.BinaryReader.prototype.readPackedInt64String=function(){return this.readPackedField_(this.decoder_.readSignedVarint64String)};
jspb.BinaryReader.prototype.readPackedUint32=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32)};jspb.BinaryReader.prototype.readPackedUint32String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32String)};jspb.BinaryReader.prototype.readPackedUint64=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64)};jspb.BinaryReader.prototype.readPackedUint64String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64String)};
jspb.BinaryReader.prototype.readPackedSint32=function(){return this.readPackedField_(this.decoder_.readZigzagVarint32)};jspb.BinaryReader.prototype.readPackedSint64=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64)};jspb.BinaryReader.prototype.readPackedSint64String=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64String)};jspb.BinaryReader.prototype.readPackedFixed32=function(){return this.readPackedField_(this.decoder_.readUint32)};
jspb.BinaryReader.prototype.readPackedFixed64=function(){return this.readPackedField_(this.decoder_.readUint64)};jspb.BinaryReader.prototype.readPackedFixed64String=function(){return this.readPackedField_(this.decoder_.readUint64String)};jspb.BinaryReader.prototype.readPackedSfixed32=function(){return this.readPackedField_(this.decoder_.readInt32)};jspb.BinaryReader.prototype.readPackedSfixed64=function(){return this.readPackedField_(this.decoder_.readInt64)};
jspb.BinaryReader.prototype.readPackedSfixed64String=function(){return this.readPackedField_(this.decoder_.readInt64String)};jspb.BinaryReader.prototype.readPackedFloat=function(){return this.readPackedField_(this.decoder_.readFloat)};jspb.BinaryReader.prototype.readPackedDouble=function(){return this.readPackedField_(this.decoder_.readDouble)};jspb.BinaryReader.prototype.readPackedBool=function(){return this.readPackedField_(this.decoder_.readBool)};jspb.BinaryReader.prototype.readPackedEnum=function(){return this.readPackedField_(this.decoder_.readEnum)};
jspb.BinaryReader.prototype.readPackedVarintHash64=function(){return this.readPackedField_(this.decoder_.readVarintHash64)};jspb.BinaryReader.prototype.readPackedFixedHash64=function(){return this.readPackedField_(this.decoder_.readFixedHash64)};jspb.Map=function(a,b){this.arr_=a;this.valueCtor_=b;this.map_={};this.arrClean=!0;0<this.arr_.length&&this.loadFromArray_()};jspb.Map.prototype.loadFromArray_=function(){for(var a=0;a<this.arr_.length;a++){var b=this.arr_[a],c=b[0];this.map_[c.toString()]=new jspb.Map.Entry_(c,b[1])}this.arrClean=!0};
jspb.Map.prototype.toArray=function(){if(this.arrClean){if(this.valueCtor_){var a=this.map_,b;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b)){var c=a[b].valueWrapper;c&&c.toArray()}}}else{this.arr_.length=0;a=this.stringKeys_();a.sort();for(b=0;b<a.length;b++){var d=this.map_[a[b]];(c=d.valueWrapper)&&c.toArray();this.arr_.push([d.key,d.value])}this.arrClean=!0}return this.arr_};
jspb.Map.prototype.toObject=function(a,b){for(var c=this.toArray(),d=[],e=0;e<c.length;e++){var f=this.map_[c[e][0].toString()];this.wrapEntry_(f);var g=f.valueWrapper;g?(goog.asserts.assert(b),d.push([f.key,b(a,g)])):d.push([f.key,f.value])}return d};jspb.Map.fromObject=function(a,b,c){b=new jspb.Map([],b);for(var d=0;d<a.length;d++){var e=a[d][0],f=c(a[d][1]);b.set(e,f)}return b};jspb.Map.ArrayIteratorIterable_=function(a){this.idx_=0;this.arr_=a};
jspb.Map.ArrayIteratorIterable_.prototype.next=function(){return this.idx_<this.arr_.length?{done:!1,value:this.arr_[this.idx_++]}:{done:!0,value:void 0}};"undefined"!=typeof Symbol&&(jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator]=function(){return this});jspb.Map.prototype.getLength=function(){return this.stringKeys_().length};jspb.Map.prototype.clear=function(){this.map_={};this.arrClean=!1};
jspb.Map.prototype.del=function(a){a=a.toString();var b=this.map_.hasOwnProperty(a);delete this.map_[a];this.arrClean=!1;return b};jspb.Map.prototype.getEntryList=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,d.value])}return a};jspb.Map.prototype.entries=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,this.wrapEntry_(d)])}return new jspb.Map.ArrayIteratorIterable_(a)};
jspb.Map.prototype.keys=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.map_[b[c]].key);return new jspb.Map.ArrayIteratorIterable_(a)};jspb.Map.prototype.values=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.wrapEntry_(this.map_[b[c]]));return new jspb.Map.ArrayIteratorIterable_(a)};
jspb.Map.prototype.forEach=function(a,b){var c=this.stringKeys_();c.sort();for(var d=0;d<c.length;d++){var e=this.map_[c[d]];a.call(b,this.wrapEntry_(e),e.key,this)}};jspb.Map.prototype.set=function(a,b){var c=new jspb.Map.Entry_(a);this.valueCtor_?(c.valueWrapper=b,c.value=b.toArray()):c.value=b;this.map_[a.toString()]=c;this.arrClean=!1;return this};jspb.Map.prototype.wrapEntry_=function(a){return this.valueCtor_?(a.valueWrapper||(a.valueWrapper=new this.valueCtor_(a.value)),a.valueWrapper):a.value};
jspb.Map.prototype.get=function(a){if(a=this.map_[a.toString()])return this.wrapEntry_(a)};jspb.Map.prototype.has=function(a){return a.toString()in this.map_};jspb.Map.prototype.serializeBinary=function(a,b,c,d,e){var f=this.stringKeys_();f.sort();for(var g=0;g<f.length;g++){var h=this.map_[f[g]];b.beginSubMessage(a);c.call(b,1,h.key);this.valueCtor_?d.call(b,2,this.wrapEntry_(h),e):d.call(b,2,h.value);b.endSubMessage()}};
jspb.Map.deserializeBinary=function(a,b,c,d,e,f,g){for(;b.nextField()&&!b.isEndGroup();){var h=b.getFieldNumber();1==h?f=c.call(b):2==h&&(a.valueCtor_?(goog.asserts.assert(e),g||(g=new a.valueCtor_),d.call(b,g,e)):g=d.call(b))}goog.asserts.assert(void 0!=f);goog.asserts.assert(void 0!=g);a.set(f,g)};jspb.Map.prototype.stringKeys_=function(){var a=this.map_,b=[],c;for(c in a)Object.prototype.hasOwnProperty.call(a,c)&&b.push(c);return b};
jspb.Map.Entry_=function(a,b){this.key=a;this.value=b;this.valueWrapper=void 0};jspb.ExtensionFieldInfo=function(a,b,c,d,e){this.fieldIndex=a;this.fieldName=b;this.ctor=c;this.toObjectFn=d;this.isRepeated=e};jspb.ExtensionFieldBinaryInfo=function(a,b,c,d,e,f){this.fieldInfo=a;this.binaryReaderFn=b;this.binaryWriterFn=c;this.binaryMessageSerializeFn=d;this.binaryMessageDeserializeFn=e;this.isPacked=f};jspb.ExtensionFieldInfo.prototype.isMessageType=function(){return!!this.ctor};jspb.Message=function(){};jspb.Message.GENERATE_TO_OBJECT=!0;jspb.Message.GENERATE_FROM_OBJECT=!goog.DISALLOW_TEST_ONLY_CODE;
jspb.Message.GENERATE_TO_STRING=!0;jspb.Message.ASSUME_LOCAL_ARRAYS=!1;jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS=!0;jspb.Message.SUPPORTS_UINT8ARRAY_="function"==typeof Uint8Array;jspb.Message.prototype.getJsPbMessageId=function(){return this.messageId_};jspb.Message.getIndex_=function(a,b){return b+a.arrayIndexOffset_};jspb.Message.hiddenES6Property_=function(){};jspb.Message.getFieldNumber_=function(a,b){return b-a.arrayIndexOffset_};
jspb.Message.initialize=function(a,b,c,d,e,f){a.wrappers_=null;b||(b=c?[c]:[]);a.messageId_=c?String(c):void 0;a.arrayIndexOffset_=0===c?-1:0;a.array=b;jspb.Message.initPivotAndExtensionObject_(a,d);a.convertedPrimitiveFields_={};jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS||(a.repeatedFields=e);if(e)for(b=0;b<e.length;b++)c=e[b],c<a.pivot_?(c=jspb.Message.getIndex_(a,c),a.array[c]=a.array[c]||jspb.Message.EMPTY_LIST_SENTINEL_):(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[c]=
a.extensionObject_[c]||jspb.Message.EMPTY_LIST_SENTINEL_);if(f&&f.length)for(b=0;b<f.length;b++)jspb.Message.computeOneofCase(a,f[b])};jspb.Message.EMPTY_LIST_SENTINEL_=goog.DEBUG&&Object.freeze?Object.freeze([]):[];jspb.Message.isArray_=function(a){return jspb.Message.ASSUME_LOCAL_ARRAYS?a instanceof Array:goog.isArray(a)};jspb.Message.isExtensionObject_=function(a){return null!==a&&"object"==typeof a&&!jspb.Message.isArray_(a)&&!(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)};
jspb.Message.initPivotAndExtensionObject_=function(a,b){var c=a.array.length,d=-1;if(c&&(d=c-1,c=a.array[d],jspb.Message.isExtensionObject_(c))){a.pivot_=jspb.Message.getFieldNumber_(a,d);a.extensionObject_=c;return}-1<b?(a.pivot_=Math.max(b,jspb.Message.getFieldNumber_(a,d+1)),a.extensionObject_=null):a.pivot_=Number.MAX_VALUE};jspb.Message.maybeInitEmptyExtensionObject_=function(a){var b=jspb.Message.getIndex_(a,a.pivot_);a.array[b]||(a.extensionObject_=a.array[b]={})};
jspb.Message.toObjectList=function(a,b,c){for(var d=[],e=0;e<a.length;e++)d[e]=b.call(a[e],c,a[e]);return d};jspb.Message.toObjectExtension=function(a,b,c,d,e){for(var f in c){var g=c[f],h=d.call(a,g);if(null!=h){for(var k in g.fieldName)if(g.fieldName.hasOwnProperty(k))break;b[k]=g.toObjectFn?g.isRepeated?jspb.Message.toObjectList(h,g.toObjectFn,e):g.toObjectFn(e,h):h}}};
jspb.Message.serializeBinaryExtensions=function(a,b,c,d){for(var e in c){var f=c[e],g=f.fieldInfo;if(!f.binaryWriterFn)throw Error("Message extension present that was generated without binary serialization support");var h=d.call(a,g);if(null!=h)if(g.isMessageType())if(f.binaryMessageSerializeFn)f.binaryWriterFn.call(b,g.fieldIndex,h,f.binaryMessageSerializeFn);else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
else f.binaryWriterFn.call(b,g.fieldIndex,h)}};jspb.Message.readBinaryExtension=function(a,b,c,d,e){var f=c[b.getFieldNumber()];if(f){c=f.fieldInfo;if(!f.binaryReaderFn)throw Error("Deserializing extension whose generated code does not support binary format");if(c.isMessageType()){var g=new c.ctor;f.binaryReaderFn.call(b,g,f.binaryMessageDeserializeFn)}else g=f.binaryReaderFn.call(b);c.isRepeated&&!f.isPacked?(b=d.call(a,c))?b.push(g):e.call(a,c,[g]):e.call(a,c,g)}else b.skipField()};
jspb.Message.getField=function(a,b){if(b<a.pivot_){b=jspb.Message.getIndex_(a,b);var c=a.array[b];return c===jspb.Message.EMPTY_LIST_SENTINEL_?a.array[b]=[]:c}if(a.extensionObject_)return c=a.extensionObject_[b],c===jspb.Message.EMPTY_LIST_SENTINEL_?a.extensionObject_[b]=[]:c};jspb.Message.getRepeatedField=function(a,b){return jspb.Message.getField(a,b)};jspb.Message.getOptionalFloatingPointField=function(a,b){a=jspb.Message.getField(a,b);return null==a?a:+a};
jspb.Message.getBooleanField=function(a,b){a=jspb.Message.getField(a,b);return null==a?a:!!a};jspb.Message.getRepeatedFloatingPointField=function(a,b){var c=jspb.Message.getRepeatedField(a,b);a.convertedPrimitiveFields_||(a.convertedPrimitiveFields_={});if(!a.convertedPrimitiveFields_[b]){for(var d=0;d<c.length;d++)c[d]=+c[d];a.convertedPrimitiveFields_[b]=!0}return c};
jspb.Message.getRepeatedBooleanField=function(a,b){var c=jspb.Message.getRepeatedField(a,b);a.convertedPrimitiveFields_||(a.convertedPrimitiveFields_={});if(!a.convertedPrimitiveFields_[b]){for(var d=0;d<c.length;d++)c[d]=!!c[d];a.convertedPrimitiveFields_[b]=!0}return c};
jspb.Message.bytesAsB64=function(a){if(null==a||"string"===typeof a)return a;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return goog.crypt.base64.encodeByteArray(a);goog.asserts.fail("Cannot coerce to b64 string: "+goog.typeOf(a));return null};jspb.Message.bytesAsU8=function(a){if(null==a||a instanceof Uint8Array)return a;if("string"===typeof a)return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Cannot coerce to Uint8Array: "+goog.typeOf(a));return null};
jspb.Message.bytesListAsB64=function(a){jspb.Message.assertConsistentTypes_(a);return a.length&&"string"!==typeof a[0]?goog.array.map(a,jspb.Message.bytesAsB64):a};jspb.Message.bytesListAsU8=function(a){jspb.Message.assertConsistentTypes_(a);return!a.length||a[0]instanceof Uint8Array?a:goog.array.map(a,jspb.Message.bytesAsU8)};
jspb.Message.assertConsistentTypes_=function(a){if(goog.DEBUG&&a&&1<a.length){var b=goog.typeOf(a[0]);goog.array.forEach(a,function(a){goog.typeOf(a)!=b&&goog.asserts.fail("Inconsistent type in JSPB repeated field array. Got "+goog.typeOf(a)+" expected "+b)})}};jspb.Message.getFieldWithDefault=function(a,b,c){a=jspb.Message.getField(a,b);return null==a?c:a};jspb.Message.getBooleanFieldWithDefault=function(a,b,c){a=jspb.Message.getBooleanField(a,b);return null==a?c:a};
jspb.Message.getFloatingPointFieldWithDefault=function(a,b,c){a=jspb.Message.getOptionalFloatingPointField(a,b);return null==a?c:a};jspb.Message.getFieldProto3=jspb.Message.getFieldWithDefault;jspb.Message.getMapField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(b in a.wrappers_)return a.wrappers_[b];var e=jspb.Message.getField(a,b);if(!e){if(c)return;e=[];jspb.Message.setField(a,b,e)}return a.wrappers_[b]=new jspb.Map(e,d)};
jspb.Message.setField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);b<a.pivot_?a.array[jspb.Message.getIndex_(a,b)]=c:(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[b]=c);return a};jspb.Message.setProto3IntField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};jspb.Message.setProto3FloatField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};
jspb.Message.setProto3BooleanField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,!1)};jspb.Message.setProto3StringField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"")};jspb.Message.setProto3BytesField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"")};jspb.Message.setProto3EnumField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,0)};
jspb.Message.setProto3StringIntField=function(a,b,c){return jspb.Message.setFieldIgnoringDefault_(a,b,c,"0")};jspb.Message.setFieldIgnoringDefault_=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);c!==d?jspb.Message.setField(a,b,c):b<a.pivot_?a.array[jspb.Message.getIndex_(a,b)]=null:(jspb.Message.maybeInitEmptyExtensionObject_(a),delete a.extensionObject_[b]);return a};
jspb.Message.addToRepeatedField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);b=jspb.Message.getRepeatedField(a,b);void 0!=d?b.splice(d,0,c):b.push(c);return a};jspb.Message.setOneofField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);(c=jspb.Message.computeOneofCase(a,c))&&c!==b&&void 0!==d&&(a.wrappers_&&c in a.wrappers_&&(a.wrappers_[c]=void 0),jspb.Message.setField(a,c,void 0));return jspb.Message.setField(a,b,d)};
jspb.Message.computeOneofCase=function(a,b){for(var c,d,e=0;e<b.length;e++){var f=b[e],g=jspb.Message.getField(a,f);null!=g&&(c=f,d=g,jspb.Message.setField(a,f,void 0))}return c?(jspb.Message.setField(a,c,d),c):0};jspb.Message.getWrapperField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){var e=jspb.Message.getField(a,c);if(d||e)a.wrappers_[c]=new b(e)}return a.wrappers_[c]};
jspb.Message.getRepeatedWrapperField=function(a,b,c){jspb.Message.wrapRepeatedField_(a,b,c);b=a.wrappers_[c];b==jspb.Message.EMPTY_LIST_SENTINEL_&&(b=a.wrappers_[c]=[]);return b};jspb.Message.wrapRepeatedField_=function(a,b,c){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){for(var d=jspb.Message.getRepeatedField(a,c),e=[],f=0;f<d.length;f++)e[f]=new b(d[f]);a.wrappers_[c]=e}};
jspb.Message.setWrapperField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});var d=c?c.toArray():c;a.wrappers_[b]=c;return jspb.Message.setField(a,b,d)};jspb.Message.setOneofWrapperField=function(a,b,c,d){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});var e=d?d.toArray():d;a.wrappers_[b]=d;return jspb.Message.setOneofField(a,b,c,e)};
jspb.Message.setRepeatedWrapperField=function(a,b,c){goog.asserts.assertInstanceof(a,jspb.Message);a.wrappers_||(a.wrappers_={});c=c||[];for(var d=[],e=0;e<c.length;e++)d[e]=c[e].toArray();a.wrappers_[b]=c;return jspb.Message.setField(a,b,d)};
jspb.Message.addToRepeatedWrapperField=function(a,b,c,d,e){jspb.Message.wrapRepeatedField_(a,d,b);var f=a.wrappers_[b];f||(f=a.wrappers_[b]=[]);c=c?c:new d;a=jspb.Message.getRepeatedField(a,b);void 0!=e?(f.splice(e,0,c),a.splice(e,0,c.toArray())):(f.push(c),a.push(c.toArray()));return c};jspb.Message.toMap=function(a,b,c,d){for(var e={},f=0;f<a.length;f++)e[b.call(a[f])]=c?c.call(a[f],d,a[f]):a[f];return e};
jspb.Message.prototype.syncMapFields_=function(){if(this.wrappers_)for(var a in this.wrappers_){var b=this.wrappers_[a];if(goog.isArray(b))for(var c=0;c<b.length;c++)b[c]&&b[c].toArray();else b&&b.toArray()}};jspb.Message.prototype.toArray=function(){this.syncMapFields_();return this.array};jspb.Message.GENERATE_TO_STRING&&(jspb.Message.prototype.toString=function(){this.syncMapFields_();return this.array.toString()});
jspb.Message.prototype.getExtension=function(a){if(this.extensionObject_){this.wrappers_||(this.wrappers_={});var b=a.fieldIndex;if(a.isRepeated){if(a.isMessageType())return this.wrappers_[b]||(this.wrappers_[b]=goog.array.map(this.extensionObject_[b]||[],function(b){return new a.ctor(b)})),this.wrappers_[b]}else if(a.isMessageType())return!this.wrappers_[b]&&this.extensionObject_[b]&&(this.wrappers_[b]=new a.ctor(this.extensionObject_[b])),this.wrappers_[b];return this.extensionObject_[b]}};
jspb.Message.prototype.setExtension=function(a,b){this.wrappers_||(this.wrappers_={});jspb.Message.maybeInitEmptyExtensionObject_(this);var c=a.fieldIndex;a.isRepeated?(b=b||[],a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=goog.array.map(b,function(a){return a.toArray()})):this.extensionObject_[c]=b):a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=b?b.toArray():b):this.extensionObject_[c]=b;return this};
jspb.Message.difference=function(a,b){if(!(a instanceof b.constructor))throw Error("Messages have different types.");var c=a.toArray();b=b.toArray();var d=[],e=0,f=c.length>b.length?c.length:b.length;a.getJsPbMessageId()&&(d[0]=a.getJsPbMessageId(),e=1);for(;e<f;e++)jspb.Message.compareFields(c[e],b[e])||(d[e]=b[e]);return new a.constructor(d)};jspb.Message.equals=function(a,b){return a==b||!(!a||!b)&&a instanceof b.constructor&&jspb.Message.compareFields(a.toArray(),b.toArray())};
jspb.Message.compareExtensions=function(a,b){a=a||{};b=b||{};var c={},d;for(d in a)c[d]=0;for(d in b)c[d]=0;for(d in c)if(!jspb.Message.compareFields(a[d],b[d]))return!1;return!0};
jspb.Message.compareFields=function(a,b){if(a==b)return!0;if(!goog.isObject(a)||!goog.isObject(b))return"number"===typeof a&&isNaN(a)||"number"===typeof b&&isNaN(b)?String(a)==String(b):!1;if(a.constructor!=b.constructor)return!1;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a.constructor===Uint8Array){if(a.length!=b.length)return!1;for(var c=0;c<a.length;c++)if(a[c]!=b[c])return!1;return!0}if(a.constructor===Array){var d=void 0,e=void 0,f=Math.max(a.length,b.length);for(c=0;c<f;c++){var g=a[c],h=b[c];g&&
g.constructor==Object&&(goog.asserts.assert(void 0===d),goog.asserts.assert(c===a.length-1),d=g,g=void 0);h&&h.constructor==Object&&(goog.asserts.assert(void 0===e),goog.asserts.assert(c===b.length-1),e=h,h=void 0);if(!jspb.Message.compareFields(g,h))return!1}return d||e?(d=d||{},e=e||{},jspb.Message.compareExtensions(d,e)):!0}if(a.constructor===Object)return jspb.Message.compareExtensions(a,b);throw Error("Invalid type in JSPB array");};jspb.Message.prototype.cloneMessage=function(){return jspb.Message.cloneMessage(this)};
jspb.Message.prototype.clone=function(){return jspb.Message.cloneMessage(this)};jspb.Message.clone=function(a){return jspb.Message.cloneMessage(a)};jspb.Message.cloneMessage=function(a){return new a.constructor(jspb.Message.clone_(a.toArray()))};
jspb.Message.copyInto=function(a,b){goog.asserts.assertInstanceof(a,jspb.Message);goog.asserts.assertInstanceof(b,jspb.Message);goog.asserts.assert(a.constructor==b.constructor,"Copy source and target message should have the same type.");a=jspb.Message.clone(a);for(var c=b.toArray(),d=a.toArray(),e=c.length=0;e<d.length;e++)c[e]=d[e];b.wrappers_=a.wrappers_;b.extensionObject_=a.extensionObject_};
jspb.Message.clone_=function(a){if(goog.isArray(a)){for(var b=Array(a.length),c=0;c<a.length;c++){var d=a[c];null!=d&&(b[c]="object"==typeof d?jspb.Message.clone_(goog.asserts.assert(d)):d)}return b}if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return new Uint8Array(a);b={};for(c in a)d=a[c],null!=d&&(b[c]="object"==typeof d?jspb.Message.clone_(goog.asserts.assert(d)):d);return b};jspb.Message.registerMessageType=function(a,b){b.messageId=a};jspb.Message.messageSetExtensions={};
jspb.Message.messageSetExtensionsBinary={};jspb.arith={};jspb.arith.UInt64=function(a,b){this.lo=a;this.hi=b};jspb.arith.UInt64.prototype.cmp=function(a){return this.hi<a.hi||this.hi==a.hi&&this.lo<a.lo?-1:this.hi==a.hi&&this.lo==a.lo?0:1};jspb.arith.UInt64.prototype.rightShift=function(){return new jspb.arith.UInt64((this.lo>>>1|(this.hi&1)<<31)>>>0,this.hi>>>1>>>0)};jspb.arith.UInt64.prototype.leftShift=function(){return new jspb.arith.UInt64(this.lo<<1>>>0,(this.hi<<1|this.lo>>>31)>>>0)};
jspb.arith.UInt64.prototype.msb=function(){return!!(this.hi&2147483648)};jspb.arith.UInt64.prototype.lsb=function(){return!!(this.lo&1)};jspb.arith.UInt64.prototype.zero=function(){return 0==this.lo&&0==this.hi};jspb.arith.UInt64.prototype.add=function(a){return new jspb.arith.UInt64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};
jspb.arith.UInt64.prototype.sub=function(a){return new jspb.arith.UInt64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.UInt64.mul32x32=function(a,b){var c=a&65535;a>>>=16;var d=b&65535,e=b>>>16;b=c*d+65536*(c*e&65535)+65536*(a*d&65535);for(c=a*e+(c*e>>>16)+(a*d>>>16);4294967296<=b;)b-=4294967296,c+=1;return new jspb.arith.UInt64(b>>>0,c>>>0)};
jspb.arith.UInt64.prototype.mul=function(a){var b=jspb.arith.UInt64.mul32x32(this.lo,a);a=jspb.arith.UInt64.mul32x32(this.hi,a);a.hi=a.lo;a.lo=0;return b.add(a)};
jspb.arith.UInt64.prototype.div=function(a){if(0==a)return[];var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(this.lo,this.hi);a=new jspb.arith.UInt64(a,0);for(var d=new jspb.arith.UInt64(1,0);!a.msb();)a=a.leftShift(),d=d.leftShift();for(;!d.zero();)0>=a.cmp(c)&&(b=b.add(d),c=c.sub(a)),a=a.rightShift(),d=d.rightShift();return[b,c]};jspb.arith.UInt64.prototype.toString=function(){for(var a="",b=this;!b.zero();){b=b.div(10);var c=b[0];a=b[1].lo+a;b=c}""==a&&(a="0");return a};
jspb.arith.UInt64.fromString=function(a){for(var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(0,0),d=0;d<a.length;d++){if("0">a[d]||"9"<a[d])return null;var e=parseInt(a[d],10);c.lo=e;b=b.mul(10).add(c)}return b};jspb.arith.UInt64.prototype.clone=function(){return new jspb.arith.UInt64(this.lo,this.hi)};jspb.arith.Int64=function(a,b){this.lo=a;this.hi=b};
jspb.arith.Int64.prototype.add=function(a){return new jspb.arith.Int64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.sub=function(a){return new jspb.arith.Int64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.clone=function(){return new jspb.arith.Int64(this.lo,this.hi)};
jspb.arith.Int64.prototype.toString=function(){var a=0!=(this.hi&2147483648),b=new jspb.arith.UInt64(this.lo,this.hi);a&&(b=(new jspb.arith.UInt64(0,0)).sub(b));return(a?"-":"")+b.toString()};jspb.arith.Int64.fromString=function(a){var b=0<a.length&&"-"==a[0];b&&(a=a.substring(1));a=jspb.arith.UInt64.fromString(a);if(null===a)return null;b&&(a=(new jspb.arith.UInt64(0,0)).sub(a));return new jspb.arith.Int64(a.lo,a.hi)};jspb.BinaryEncoder=function(){this.buffer_=[]};jspb.BinaryEncoder.prototype.length=function(){return this.buffer_.length};jspb.BinaryEncoder.prototype.end=function(){var a=this.buffer_;this.buffer_=[];return a};
jspb.BinaryEncoder.prototype.writeSplitVarint64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);for(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);0<b||127<a;)this.buffer_.push(a&127|128),a=(a>>>7|b<<25)>>>0,b>>>=7;this.buffer_.push(a)};
jspb.BinaryEncoder.prototype.writeSplitFixed64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);this.writeUint32(a);this.writeUint32(b)};
jspb.BinaryEncoder.prototype.writeUnsignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));for(goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);127<a;)this.buffer_.push(a&127|128),a>>>=7;this.buffer_.push(a)};
jspb.BinaryEncoder.prototype.writeSignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);if(0<=a)this.writeUnsignedVarint32(a);else{for(var b=0;9>b;b++)this.buffer_.push(a&127|128),a>>=7;this.buffer_.push(1)}};
jspb.BinaryEncoder.prototype.writeUnsignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeSignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeZigzagVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeUnsignedVarint32((a<<1^a>>31)>>>0)};jspb.BinaryEncoder.prototype.writeZigzagVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitZigzag64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeZigzagVarint64String=function(a){this.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(a))};jspb.BinaryEncoder.prototype.writeZigzagVarintHash64=function(a){var b=this;jspb.utils.splitHash64(a);jspb.utils.toZigzag64(jspb.utils.split64Low,jspb.utils.split64High,function(a,d){b.writeSplitVarint64(a>>>0,d>>>0)})};
jspb.BinaryEncoder.prototype.writeUint8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&256>a);this.buffer_.push(a>>>0&255)};jspb.BinaryEncoder.prototype.writeUint16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&65536>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255)};
jspb.BinaryEncoder.prototype.writeUint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255)};jspb.BinaryEncoder.prototype.writeUint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitUint64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeInt8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-128<=a&&128>a);this.buffer_.push(a>>>0&255)};jspb.BinaryEncoder.prototype.writeInt16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-32768<=a&&32768>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255)};
jspb.BinaryEncoder.prototype.writeInt32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255)};
jspb.BinaryEncoder.prototype.writeInt64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeInt64String=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(+a>=-jspb.BinaryConstants.TWO_TO_63&&+a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeFloat=function(a){goog.asserts.assert(Infinity===a||-Infinity===a||isNaN(a)||a>=-jspb.BinaryConstants.FLOAT32_MAX&&a<=jspb.BinaryConstants.FLOAT32_MAX);jspb.utils.splitFloat32(a);this.writeUint32(jspb.utils.split64Low)};
jspb.BinaryEncoder.prototype.writeDouble=function(a){goog.asserts.assert(Infinity===a||-Infinity===a||isNaN(a)||a>=-jspb.BinaryConstants.FLOAT64_MAX&&a<=jspb.BinaryConstants.FLOAT64_MAX);jspb.utils.splitFloat64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High)};jspb.BinaryEncoder.prototype.writeBool=function(a){goog.asserts.assert("boolean"===typeof a||"number"===typeof a);this.buffer_.push(a?1:0)};
jspb.BinaryEncoder.prototype.writeEnum=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeSignedVarint32(a)};jspb.BinaryEncoder.prototype.writeBytes=function(a){this.buffer_.push.apply(this.buffer_,a)};jspb.BinaryEncoder.prototype.writeVarintHash64=function(a){jspb.utils.splitHash64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeFixedHash64=function(a){jspb.utils.splitHash64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High)};
jspb.BinaryEncoder.prototype.writeString=function(a){for(var b=this.buffer_.length,c=0;c<a.length;c++){var d=a.charCodeAt(c);if(128>d)this.buffer_.push(d);else if(2048>d)this.buffer_.push(d>>6|192),this.buffer_.push(d&63|128);else if(65536>d)if(55296<=d&&56319>=d&&c+1<a.length){var e=a.charCodeAt(c+1);56320<=e&&57343>=e&&(d=1024*(d-55296)+e-56320+65536,this.buffer_.push(d>>18|240),this.buffer_.push(d>>12&63|128),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128),c++)}else this.buffer_.push(d>>
12|224),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128)}return this.buffer_.length-b};jspb.BinaryWriter=function(){this.blocks_=[];this.totalLength_=0;this.encoder_=new jspb.BinaryEncoder;this.bookmarks_=[]};jspb.BinaryWriter.prototype.appendUint8Array_=function(a){var b=this.encoder_.end();this.blocks_.push(b);this.blocks_.push(a);this.totalLength_+=b.length+a.length};
jspb.BinaryWriter.prototype.beginDelimited_=function(a){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);a=this.encoder_.end();this.blocks_.push(a);this.totalLength_+=a.length;a.push(this.totalLength_);return a};jspb.BinaryWriter.prototype.endDelimited_=function(a){var b=a.pop();b=this.totalLength_+this.encoder_.length()-b;for(goog.asserts.assert(0<=b);127<b;)a.push(b&127|128),b>>>=7,this.totalLength_++;a.push(b);this.totalLength_++};
jspb.BinaryWriter.prototype.writeSerializedMessage=function(a,b,c){this.appendUint8Array_(a.subarray(b,c))};jspb.BinaryWriter.prototype.maybeWriteSerializedMessage=function(a,b,c){null!=a&&null!=b&&null!=c&&this.writeSerializedMessage(a,b,c)};jspb.BinaryWriter.prototype.reset=function(){this.blocks_=[];this.encoder_.end();this.totalLength_=0;this.bookmarks_=[]};
jspb.BinaryWriter.prototype.getResultBuffer=function(){goog.asserts.assert(0==this.bookmarks_.length);for(var a=new Uint8Array(this.totalLength_+this.encoder_.length()),b=this.blocks_,c=b.length,d=0,e=0;e<c;e++){var f=b[e];a.set(f,d);d+=f.length}b=this.encoder_.end();a.set(b,d);d+=b.length;goog.asserts.assert(d==a.length);this.blocks_=[a];return a};jspb.BinaryWriter.prototype.getResultBase64String=function(a){return goog.crypt.base64.encodeByteArray(this.getResultBuffer(),a)};
jspb.BinaryWriter.prototype.beginSubMessage=function(a){this.bookmarks_.push(this.beginDelimited_(a))};jspb.BinaryWriter.prototype.endSubMessage=function(){goog.asserts.assert(0<=this.bookmarks_.length);this.endDelimited_(this.bookmarks_.pop())};jspb.BinaryWriter.prototype.writeFieldHeader_=function(a,b){goog.asserts.assert(1<=a&&a==Math.floor(a));this.encoder_.writeUnsignedVarint32(8*a+b)};
jspb.BinaryWriter.prototype.writeAny=function(a,b,c){var d=jspb.BinaryConstants.FieldType;switch(a){case d.DOUBLE:this.writeDouble(b,c);break;case d.FLOAT:this.writeFloat(b,c);break;case d.INT64:this.writeInt64(b,c);break;case d.UINT64:this.writeUint64(b,c);break;case d.INT32:this.writeInt32(b,c);break;case d.FIXED64:this.writeFixed64(b,c);break;case d.FIXED32:this.writeFixed32(b,c);break;case d.BOOL:this.writeBool(b,c);break;case d.STRING:this.writeString(b,c);break;case d.GROUP:goog.asserts.fail("Group field type not supported in writeAny()");
break;case d.MESSAGE:goog.asserts.fail("Message field type not supported in writeAny()");break;case d.BYTES:this.writeBytes(b,c);break;case d.UINT32:this.writeUint32(b,c);break;case d.ENUM:this.writeEnum(b,c);break;case d.SFIXED32:this.writeSfixed32(b,c);break;case d.SFIXED64:this.writeSfixed64(b,c);break;case d.SINT32:this.writeSint32(b,c);break;case d.SINT64:this.writeSint64(b,c);break;case d.FHASH64:this.writeFixedHash64(b,c);break;case d.VHASH64:this.writeVarintHash64(b,c);break;default:goog.asserts.fail("Invalid field type in writeAny()")}};
jspb.BinaryWriter.prototype.writeUnsignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint32(b))};jspb.BinaryWriter.prototype.writeSignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b))};jspb.BinaryWriter.prototype.writeUnsignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint64(b))};
jspb.BinaryWriter.prototype.writeSignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint64(b))};jspb.BinaryWriter.prototype.writeZigzagVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint32(b))};jspb.BinaryWriter.prototype.writeZigzagVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64(b))};
jspb.BinaryWriter.prototype.writeZigzagVarint64String_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64String(b))};jspb.BinaryWriter.prototype.writeZigzagVarintHash64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarintHash64(b))};
jspb.BinaryWriter.prototype.writeInt32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b))};jspb.BinaryWriter.prototype.writeInt32String=function(a,b){null!=b&&(b=parseInt(b,10),goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b))};
jspb.BinaryWriter.prototype.writeInt64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeSignedVarint64_(a,b))};jspb.BinaryWriter.prototype.writeInt64String=function(a,b){null!=b&&(b=jspb.arith.Int64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSplitVarint64(b.lo,b.hi))};
jspb.BinaryWriter.prototype.writeUint32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b))};jspb.BinaryWriter.prototype.writeUint32String=function(a,b){null!=b&&(b=parseInt(b,10),goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b))};jspb.BinaryWriter.prototype.writeUint64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeUnsignedVarint64_(a,b))};
jspb.BinaryWriter.prototype.writeUint64String=function(a,b){null!=b&&(b=jspb.arith.UInt64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSplitVarint64(b.lo,b.hi))};jspb.BinaryWriter.prototype.writeSint32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeZigzagVarint32_(a,b))};
jspb.BinaryWriter.prototype.writeSint64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeZigzagVarint64_(a,b))};jspb.BinaryWriter.prototype.writeSintHash64=function(a,b){null!=b&&this.writeZigzagVarintHash64_(a,b)};jspb.BinaryWriter.prototype.writeSint64String=function(a,b){null!=b&&this.writeZigzagVarint64String_(a,b)};
jspb.BinaryWriter.prototype.writeFixed32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeUint32(b))};jspb.BinaryWriter.prototype.writeFixed64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeUint64(b))};
jspb.BinaryWriter.prototype.writeFixed64String=function(a,b){null!=b&&(b=jspb.arith.UInt64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeSplitFixed64(b.lo,b.hi))};jspb.BinaryWriter.prototype.writeSfixed32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeInt32(b))};
jspb.BinaryWriter.prototype.writeSfixed64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeInt64(b))};jspb.BinaryWriter.prototype.writeSfixed64String=function(a,b){null!=b&&(b=jspb.arith.Int64.fromString(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeSplitFixed64(b.lo,b.hi))};
jspb.BinaryWriter.prototype.writeFloat=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeFloat(b))};jspb.BinaryWriter.prototype.writeDouble=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeDouble(b))};
jspb.BinaryWriter.prototype.writeBool=function(a,b){null!=b&&(goog.asserts.assert("boolean"===typeof b||"number"===typeof b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeBool(b))};jspb.BinaryWriter.prototype.writeEnum=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b))};
jspb.BinaryWriter.prototype.writeString=function(a,b){null!=b&&(a=this.beginDelimited_(a),this.encoder_.writeString(b),this.endDelimited_(a))};jspb.BinaryWriter.prototype.writeBytes=function(a,b){null!=b&&(b=jspb.utils.byteSourceToUint8Array(b),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(b.length),this.appendUint8Array_(b))};jspb.BinaryWriter.prototype.writeMessage=function(a,b,c){null!=b&&(a=this.beginDelimited_(a),c(b,this),this.endDelimited_(a))};
jspb.BinaryWriter.prototype.writeMessageSet=function(a,b,c){null!=b&&(this.writeFieldHeader_(1,jspb.BinaryConstants.WireType.START_GROUP),this.writeFieldHeader_(2,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(a),a=this.beginDelimited_(3),c(b,this),this.endDelimited_(a),this.writeFieldHeader_(1,jspb.BinaryConstants.WireType.END_GROUP))};
jspb.BinaryWriter.prototype.writeGroup=function(a,b,c){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b,this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP))};jspb.BinaryWriter.prototype.writeFixedHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeFixedHash64(b))};
jspb.BinaryWriter.prototype.writeVarintHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeVarintHash64(b))};jspb.BinaryWriter.prototype.writeSplitFixed64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64);this.encoder_.writeSplitFixed64(b,c)};
jspb.BinaryWriter.prototype.writeSplitVarint64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);this.encoder_.writeSplitVarint64(b,c)};jspb.BinaryWriter.prototype.writeSplitZigzagVarint64=function(a,b,c){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);var d=this.encoder_;jspb.utils.toZigzag64(b,c,function(a,b){d.writeSplitVarint64(a>>>0,b>>>0)})};
jspb.BinaryWriter.prototype.writeRepeatedInt32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint32_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedInt32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt32String(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedInt64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint64_(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedSplitFixed64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitFixed64(a,c(b[e]),d(b[e]))};jspb.BinaryWriter.prototype.writeRepeatedSplitVarint64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitVarint64(a,c(b[e]),d(b[e]))};jspb.BinaryWriter.prototype.writeRepeatedSplitZigzagVarint64=function(a,b,c,d){if(null!=b)for(var e=0;e<b.length;e++)this.writeSplitZigzagVarint64(a,c(b[e]),d(b[e]))};
jspb.BinaryWriter.prototype.writeRepeatedInt64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt64String(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedUint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint32_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedUint32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint32String(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedUint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint64_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedUint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint64String(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint32_(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedSint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64String_(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarintHash64_(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedFixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed32(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedFixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedFixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64String(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedSfixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed32(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSfixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedSfixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64String(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedFloat=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFloat(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedDouble=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeDouble(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedBool=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBool(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedEnum=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeEnum(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedString=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeString(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedBytes=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBytes(a,b[c])};jspb.BinaryWriter.prototype.writeRepeatedMessage=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++){var e=this.beginDelimited_(a);c(b[d],this);this.endDelimited_(e)}};
jspb.BinaryWriter.prototype.writeRepeatedGroup=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++)this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b[d],this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP)};jspb.BinaryWriter.prototype.writeRepeatedFixedHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixedHash64(a,b[c])};
jspb.BinaryWriter.prototype.writeRepeatedVarintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeVarintHash64(a,b[c])};jspb.BinaryWriter.prototype.writePackedInt32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint32(b[c]);this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedInt32String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint32(parseInt(b[c],10));this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedInt64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeSignedVarint64(b[c]);this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedSplitFixed64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=0;e<b.length;e++)this.encoder_.writeSplitFixed64(c(b[e]),d(b[e]));this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedSplitVarint64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=0;e<b.length;e++)this.encoder_.writeSplitVarint64(c(b[e]),d(b[e]));this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedSplitZigzagVarint64=function(a,b,c,d){if(null!=b){a=this.beginDelimited_(a);for(var e=this.encoder_,f=0;f<b.length;f++)jspb.utils.toZigzag64(c(b[f]),d(b[f]),function(a,b){e.writeSplitVarint64(a>>>0,b>>>0)});this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedInt64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++){var d=jspb.arith.Int64.fromString(b[c]);this.encoder_.writeSplitVarint64(d.lo,d.hi)}this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedUint32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint32(b[c]);this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedUint32String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint32(parseInt(b[c],10));this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedUint64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeUnsignedVarint64(b[c]);this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedUint64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++){var d=jspb.arith.UInt64.fromString(b[c]);this.encoder_.writeSplitVarint64(d.lo,d.hi)}this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedSint32=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarint32(b[c]);this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedSint64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarint64(b[c]);this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedSint64String=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(b[c]));this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedSintHash64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeZigzagVarintHash64(b[c]);this.endDelimited_(a)}};
jspb.BinaryWriter.prototype.writePackedFixed32=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeUint32(b[a])};jspb.BinaryWriter.prototype.writePackedFixed64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeUint64(b[a])};
jspb.BinaryWriter.prototype.writePackedFixed64String=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++){var c=jspb.arith.UInt64.fromString(b[a]);this.encoder_.writeSplitFixed64(c.lo,c.hi)}};
jspb.BinaryWriter.prototype.writePackedSfixed32=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeInt32(b[a])};jspb.BinaryWriter.prototype.writePackedSfixed64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeInt64(b[a])};
jspb.BinaryWriter.prototype.writePackedSfixed64String=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeInt64String(b[a])};jspb.BinaryWriter.prototype.writePackedFloat=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(4*b.length),a=0;a<b.length;a++)this.encoder_.writeFloat(b[a])};
jspb.BinaryWriter.prototype.writePackedDouble=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeDouble(b[a])};jspb.BinaryWriter.prototype.writePackedBool=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(b.length),a=0;a<b.length;a++)this.encoder_.writeBool(b[a])};
jspb.BinaryWriter.prototype.writePackedEnum=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeEnum(b[c]);this.endDelimited_(a)}};jspb.BinaryWriter.prototype.writePackedFixedHash64=function(a,b){if(null!=b&&b.length)for(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED),this.encoder_.writeUnsignedVarint32(8*b.length),a=0;a<b.length;a++)this.encoder_.writeFixedHash64(b[a])};
jspb.BinaryWriter.prototype.writePackedVarintHash64=function(a,b){if(null!=b&&b.length){a=this.beginDelimited_(a);for(var c=0;c<b.length;c++)this.encoder_.writeVarintHash64(b[c]);this.endDelimited_(a)}};jspb.Export={};exports.Map=jspb.Map;exports.Message=jspb.Message;exports.BinaryReader=jspb.BinaryReader;exports.BinaryWriter=jspb.BinaryWriter;exports.ExtensionFieldInfo=jspb.ExtensionFieldInfo;exports.ExtensionFieldBinaryInfo=jspb.ExtensionFieldBinaryInfo;exports.exportSymbol=goog.exportSymbol;exports.inherits=goog.inherits;exports.object={extend:goog.object.extend};exports.typeOf=goog.typeOf;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"buffer":3}],69:[function(require,module,exports){
// full library entry point.

"use strict";
module.exports = require("./src/index");

},{"./src/index":78}],70:[function(require,module,exports){
"use strict";
module.exports = common;

var commonRe = /\/|\./;

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 * @returns {undefined}
 * @property {INamespace} google/protobuf/any.proto Any
 * @property {INamespace} google/protobuf/duration.proto Duration
 * @property {INamespace} google/protobuf/empty.proto Empty
 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
 * @example
 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
 * protobuf.common("descriptor", descriptorJson);
 *
 * // manually provides a custom definition (uses my.foo namespace)
 * protobuf.common("my/foo/bar.proto", myFooBarJson);
 */
function common(name, json) {
    if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
}

// Not provided because of limited use (feel free to discuss or to provide yourself):
//
// google/protobuf/descriptor.proto
// google/protobuf/source_context.proto
// google/protobuf/type.proto
//
// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
// the repository or package within the google/protobuf directory.

common("any", {

    /**
     * Properties of a google.protobuf.Any message.
     * @interface IAny
     * @type {Object}
     * @property {string} [typeUrl]
     * @property {Uint8Array} [bytes]
     * @memberof common
     */
    Any: {
        fields: {
            type_url: {
                type: "string",
                id: 1
            },
            value: {
                type: "bytes",
                id: 2
            }
        }
    }
});

var timeType;

common("duration", {

    /**
     * Properties of a google.protobuf.Duration message.
     * @interface IDuration
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Duration: timeType = {
        fields: {
            seconds: {
                type: "int64",
                id: 1
            },
            nanos: {
                type: "int32",
                id: 2
            }
        }
    }
});

common("timestamp", {

    /**
     * Properties of a google.protobuf.Timestamp message.
     * @interface ITimestamp
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Timestamp: timeType
});

common("empty", {

    /**
     * Properties of a google.protobuf.Empty message.
     * @interface IEmpty
     * @memberof common
     */
    Empty: {
        fields: {}
    }
});

common("struct", {

    /**
     * Properties of a google.protobuf.Struct message.
     * @interface IStruct
     * @type {Object}
     * @property {Object.<string,IValue>} [fields]
     * @memberof common
     */
    Struct: {
        fields: {
            fields: {
                keyType: "string",
                type: "Value",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Value message.
     * @interface IValue
     * @type {Object}
     * @property {string} [kind]
     * @property {0} [nullValue]
     * @property {number} [numberValue]
     * @property {string} [stringValue]
     * @property {boolean} [boolValue]
     * @property {IStruct} [structValue]
     * @property {IListValue} [listValue]
     * @memberof common
     */
    Value: {
        oneofs: {
            kind: {
                oneof: [
                    "nullValue",
                    "numberValue",
                    "stringValue",
                    "boolValue",
                    "structValue",
                    "listValue"
                ]
            }
        },
        fields: {
            nullValue: {
                type: "NullValue",
                id: 1
            },
            numberValue: {
                type: "double",
                id: 2
            },
            stringValue: {
                type: "string",
                id: 3
            },
            boolValue: {
                type: "bool",
                id: 4
            },
            structValue: {
                type: "Struct",
                id: 5
            },
            listValue: {
                type: "ListValue",
                id: 6
            }
        }
    },

    NullValue: {
        values: {
            NULL_VALUE: 0
        }
    },

    /**
     * Properties of a google.protobuf.ListValue message.
     * @interface IListValue
     * @type {Object}
     * @property {Array.<IValue>} [values]
     * @memberof common
     */
    ListValue: {
        fields: {
            values: {
                rule: "repeated",
                type: "Value",
                id: 1
            }
        }
    }
});

common("wrappers", {

    /**
     * Properties of a google.protobuf.DoubleValue message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    DoubleValue: {
        fields: {
            value: {
                type: "double",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.FloatValue message.
     * @interface IFloatValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FloatValue: {
        fields: {
            value: {
                type: "float",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int64Value message.
     * @interface IInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    Int64Value: {
        fields: {
            value: {
                type: "int64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt64Value message.
     * @interface IUInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    UInt64Value: {
        fields: {
            value: {
                type: "uint64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int32Value message.
     * @interface IInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    Int32Value: {
        fields: {
            value: {
                type: "int32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt32Value message.
     * @interface IUInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    UInt32Value: {
        fields: {
            value: {
                type: "uint32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BoolValue message.
     * @interface IBoolValue
     * @type {Object}
     * @property {boolean} [value]
     * @memberof common
     */
    BoolValue: {
        fields: {
            value: {
                type: "bool",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.StringValue message.
     * @interface IStringValue
     * @type {Object}
     * @property {string} [value]
     * @memberof common
     */
    StringValue: {
        fields: {
            value: {
                type: "string",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BytesValue message.
     * @interface IBytesValue
     * @type {Object}
     * @property {Uint8Array} [value]
     * @memberof common
     */
    BytesValue: {
        fields: {
            value: {
                type: "bytes",
                id: 1
            }
        }
    }
});

common("field_mask", {

    /**
     * Properties of a google.protobuf.FieldMask message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FieldMask: {
        fields: {
            paths: {
                rule: "repeated",
                type: "string",
                id: 1
            }
        }
    }
});

/**
 * Gets the root definition of the specified common proto file.
 *
 * Bundled definitions are:
 * - google/protobuf/any.proto
 * - google/protobuf/duration.proto
 * - google/protobuf/empty.proto
 * - google/protobuf/field_mask.proto
 * - google/protobuf/struct.proto
 * - google/protobuf/timestamp.proto
 * - google/protobuf/wrappers.proto
 *
 * @param {string} file Proto file name
 * @returns {INamespace|null} Root definition or `null` if not defined
 */
common.get = function get(file) {
    return common[file] || null;
};

},{}],71:[function(require,module,exports){
"use strict";
/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = require("./enum"),
    util = require("./util");

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                if (field.repeated && values[keys[i]] === field.typeDefault) gen
                ("default:");
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) {
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen
        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
        ("else{")
            ("d%s=%s", prop, arrayDefault)
            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
        ("}");
            } else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

},{"./enum":74,"./util":96}],72:[function(require,module,exports){
"use strict";
module.exports = decoder;

var Enum    = require("./enum"),
    types   = require("./types"),
    util    = require("./util");

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k,value" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i:", field.id);

        // Map fields
        if (field.map) { gen
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("var c2 = r.uint32()+r.pos");

            if (types.defaults[field.keyType] !== undefined) gen
                ("k=%j", types.defaults[field.keyType]);
            else gen
                ("k=null");

            if (types.defaults[type] !== undefined) gen
                ("value=%j", types.defaults[type]);
            else gen
                ("value=null");

            gen
                ("while(r.pos<c2){")
                    ("var tag2=r.uint32()")
                    ("switch(tag2>>>3){")
                        ("case 1: k=r.%s(); break", field.keyType)
                        ("case 2:");

            if (types.basic[type] === undefined) gen
                            ("value=types[%i].decode(r,r.uint32())", i); // can't be groups
            else gen
                            ("value=r.%s()", type);

            gen
                            ("break")
                        ("default:")
                            ("r.skipType(tag2&7)")
                            ("break")
                    ("}")
                ("}");

            if (types.long[field.keyType] !== undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);
            else gen
                ("%s[k]=value", ref);

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break");
    // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}

},{"./enum":74,"./types":95,"./util":96}],73:[function(require,module,exports){
"use strict";
module.exports = encoder;

var Enum     = require("./enum"),
    types    = require("./types"),
    util     = require("./util");

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

},{"./enum":74,"./types":95,"./util":96}],74:[function(require,module,exports){
"use strict";
module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = require("./namespace"),
    util = require("./util");

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 */
function Enum(name, values, options, comment, comments) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"  , this.options,
        "values"   , this.values,
        "reserved" , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"  , keepComments ? this.comment : undefined,
        "comments" , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

},{"./namespace":82,"./object":83,"./util":96}],75:[function(require,module,exports){
"use strict";
module.exports = Field;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = require("./enum"),
    types = require("./types"),
    util  = require("./util");

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

// Sets up cyclic dependencies (called in index-light)
Field._configure = function configure(Type_) {
    Type = Type_;
};

},{"./enum":74,"./object":83,"./types":95,"./util":96}],76:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require("./index-minimal");

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = require("./encoder");
protobuf.decoder          = require("./decoder");
protobuf.verifier         = require("./verifier");
protobuf.converter        = require("./converter");

// Reflection
protobuf.ReflectionObject = require("./object");
protobuf.Namespace        = require("./namespace");
protobuf.Root             = require("./root");
protobuf.Enum             = require("./enum");
protobuf.Type             = require("./type");
protobuf.Field            = require("./field");
protobuf.OneOf            = require("./oneof");
protobuf.MapField         = require("./mapfield");
protobuf.Service          = require("./service");
protobuf.Method           = require("./method");

// Runtime
protobuf.Message          = require("./message");
protobuf.wrappers         = require("./wrappers");

// Utility
protobuf.types            = require("./types");
protobuf.util             = require("./util");

// Set up possibly cyclic reflection dependencies
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);

},{"./converter":71,"./decoder":72,"./encoder":73,"./enum":74,"./field":75,"./index-minimal":77,"./mapfield":79,"./message":80,"./method":81,"./namespace":82,"./object":83,"./oneof":84,"./root":88,"./service":92,"./type":94,"./types":95,"./util":96,"./verifier":99,"./wrappers":100}],77:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();

},{"./reader":86,"./reader_buffer":87,"./roots":89,"./rpc":90,"./util/minimal":98,"./writer":101,"./writer_buffer":102}],78:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require("./index-light");

protobuf.build = "full";

// Parser
protobuf.tokenize         = require("./tokenize");
protobuf.parse            = require("./parse");
protobuf.common           = require("./common");

// Configure parser
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);

},{"./common":70,"./index-light":76,"./parse":85,"./tokenize":93}],79:[function(require,module,exports){
"use strict";
module.exports = MapField;

// extends Field
var Field = require("./field");
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = require("./types"),
    util    = require("./util");

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};

},{"./field":75,"./types":95,"./util":96}],80:[function(require,module,exports){
"use strict";
module.exports = Message;

var util = require("./util/minimal");

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object = object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/
},{"./util/minimal":98}],81:[function(require,module,exports){
"use strict";
module.exports = Method;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = require("./util");

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};

},{"./object":83,"./util":96}],82:[function(require,module,exports){
"use strict";
module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Field    = require("./field"),
    util     = require("./util");

var Type,    // cyclic
    Service,
    Enum;

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
 */
// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name]
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

// Sets up cyclic dependencies (called in index-light)
Namespace._configure = function(Type_, Service_, Enum_) {
    Type    = Type_;
    Service = Service_;
    Enum    = Enum_;
};

},{"./field":75,"./object":83,"./util":96}],83:[function(require,module,exports){
"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require("./util");

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Parsed Options.
     * @type {Array.<Object.<string,*>>|undefined}
     */
    this.parsedOptions = null;

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets a parsed option.
 * @param {string} name parsed Option name
 * @param {*} value Option value
 * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
        this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
        // If setting a sub property of an option then try to merge it
        // with an existing option
        var opt = parsedOptions.find(function (opt) {
            return Object.prototype.hasOwnProperty.call(opt, name);
        });
        if (opt) {
            // If we found an existing option - just merge the property value
            var newValue = opt[name];
            util.setProperty(newValue, propName, value);
        } else {
            // otherwise, create a new option, set it's property and add it to the list
            opt = {};
            opt[name] = util.setProperty({}, propName, value);
            parsedOptions.push(opt);
        }
    } else {
        // Always create a new option when setting the value of the option itself
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
    }
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

// Sets up cyclic dependencies (called in index-light)
ReflectionObject._configure = function(Root_) {
    Root = Root_;
};

},{"./util":96}],84:[function(require,module,exports){
"use strict";
module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = require("./object");
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = require("./field"),
    util  = require("./util");

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};

},{"./field":75,"./object":83,"./util":96}],85:[function(require,module,exports){
"use strict";
module.exports = parse;

parse.filename = null;
parse.defaults = { keepCase: false };

var tokenize  = require("./tokenize"),
    Root      = require("./root"),
    Type      = require("./type"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    OneOf     = require("./oneof"),
    Enum      = require("./enum"),
    Service   = require("./service"),
    Method    = require("./method"),
    types     = require("./types"),
    util      = require("./util");

var base10Re    = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re    = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re     = /^0[0-7]+$/,
    base8NegRe  = /^-?0[0-7]+$/,
    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

/**
 * Result object returned from {@link parse}.
 * @interface IParserResult
 * @property {string|undefined} package Package name, if declared
 * @property {string[]|undefined} imports Imports, if any
 * @property {string[]|undefined} weakImports Weak imports, if any
 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
 * @property {Root} root Populated root instance
 */

/**
 * Options modifying the behavior of {@link parse}.
 * @interface IParseOptions
 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
 * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.
 */

/**
 * Options modifying the behavior of JSON serialization.
 * @interface IToJSONOptions
 * @property {boolean} [keepComments=false] Serializes comments.
 */

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param {string} source Source contents
 * @param {Root} root Root to populate
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 */
function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var preferTrailingComment = options.preferTrailingComment || false;
    var tn = tokenize(source, options.alternateCommentMode || false),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        syntax,
        isProto3 = false;

    var ptr = root;

    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" && token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {

            /* istanbul ignore else */
            if (acceptTypeRef && typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
                target.push(readString());
            else
                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
        } while (skip(",", true));
        skip(";");
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative && token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illegal(token, "id");
    }

    function parsePackage() {

        /* istanbul ignore if */
        if (pkg !== undefined)
            throw illegal("package");

        pkg = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");

        ptr = ptr.define(pkg);
        skip(";");
    }

    function parseImport() {
        var token = peek();
        var whichImports;
        switch (token) {
            case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;
            case "public":
                next();
                // eslint-disable-line no-fallthrough
            default:
                whichImports = imports || (imports = []);
                break;
        }
        token = readString();
        skip(";");
        whichImports.push(token);
    }

    function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";

        /* istanbul ignore if */
        if (!isProto3 && syntax !== "proto2")
            throw illegal(syntax, "syntax");

        skip(";");
    }

    function parseCommon(parent, token) {
        switch (token) {

            case "option":
                parseOption(parent, token);
                skip(";");
                return true;

            case "message":
                parseType(parent, token);
                return true;

            case "enum":
                parseEnum(parent, token);
                return true;

            case "service":
                parseService(parent, token);
                return true;

            case "extend":
                parseExtension(parent, token);
                return true;
        }
        return false;
    }

    function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
            if(typeof obj.comment !== "string") {
              obj.comment = cmnt(); // try block-type comment
            }
            obj.filename = parse.filename;
        }
        if (skip("{", true)) {
            var token;
            while ((token = next()) !== "}")
                fnIf(token);
            skip(";", true);
        } else {
            if (fnElse)
                fnElse();
            skip(";");
            if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment
        }
    }

    function parseType(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "type name");

        var type = new Type(token);
        ifBlock(type, function parseType_block(token) {
            if (parseCommon(type, token))
                return;

            switch (token) {

                case "map":
                    parseMapField(type, token);
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                case "oneof":
                    parseOneOf(type, token);
                    break;

                case "extensions":
                    readRanges(type.extensions || (type.extensions = []));
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);

                    push(token);
                    parseField(type, "optional");
                    break;
            }
        });
        parent.add(type);
    }

    function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
            parseGroup(parent, rule);
            return;
        }

        /* istanbul ignore if */
        if (!typeRefRe.test(type))
            throw illegal(type, "type");

        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        name = applyCase(name);
        skip("=");

        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);

        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
        // parsing proto2 descriptors without the option, where applicable. This must be done for
        // all known packable types and anything that could be an enum (= is not a basic type).
        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
            field.setOption("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        var fieldName = util.lcFirst(name);
        if (name === fieldName)
            name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token) {
            switch (token) {

                case "option":
                    parseOption(type, token);
                    skip(";");
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                /* istanbul ignore next */
                default:
                    throw illegal(token); // there are no groups with proto3 semantics
            }
        });
        parent.add(type)
              .add(field);
    }

    function parseMapField(parent) {
        skip("<");
        var keyType = next();

        /* istanbul ignore if */
        if (types.mapKey[keyType] === undefined)
            throw illegal(keyType, "type");

        skip(",");
        var valueType = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");

        skip(">");
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseMapField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);
    }

    function parseOneOf(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var oneof = new OneOf(applyCase(token));
        ifBlock(oneof, function parseOneOf_block(token) {
            if (token === "option") {
                parseOption(oneof, token);
                skip(";");
            } else {
                push(token);
                parseField(oneof, "optional");
            }
        });
        parent.add(oneof);
    }

    function parseEnum(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var enm = new Enum(token);
        ifBlock(enm, function parseEnum_block(token) {
          switch(token) {
            case "option":
              parseOption(enm, token);
              skip(";");
              break;

            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;

            default:
              parseEnumValue(enm, token);
          }
        });
        parent.add(enm);
    }

    function parseEnumValue(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token))
            throw illegal(token, "name");

        skip("=");
        var value = parseId(next(), true),
            dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(dummy, token); // skip
                skip(";");
            } else
                throw illegal(token);

        }, function parseEnumValue_line() {
            parseInlineOptions(dummy); // skip
        });
        parent.add(token, value, dummy.comment);
    }

    function parseOption(parent, token) {
        var isCustom = skip("(", true);

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "name");

        var name = token;
        var option = name;
        var propName;

        if (isCustom) {
            skip(")");
            name = "(" + name + ")";
            option = name;
            token = peek();
            if (fqTypeRefRe.test(token)) {
                propName = token.substr(1); //remove '.' before property name
                name += token;
                next();
            }
        }
        skip("=");
        var optionValue = parseOptionValue(parent, name);
        setParsedOption(parent, option, optionValue, propName);
    }

    function parseOptionValue(parent, name) {
        if (skip("{", true)) { // { a: "foo" b { c: "bar" } }
            var result = {};
            while (!skip("}", true)) {
                /* istanbul ignore if */
                if (!nameRe.test(token = next()))
                    throw illegal(token, "name");

                var value;
                var propName = token;
                if (peek() === "{")
                    value = parseOptionValue(parent, name + "." + token);
                else {
                    skip(":");
                    if (peek() === "{")
                        value = parseOptionValue(parent, name + "." + token);
                    else {
                        value = readValue(true);
                        setOption(parent, name + "." + token, value);
                    }
                }
                var prevValue = result[propName];
                if (prevValue)
                    value = [].concat(prevValue).concat(value);
                result[propName] = value;
                skip(",", true);
            }
            return result;
        }

        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
        // Does not enforce a delimiter to be universal
    }

    function setOption(parent, name, value) {
        if (parent.setOption)
            parent.setOption(name, value);
    }

    function setParsedOption(parent, name, value, propName) {
        if (parent.setParsedOption)
            parent.setParsedOption(name, value, propName);
    }

    function parseInlineOptions(parent) {
        if (skip("[", true)) {
            do {
                parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
        }
        return parent;
    }

    function parseService(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "service name");

        var service = new Service(token);
        ifBlock(service, function parseService_block(token) {
            if (parseCommon(service, token))
                return;

            /* istanbul ignore else */
            if (token === "rpc")
                parseMethod(service, token);
            else
                throw illegal(token);
        });
        parent.add(service);
    }

    function parseMethod(parent, token) {
        // Get the comment of the preceding line now (if one exists) in case the
        // method is defined across multiple lines.
        var commentText = cmnt();

        var type = token;

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var name = token,
            requestType, requestStream,
            responseType, responseStream;

        skip("(");
        if (skip("stream", true))
            requestStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        requestType = token;
        skip(")"); skip("returns"); skip("(");
        if (skip("stream", true))
            responseStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        responseType = token;
        skip(")");

        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(method, token);
                skip(";");
            } else
                throw illegal(token);

        });
        parent.add(method);
    }

    function parseExtension(parent, token) {

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "reference");

        var reference = token;
        ifBlock(null, function parseExtension_block(token) {
            switch (token) {

                case "required":
                case "repeated":
                case "optional":
                    parseField(parent, token, reference);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);
                    push(token);
                    parseField(parent, "optional", reference);
                    break;
            }
        });
    }

    var token;
    while ((token = next()) !== null) {
        switch (token) {

            case "package":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parsePackage();
                break;

            case "import":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseImport();
                break;

            case "syntax":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseSyntax();
                break;

            case "option":

                parseOption(ptr, token);
                skip(";");
                break;

            default:

                /* istanbul ignore else */
                if (parseCommon(ptr, token)) {
                    head = false;
                    continue;
                }

                /* istanbul ignore next */
                throw illegal(token);
        }
    }

    parse.filename = null;
    return {
        "package"     : pkg,
        "imports"     : imports,
         weakImports  : weakImports,
         syntax       : syntax,
         root         : root
    };
}

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @name parse
 * @function
 * @param {string} source Source contents
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 * @variation 2
 */

},{"./enum":74,"./field":75,"./mapfield":79,"./method":81,"./oneof":84,"./root":88,"./service":92,"./tokenize":93,"./type":94,"./types":95,"./util":96}],86:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"./util/minimal":98}],87:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();

},{"./reader":86,"./util/minimal":98}],88:[function(require,module,exports){
"use strict";
module.exports = Root;

// extends Namespace
var Namespace = require("./namespace");
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = require("./field"),
    Enum    = require("./enum"),
    OneOf   = require("./oneof"),
    util    = require("./util");

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

/**
 * Fetch content from file path or url
 * This method exists so you can override it with your own logic.
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.fetch = util.fetch;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
    }

    // Bundled definition existence checking
    function getBundledFileName(filename) {
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common) return altname;
        }
        return null;
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            self.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

// Sets up cyclic dependencies (called in index-light)
Root._configure = function(Type_, parse_, common_) {
    Type   = Type_;
    parse  = parse_;
    common = common_;
};

},{"./enum":74,"./field":75,"./namespace":82,"./oneof":84,"./util":96}],89:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],90:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

},{"./rpc/service":91}],91:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"../util/minimal":98}],92:[function(require,module,exports){
"use strict";
module.exports = Service;

// extends Namespace
var Namespace = require("./namespace");
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = require("./method"),
    util   = require("./util"),
    rpc    = require("./rpc");

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return this.methods[name]
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};

},{"./method":81,"./namespace":82,"./rpc":90,"./util":96}],93:[function(require,module,exports){
"use strict";
module.exports = tokenize;

var delimRe        = /[\s{}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = {
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
};

/**
 * Unescapes a string.
 * @param {string} str String to unescape
 * @returns {string} Unescaped string
 * @property {Object.<string,string>} map Special characters map
 * @memberof tokenize
 */
function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        }
    });
}

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type {function}
 * @param {string} token Token
 * @returns {undefined}
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type {function}
 * @param {string} expected Expected token
 * @param {boolean} [optional=false] If optional
 * @returns {boolean} Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type {function}
 * @param {number} [line] Line number
 * @returns {string|null} Comment text or `null` if none
 */

/**
 * Handle object returned from {@link tokenize}.
 * @interface ITokenizerHandle
 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
 * @property {TokenizerHandlePush} push Pushes a token back to the stack
 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property {number} line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param {string} source Source contents
 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns {ITokenizerHandle} Tokenizer handle
 */
function tokenize(source, alternateCommentMode) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0,
        commentLineEmpty = false,
        commentIsLeading = false;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @param {boolean} isLeading set if a leading comment
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end, isLeading) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        commentIsLeading = isLeading;
        var lookback;
        if (alternateCommentMode) {
            lookback = 2;  // alternate comment parsing: "//" or "/*"
        } else {
            lookback = 3;  // "///" or "/**"
        }
        var commentOffset = start - lookback,
            c;
        do {
            if (--commentOffset < 0 ||
                    (c = source.charAt(commentOffset)) === "\n") {
                commentLineEmpty = true;
                break;
            }
        } while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i]
                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                .trim();
        commentText = lines
            .join("\n")
            .trim();
    }

    function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);

        // see if remaining line matches comment pattern
        var lineText = source.substring(startOffset, endOffset);
        // look for 1 or 2 slashes since startOffset would already point past
        // the first slash that started the comment.
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
    }

    function findEndOfLine(cursor) {
        // find end of cursor's line
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
            endOffset++;
        }
        return endOffset;
    }

    /**
     * Obtains the next token.
     * @returns {string|null} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc,
            isLeadingComment = offset === 0;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n") {
                    isLeadingComment = true;
                    ++line;
                }
                if (++offset === length)
                    return null;
            }

            if (charAt(offset) === "/") {
                if (++offset === length) {
                    throw illegal("comment");
                }
                if (charAt(offset) === "/") { // Line
                    if (!alternateCommentMode) {
                        // check for triple-slash comment
                        isDoc = charAt(start = offset + 1) === "/";

                        while (charAt(++offset) !== "\n") {
                            if (offset === length) {
                                return null;
                            }
                        }
                        ++offset;
                        if (isDoc) {
                            setComment(start, offset - 1, isLeadingComment);
                        }
                        ++line;
                        repeat = true;
                    } else {
                        // check for double-slash comments, consolidating consecutive lines
                        start = offset;
                        isDoc = false;
                        if (isDoubleSlashCommentLine(offset)) {
                            isDoc = true;
                            do {
                                offset = findEndOfLine(offset);
                                if (offset === length) {
                                    break;
                                }
                                offset++;
                            } while (isDoubleSlashCommentLine(offset));
                        } else {
                            offset = Math.min(length, findEndOfLine(offset) + 1);
                        }
                        if (isDoc) {
                            setComment(start, offset, isLeadingComment);
                        }
                        line++;
                        repeat = true;
                    }
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    // check for /** (regular comment mode) or /* (alternate comment mode)
                    start = offset + 1;
                    isDoc = alternateCommentMode || charAt(start) === "*";
                    do {
                        if (curr === "\n") {
                            ++line;
                        }
                        if (++offset === length) {
                            throw illegal("comment");
                        }
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) {
                        setComment(start, offset - 2, isLeadingComment);
                    }
                    repeat = true;
                } else {
                    return "/";
                }
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
    }

    /**
     * Pushes a token back to the stack.
     * @param {string} token Token
     * @returns {undefined}
     * @inner
     */
    function push(token) {
        stack.push(token);
    }

    /**
     * Peeks for the next token.
     * @returns {string|null} Token or `null` on eof
     * @inner
     */
    function peek() {
        if (!stack.length) {
            var token = next();
            if (token === null)
                return null;
            push(token);
        }
        return stack[0];
    }

    /**
     * Skips a token.
     * @param {string} expected Expected token
     * @param {boolean} [optional=false] Whether the token is optional
     * @returns {boolean} `true` when skipped, `false` if not
     * @throws {Error} When a required token is not present
     * @inner
     */
    function skip(expected, optional) {
        var actual = peek(),
            equals = actual === expected;
        if (equals) {
            next();
            return true;
        }
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
    }

    /**
     * Gets a comment.
     * @param {number} [trailingLine] Line number if looking for a trailing comment
     * @returns {string|null} Comment text
     * @inner
     */
    function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === undefined) {
            if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
                ret = commentIsLeading ? commentText : null;
            }
        } else {
            /* istanbul ignore else */
            if (commentLine < trailingLine) {
                peek();
            }
            if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
                ret = commentIsLeading ? null : commentText;
            }
        }
        return ret;
    }

    return Object.defineProperty({
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
    }, "line", {
        get: function() { return line; }
    });
    /* eslint-enable callback-return */
}

},{}],94:[function(require,module,exports){
"use strict";
module.exports = Type;

// extends Namespace
var Namespace = require("./namespace");
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = require("./enum"),
    OneOf     = require("./oneof"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    Service   = require("./service"),
    Message   = require("./message"),
    Reader    = require("./reader"),
    Writer    = require("./writer"),
    util      = require("./util"),
    encoder   = require("./encoder"),
    decoder   = require("./decoder"),
    verifier  = require("./verifier"),
    converter = require("./converter"),
    wrappers  = require("./wrappers");

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {number[][]} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return this.fields[name]
        || this.oneofs && this.oneofs[name]
        || this.nested && this.nested[name]
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};

},{"./converter":71,"./decoder":72,"./encoder":73,"./enum":74,"./field":75,"./mapfield":79,"./message":80,"./namespace":82,"./oneof":84,"./reader":86,"./service":92,"./util":96,"./verifier":99,"./wrappers":100,"./writer":101}],95:[function(require,module,exports){
"use strict";

/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = require("./util");

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);

},{"./util":96}],96:[function(require,module,exports){
"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require("./util/minimal");

var roots = require("./roots");

var Type, // cyclic
    Enum;

util.codegen = require("@protobufjs/codegen");
util.fetch   = require("@protobufjs/fetch");
util.path    = require("@protobufjs/path");

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = require("./type");

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = require("./enum");

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};


/**
 * Sets the value of a property by property path. If a value already exists, it is turned to an array
 * @param {Object.<string,*>} dst Destination object
 * @param {string} path dot '.' delimited path of the property to set
 * @param {Object} value the value to set
 * @returns {Object.<string,*>} Destination object
 */
util.setProperty = function setProperty(dst, path, value) {
    function setProp(dst, path, value) {
        var part = path.shift();
        if (path.length > 0) {
            dst[part] = setProp(dst[part] || {}, path, value);
        } else {
            var prevValue = dst[part];
            if (prevValue)
                value = [].concat(prevValue).concat(value);
            dst[part] = value;
        }
        return dst;
    }

    if (typeof dst !== "object")
        throw TypeError("dst must be an object");
    if (!path)
        throw TypeError("path must be specified");

    path = path.split(".");
    return setProp(dst, path, value);
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require("./root"))());
    }
});

},{"./enum":74,"./root":88,"./roots":89,"./type":94,"./util/minimal":98,"@protobufjs/codegen":13,"@protobufjs/fetch":15,"@protobufjs/path":18}],97:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"../util/minimal":98}],98:[function(require,module,exports){
(function (global){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./longbits":97,"@protobufjs/aspromise":11,"@protobufjs/base64":12,"@protobufjs/eventemitter":14,"@protobufjs/float":16,"@protobufjs/inquire":17,"@protobufjs/pool":19,"@protobufjs/utf8":20}],99:[function(require,module,exports){
"use strict";
module.exports = verifier;

var Enum      = require("./enum"),
    util      = require("./util");

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}
},{"./enum":74,"./util":96}],100:[function(require,module,exports){
"use strict";

/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = require("./message");

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
             // Only use fully qualified type name after the last '/'
            var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].substr(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                if (type_url.indexOf("/") === -1) {
                    type_url = "/" + type_url;
                }
                return this.create({
                    type_url: type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // Default prefix
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            // Separate the prefix used
            prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            var messageName = message.$type.fullName[0] === "." ?
                message.$type.fullName.substr(1) : message.$type.fullName;
            // Default to type.googleapis.com prefix if no prefix is used
            if (prefix === "") {
                prefix = googleApi;
            }
            name = prefix + messageName;
            object["@type"] = name;
            return object;
        }

        return this.toObject(message, options);
    }
};

},{"./message":80}],101:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};

},{"./util/minimal":98}],102:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();

},{"./util/minimal":98,"./writer":101}],103:[function(require,module,exports){
(function (process){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.Enum = {}));
}(this, (function (exports) { 'use strict';

  function getUserClassStr(name) {
    return `
    let topLevelScope
    if (typeof(process) !== 'undefined') {
        topLevelScope = process
    } else {
      topLevelScope = window
    }
    var EnumMeta = topLevelScope.EnumMeta

    return class ${name} extends EnumMeta {
      constructor(val, key) {
        super(val)
        if (!this.constructor._vals.hasOwnProperty(val)) {
          throw new Error('ValueError: '+ val + ' is not a valid ' + 'UserClass')
        }
        if (this.constructor._init) {
          const lookUpKey = this.constructor._vals[val]
          return this.constructor[lookUpKey]
        }
        this.val = val
        this.key = key
      }

      get value() {
        return this.val
      }

      toString() {
        return '${name}.' + this.key + ': ' + this.val
      }
    };
  `
  }

  class EnumMeta extends Number {
    toArray() {
      const result = [];
      for (let i = 0; i < this._keys.length; i++) {
        result.push(this[this._keys[i]]);
      }
      return result
    }

    has(key) {
      return this.hasOwnProperty(key)
    }
  }
  let topLevelScope;
  if (typeof(process) !== 'undefined' && !process.browser) {
      topLevelScope = process;
  } else {
    topLevelScope = window;
  }
  topLevelScope.EnumMeta = EnumMeta;
  const specialKeys = {
    _missing_: true,
  };
  function getDict({ dict, keys, start = 1, seperator }) {
    const usedDict = {};
    const values = {};
    const userMethods = [];
    let test;
    // STRING
    if (typeof(dict) === 'string') {
      if (seperator) {
        test = dict.split(seperator);
      }
      if (!seperator) {
        test = dict.split(',');
      }
      if (test.length === 1 && !seperator) {
        test = dict.split(' ');
      }
      test.forEach((key, index) => {
        const usedKey = key.trim();
        if (!usedKey || specialKeys[usedKey]) {
          console.warn('Cannot use reserved keyword ', usedKey);
          return
        }
        values[index + start] = usedKey;
        usedDict[usedKey] = index + start;
      });
      return { dict: usedDict, values, userMethods }
    }
    const usedKeys = keys || Object.keys(dict);
    // ARRAY
    if (Array.isArray(dict)) {
      usedKeys.forEach((key, index) => {
        const valOfArray = dict[key];
        if (typeof valOfArray === 'function') {
          // ex: _missing_
          if (specialKeys[valOfArray.name]) {
            userMethods.push(valOfArray);
            return
          }
          usedDict[valOfArray.name] = index + start;
          values[index + start] = valOfArray.name;
          return
        }
        usedDict[valOfArray] = index + start;
        values[index + start] = valOfArray;
      });
      return { dict: usedDict, values, userMethods }
    }
    // OBJECT
    usedKeys.forEach((key) => {
      const val = dict[key];
      if (typeof val === 'function') {
        if (specialKeys[val.name]) {
          userMethods.push(val);
          return
        }
      }
      usedDict[key] = val;
      values[val] = key;
    });
    return  { dict: usedDict, values, userMethods }
  }
  function getUserEnum(name, userDict, start, seperator) {
    let keys = Object.keys(userDict);
    const { dict, values, userMethods } = getDict({ dict: userDict, keys });
    keys = Object.keys(dict);
    const UserClass = Function(getUserClassStr(name))();
    UserClass._vals = values;
    UserClass._keys = keys;
    UserClass.member_names_ = keys;
    keys.forEach((key) => {
      const val = dict[key];
      UserClass[key] = new UserClass(val, key);
      UserClass.prototype[key] = UserClass[key];
    });
    userMethods.forEach((func) => {
      UserClass.prototype[func.name] = func;
    });
    UserClass.prototype.member_names_ = keys;
    UserClass.toArray = function toArray() {
      const result = [];
      for (let i = 0; i < UserClass._keys.length; i++) {
        result.push(UserClass[UserClass._keys[i]]);
      }
      return result
    };
    UserClass.has = function has(key) {
      return UserClass.hasOwnProperty(key)
    };
    UserClass._init = true;
    // set up map for override properties
    const prox = new Proxy(UserClass, {
      get: (target, name) => {
        if (target[name]) {
          return target[name]
        }
        let val;
        if (target['_missing_'] ===  null) {
          return undefined
        }
        if (typeof target['_missing_'] === 'function') {
          val = target['_missing_']();
        } else {
          val = target['_missing_'];
        }
        return val
      },
      apply: function(target, thisArg, argumentsList) {
        if (target._vals.hasOwnProperty(argumentsList[0])) {
          const lookUpKey = target._vals[argumentsList[0]];
          return target[lookUpKey]
        }
        return new target(argumentsList[0])
      },
    });
    prox.__proto__ = UserClass[UserClass._keys[0]];
    Object.freeze(UserClass);

    return prox
  }
  function IntEnum(name, dict, options = { seperator: null, start: 1 }) {
    return getUserEnum(name, dict)
  }
  function Enum(name, dict,  options = { seperator: null, start: 1 }) {
    return getUserEnum(name, dict)
  }
  Enum.EnumMeta = EnumMeta;
  Enum.IntEnum = IntEnum;
  Enum.Enum = Enum;
  module.exports = Enum;

  exports.default = Enum;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

}).call(this,require('_process'))
},{"_process":7}],104:[function(require,module,exports){
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.SC2APIProtocol.AvailableAbility', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ImageData', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Point', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Point2D', null, global);
goog.exportSymbol('proto.SC2APIProtocol.PointI', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Race', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RectangleI', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Size2DI', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.AvailableAbility = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.AvailableAbility, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.AvailableAbility.displayName = 'proto.SC2APIProtocol.AvailableAbility';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.AvailableAbility.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.AvailableAbility.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.AvailableAbility} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.AvailableAbility.toObject = function(includeInstance, msg) {
  var f, obj = {
    abilityId: jspb.Message.getField(msg, 1),
    requiresPoint: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.AvailableAbility}
 */
proto.SC2APIProtocol.AvailableAbility.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.AvailableAbility;
  return proto.SC2APIProtocol.AvailableAbility.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.AvailableAbility} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.AvailableAbility}
 */
proto.SC2APIProtocol.AvailableAbility.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAbilityId(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRequiresPoint(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.AvailableAbility.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.AvailableAbility.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.AvailableAbility} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.AvailableAbility.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * optional int32 ability_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.AvailableAbility.prototype.getAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.AvailableAbility.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.AvailableAbility.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AvailableAbility.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool requires_point = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.AvailableAbility.prototype.getRequiresPoint = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.AvailableAbility.prototype.setRequiresPoint = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.AvailableAbility.prototype.clearRequiresPoint = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AvailableAbility.prototype.hasRequiresPoint = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ImageData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ImageData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ImageData.displayName = 'proto.SC2APIProtocol.ImageData';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ImageData.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ImageData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ImageData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ImageData.toObject = function(includeInstance, msg) {
  var f, obj = {
    bitsPerPixel: jspb.Message.getField(msg, 1),
    size: (f = msg.getSize()) && proto.SC2APIProtocol.Size2DI.toObject(includeInstance, f),
    data: msg.getData_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.ImageData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ImageData;
  return proto.SC2APIProtocol.ImageData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ImageData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.ImageData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBitsPerPixel(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.Size2DI;
      reader.readMessage(value,proto.SC2APIProtocol.Size2DI.deserializeBinaryFromReader);
      msg.setSize(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ImageData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ImageData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ImageData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ImageData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = message.getSize();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.SC2APIProtocol.Size2DI.serializeBinaryToWriter
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional int32 bits_per_pixel = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ImageData.prototype.getBitsPerPixel = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ImageData.prototype.setBitsPerPixel = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ImageData.prototype.clearBitsPerPixel = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ImageData.prototype.hasBitsPerPixel = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Size2DI size = 2;
 * @return {?proto.SC2APIProtocol.Size2DI}
 */
proto.SC2APIProtocol.ImageData.prototype.getSize = function() {
  return /** @type{?proto.SC2APIProtocol.Size2DI} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.Size2DI, 2));
};


/** @param {?proto.SC2APIProtocol.Size2DI|undefined} value */
proto.SC2APIProtocol.ImageData.prototype.setSize = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.ImageData.prototype.clearSize = function() {
  this.setSize(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ImageData.prototype.hasSize = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes data = 3;
 * @return {!(string|Uint8Array)}
 */
proto.SC2APIProtocol.ImageData.prototype.getData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes data = 3;
 * This is a type-conversion wrapper around `getData()`
 * @return {string}
 */
proto.SC2APIProtocol.ImageData.prototype.getData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getData()));
};


/**
 * optional bytes data = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getData()`
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ImageData.prototype.getData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getData()));
};


/** @param {!(string|Uint8Array)} value */
proto.SC2APIProtocol.ImageData.prototype.setData = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.ImageData.prototype.clearData = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ImageData.prototype.hasData = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.PointI = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.PointI, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.PointI.displayName = 'proto.SC2APIProtocol.PointI';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.PointI.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.PointI.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.PointI} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PointI.toObject = function(includeInstance, msg) {
  var f, obj = {
    x: jspb.Message.getField(msg, 1),
    y: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.PointI}
 */
proto.SC2APIProtocol.PointI.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.PointI;
  return proto.SC2APIProtocol.PointI.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.PointI} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.PointI}
 */
proto.SC2APIProtocol.PointI.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setX(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setY(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.PointI.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.PointI.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.PointI} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PointI.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional int32 x = 1;
 * @return {number}
 */
proto.SC2APIProtocol.PointI.prototype.getX = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PointI.prototype.setX = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.PointI.prototype.clearX = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PointI.prototype.hasX = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int32 y = 2;
 * @return {number}
 */
proto.SC2APIProtocol.PointI.prototype.getY = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PointI.prototype.setY = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.PointI.prototype.clearY = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PointI.prototype.hasY = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RectangleI = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RectangleI, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RectangleI.displayName = 'proto.SC2APIProtocol.RectangleI';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RectangleI.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RectangleI.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RectangleI} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RectangleI.toObject = function(includeInstance, msg) {
  var f, obj = {
    p0: (f = msg.getP0()) && proto.SC2APIProtocol.PointI.toObject(includeInstance, f),
    p1: (f = msg.getP1()) && proto.SC2APIProtocol.PointI.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RectangleI}
 */
proto.SC2APIProtocol.RectangleI.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RectangleI;
  return proto.SC2APIProtocol.RectangleI.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RectangleI} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RectangleI}
 */
proto.SC2APIProtocol.RectangleI.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.PointI;
      reader.readMessage(value,proto.SC2APIProtocol.PointI.deserializeBinaryFromReader);
      msg.setP0(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.PointI;
      reader.readMessage(value,proto.SC2APIProtocol.PointI.deserializeBinaryFromReader);
      msg.setP1(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RectangleI.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RectangleI.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RectangleI} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RectangleI.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getP0();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.PointI.serializeBinaryToWriter
    );
  }
  f = message.getP1();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.SC2APIProtocol.PointI.serializeBinaryToWriter
    );
  }
};


/**
 * optional PointI p0 = 1;
 * @return {?proto.SC2APIProtocol.PointI}
 */
proto.SC2APIProtocol.RectangleI.prototype.getP0 = function() {
  return /** @type{?proto.SC2APIProtocol.PointI} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.PointI, 1));
};


/** @param {?proto.SC2APIProtocol.PointI|undefined} value */
proto.SC2APIProtocol.RectangleI.prototype.setP0 = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.RectangleI.prototype.clearP0 = function() {
  this.setP0(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RectangleI.prototype.hasP0 = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional PointI p1 = 2;
 * @return {?proto.SC2APIProtocol.PointI}
 */
proto.SC2APIProtocol.RectangleI.prototype.getP1 = function() {
  return /** @type{?proto.SC2APIProtocol.PointI} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.PointI, 2));
};


/** @param {?proto.SC2APIProtocol.PointI|undefined} value */
proto.SC2APIProtocol.RectangleI.prototype.setP1 = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.RectangleI.prototype.clearP1 = function() {
  this.setP1(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RectangleI.prototype.hasP1 = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Point2D = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.Point2D, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Point2D.displayName = 'proto.SC2APIProtocol.Point2D';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Point2D.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Point2D.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Point2D} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Point2D.toObject = function(includeInstance, msg) {
  var f, obj = {
    x: jspb.Message.getOptionalFloatingPointField(msg, 1),
    y: jspb.Message.getOptionalFloatingPointField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Point2D}
 */
proto.SC2APIProtocol.Point2D.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Point2D;
  return proto.SC2APIProtocol.Point2D.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Point2D} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Point2D}
 */
proto.SC2APIProtocol.Point2D.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setX(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setY(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Point2D.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Point2D.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Point2D} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Point2D.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
};


/**
 * optional float x = 1;
 * @return {number}
 */
proto.SC2APIProtocol.Point2D.prototype.getX = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 1, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Point2D.prototype.setX = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.Point2D.prototype.clearX = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Point2D.prototype.hasX = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float y = 2;
 * @return {number}
 */
proto.SC2APIProtocol.Point2D.prototype.getY = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Point2D.prototype.setY = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.Point2D.prototype.clearY = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Point2D.prototype.hasY = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Point = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.Point, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Point.displayName = 'proto.SC2APIProtocol.Point';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Point.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Point.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Point} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Point.toObject = function(includeInstance, msg) {
  var f, obj = {
    x: jspb.Message.getOptionalFloatingPointField(msg, 1),
    y: jspb.Message.getOptionalFloatingPointField(msg, 2),
    z: jspb.Message.getOptionalFloatingPointField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.Point.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Point;
  return proto.SC2APIProtocol.Point.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Point} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.Point.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setX(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setY(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setZ(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Point.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Point.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Point} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Point.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeFloat(
      3,
      f
    );
  }
};


/**
 * optional float x = 1;
 * @return {number}
 */
proto.SC2APIProtocol.Point.prototype.getX = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 1, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Point.prototype.setX = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.Point.prototype.clearX = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Point.prototype.hasX = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float y = 2;
 * @return {number}
 */
proto.SC2APIProtocol.Point.prototype.getY = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Point.prototype.setY = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.Point.prototype.clearY = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Point.prototype.hasY = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional float z = 3;
 * @return {number}
 */
proto.SC2APIProtocol.Point.prototype.getZ = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 3, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Point.prototype.setZ = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.Point.prototype.clearZ = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Point.prototype.hasZ = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Size2DI = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.Size2DI, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Size2DI.displayName = 'proto.SC2APIProtocol.Size2DI';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Size2DI.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Size2DI.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Size2DI} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Size2DI.toObject = function(includeInstance, msg) {
  var f, obj = {
    x: jspb.Message.getField(msg, 1),
    y: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Size2DI}
 */
proto.SC2APIProtocol.Size2DI.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Size2DI;
  return proto.SC2APIProtocol.Size2DI.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Size2DI} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Size2DI}
 */
proto.SC2APIProtocol.Size2DI.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setX(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setY(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Size2DI.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Size2DI.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Size2DI} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Size2DI.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional int32 x = 1;
 * @return {number}
 */
proto.SC2APIProtocol.Size2DI.prototype.getX = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Size2DI.prototype.setX = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.Size2DI.prototype.clearX = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Size2DI.prototype.hasX = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int32 y = 2;
 * @return {number}
 */
proto.SC2APIProtocol.Size2DI.prototype.getY = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Size2DI.prototype.setY = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.Size2DI.prototype.clearY = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Size2DI.prototype.hasY = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.Race = {
  NORACE: 0,
  TERRAN: 1,
  ZERG: 2,
  PROTOSS: 3,
  RANDOM: 4
};

goog.object.extend(exports, proto.SC2APIProtocol);

},{"google-protobuf":68}],105:[function(require,module,exports){
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var s2clientprotocol_common_pb = require('./common_pb.js');
goog.exportSymbol('proto.SC2APIProtocol.AbilityData', null, global);
goog.exportSymbol('proto.SC2APIProtocol.AbilityData.Target', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Attribute', null, global);
goog.exportSymbol('proto.SC2APIProtocol.BuffData', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DamageBonus', null, global);
goog.exportSymbol('proto.SC2APIProtocol.EffectData', null, global);
goog.exportSymbol('proto.SC2APIProtocol.UnitTypeData', null, global);
goog.exportSymbol('proto.SC2APIProtocol.UpgradeData', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Weapon', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Weapon.TargetType', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.AbilityData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.AbilityData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.AbilityData.displayName = 'proto.SC2APIProtocol.AbilityData';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.AbilityData.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.AbilityData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.AbilityData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.AbilityData.toObject = function(includeInstance, msg) {
  var f, obj = {
    abilityId: jspb.Message.getField(msg, 1),
    linkName: jspb.Message.getField(msg, 2),
    linkIndex: jspb.Message.getField(msg, 3),
    buttonName: jspb.Message.getField(msg, 4),
    friendlyName: jspb.Message.getField(msg, 5),
    hotkey: jspb.Message.getField(msg, 6),
    remapsToAbilityId: jspb.Message.getField(msg, 7),
    available: jspb.Message.getField(msg, 8),
    target: jspb.Message.getField(msg, 9),
    allowMinimap: jspb.Message.getField(msg, 10),
    allowAutocast: jspb.Message.getField(msg, 11),
    isBuilding: jspb.Message.getField(msg, 12),
    footprintRadius: jspb.Message.getOptionalFloatingPointField(msg, 13),
    isInstantPlacement: jspb.Message.getField(msg, 14),
    castRange: jspb.Message.getOptionalFloatingPointField(msg, 15)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.AbilityData}
 */
proto.SC2APIProtocol.AbilityData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.AbilityData;
  return proto.SC2APIProtocol.AbilityData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.AbilityData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.AbilityData}
 */
proto.SC2APIProtocol.AbilityData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAbilityId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setLinkName(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLinkIndex(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setButtonName(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setFriendlyName(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setHotkey(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRemapsToAbilityId(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAvailable(value);
      break;
    case 9:
      var value = /** @type {!proto.SC2APIProtocol.AbilityData.Target} */ (reader.readEnum());
      msg.setTarget(value);
      break;
    case 10:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAllowMinimap(value);
      break;
    case 11:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAllowAutocast(value);
      break;
    case 12:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsBuilding(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setFootprintRadius(value);
      break;
    case 14:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsInstantPlacement(value);
      break;
    case 15:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setCastRange(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.AbilityData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.AbilityData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.AbilityData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.AbilityData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeString(
      5,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeString(
      6,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeBool(
      8,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.AbilityData.Target} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeEnum(
      9,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeBool(
      10,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 11));
  if (f != null) {
    writer.writeBool(
      11,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 12));
  if (f != null) {
    writer.writeBool(
      12,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 13));
  if (f != null) {
    writer.writeFloat(
      13,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 14));
  if (f != null) {
    writer.writeBool(
      14,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 15));
  if (f != null) {
    writer.writeFloat(
      15,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.AbilityData.Target = {
  NONE: 1,
  POINT: 2,
  UNIT: 3,
  POINTORUNIT: 4,
  POINTORNONE: 5
};

/**
 * optional uint32 ability_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.AbilityData.prototype.getAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.AbilityData.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string link_name = 2;
 * @return {string}
 */
proto.SC2APIProtocol.AbilityData.prototype.getLinkName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.AbilityData.prototype.setLinkName = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearLinkName = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasLinkName = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 link_index = 3;
 * @return {number}
 */
proto.SC2APIProtocol.AbilityData.prototype.getLinkIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.AbilityData.prototype.setLinkIndex = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearLinkIndex = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasLinkIndex = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional string button_name = 4;
 * @return {string}
 */
proto.SC2APIProtocol.AbilityData.prototype.getButtonName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.AbilityData.prototype.setButtonName = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearButtonName = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasButtonName = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional string friendly_name = 5;
 * @return {string}
 */
proto.SC2APIProtocol.AbilityData.prototype.getFriendlyName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.AbilityData.prototype.setFriendlyName = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearFriendlyName = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasFriendlyName = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional string hotkey = 6;
 * @return {string}
 */
proto.SC2APIProtocol.AbilityData.prototype.getHotkey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.AbilityData.prototype.setHotkey = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearHotkey = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasHotkey = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional uint32 remaps_to_ability_id = 7;
 * @return {number}
 */
proto.SC2APIProtocol.AbilityData.prototype.getRemapsToAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.AbilityData.prototype.setRemapsToAbilityId = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearRemapsToAbilityId = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasRemapsToAbilityId = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional bool available = 8;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.getAvailable = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 8, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.AbilityData.prototype.setAvailable = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearAvailable = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasAvailable = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional Target target = 9;
 * @return {!proto.SC2APIProtocol.AbilityData.Target}
 */
proto.SC2APIProtocol.AbilityData.prototype.getTarget = function() {
  return /** @type {!proto.SC2APIProtocol.AbilityData.Target} */ (jspb.Message.getFieldWithDefault(this, 9, 1));
};


/** @param {!proto.SC2APIProtocol.AbilityData.Target} value */
proto.SC2APIProtocol.AbilityData.prototype.setTarget = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearTarget = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasTarget = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional bool allow_minimap = 10;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.getAllowMinimap = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 10, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.AbilityData.prototype.setAllowMinimap = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearAllowMinimap = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasAllowMinimap = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional bool allow_autocast = 11;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.getAllowAutocast = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 11, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.AbilityData.prototype.setAllowAutocast = function(value) {
  jspb.Message.setField(this, 11, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearAllowAutocast = function() {
  jspb.Message.setField(this, 11, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasAllowAutocast = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional bool is_building = 12;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.getIsBuilding = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 12, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.AbilityData.prototype.setIsBuilding = function(value) {
  jspb.Message.setField(this, 12, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearIsBuilding = function() {
  jspb.Message.setField(this, 12, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasIsBuilding = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional float footprint_radius = 13;
 * @return {number}
 */
proto.SC2APIProtocol.AbilityData.prototype.getFootprintRadius = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 13, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.AbilityData.prototype.setFootprintRadius = function(value) {
  jspb.Message.setField(this, 13, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearFootprintRadius = function() {
  jspb.Message.setField(this, 13, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasFootprintRadius = function() {
  return jspb.Message.getField(this, 13) != null;
};


/**
 * optional bool is_instant_placement = 14;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.getIsInstantPlacement = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 14, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.AbilityData.prototype.setIsInstantPlacement = function(value) {
  jspb.Message.setField(this, 14, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearIsInstantPlacement = function() {
  jspb.Message.setField(this, 14, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasIsInstantPlacement = function() {
  return jspb.Message.getField(this, 14) != null;
};


/**
 * optional float cast_range = 15;
 * @return {number}
 */
proto.SC2APIProtocol.AbilityData.prototype.getCastRange = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 15, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.AbilityData.prototype.setCastRange = function(value) {
  jspb.Message.setField(this, 15, value);
};


proto.SC2APIProtocol.AbilityData.prototype.clearCastRange = function() {
  jspb.Message.setField(this, 15, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.AbilityData.prototype.hasCastRange = function() {
  return jspb.Message.getField(this, 15) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DamageBonus = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.DamageBonus, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DamageBonus.displayName = 'proto.SC2APIProtocol.DamageBonus';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DamageBonus.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DamageBonus.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DamageBonus} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DamageBonus.toObject = function(includeInstance, msg) {
  var f, obj = {
    attribute: jspb.Message.getField(msg, 1),
    bonus: jspb.Message.getOptionalFloatingPointField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DamageBonus}
 */
proto.SC2APIProtocol.DamageBonus.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DamageBonus;
  return proto.SC2APIProtocol.DamageBonus.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DamageBonus} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DamageBonus}
 */
proto.SC2APIProtocol.DamageBonus.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.Attribute} */ (reader.readEnum());
      msg.setAttribute(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setBonus(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DamageBonus.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DamageBonus.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DamageBonus} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DamageBonus.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.Attribute} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
};


/**
 * optional Attribute attribute = 1;
 * @return {!proto.SC2APIProtocol.Attribute}
 */
proto.SC2APIProtocol.DamageBonus.prototype.getAttribute = function() {
  return /** @type {!proto.SC2APIProtocol.Attribute} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.Attribute} value */
proto.SC2APIProtocol.DamageBonus.prototype.setAttribute = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.DamageBonus.prototype.clearAttribute = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DamageBonus.prototype.hasAttribute = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float bonus = 2;
 * @return {number}
 */
proto.SC2APIProtocol.DamageBonus.prototype.getBonus = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.DamageBonus.prototype.setBonus = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.DamageBonus.prototype.clearBonus = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DamageBonus.prototype.hasBonus = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Weapon = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.Weapon.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.Weapon, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Weapon.displayName = 'proto.SC2APIProtocol.Weapon';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.Weapon.repeatedFields_ = [3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Weapon.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Weapon.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Weapon} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Weapon.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getField(msg, 1),
    damage: jspb.Message.getOptionalFloatingPointField(msg, 2),
    damageBonusList: jspb.Message.toObjectList(msg.getDamageBonusList(),
    proto.SC2APIProtocol.DamageBonus.toObject, includeInstance),
    attacks: jspb.Message.getField(msg, 4),
    range: jspb.Message.getOptionalFloatingPointField(msg, 5),
    speed: jspb.Message.getOptionalFloatingPointField(msg, 6)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Weapon}
 */
proto.SC2APIProtocol.Weapon.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Weapon;
  return proto.SC2APIProtocol.Weapon.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Weapon} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Weapon}
 */
proto.SC2APIProtocol.Weapon.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.Weapon.TargetType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setDamage(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.DamageBonus;
      reader.readMessage(value,proto.SC2APIProtocol.DamageBonus.deserializeBinaryFromReader);
      msg.addDamageBonus(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAttacks(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setRange(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setSpeed(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Weapon.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Weapon.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Weapon} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Weapon.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.Weapon.TargetType} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = message.getDamageBonusList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.SC2APIProtocol.DamageBonus.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeFloat(
      5,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeFloat(
      6,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.Weapon.TargetType = {
  GROUND: 1,
  AIR: 2,
  ANY: 3
};

/**
 * optional TargetType type = 1;
 * @return {!proto.SC2APIProtocol.Weapon.TargetType}
 */
proto.SC2APIProtocol.Weapon.prototype.getType = function() {
  return /** @type {!proto.SC2APIProtocol.Weapon.TargetType} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.Weapon.TargetType} value */
proto.SC2APIProtocol.Weapon.prototype.setType = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.Weapon.prototype.clearType = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Weapon.prototype.hasType = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float damage = 2;
 * @return {number}
 */
proto.SC2APIProtocol.Weapon.prototype.getDamage = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Weapon.prototype.setDamage = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.Weapon.prototype.clearDamage = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Weapon.prototype.hasDamage = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * repeated DamageBonus damage_bonus = 3;
 * @return {!Array.<!proto.SC2APIProtocol.DamageBonus>}
 */
proto.SC2APIProtocol.Weapon.prototype.getDamageBonusList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.DamageBonus>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.DamageBonus, 3));
};


/** @param {!Array.<!proto.SC2APIProtocol.DamageBonus>} value */
proto.SC2APIProtocol.Weapon.prototype.setDamageBonusList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.SC2APIProtocol.DamageBonus=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.DamageBonus}
 */
proto.SC2APIProtocol.Weapon.prototype.addDamageBonus = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.SC2APIProtocol.DamageBonus, opt_index);
};


proto.SC2APIProtocol.Weapon.prototype.clearDamageBonusList = function() {
  this.setDamageBonusList([]);
};


/**
 * optional uint32 attacks = 4;
 * @return {number}
 */
proto.SC2APIProtocol.Weapon.prototype.getAttacks = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Weapon.prototype.setAttacks = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.Weapon.prototype.clearAttacks = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Weapon.prototype.hasAttacks = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional float range = 5;
 * @return {number}
 */
proto.SC2APIProtocol.Weapon.prototype.getRange = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 5, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Weapon.prototype.setRange = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.Weapon.prototype.clearRange = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Weapon.prototype.hasRange = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional float speed = 6;
 * @return {number}
 */
proto.SC2APIProtocol.Weapon.prototype.getSpeed = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 6, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Weapon.prototype.setSpeed = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.Weapon.prototype.clearSpeed = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Weapon.prototype.hasSpeed = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.UnitTypeData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.UnitTypeData.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.UnitTypeData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.UnitTypeData.displayName = 'proto.SC2APIProtocol.UnitTypeData';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.UnitTypeData.repeatedFields_ = [21,8,11];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.UnitTypeData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.UnitTypeData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.UnitTypeData.toObject = function(includeInstance, msg) {
  var f, obj = {
    unitId: jspb.Message.getField(msg, 1),
    name: jspb.Message.getField(msg, 2),
    available: jspb.Message.getField(msg, 3),
    cargoSize: jspb.Message.getField(msg, 4),
    mineralCost: jspb.Message.getField(msg, 12),
    vespeneCost: jspb.Message.getField(msg, 13),
    foodRequired: jspb.Message.getOptionalFloatingPointField(msg, 14),
    foodProvided: jspb.Message.getOptionalFloatingPointField(msg, 18),
    abilityId: jspb.Message.getField(msg, 15),
    race: jspb.Message.getField(msg, 16),
    buildTime: jspb.Message.getOptionalFloatingPointField(msg, 17),
    hasVespene: jspb.Message.getField(msg, 19),
    hasMinerals: jspb.Message.getField(msg, 20),
    sightRange: jspb.Message.getOptionalFloatingPointField(msg, 25),
    techAliasList: jspb.Message.getRepeatedField(msg, 21),
    unitAlias: jspb.Message.getField(msg, 22),
    techRequirement: jspb.Message.getField(msg, 23),
    requireAttached: jspb.Message.getField(msg, 24),
    attributesList: jspb.Message.getRepeatedField(msg, 8),
    movementSpeed: jspb.Message.getOptionalFloatingPointField(msg, 9),
    armor: jspb.Message.getOptionalFloatingPointField(msg, 10),
    weaponsList: jspb.Message.toObjectList(msg.getWeaponsList(),
    proto.SC2APIProtocol.Weapon.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.UnitTypeData}
 */
proto.SC2APIProtocol.UnitTypeData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.UnitTypeData;
  return proto.SC2APIProtocol.UnitTypeData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.UnitTypeData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.UnitTypeData}
 */
proto.SC2APIProtocol.UnitTypeData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setUnitId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAvailable(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCargoSize(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMineralCost(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVespeneCost(value);
      break;
    case 14:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setFoodRequired(value);
      break;
    case 18:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setFoodProvided(value);
      break;
    case 15:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAbilityId(value);
      break;
    case 16:
      var value = /** @type {!proto.SC2APIProtocol.Race} */ (reader.readEnum());
      msg.setRace(value);
      break;
    case 17:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setBuildTime(value);
      break;
    case 19:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setHasVespene(value);
      break;
    case 20:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setHasMinerals(value);
      break;
    case 25:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setSightRange(value);
      break;
    case 21:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addTechAlias(value);
      break;
    case 22:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setUnitAlias(value);
      break;
    case 23:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setTechRequirement(value);
      break;
    case 24:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRequireAttached(value);
      break;
    case 8:
      var value = /** @type {!proto.SC2APIProtocol.Attribute} */ (reader.readEnum());
      msg.addAttributes(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setMovementSpeed(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setArmor(value);
      break;
    case 11:
      var value = new proto.SC2APIProtocol.Weapon;
      reader.readMessage(value,proto.SC2APIProtocol.Weapon.deserializeBinaryFromReader);
      msg.addWeapons(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.UnitTypeData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.UnitTypeData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.UnitTypeData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 12));
  if (f != null) {
    writer.writeUint32(
      12,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 13));
  if (f != null) {
    writer.writeUint32(
      13,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 14));
  if (f != null) {
    writer.writeFloat(
      14,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 18));
  if (f != null) {
    writer.writeFloat(
      18,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 15));
  if (f != null) {
    writer.writeUint32(
      15,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.Race} */ (jspb.Message.getField(message, 16));
  if (f != null) {
    writer.writeEnum(
      16,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 17));
  if (f != null) {
    writer.writeFloat(
      17,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 19));
  if (f != null) {
    writer.writeBool(
      19,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 20));
  if (f != null) {
    writer.writeBool(
      20,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 25));
  if (f != null) {
    writer.writeFloat(
      25,
      f
    );
  }
  f = message.getTechAliasList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      21,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 22));
  if (f != null) {
    writer.writeUint32(
      22,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 23));
  if (f != null) {
    writer.writeUint32(
      23,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 24));
  if (f != null) {
    writer.writeBool(
      24,
      f
    );
  }
  f = message.getAttributesList();
  if (f.length > 0) {
    writer.writeRepeatedEnum(
      8,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeFloat(
      9,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeFloat(
      10,
      f
    );
  }
  f = message.getWeaponsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      11,
      f,
      proto.SC2APIProtocol.Weapon.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint32 unit_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getUnitId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setUnitId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearUnitId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasUnitId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string name = 2;
 * @return {string}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setName = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearName = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasName = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool available = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getAvailable = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setAvailable = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearAvailable = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasAvailable = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional uint32 cargo_size = 4;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getCargoSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setCargoSize = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearCargoSize = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasCargoSize = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional uint32 mineral_cost = 12;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getMineralCost = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 12, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setMineralCost = function(value) {
  jspb.Message.setField(this, 12, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearMineralCost = function() {
  jspb.Message.setField(this, 12, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasMineralCost = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional uint32 vespene_cost = 13;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getVespeneCost = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 13, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setVespeneCost = function(value) {
  jspb.Message.setField(this, 13, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearVespeneCost = function() {
  jspb.Message.setField(this, 13, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasVespeneCost = function() {
  return jspb.Message.getField(this, 13) != null;
};


/**
 * optional float food_required = 14;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getFoodRequired = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 14, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setFoodRequired = function(value) {
  jspb.Message.setField(this, 14, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearFoodRequired = function() {
  jspb.Message.setField(this, 14, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasFoodRequired = function() {
  return jspb.Message.getField(this, 14) != null;
};


/**
 * optional float food_provided = 18;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getFoodProvided = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 18, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setFoodProvided = function(value) {
  jspb.Message.setField(this, 18, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearFoodProvided = function() {
  jspb.Message.setField(this, 18, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasFoodProvided = function() {
  return jspb.Message.getField(this, 18) != null;
};


/**
 * optional uint32 ability_id = 15;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 15, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 15, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 15, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 15) != null;
};


/**
 * optional Race race = 16;
 * @return {!proto.SC2APIProtocol.Race}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getRace = function() {
  return /** @type {!proto.SC2APIProtocol.Race} */ (jspb.Message.getFieldWithDefault(this, 16, 0));
};


/** @param {!proto.SC2APIProtocol.Race} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setRace = function(value) {
  jspb.Message.setField(this, 16, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearRace = function() {
  jspb.Message.setField(this, 16, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasRace = function() {
  return jspb.Message.getField(this, 16) != null;
};


/**
 * optional float build_time = 17;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getBuildTime = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 17, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setBuildTime = function(value) {
  jspb.Message.setField(this, 17, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearBuildTime = function() {
  jspb.Message.setField(this, 17, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasBuildTime = function() {
  return jspb.Message.getField(this, 17) != null;
};


/**
 * optional bool has_vespene = 19;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getHasVespene = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 19, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setHasVespene = function(value) {
  jspb.Message.setField(this, 19, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearHasVespene = function() {
  jspb.Message.setField(this, 19, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasHasVespene = function() {
  return jspb.Message.getField(this, 19) != null;
};


/**
 * optional bool has_minerals = 20;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getHasMinerals = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 20, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setHasMinerals = function(value) {
  jspb.Message.setField(this, 20, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearHasMinerals = function() {
  jspb.Message.setField(this, 20, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasHasMinerals = function() {
  return jspb.Message.getField(this, 20) != null;
};


/**
 * optional float sight_range = 25;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getSightRange = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 25, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setSightRange = function(value) {
  jspb.Message.setField(this, 25, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearSightRange = function() {
  jspb.Message.setField(this, 25, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasSightRange = function() {
  return jspb.Message.getField(this, 25) != null;
};


/**
 * repeated uint32 tech_alias = 21;
 * @return {!Array.<number>}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getTechAliasList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getRepeatedField(this, 21));
};


/** @param {!Array.<number>} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setTechAliasList = function(value) {
  jspb.Message.setField(this, 21, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.UnitTypeData.prototype.addTechAlias = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 21, value, opt_index);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearTechAliasList = function() {
  this.setTechAliasList([]);
};


/**
 * optional uint32 unit_alias = 22;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getUnitAlias = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 22, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setUnitAlias = function(value) {
  jspb.Message.setField(this, 22, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearUnitAlias = function() {
  jspb.Message.setField(this, 22, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasUnitAlias = function() {
  return jspb.Message.getField(this, 22) != null;
};


/**
 * optional uint32 tech_requirement = 23;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getTechRequirement = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 23, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setTechRequirement = function(value) {
  jspb.Message.setField(this, 23, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearTechRequirement = function() {
  jspb.Message.setField(this, 23, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasTechRequirement = function() {
  return jspb.Message.getField(this, 23) != null;
};


/**
 * optional bool require_attached = 24;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getRequireAttached = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 24, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setRequireAttached = function(value) {
  jspb.Message.setField(this, 24, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearRequireAttached = function() {
  jspb.Message.setField(this, 24, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasRequireAttached = function() {
  return jspb.Message.getField(this, 24) != null;
};


/**
 * repeated Attribute attributes = 8;
 * @return {!Array.<!proto.SC2APIProtocol.Attribute>}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getAttributesList = function() {
  return /** @type {!Array.<!proto.SC2APIProtocol.Attribute>} */ (jspb.Message.getRepeatedField(this, 8));
};


/** @param {!Array.<!proto.SC2APIProtocol.Attribute>} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setAttributesList = function(value) {
  jspb.Message.setField(this, 8, value || []);
};


/**
 * @param {!proto.SC2APIProtocol.Attribute} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.UnitTypeData.prototype.addAttributes = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 8, value, opt_index);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearAttributesList = function() {
  this.setAttributesList([]);
};


/**
 * optional float movement_speed = 9;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getMovementSpeed = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 9, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setMovementSpeed = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearMovementSpeed = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasMovementSpeed = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional float armor = 10;
 * @return {number}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getArmor = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 10, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setArmor = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearArmor = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.hasArmor = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * repeated Weapon weapons = 11;
 * @return {!Array.<!proto.SC2APIProtocol.Weapon>}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.getWeaponsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.Weapon>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.Weapon, 11));
};


/** @param {!Array.<!proto.SC2APIProtocol.Weapon>} value */
proto.SC2APIProtocol.UnitTypeData.prototype.setWeaponsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 11, value);
};


/**
 * @param {!proto.SC2APIProtocol.Weapon=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.Weapon}
 */
proto.SC2APIProtocol.UnitTypeData.prototype.addWeapons = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 11, opt_value, proto.SC2APIProtocol.Weapon, opt_index);
};


proto.SC2APIProtocol.UnitTypeData.prototype.clearWeaponsList = function() {
  this.setWeaponsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.UpgradeData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.UpgradeData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.UpgradeData.displayName = 'proto.SC2APIProtocol.UpgradeData';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.UpgradeData.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.UpgradeData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.UpgradeData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.UpgradeData.toObject = function(includeInstance, msg) {
  var f, obj = {
    upgradeId: jspb.Message.getField(msg, 1),
    name: jspb.Message.getField(msg, 2),
    mineralCost: jspb.Message.getField(msg, 3),
    vespeneCost: jspb.Message.getField(msg, 4),
    researchTime: jspb.Message.getOptionalFloatingPointField(msg, 5),
    abilityId: jspb.Message.getField(msg, 6)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.UpgradeData}
 */
proto.SC2APIProtocol.UpgradeData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.UpgradeData;
  return proto.SC2APIProtocol.UpgradeData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.UpgradeData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.UpgradeData}
 */
proto.SC2APIProtocol.UpgradeData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setUpgradeId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMineralCost(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVespeneCost(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setResearchTime(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAbilityId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.UpgradeData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.UpgradeData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.UpgradeData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.UpgradeData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeFloat(
      5,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeUint32(
      6,
      f
    );
  }
};


/**
 * optional uint32 upgrade_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.UpgradeData.prototype.getUpgradeId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UpgradeData.prototype.setUpgradeId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.UpgradeData.prototype.clearUpgradeId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UpgradeData.prototype.hasUpgradeId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string name = 2;
 * @return {string}
 */
proto.SC2APIProtocol.UpgradeData.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.UpgradeData.prototype.setName = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.UpgradeData.prototype.clearName = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UpgradeData.prototype.hasName = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 mineral_cost = 3;
 * @return {number}
 */
proto.SC2APIProtocol.UpgradeData.prototype.getMineralCost = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UpgradeData.prototype.setMineralCost = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.UpgradeData.prototype.clearMineralCost = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UpgradeData.prototype.hasMineralCost = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional uint32 vespene_cost = 4;
 * @return {number}
 */
proto.SC2APIProtocol.UpgradeData.prototype.getVespeneCost = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UpgradeData.prototype.setVespeneCost = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.UpgradeData.prototype.clearVespeneCost = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UpgradeData.prototype.hasVespeneCost = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional float research_time = 5;
 * @return {number}
 */
proto.SC2APIProtocol.UpgradeData.prototype.getResearchTime = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 5, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.UpgradeData.prototype.setResearchTime = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.UpgradeData.prototype.clearResearchTime = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UpgradeData.prototype.hasResearchTime = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional uint32 ability_id = 6;
 * @return {number}
 */
proto.SC2APIProtocol.UpgradeData.prototype.getAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UpgradeData.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.UpgradeData.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UpgradeData.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.BuffData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.BuffData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.BuffData.displayName = 'proto.SC2APIProtocol.BuffData';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.BuffData.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.BuffData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.BuffData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.BuffData.toObject = function(includeInstance, msg) {
  var f, obj = {
    buffId: jspb.Message.getField(msg, 1),
    name: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.BuffData}
 */
proto.SC2APIProtocol.BuffData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.BuffData;
  return proto.SC2APIProtocol.BuffData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.BuffData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.BuffData}
 */
proto.SC2APIProtocol.BuffData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBuffId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.BuffData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.BuffData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.BuffData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.BuffData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional uint32 buff_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.BuffData.prototype.getBuffId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.BuffData.prototype.setBuffId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.BuffData.prototype.clearBuffId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.BuffData.prototype.hasBuffId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string name = 2;
 * @return {string}
 */
proto.SC2APIProtocol.BuffData.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.BuffData.prototype.setName = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.BuffData.prototype.clearName = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.BuffData.prototype.hasName = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.EffectData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.EffectData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.EffectData.displayName = 'proto.SC2APIProtocol.EffectData';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.EffectData.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.EffectData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.EffectData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.EffectData.toObject = function(includeInstance, msg) {
  var f, obj = {
    effectId: jspb.Message.getField(msg, 1),
    name: jspb.Message.getField(msg, 2),
    friendlyName: jspb.Message.getField(msg, 3),
    radius: jspb.Message.getOptionalFloatingPointField(msg, 4)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.EffectData}
 */
proto.SC2APIProtocol.EffectData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.EffectData;
  return proto.SC2APIProtocol.EffectData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.EffectData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.EffectData}
 */
proto.SC2APIProtocol.EffectData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setEffectId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setFriendlyName(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setRadius(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.EffectData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.EffectData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.EffectData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.EffectData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeFloat(
      4,
      f
    );
  }
};


/**
 * optional uint32 effect_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.EffectData.prototype.getEffectId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.EffectData.prototype.setEffectId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.EffectData.prototype.clearEffectId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.EffectData.prototype.hasEffectId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string name = 2;
 * @return {string}
 */
proto.SC2APIProtocol.EffectData.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.EffectData.prototype.setName = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.EffectData.prototype.clearName = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.EffectData.prototype.hasName = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string friendly_name = 3;
 * @return {string}
 */
proto.SC2APIProtocol.EffectData.prototype.getFriendlyName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.EffectData.prototype.setFriendlyName = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.EffectData.prototype.clearFriendlyName = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.EffectData.prototype.hasFriendlyName = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional float radius = 4;
 * @return {number}
 */
proto.SC2APIProtocol.EffectData.prototype.getRadius = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 4, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.EffectData.prototype.setRadius = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.EffectData.prototype.clearRadius = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.EffectData.prototype.hasRadius = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.Attribute = {
  LIGHT: 1,
  ARMORED: 2,
  BIOLOGICAL: 3,
  MECHANICAL: 4,
  ROBOTIC: 5,
  PSIONIC: 6,
  MASSIVE: 7,
  STRUCTURE: 8,
  HOVER: 9,
  HEROIC: 10,
  SUMMONED: 11
};

goog.object.extend(exports, proto.SC2APIProtocol);

},{"./common_pb.js":104,"google-protobuf":68}],106:[function(require,module,exports){
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var s2clientprotocol_common_pb = require('./common_pb.js');
goog.exportSymbol('proto.SC2APIProtocol.Color', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugBox', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugCommand', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugCreateUnit', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugDraw', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugEndGame', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugEndGame.EndResult', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugGameState', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugKillUnit', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugLine', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugSetScore', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugSetUnitValue', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugSetUnitValue.UnitValue', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugSphere', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugTestProcess', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugTestProcess.Test', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DebugText', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Line', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DebugCommand = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.SC2APIProtocol.DebugCommand.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.DebugCommand, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DebugCommand.displayName = 'proto.SC2APIProtocol.DebugCommand';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.DebugCommand.oneofGroups_ = [[1,2,3,4,5,6,7,8]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.DebugCommand.CommandCase = {
  COMMAND_NOT_SET: 0,
  DRAW: 1,
  GAME_STATE: 2,
  CREATE_UNIT: 3,
  KILL_UNIT: 4,
  TEST_PROCESS: 5,
  SCORE: 6,
  END_GAME: 7,
  UNIT_VALUE: 8
};

/**
 * @return {proto.SC2APIProtocol.DebugCommand.CommandCase}
 */
proto.SC2APIProtocol.DebugCommand.prototype.getCommandCase = function() {
  return /** @type {proto.SC2APIProtocol.DebugCommand.CommandCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.DebugCommand.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DebugCommand.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DebugCommand.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DebugCommand} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugCommand.toObject = function(includeInstance, msg) {
  var f, obj = {
    draw: (f = msg.getDraw()) && proto.SC2APIProtocol.DebugDraw.toObject(includeInstance, f),
    gameState: jspb.Message.getField(msg, 2),
    createUnit: (f = msg.getCreateUnit()) && proto.SC2APIProtocol.DebugCreateUnit.toObject(includeInstance, f),
    killUnit: (f = msg.getKillUnit()) && proto.SC2APIProtocol.DebugKillUnit.toObject(includeInstance, f),
    testProcess: (f = msg.getTestProcess()) && proto.SC2APIProtocol.DebugTestProcess.toObject(includeInstance, f),
    score: (f = msg.getScore()) && proto.SC2APIProtocol.DebugSetScore.toObject(includeInstance, f),
    endGame: (f = msg.getEndGame()) && proto.SC2APIProtocol.DebugEndGame.toObject(includeInstance, f),
    unitValue: (f = msg.getUnitValue()) && proto.SC2APIProtocol.DebugSetUnitValue.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DebugCommand}
 */
proto.SC2APIProtocol.DebugCommand.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DebugCommand;
  return proto.SC2APIProtocol.DebugCommand.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DebugCommand} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DebugCommand}
 */
proto.SC2APIProtocol.DebugCommand.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.DebugDraw;
      reader.readMessage(value,proto.SC2APIProtocol.DebugDraw.deserializeBinaryFromReader);
      msg.setDraw(value);
      break;
    case 2:
      var value = /** @type {!proto.SC2APIProtocol.DebugGameState} */ (reader.readEnum());
      msg.setGameState(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.DebugCreateUnit;
      reader.readMessage(value,proto.SC2APIProtocol.DebugCreateUnit.deserializeBinaryFromReader);
      msg.setCreateUnit(value);
      break;
    case 4:
      var value = new proto.SC2APIProtocol.DebugKillUnit;
      reader.readMessage(value,proto.SC2APIProtocol.DebugKillUnit.deserializeBinaryFromReader);
      msg.setKillUnit(value);
      break;
    case 5:
      var value = new proto.SC2APIProtocol.DebugTestProcess;
      reader.readMessage(value,proto.SC2APIProtocol.DebugTestProcess.deserializeBinaryFromReader);
      msg.setTestProcess(value);
      break;
    case 6:
      var value = new proto.SC2APIProtocol.DebugSetScore;
      reader.readMessage(value,proto.SC2APIProtocol.DebugSetScore.deserializeBinaryFromReader);
      msg.setScore(value);
      break;
    case 7:
      var value = new proto.SC2APIProtocol.DebugEndGame;
      reader.readMessage(value,proto.SC2APIProtocol.DebugEndGame.deserializeBinaryFromReader);
      msg.setEndGame(value);
      break;
    case 8:
      var value = new proto.SC2APIProtocol.DebugSetUnitValue;
      reader.readMessage(value,proto.SC2APIProtocol.DebugSetUnitValue.deserializeBinaryFromReader);
      msg.setUnitValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DebugCommand.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DebugCommand.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DebugCommand} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugCommand.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDraw();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.DebugDraw.serializeBinaryToWriter
    );
  }
  f = /** @type {!proto.SC2APIProtocol.DebugGameState} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getCreateUnit();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.DebugCreateUnit.serializeBinaryToWriter
    );
  }
  f = message.getKillUnit();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.SC2APIProtocol.DebugKillUnit.serializeBinaryToWriter
    );
  }
  f = message.getTestProcess();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.SC2APIProtocol.DebugTestProcess.serializeBinaryToWriter
    );
  }
  f = message.getScore();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.SC2APIProtocol.DebugSetScore.serializeBinaryToWriter
    );
  }
  f = message.getEndGame();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.SC2APIProtocol.DebugEndGame.serializeBinaryToWriter
    );
  }
  f = message.getUnitValue();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.SC2APIProtocol.DebugSetUnitValue.serializeBinaryToWriter
    );
  }
};


/**
 * optional DebugDraw draw = 1;
 * @return {?proto.SC2APIProtocol.DebugDraw}
 */
proto.SC2APIProtocol.DebugCommand.prototype.getDraw = function() {
  return /** @type{?proto.SC2APIProtocol.DebugDraw} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.DebugDraw, 1));
};


/** @param {?proto.SC2APIProtocol.DebugDraw|undefined} value */
proto.SC2APIProtocol.DebugCommand.prototype.setDraw = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.SC2APIProtocol.DebugCommand.oneofGroups_[0], value);
};


proto.SC2APIProtocol.DebugCommand.prototype.clearDraw = function() {
  this.setDraw(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugCommand.prototype.hasDraw = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional DebugGameState game_state = 2;
 * @return {!proto.SC2APIProtocol.DebugGameState}
 */
proto.SC2APIProtocol.DebugCommand.prototype.getGameState = function() {
  return /** @type {!proto.SC2APIProtocol.DebugGameState} */ (jspb.Message.getFieldWithDefault(this, 2, 1));
};


/** @param {!proto.SC2APIProtocol.DebugGameState} value */
proto.SC2APIProtocol.DebugCommand.prototype.setGameState = function(value) {
  jspb.Message.setOneofField(this, 2, proto.SC2APIProtocol.DebugCommand.oneofGroups_[0], value);
};


proto.SC2APIProtocol.DebugCommand.prototype.clearGameState = function() {
  jspb.Message.setOneofField(this, 2, proto.SC2APIProtocol.DebugCommand.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugCommand.prototype.hasGameState = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional DebugCreateUnit create_unit = 3;
 * @return {?proto.SC2APIProtocol.DebugCreateUnit}
 */
proto.SC2APIProtocol.DebugCommand.prototype.getCreateUnit = function() {
  return /** @type{?proto.SC2APIProtocol.DebugCreateUnit} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.DebugCreateUnit, 3));
};


/** @param {?proto.SC2APIProtocol.DebugCreateUnit|undefined} value */
proto.SC2APIProtocol.DebugCommand.prototype.setCreateUnit = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.SC2APIProtocol.DebugCommand.oneofGroups_[0], value);
};


proto.SC2APIProtocol.DebugCommand.prototype.clearCreateUnit = function() {
  this.setCreateUnit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugCommand.prototype.hasCreateUnit = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional DebugKillUnit kill_unit = 4;
 * @return {?proto.SC2APIProtocol.DebugKillUnit}
 */
proto.SC2APIProtocol.DebugCommand.prototype.getKillUnit = function() {
  return /** @type{?proto.SC2APIProtocol.DebugKillUnit} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.DebugKillUnit, 4));
};


/** @param {?proto.SC2APIProtocol.DebugKillUnit|undefined} value */
proto.SC2APIProtocol.DebugCommand.prototype.setKillUnit = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.SC2APIProtocol.DebugCommand.oneofGroups_[0], value);
};


proto.SC2APIProtocol.DebugCommand.prototype.clearKillUnit = function() {
  this.setKillUnit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugCommand.prototype.hasKillUnit = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional DebugTestProcess test_process = 5;
 * @return {?proto.SC2APIProtocol.DebugTestProcess}
 */
proto.SC2APIProtocol.DebugCommand.prototype.getTestProcess = function() {
  return /** @type{?proto.SC2APIProtocol.DebugTestProcess} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.DebugTestProcess, 5));
};


/** @param {?proto.SC2APIProtocol.DebugTestProcess|undefined} value */
proto.SC2APIProtocol.DebugCommand.prototype.setTestProcess = function(value) {
  jspb.Message.setOneofWrapperField(this, 5, proto.SC2APIProtocol.DebugCommand.oneofGroups_[0], value);
};


proto.SC2APIProtocol.DebugCommand.prototype.clearTestProcess = function() {
  this.setTestProcess(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugCommand.prototype.hasTestProcess = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional DebugSetScore score = 6;
 * @return {?proto.SC2APIProtocol.DebugSetScore}
 */
proto.SC2APIProtocol.DebugCommand.prototype.getScore = function() {
  return /** @type{?proto.SC2APIProtocol.DebugSetScore} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.DebugSetScore, 6));
};


/** @param {?proto.SC2APIProtocol.DebugSetScore|undefined} value */
proto.SC2APIProtocol.DebugCommand.prototype.setScore = function(value) {
  jspb.Message.setOneofWrapperField(this, 6, proto.SC2APIProtocol.DebugCommand.oneofGroups_[0], value);
};


proto.SC2APIProtocol.DebugCommand.prototype.clearScore = function() {
  this.setScore(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugCommand.prototype.hasScore = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional DebugEndGame end_game = 7;
 * @return {?proto.SC2APIProtocol.DebugEndGame}
 */
proto.SC2APIProtocol.DebugCommand.prototype.getEndGame = function() {
  return /** @type{?proto.SC2APIProtocol.DebugEndGame} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.DebugEndGame, 7));
};


/** @param {?proto.SC2APIProtocol.DebugEndGame|undefined} value */
proto.SC2APIProtocol.DebugCommand.prototype.setEndGame = function(value) {
  jspb.Message.setOneofWrapperField(this, 7, proto.SC2APIProtocol.DebugCommand.oneofGroups_[0], value);
};


proto.SC2APIProtocol.DebugCommand.prototype.clearEndGame = function() {
  this.setEndGame(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugCommand.prototype.hasEndGame = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional DebugSetUnitValue unit_value = 8;
 * @return {?proto.SC2APIProtocol.DebugSetUnitValue}
 */
proto.SC2APIProtocol.DebugCommand.prototype.getUnitValue = function() {
  return /** @type{?proto.SC2APIProtocol.DebugSetUnitValue} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.DebugSetUnitValue, 8));
};


/** @param {?proto.SC2APIProtocol.DebugSetUnitValue|undefined} value */
proto.SC2APIProtocol.DebugCommand.prototype.setUnitValue = function(value) {
  jspb.Message.setOneofWrapperField(this, 8, proto.SC2APIProtocol.DebugCommand.oneofGroups_[0], value);
};


proto.SC2APIProtocol.DebugCommand.prototype.clearUnitValue = function() {
  this.setUnitValue(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugCommand.prototype.hasUnitValue = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DebugDraw = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.DebugDraw.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.DebugDraw, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DebugDraw.displayName = 'proto.SC2APIProtocol.DebugDraw';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.DebugDraw.repeatedFields_ = [1,2,3,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DebugDraw.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DebugDraw.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DebugDraw} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugDraw.toObject = function(includeInstance, msg) {
  var f, obj = {
    textList: jspb.Message.toObjectList(msg.getTextList(),
    proto.SC2APIProtocol.DebugText.toObject, includeInstance),
    linesList: jspb.Message.toObjectList(msg.getLinesList(),
    proto.SC2APIProtocol.DebugLine.toObject, includeInstance),
    boxesList: jspb.Message.toObjectList(msg.getBoxesList(),
    proto.SC2APIProtocol.DebugBox.toObject, includeInstance),
    spheresList: jspb.Message.toObjectList(msg.getSpheresList(),
    proto.SC2APIProtocol.DebugSphere.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DebugDraw}
 */
proto.SC2APIProtocol.DebugDraw.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DebugDraw;
  return proto.SC2APIProtocol.DebugDraw.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DebugDraw} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DebugDraw}
 */
proto.SC2APIProtocol.DebugDraw.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.DebugText;
      reader.readMessage(value,proto.SC2APIProtocol.DebugText.deserializeBinaryFromReader);
      msg.addText(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.DebugLine;
      reader.readMessage(value,proto.SC2APIProtocol.DebugLine.deserializeBinaryFromReader);
      msg.addLines(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.DebugBox;
      reader.readMessage(value,proto.SC2APIProtocol.DebugBox.deserializeBinaryFromReader);
      msg.addBoxes(value);
      break;
    case 4:
      var value = new proto.SC2APIProtocol.DebugSphere;
      reader.readMessage(value,proto.SC2APIProtocol.DebugSphere.deserializeBinaryFromReader);
      msg.addSpheres(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DebugDraw.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DebugDraw.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DebugDraw} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugDraw.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTextList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.SC2APIProtocol.DebugText.serializeBinaryToWriter
    );
  }
  f = message.getLinesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.SC2APIProtocol.DebugLine.serializeBinaryToWriter
    );
  }
  f = message.getBoxesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.SC2APIProtocol.DebugBox.serializeBinaryToWriter
    );
  }
  f = message.getSpheresList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.SC2APIProtocol.DebugSphere.serializeBinaryToWriter
    );
  }
};


/**
 * repeated DebugText text = 1;
 * @return {!Array.<!proto.SC2APIProtocol.DebugText>}
 */
proto.SC2APIProtocol.DebugDraw.prototype.getTextList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.DebugText>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.DebugText, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.DebugText>} value */
proto.SC2APIProtocol.DebugDraw.prototype.setTextList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.DebugText=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.DebugText}
 */
proto.SC2APIProtocol.DebugDraw.prototype.addText = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.DebugText, opt_index);
};


proto.SC2APIProtocol.DebugDraw.prototype.clearTextList = function() {
  this.setTextList([]);
};


/**
 * repeated DebugLine lines = 2;
 * @return {!Array.<!proto.SC2APIProtocol.DebugLine>}
 */
proto.SC2APIProtocol.DebugDraw.prototype.getLinesList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.DebugLine>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.DebugLine, 2));
};


/** @param {!Array.<!proto.SC2APIProtocol.DebugLine>} value */
proto.SC2APIProtocol.DebugDraw.prototype.setLinesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.SC2APIProtocol.DebugLine=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.DebugLine}
 */
proto.SC2APIProtocol.DebugDraw.prototype.addLines = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.SC2APIProtocol.DebugLine, opt_index);
};


proto.SC2APIProtocol.DebugDraw.prototype.clearLinesList = function() {
  this.setLinesList([]);
};


/**
 * repeated DebugBox boxes = 3;
 * @return {!Array.<!proto.SC2APIProtocol.DebugBox>}
 */
proto.SC2APIProtocol.DebugDraw.prototype.getBoxesList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.DebugBox>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.DebugBox, 3));
};


/** @param {!Array.<!proto.SC2APIProtocol.DebugBox>} value */
proto.SC2APIProtocol.DebugDraw.prototype.setBoxesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.SC2APIProtocol.DebugBox=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.DebugBox}
 */
proto.SC2APIProtocol.DebugDraw.prototype.addBoxes = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.SC2APIProtocol.DebugBox, opt_index);
};


proto.SC2APIProtocol.DebugDraw.prototype.clearBoxesList = function() {
  this.setBoxesList([]);
};


/**
 * repeated DebugSphere spheres = 4;
 * @return {!Array.<!proto.SC2APIProtocol.DebugSphere>}
 */
proto.SC2APIProtocol.DebugDraw.prototype.getSpheresList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.DebugSphere>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.DebugSphere, 4));
};


/** @param {!Array.<!proto.SC2APIProtocol.DebugSphere>} value */
proto.SC2APIProtocol.DebugDraw.prototype.setSpheresList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.SC2APIProtocol.DebugSphere=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.DebugSphere}
 */
proto.SC2APIProtocol.DebugDraw.prototype.addSpheres = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.SC2APIProtocol.DebugSphere, opt_index);
};


proto.SC2APIProtocol.DebugDraw.prototype.clearSpheresList = function() {
  this.setSpheresList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Line = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.Line, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Line.displayName = 'proto.SC2APIProtocol.Line';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Line.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Line.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Line} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Line.toObject = function(includeInstance, msg) {
  var f, obj = {
    p0: (f = msg.getP0()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f),
    p1: (f = msg.getP1()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Line}
 */
proto.SC2APIProtocol.Line.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Line;
  return proto.SC2APIProtocol.Line.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Line} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Line}
 */
proto.SC2APIProtocol.Line.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setP0(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setP1(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Line.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Line.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Line} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Line.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getP0();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
  f = message.getP1();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
};


/**
 * optional Point p0 = 1;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.Line.prototype.getP0 = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 1));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.Line.prototype.setP0 = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.Line.prototype.clearP0 = function() {
  this.setP0(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Line.prototype.hasP0 = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Point p1 = 2;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.Line.prototype.getP1 = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 2));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.Line.prototype.setP1 = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.Line.prototype.clearP1 = function() {
  this.setP1(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Line.prototype.hasP1 = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Color = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.Color, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Color.displayName = 'proto.SC2APIProtocol.Color';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Color.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Color.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Color} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Color.toObject = function(includeInstance, msg) {
  var f, obj = {
    r: jspb.Message.getField(msg, 1),
    g: jspb.Message.getField(msg, 2),
    b: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Color}
 */
proto.SC2APIProtocol.Color.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Color;
  return proto.SC2APIProtocol.Color.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Color} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Color}
 */
proto.SC2APIProtocol.Color.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setR(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setG(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setB(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Color.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Color.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Color} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Color.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * optional uint32 r = 1;
 * @return {number}
 */
proto.SC2APIProtocol.Color.prototype.getR = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Color.prototype.setR = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.Color.prototype.clearR = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Color.prototype.hasR = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 g = 2;
 * @return {number}
 */
proto.SC2APIProtocol.Color.prototype.getG = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Color.prototype.setG = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.Color.prototype.clearG = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Color.prototype.hasG = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 b = 3;
 * @return {number}
 */
proto.SC2APIProtocol.Color.prototype.getB = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Color.prototype.setB = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.Color.prototype.clearB = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Color.prototype.hasB = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DebugText = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.DebugText, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DebugText.displayName = 'proto.SC2APIProtocol.DebugText';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DebugText.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DebugText.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DebugText} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugText.toObject = function(includeInstance, msg) {
  var f, obj = {
    color: (f = msg.getColor()) && proto.SC2APIProtocol.Color.toObject(includeInstance, f),
    text: jspb.Message.getField(msg, 2),
    virtualPos: (f = msg.getVirtualPos()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f),
    worldPos: (f = msg.getWorldPos()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f),
    size: jspb.Message.getField(msg, 5)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DebugText}
 */
proto.SC2APIProtocol.DebugText.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DebugText;
  return proto.SC2APIProtocol.DebugText.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DebugText} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DebugText}
 */
proto.SC2APIProtocol.DebugText.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.Color;
      reader.readMessage(value,proto.SC2APIProtocol.Color.deserializeBinaryFromReader);
      msg.setColor(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setText(value);
      break;
    case 3:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setVirtualPos(value);
      break;
    case 4:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setWorldPos(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSize(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DebugText.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DebugText.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DebugText} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugText.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getColor();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.Color.serializeBinaryToWriter
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getVirtualPos();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
  f = message.getWorldPos();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeUint32(
      5,
      f
    );
  }
};


/**
 * optional Color color = 1;
 * @return {?proto.SC2APIProtocol.Color}
 */
proto.SC2APIProtocol.DebugText.prototype.getColor = function() {
  return /** @type{?proto.SC2APIProtocol.Color} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.Color, 1));
};


/** @param {?proto.SC2APIProtocol.Color|undefined} value */
proto.SC2APIProtocol.DebugText.prototype.setColor = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.DebugText.prototype.clearColor = function() {
  this.setColor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugText.prototype.hasColor = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string text = 2;
 * @return {string}
 */
proto.SC2APIProtocol.DebugText.prototype.getText = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.DebugText.prototype.setText = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.DebugText.prototype.clearText = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugText.prototype.hasText = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Point virtual_pos = 3;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.DebugText.prototype.getVirtualPos = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 3));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.DebugText.prototype.setVirtualPos = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.DebugText.prototype.clearVirtualPos = function() {
  this.setVirtualPos(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugText.prototype.hasVirtualPos = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Point world_pos = 4;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.DebugText.prototype.getWorldPos = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 4));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.DebugText.prototype.setWorldPos = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.SC2APIProtocol.DebugText.prototype.clearWorldPos = function() {
  this.setWorldPos(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugText.prototype.hasWorldPos = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional uint32 size = 5;
 * @return {number}
 */
proto.SC2APIProtocol.DebugText.prototype.getSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.DebugText.prototype.setSize = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.DebugText.prototype.clearSize = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugText.prototype.hasSize = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DebugLine = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.DebugLine, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DebugLine.displayName = 'proto.SC2APIProtocol.DebugLine';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DebugLine.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DebugLine.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DebugLine} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugLine.toObject = function(includeInstance, msg) {
  var f, obj = {
    color: (f = msg.getColor()) && proto.SC2APIProtocol.Color.toObject(includeInstance, f),
    line: (f = msg.getLine()) && proto.SC2APIProtocol.Line.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DebugLine}
 */
proto.SC2APIProtocol.DebugLine.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DebugLine;
  return proto.SC2APIProtocol.DebugLine.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DebugLine} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DebugLine}
 */
proto.SC2APIProtocol.DebugLine.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.Color;
      reader.readMessage(value,proto.SC2APIProtocol.Color.deserializeBinaryFromReader);
      msg.setColor(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.Line;
      reader.readMessage(value,proto.SC2APIProtocol.Line.deserializeBinaryFromReader);
      msg.setLine(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DebugLine.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DebugLine.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DebugLine} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugLine.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getColor();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.Color.serializeBinaryToWriter
    );
  }
  f = message.getLine();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.SC2APIProtocol.Line.serializeBinaryToWriter
    );
  }
};


/**
 * optional Color color = 1;
 * @return {?proto.SC2APIProtocol.Color}
 */
proto.SC2APIProtocol.DebugLine.prototype.getColor = function() {
  return /** @type{?proto.SC2APIProtocol.Color} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.Color, 1));
};


/** @param {?proto.SC2APIProtocol.Color|undefined} value */
proto.SC2APIProtocol.DebugLine.prototype.setColor = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.DebugLine.prototype.clearColor = function() {
  this.setColor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugLine.prototype.hasColor = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Line line = 2;
 * @return {?proto.SC2APIProtocol.Line}
 */
proto.SC2APIProtocol.DebugLine.prototype.getLine = function() {
  return /** @type{?proto.SC2APIProtocol.Line} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.Line, 2));
};


/** @param {?proto.SC2APIProtocol.Line|undefined} value */
proto.SC2APIProtocol.DebugLine.prototype.setLine = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.DebugLine.prototype.clearLine = function() {
  this.setLine(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugLine.prototype.hasLine = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DebugBox = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.DebugBox, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DebugBox.displayName = 'proto.SC2APIProtocol.DebugBox';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DebugBox.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DebugBox.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DebugBox} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugBox.toObject = function(includeInstance, msg) {
  var f, obj = {
    color: (f = msg.getColor()) && proto.SC2APIProtocol.Color.toObject(includeInstance, f),
    min: (f = msg.getMin()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f),
    max: (f = msg.getMax()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DebugBox}
 */
proto.SC2APIProtocol.DebugBox.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DebugBox;
  return proto.SC2APIProtocol.DebugBox.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DebugBox} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DebugBox}
 */
proto.SC2APIProtocol.DebugBox.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.Color;
      reader.readMessage(value,proto.SC2APIProtocol.Color.deserializeBinaryFromReader);
      msg.setColor(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setMin(value);
      break;
    case 3:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setMax(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DebugBox.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DebugBox.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DebugBox} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugBox.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getColor();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.Color.serializeBinaryToWriter
    );
  }
  f = message.getMin();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
  f = message.getMax();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
};


/**
 * optional Color color = 1;
 * @return {?proto.SC2APIProtocol.Color}
 */
proto.SC2APIProtocol.DebugBox.prototype.getColor = function() {
  return /** @type{?proto.SC2APIProtocol.Color} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.Color, 1));
};


/** @param {?proto.SC2APIProtocol.Color|undefined} value */
proto.SC2APIProtocol.DebugBox.prototype.setColor = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.DebugBox.prototype.clearColor = function() {
  this.setColor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugBox.prototype.hasColor = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Point min = 2;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.DebugBox.prototype.getMin = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 2));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.DebugBox.prototype.setMin = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.DebugBox.prototype.clearMin = function() {
  this.setMin(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugBox.prototype.hasMin = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Point max = 3;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.DebugBox.prototype.getMax = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 3));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.DebugBox.prototype.setMax = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.DebugBox.prototype.clearMax = function() {
  this.setMax(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugBox.prototype.hasMax = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DebugSphere = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.DebugSphere, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DebugSphere.displayName = 'proto.SC2APIProtocol.DebugSphere';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DebugSphere.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DebugSphere.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DebugSphere} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugSphere.toObject = function(includeInstance, msg) {
  var f, obj = {
    color: (f = msg.getColor()) && proto.SC2APIProtocol.Color.toObject(includeInstance, f),
    p: (f = msg.getP()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f),
    r: jspb.Message.getOptionalFloatingPointField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DebugSphere}
 */
proto.SC2APIProtocol.DebugSphere.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DebugSphere;
  return proto.SC2APIProtocol.DebugSphere.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DebugSphere} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DebugSphere}
 */
proto.SC2APIProtocol.DebugSphere.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.Color;
      reader.readMessage(value,proto.SC2APIProtocol.Color.deserializeBinaryFromReader);
      msg.setColor(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setP(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setR(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DebugSphere.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DebugSphere.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DebugSphere} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugSphere.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getColor();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.Color.serializeBinaryToWriter
    );
  }
  f = message.getP();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeFloat(
      3,
      f
    );
  }
};


/**
 * optional Color color = 1;
 * @return {?proto.SC2APIProtocol.Color}
 */
proto.SC2APIProtocol.DebugSphere.prototype.getColor = function() {
  return /** @type{?proto.SC2APIProtocol.Color} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.Color, 1));
};


/** @param {?proto.SC2APIProtocol.Color|undefined} value */
proto.SC2APIProtocol.DebugSphere.prototype.setColor = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.DebugSphere.prototype.clearColor = function() {
  this.setColor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugSphere.prototype.hasColor = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Point p = 2;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.DebugSphere.prototype.getP = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 2));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.DebugSphere.prototype.setP = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.DebugSphere.prototype.clearP = function() {
  this.setP(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugSphere.prototype.hasP = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional float r = 3;
 * @return {number}
 */
proto.SC2APIProtocol.DebugSphere.prototype.getR = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 3, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.DebugSphere.prototype.setR = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.DebugSphere.prototype.clearR = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugSphere.prototype.hasR = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DebugCreateUnit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.DebugCreateUnit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DebugCreateUnit.displayName = 'proto.SC2APIProtocol.DebugCreateUnit';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DebugCreateUnit.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DebugCreateUnit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DebugCreateUnit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugCreateUnit.toObject = function(includeInstance, msg) {
  var f, obj = {
    unitType: jspb.Message.getField(msg, 1),
    owner: jspb.Message.getField(msg, 2),
    pos: (f = msg.getPos()) && s2clientprotocol_common_pb.Point2D.toObject(includeInstance, f),
    quantity: jspb.Message.getField(msg, 4)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DebugCreateUnit}
 */
proto.SC2APIProtocol.DebugCreateUnit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DebugCreateUnit;
  return proto.SC2APIProtocol.DebugCreateUnit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DebugCreateUnit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DebugCreateUnit}
 */
proto.SC2APIProtocol.DebugCreateUnit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setUnitType(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setOwner(value);
      break;
    case 3:
      var value = new s2clientprotocol_common_pb.Point2D;
      reader.readMessage(value,s2clientprotocol_common_pb.Point2D.deserializeBinaryFromReader);
      msg.setPos(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setQuantity(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DebugCreateUnit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DebugCreateUnit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DebugCreateUnit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugCreateUnit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getPos();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      s2clientprotocol_common_pb.Point2D.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
};


/**
 * optional uint32 unit_type = 1;
 * @return {number}
 */
proto.SC2APIProtocol.DebugCreateUnit.prototype.getUnitType = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.DebugCreateUnit.prototype.setUnitType = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.DebugCreateUnit.prototype.clearUnitType = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugCreateUnit.prototype.hasUnitType = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int32 owner = 2;
 * @return {number}
 */
proto.SC2APIProtocol.DebugCreateUnit.prototype.getOwner = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.DebugCreateUnit.prototype.setOwner = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.DebugCreateUnit.prototype.clearOwner = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugCreateUnit.prototype.hasOwner = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Point2D pos = 3;
 * @return {?proto.SC2APIProtocol.Point2D}
 */
proto.SC2APIProtocol.DebugCreateUnit.prototype.getPos = function() {
  return /** @type{?proto.SC2APIProtocol.Point2D} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point2D, 3));
};


/** @param {?proto.SC2APIProtocol.Point2D|undefined} value */
proto.SC2APIProtocol.DebugCreateUnit.prototype.setPos = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.DebugCreateUnit.prototype.clearPos = function() {
  this.setPos(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugCreateUnit.prototype.hasPos = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional uint32 quantity = 4;
 * @return {number}
 */
proto.SC2APIProtocol.DebugCreateUnit.prototype.getQuantity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.DebugCreateUnit.prototype.setQuantity = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.DebugCreateUnit.prototype.clearQuantity = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugCreateUnit.prototype.hasQuantity = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DebugKillUnit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.DebugKillUnit.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.DebugKillUnit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DebugKillUnit.displayName = 'proto.SC2APIProtocol.DebugKillUnit';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.DebugKillUnit.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DebugKillUnit.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DebugKillUnit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DebugKillUnit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugKillUnit.toObject = function(includeInstance, msg) {
  var f, obj = {
    tagList: jspb.Message.getRepeatedField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DebugKillUnit}
 */
proto.SC2APIProtocol.DebugKillUnit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DebugKillUnit;
  return proto.SC2APIProtocol.DebugKillUnit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DebugKillUnit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DebugKillUnit}
 */
proto.SC2APIProtocol.DebugKillUnit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.addTag(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DebugKillUnit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DebugKillUnit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DebugKillUnit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugKillUnit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTagList();
  if (f.length > 0) {
    writer.writeRepeatedUint64(
      1,
      f
    );
  }
};


/**
 * repeated uint64 tag = 1;
 * @return {!Array.<number>}
 */
proto.SC2APIProtocol.DebugKillUnit.prototype.getTagList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array.<number>} value */
proto.SC2APIProtocol.DebugKillUnit.prototype.setTagList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.DebugKillUnit.prototype.addTag = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.SC2APIProtocol.DebugKillUnit.prototype.clearTagList = function() {
  this.setTagList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DebugTestProcess = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.DebugTestProcess, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DebugTestProcess.displayName = 'proto.SC2APIProtocol.DebugTestProcess';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DebugTestProcess.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DebugTestProcess.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DebugTestProcess} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugTestProcess.toObject = function(includeInstance, msg) {
  var f, obj = {
    test: jspb.Message.getField(msg, 1),
    delayMs: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DebugTestProcess}
 */
proto.SC2APIProtocol.DebugTestProcess.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DebugTestProcess;
  return proto.SC2APIProtocol.DebugTestProcess.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DebugTestProcess} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DebugTestProcess}
 */
proto.SC2APIProtocol.DebugTestProcess.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.DebugTestProcess.Test} */ (reader.readEnum());
      msg.setTest(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setDelayMs(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DebugTestProcess.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DebugTestProcess.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DebugTestProcess} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugTestProcess.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.DebugTestProcess.Test} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.DebugTestProcess.Test = {
  HANG: 1,
  CRASH: 2,
  EXIT: 3
};

/**
 * optional Test test = 1;
 * @return {!proto.SC2APIProtocol.DebugTestProcess.Test}
 */
proto.SC2APIProtocol.DebugTestProcess.prototype.getTest = function() {
  return /** @type {!proto.SC2APIProtocol.DebugTestProcess.Test} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.DebugTestProcess.Test} value */
proto.SC2APIProtocol.DebugTestProcess.prototype.setTest = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.DebugTestProcess.prototype.clearTest = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugTestProcess.prototype.hasTest = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int32 delay_ms = 2;
 * @return {number}
 */
proto.SC2APIProtocol.DebugTestProcess.prototype.getDelayMs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.DebugTestProcess.prototype.setDelayMs = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.DebugTestProcess.prototype.clearDelayMs = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugTestProcess.prototype.hasDelayMs = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DebugSetScore = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.DebugSetScore, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DebugSetScore.displayName = 'proto.SC2APIProtocol.DebugSetScore';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DebugSetScore.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DebugSetScore.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DebugSetScore} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugSetScore.toObject = function(includeInstance, msg) {
  var f, obj = {
    score: jspb.Message.getOptionalFloatingPointField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DebugSetScore}
 */
proto.SC2APIProtocol.DebugSetScore.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DebugSetScore;
  return proto.SC2APIProtocol.DebugSetScore.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DebugSetScore} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DebugSetScore}
 */
proto.SC2APIProtocol.DebugSetScore.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setScore(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DebugSetScore.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DebugSetScore.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DebugSetScore} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugSetScore.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeFloat(
      1,
      f
    );
  }
};


/**
 * optional float score = 1;
 * @return {number}
 */
proto.SC2APIProtocol.DebugSetScore.prototype.getScore = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 1, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.DebugSetScore.prototype.setScore = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.DebugSetScore.prototype.clearScore = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugSetScore.prototype.hasScore = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DebugEndGame = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.DebugEndGame, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DebugEndGame.displayName = 'proto.SC2APIProtocol.DebugEndGame';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DebugEndGame.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DebugEndGame.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DebugEndGame} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugEndGame.toObject = function(includeInstance, msg) {
  var f, obj = {
    endResult: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DebugEndGame}
 */
proto.SC2APIProtocol.DebugEndGame.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DebugEndGame;
  return proto.SC2APIProtocol.DebugEndGame.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DebugEndGame} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DebugEndGame}
 */
proto.SC2APIProtocol.DebugEndGame.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.DebugEndGame.EndResult} */ (reader.readEnum());
      msg.setEndResult(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DebugEndGame.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DebugEndGame.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DebugEndGame} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugEndGame.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.DebugEndGame.EndResult} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.DebugEndGame.EndResult = {
  SURRENDER: 1,
  DECLAREVICTORY: 2
};

/**
 * optional EndResult end_result = 1;
 * @return {!proto.SC2APIProtocol.DebugEndGame.EndResult}
 */
proto.SC2APIProtocol.DebugEndGame.prototype.getEndResult = function() {
  return /** @type {!proto.SC2APIProtocol.DebugEndGame.EndResult} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.DebugEndGame.EndResult} value */
proto.SC2APIProtocol.DebugEndGame.prototype.setEndResult = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.DebugEndGame.prototype.clearEndResult = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugEndGame.prototype.hasEndResult = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.DebugSetUnitValue = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.DebugSetUnitValue, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.DebugSetUnitValue.displayName = 'proto.SC2APIProtocol.DebugSetUnitValue';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.DebugSetUnitValue.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.DebugSetUnitValue.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.DebugSetUnitValue} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugSetUnitValue.toObject = function(includeInstance, msg) {
  var f, obj = {
    unitValue: jspb.Message.getField(msg, 1),
    value: jspb.Message.getOptionalFloatingPointField(msg, 2),
    unitTag: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.DebugSetUnitValue}
 */
proto.SC2APIProtocol.DebugSetUnitValue.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.DebugSetUnitValue;
  return proto.SC2APIProtocol.DebugSetUnitValue.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.DebugSetUnitValue} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.DebugSetUnitValue}
 */
proto.SC2APIProtocol.DebugSetUnitValue.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.DebugSetUnitValue.UnitValue} */ (reader.readEnum());
      msg.setUnitValue(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setValue(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setUnitTag(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.DebugSetUnitValue.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.DebugSetUnitValue.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.DebugSetUnitValue} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.DebugSetUnitValue.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.DebugSetUnitValue.UnitValue} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint64(
      3,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.DebugSetUnitValue.UnitValue = {
  ENERGY: 1,
  LIFE: 2,
  SHIELDS: 3
};

/**
 * optional UnitValue unit_value = 1;
 * @return {!proto.SC2APIProtocol.DebugSetUnitValue.UnitValue}
 */
proto.SC2APIProtocol.DebugSetUnitValue.prototype.getUnitValue = function() {
  return /** @type {!proto.SC2APIProtocol.DebugSetUnitValue.UnitValue} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.DebugSetUnitValue.UnitValue} value */
proto.SC2APIProtocol.DebugSetUnitValue.prototype.setUnitValue = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.DebugSetUnitValue.prototype.clearUnitValue = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugSetUnitValue.prototype.hasUnitValue = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float value = 2;
 * @return {number}
 */
proto.SC2APIProtocol.DebugSetUnitValue.prototype.getValue = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.DebugSetUnitValue.prototype.setValue = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.DebugSetUnitValue.prototype.clearValue = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugSetUnitValue.prototype.hasValue = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint64 unit_tag = 3;
 * @return {number}
 */
proto.SC2APIProtocol.DebugSetUnitValue.prototype.getUnitTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.DebugSetUnitValue.prototype.setUnitTag = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.DebugSetUnitValue.prototype.clearUnitTag = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.DebugSetUnitValue.prototype.hasUnitTag = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.DebugGameState = {
  SHOW_MAP: 1,
  CONTROL_ENEMY: 2,
  FOOD: 3,
  FREE: 4,
  ALL_RESOURCES: 5,
  GOD: 6,
  MINERALS: 7,
  GAS: 8,
  COOLDOWN: 9,
  TECH_TREE: 10,
  UPGRADE: 11,
  FAST_BUILD: 12
};

goog.object.extend(exports, proto.SC2APIProtocol);

},{"./common_pb.js":104,"google-protobuf":68}],107:[function(require,module,exports){
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.SC2APIProtocol.ActionResult', null, global);
/**
 * @enum {number}
 */
proto.SC2APIProtocol.ActionResult = {
  SUCCESS: 1,
  NOTSUPPORTED: 2,
  ERROR: 3,
  CANTQUEUETHATORDER: 4,
  RETRY: 5,
  COOLDOWN: 6,
  QUEUEISFULL: 7,
  RALLYQUEUEISFULL: 8,
  NOTENOUGHMINERALS: 9,
  NOTENOUGHVESPENE: 10,
  NOTENOUGHTERRAZINE: 11,
  NOTENOUGHCUSTOM: 12,
  NOTENOUGHFOOD: 13,
  FOODUSAGEIMPOSSIBLE: 14,
  NOTENOUGHLIFE: 15,
  NOTENOUGHSHIELDS: 16,
  NOTENOUGHENERGY: 17,
  LIFESUPPRESSED: 18,
  SHIELDSSUPPRESSED: 19,
  ENERGYSUPPRESSED: 20,
  NOTENOUGHCHARGES: 21,
  CANTADDMORECHARGES: 22,
  TOOMUCHMINERALS: 23,
  TOOMUCHVESPENE: 24,
  TOOMUCHTERRAZINE: 25,
  TOOMUCHCUSTOM: 26,
  TOOMUCHFOOD: 27,
  TOOMUCHLIFE: 28,
  TOOMUCHSHIELDS: 29,
  TOOMUCHENERGY: 30,
  MUSTTARGETUNITWITHLIFE: 31,
  MUSTTARGETUNITWITHSHIELDS: 32,
  MUSTTARGETUNITWITHENERGY: 33,
  CANTTRADE: 34,
  CANTSPEND: 35,
  CANTTARGETTHATUNIT: 36,
  COULDNTALLOCATEUNIT: 37,
  UNITCANTMOVE: 38,
  TRANSPORTISHOLDINGPOSITION: 39,
  BUILDTECHREQUIREMENTSNOTMET: 40,
  CANTFINDPLACEMENTLOCATION: 41,
  CANTBUILDONTHAT: 42,
  CANTBUILDTOOCLOSETODROPOFF: 43,
  CANTBUILDLOCATIONINVALID: 44,
  CANTSEEBUILDLOCATION: 45,
  CANTBUILDTOOCLOSETOCREEPSOURCE: 46,
  CANTBUILDTOOCLOSETORESOURCES: 47,
  CANTBUILDTOOFARFROMWATER: 48,
  CANTBUILDTOOFARFROMCREEPSOURCE: 49,
  CANTBUILDTOOFARFROMBUILDPOWERSOURCE: 50,
  CANTBUILDONDENSETERRAIN: 51,
  CANTTRAINTOOFARFROMTRAINPOWERSOURCE: 52,
  CANTLANDLOCATIONINVALID: 53,
  CANTSEELANDLOCATION: 54,
  CANTLANDTOOCLOSETOCREEPSOURCE: 55,
  CANTLANDTOOCLOSETORESOURCES: 56,
  CANTLANDTOOFARFROMWATER: 57,
  CANTLANDTOOFARFROMCREEPSOURCE: 58,
  CANTLANDTOOFARFROMBUILDPOWERSOURCE: 59,
  CANTLANDTOOFARFROMTRAINPOWERSOURCE: 60,
  CANTLANDONDENSETERRAIN: 61,
  ADDONTOOFARFROMBUILDING: 62,
  MUSTBUILDREFINERYFIRST: 63,
  BUILDINGISUNDERCONSTRUCTION: 64,
  CANTFINDDROPOFF: 65,
  CANTLOADOTHERPLAYERSUNITS: 66,
  NOTENOUGHROOMTOLOADUNIT: 67,
  CANTUNLOADUNITSTHERE: 68,
  CANTWARPINUNITSTHERE: 69,
  CANTLOADIMMOBILEUNITS: 70,
  CANTRECHARGEIMMOBILEUNITS: 71,
  CANTRECHARGEUNDERCONSTRUCTIONUNITS: 72,
  CANTLOADTHATUNIT: 73,
  NOCARGOTOUNLOAD: 74,
  LOADALLNOTARGETSFOUND: 75,
  NOTWHILEOCCUPIED: 76,
  CANTATTACKWITHOUTAMMO: 77,
  CANTHOLDANYMOREAMMO: 78,
  TECHREQUIREMENTSNOTMET: 79,
  MUSTLOCKDOWNUNITFIRST: 80,
  MUSTTARGETUNIT: 81,
  MUSTTARGETINVENTORY: 82,
  MUSTTARGETVISIBLEUNIT: 83,
  MUSTTARGETVISIBLELOCATION: 84,
  MUSTTARGETWALKABLELOCATION: 85,
  MUSTTARGETPAWNABLEUNIT: 86,
  YOUCANTCONTROLTHATUNIT: 87,
  YOUCANTISSUECOMMANDSTOTHATUNIT: 88,
  MUSTTARGETRESOURCES: 89,
  REQUIRESHEALTARGET: 90,
  REQUIRESREPAIRTARGET: 91,
  NOITEMSTODROP: 92,
  CANTHOLDANYMOREITEMS: 93,
  CANTHOLDTHAT: 94,
  TARGETHASNOINVENTORY: 95,
  CANTDROPTHISITEM: 96,
  CANTMOVETHISITEM: 97,
  CANTPAWNTHISUNIT: 98,
  MUSTTARGETCASTER: 99,
  CANTTARGETCASTER: 100,
  MUSTTARGETOUTER: 101,
  CANTTARGETOUTER: 102,
  MUSTTARGETYOUROWNUNITS: 103,
  CANTTARGETYOUROWNUNITS: 104,
  MUSTTARGETFRIENDLYUNITS: 105,
  CANTTARGETFRIENDLYUNITS: 106,
  MUSTTARGETNEUTRALUNITS: 107,
  CANTTARGETNEUTRALUNITS: 108,
  MUSTTARGETENEMYUNITS: 109,
  CANTTARGETENEMYUNITS: 110,
  MUSTTARGETAIRUNITS: 111,
  CANTTARGETAIRUNITS: 112,
  MUSTTARGETGROUNDUNITS: 113,
  CANTTARGETGROUNDUNITS: 114,
  MUSTTARGETSTRUCTURES: 115,
  CANTTARGETSTRUCTURES: 116,
  MUSTTARGETLIGHTUNITS: 117,
  CANTTARGETLIGHTUNITS: 118,
  MUSTTARGETARMOREDUNITS: 119,
  CANTTARGETARMOREDUNITS: 120,
  MUSTTARGETBIOLOGICALUNITS: 121,
  CANTTARGETBIOLOGICALUNITS: 122,
  MUSTTARGETHEROICUNITS: 123,
  CANTTARGETHEROICUNITS: 124,
  MUSTTARGETROBOTICUNITS: 125,
  CANTTARGETROBOTICUNITS: 126,
  MUSTTARGETMECHANICALUNITS: 127,
  CANTTARGETMECHANICALUNITS: 128,
  MUSTTARGETPSIONICUNITS: 129,
  CANTTARGETPSIONICUNITS: 130,
  MUSTTARGETMASSIVEUNITS: 131,
  CANTTARGETMASSIVEUNITS: 132,
  MUSTTARGETMISSILE: 133,
  CANTTARGETMISSILE: 134,
  MUSTTARGETWORKERUNITS: 135,
  CANTTARGETWORKERUNITS: 136,
  MUSTTARGETENERGYCAPABLEUNITS: 137,
  CANTTARGETENERGYCAPABLEUNITS: 138,
  MUSTTARGETSHIELDCAPABLEUNITS: 139,
  CANTTARGETSHIELDCAPABLEUNITS: 140,
  MUSTTARGETFLYERS: 141,
  CANTTARGETFLYERS: 142,
  MUSTTARGETBURIEDUNITS: 143,
  CANTTARGETBURIEDUNITS: 144,
  MUSTTARGETCLOAKEDUNITS: 145,
  CANTTARGETCLOAKEDUNITS: 146,
  MUSTTARGETUNITSINASTASISFIELD: 147,
  CANTTARGETUNITSINASTASISFIELD: 148,
  MUSTTARGETUNDERCONSTRUCTIONUNITS: 149,
  CANTTARGETUNDERCONSTRUCTIONUNITS: 150,
  MUSTTARGETDEADUNITS: 151,
  CANTTARGETDEADUNITS: 152,
  MUSTTARGETREVIVABLEUNITS: 153,
  CANTTARGETREVIVABLEUNITS: 154,
  MUSTTARGETHIDDENUNITS: 155,
  CANTTARGETHIDDENUNITS: 156,
  CANTRECHARGEOTHERPLAYERSUNITS: 157,
  MUSTTARGETHALLUCINATIONS: 158,
  CANTTARGETHALLUCINATIONS: 159,
  MUSTTARGETINVULNERABLEUNITS: 160,
  CANTTARGETINVULNERABLEUNITS: 161,
  MUSTTARGETDETECTEDUNITS: 162,
  CANTTARGETDETECTEDUNITS: 163,
  CANTTARGETUNITWITHENERGY: 164,
  CANTTARGETUNITWITHSHIELDS: 165,
  MUSTTARGETUNCOMMANDABLEUNITS: 166,
  CANTTARGETUNCOMMANDABLEUNITS: 167,
  MUSTTARGETPREVENTDEFEATUNITS: 168,
  CANTTARGETPREVENTDEFEATUNITS: 169,
  MUSTTARGETPREVENTREVEALUNITS: 170,
  CANTTARGETPREVENTREVEALUNITS: 171,
  MUSTTARGETPASSIVEUNITS: 172,
  CANTTARGETPASSIVEUNITS: 173,
  MUSTTARGETSTUNNEDUNITS: 174,
  CANTTARGETSTUNNEDUNITS: 175,
  MUSTTARGETSUMMONEDUNITS: 176,
  CANTTARGETSUMMONEDUNITS: 177,
  MUSTTARGETUSER1: 178,
  CANTTARGETUSER1: 179,
  MUSTTARGETUNSTOPPABLEUNITS: 180,
  CANTTARGETUNSTOPPABLEUNITS: 181,
  MUSTTARGETRESISTANTUNITS: 182,
  CANTTARGETRESISTANTUNITS: 183,
  MUSTTARGETDAZEDUNITS: 184,
  CANTTARGETDAZEDUNITS: 185,
  CANTLOCKDOWN: 186,
  CANTMINDCONTROL: 187,
  MUSTTARGETDESTRUCTIBLES: 188,
  CANTTARGETDESTRUCTIBLES: 189,
  MUSTTARGETITEMS: 190,
  CANTTARGETITEMS: 191,
  NOCALLDOWNAVAILABLE: 192,
  WAYPOINTLISTFULL: 193,
  MUSTTARGETRACE: 194,
  CANTTARGETRACE: 195,
  MUSTTARGETSIMILARUNITS: 196,
  CANTTARGETSIMILARUNITS: 197,
  CANTFINDENOUGHTARGETS: 198,
  ALREADYSPAWNINGLARVA: 199,
  CANTTARGETEXHAUSTEDRESOURCES: 200,
  CANTUSEMINIMAP: 201,
  CANTUSEINFOPANEL: 202,
  ORDERQUEUEISFULL: 203,
  CANTHARVESTTHATRESOURCE: 204,
  HARVESTERSNOTREQUIRED: 205,
  ALREADYTARGETED: 206,
  CANTATTACKWEAPONSDISABLED: 207,
  COULDNTREACHTARGET: 208,
  TARGETISOUTOFRANGE: 209,
  TARGETISTOOCLOSE: 210,
  TARGETISOUTOFARC: 211,
  CANTFINDTELEPORTLOCATION: 212,
  INVALIDITEMCLASS: 213,
  CANTFINDCANCELORDER: 214
};

goog.object.extend(exports, proto.SC2APIProtocol);

},{"google-protobuf":68}],108:[function(require,module,exports){
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var s2clientprotocol_common_pb = require('./common_pb.js');
var s2clientprotocol_error_pb = require('./error_pb.js');
goog.exportSymbol('proto.SC2APIProtocol.RequestQuery', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestQueryAvailableAbilities', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestQueryBuildingPlacement', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestQueryPathing', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseQuery', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseQueryAvailableAbilities', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseQueryBuildingPlacement', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseQueryPathing', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestQuery = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.RequestQuery.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.RequestQuery, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestQuery.displayName = 'proto.SC2APIProtocol.RequestQuery';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.RequestQuery.repeatedFields_ = [1,2,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestQuery.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestQuery.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestQuery} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQuery.toObject = function(includeInstance, msg) {
  var f, obj = {
    pathingList: jspb.Message.toObjectList(msg.getPathingList(),
    proto.SC2APIProtocol.RequestQueryPathing.toObject, includeInstance),
    abilitiesList: jspb.Message.toObjectList(msg.getAbilitiesList(),
    proto.SC2APIProtocol.RequestQueryAvailableAbilities.toObject, includeInstance),
    placementsList: jspb.Message.toObjectList(msg.getPlacementsList(),
    proto.SC2APIProtocol.RequestQueryBuildingPlacement.toObject, includeInstance),
    ignoreResourceRequirements: jspb.Message.getField(msg, 4)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestQuery}
 */
proto.SC2APIProtocol.RequestQuery.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestQuery;
  return proto.SC2APIProtocol.RequestQuery.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestQuery} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestQuery}
 */
proto.SC2APIProtocol.RequestQuery.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.RequestQueryPathing;
      reader.readMessage(value,proto.SC2APIProtocol.RequestQueryPathing.deserializeBinaryFromReader);
      msg.addPathing(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.RequestQueryAvailableAbilities;
      reader.readMessage(value,proto.SC2APIProtocol.RequestQueryAvailableAbilities.deserializeBinaryFromReader);
      msg.addAbilities(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.RequestQueryBuildingPlacement;
      reader.readMessage(value,proto.SC2APIProtocol.RequestQueryBuildingPlacement.deserializeBinaryFromReader);
      msg.addPlacements(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIgnoreResourceRequirements(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestQuery.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestQuery.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestQuery} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQuery.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPathingList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.SC2APIProtocol.RequestQueryPathing.serializeBinaryToWriter
    );
  }
  f = message.getAbilitiesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.SC2APIProtocol.RequestQueryAvailableAbilities.serializeBinaryToWriter
    );
  }
  f = message.getPlacementsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.SC2APIProtocol.RequestQueryBuildingPlacement.serializeBinaryToWriter
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBool(
      4,
      f
    );
  }
};


/**
 * repeated RequestQueryPathing pathing = 1;
 * @return {!Array.<!proto.SC2APIProtocol.RequestQueryPathing>}
 */
proto.SC2APIProtocol.RequestQuery.prototype.getPathingList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.RequestQueryPathing>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.RequestQueryPathing, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.RequestQueryPathing>} value */
proto.SC2APIProtocol.RequestQuery.prototype.setPathingList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.RequestQueryPathing=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.RequestQueryPathing}
 */
proto.SC2APIProtocol.RequestQuery.prototype.addPathing = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.RequestQueryPathing, opt_index);
};


proto.SC2APIProtocol.RequestQuery.prototype.clearPathingList = function() {
  this.setPathingList([]);
};


/**
 * repeated RequestQueryAvailableAbilities abilities = 2;
 * @return {!Array.<!proto.SC2APIProtocol.RequestQueryAvailableAbilities>}
 */
proto.SC2APIProtocol.RequestQuery.prototype.getAbilitiesList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.RequestQueryAvailableAbilities>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.RequestQueryAvailableAbilities, 2));
};


/** @param {!Array.<!proto.SC2APIProtocol.RequestQueryAvailableAbilities>} value */
proto.SC2APIProtocol.RequestQuery.prototype.setAbilitiesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.SC2APIProtocol.RequestQueryAvailableAbilities=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.RequestQueryAvailableAbilities}
 */
proto.SC2APIProtocol.RequestQuery.prototype.addAbilities = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.SC2APIProtocol.RequestQueryAvailableAbilities, opt_index);
};


proto.SC2APIProtocol.RequestQuery.prototype.clearAbilitiesList = function() {
  this.setAbilitiesList([]);
};


/**
 * repeated RequestQueryBuildingPlacement placements = 3;
 * @return {!Array.<!proto.SC2APIProtocol.RequestQueryBuildingPlacement>}
 */
proto.SC2APIProtocol.RequestQuery.prototype.getPlacementsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.RequestQueryBuildingPlacement>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.RequestQueryBuildingPlacement, 3));
};


/** @param {!Array.<!proto.SC2APIProtocol.RequestQueryBuildingPlacement>} value */
proto.SC2APIProtocol.RequestQuery.prototype.setPlacementsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.SC2APIProtocol.RequestQueryBuildingPlacement=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.RequestQueryBuildingPlacement}
 */
proto.SC2APIProtocol.RequestQuery.prototype.addPlacements = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.SC2APIProtocol.RequestQueryBuildingPlacement, opt_index);
};


proto.SC2APIProtocol.RequestQuery.prototype.clearPlacementsList = function() {
  this.setPlacementsList([]);
};


/**
 * optional bool ignore_resource_requirements = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestQuery.prototype.getIgnoreResourceRequirements = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestQuery.prototype.setIgnoreResourceRequirements = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.RequestQuery.prototype.clearIgnoreResourceRequirements = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestQuery.prototype.hasIgnoreResourceRequirements = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseQuery = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ResponseQuery.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseQuery, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseQuery.displayName = 'proto.SC2APIProtocol.ResponseQuery';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ResponseQuery.repeatedFields_ = [1,2,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseQuery.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseQuery.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseQuery} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQuery.toObject = function(includeInstance, msg) {
  var f, obj = {
    pathingList: jspb.Message.toObjectList(msg.getPathingList(),
    proto.SC2APIProtocol.ResponseQueryPathing.toObject, includeInstance),
    abilitiesList: jspb.Message.toObjectList(msg.getAbilitiesList(),
    proto.SC2APIProtocol.ResponseQueryAvailableAbilities.toObject, includeInstance),
    placementsList: jspb.Message.toObjectList(msg.getPlacementsList(),
    proto.SC2APIProtocol.ResponseQueryBuildingPlacement.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseQuery}
 */
proto.SC2APIProtocol.ResponseQuery.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseQuery;
  return proto.SC2APIProtocol.ResponseQuery.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseQuery} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseQuery}
 */
proto.SC2APIProtocol.ResponseQuery.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.ResponseQueryPathing;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseQueryPathing.deserializeBinaryFromReader);
      msg.addPathing(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.ResponseQueryAvailableAbilities;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseQueryAvailableAbilities.deserializeBinaryFromReader);
      msg.addAbilities(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.ResponseQueryBuildingPlacement;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseQueryBuildingPlacement.deserializeBinaryFromReader);
      msg.addPlacements(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseQuery.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseQuery.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseQuery} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQuery.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPathingList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.SC2APIProtocol.ResponseQueryPathing.serializeBinaryToWriter
    );
  }
  f = message.getAbilitiesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.SC2APIProtocol.ResponseQueryAvailableAbilities.serializeBinaryToWriter
    );
  }
  f = message.getPlacementsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.SC2APIProtocol.ResponseQueryBuildingPlacement.serializeBinaryToWriter
    );
  }
};


/**
 * repeated ResponseQueryPathing pathing = 1;
 * @return {!Array.<!proto.SC2APIProtocol.ResponseQueryPathing>}
 */
proto.SC2APIProtocol.ResponseQuery.prototype.getPathingList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.ResponseQueryPathing>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.ResponseQueryPathing, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.ResponseQueryPathing>} value */
proto.SC2APIProtocol.ResponseQuery.prototype.setPathingList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.ResponseQueryPathing=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.ResponseQueryPathing}
 */
proto.SC2APIProtocol.ResponseQuery.prototype.addPathing = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.ResponseQueryPathing, opt_index);
};


proto.SC2APIProtocol.ResponseQuery.prototype.clearPathingList = function() {
  this.setPathingList([]);
};


/**
 * repeated ResponseQueryAvailableAbilities abilities = 2;
 * @return {!Array.<!proto.SC2APIProtocol.ResponseQueryAvailableAbilities>}
 */
proto.SC2APIProtocol.ResponseQuery.prototype.getAbilitiesList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.ResponseQueryAvailableAbilities>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.ResponseQueryAvailableAbilities, 2));
};


/** @param {!Array.<!proto.SC2APIProtocol.ResponseQueryAvailableAbilities>} value */
proto.SC2APIProtocol.ResponseQuery.prototype.setAbilitiesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.SC2APIProtocol.ResponseQueryAvailableAbilities=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.ResponseQueryAvailableAbilities}
 */
proto.SC2APIProtocol.ResponseQuery.prototype.addAbilities = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.SC2APIProtocol.ResponseQueryAvailableAbilities, opt_index);
};


proto.SC2APIProtocol.ResponseQuery.prototype.clearAbilitiesList = function() {
  this.setAbilitiesList([]);
};


/**
 * repeated ResponseQueryBuildingPlacement placements = 3;
 * @return {!Array.<!proto.SC2APIProtocol.ResponseQueryBuildingPlacement>}
 */
proto.SC2APIProtocol.ResponseQuery.prototype.getPlacementsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.ResponseQueryBuildingPlacement>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.ResponseQueryBuildingPlacement, 3));
};


/** @param {!Array.<!proto.SC2APIProtocol.ResponseQueryBuildingPlacement>} value */
proto.SC2APIProtocol.ResponseQuery.prototype.setPlacementsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.SC2APIProtocol.ResponseQueryBuildingPlacement=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.ResponseQueryBuildingPlacement}
 */
proto.SC2APIProtocol.ResponseQuery.prototype.addPlacements = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.SC2APIProtocol.ResponseQueryBuildingPlacement, opt_index);
};


proto.SC2APIProtocol.ResponseQuery.prototype.clearPlacementsList = function() {
  this.setPlacementsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestQueryPathing = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.SC2APIProtocol.RequestQueryPathing.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.RequestQueryPathing, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestQueryPathing.displayName = 'proto.SC2APIProtocol.RequestQueryPathing';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.RequestQueryPathing.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.RequestQueryPathing.StartCase = {
  START_NOT_SET: 0,
  START_POS: 1,
  UNIT_TAG: 2
};

/**
 * @return {proto.SC2APIProtocol.RequestQueryPathing.StartCase}
 */
proto.SC2APIProtocol.RequestQueryPathing.prototype.getStartCase = function() {
  return /** @type {proto.SC2APIProtocol.RequestQueryPathing.StartCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.RequestQueryPathing.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestQueryPathing.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestQueryPathing.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestQueryPathing} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQueryPathing.toObject = function(includeInstance, msg) {
  var f, obj = {
    startPos: (f = msg.getStartPos()) && s2clientprotocol_common_pb.Point2D.toObject(includeInstance, f),
    unitTag: jspb.Message.getField(msg, 2),
    endPos: (f = msg.getEndPos()) && s2clientprotocol_common_pb.Point2D.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestQueryPathing}
 */
proto.SC2APIProtocol.RequestQueryPathing.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestQueryPathing;
  return proto.SC2APIProtocol.RequestQueryPathing.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestQueryPathing} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestQueryPathing}
 */
proto.SC2APIProtocol.RequestQueryPathing.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.Point2D;
      reader.readMessage(value,s2clientprotocol_common_pb.Point2D.deserializeBinaryFromReader);
      msg.setStartPos(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setUnitTag(value);
      break;
    case 3:
      var value = new s2clientprotocol_common_pb.Point2D;
      reader.readMessage(value,s2clientprotocol_common_pb.Point2D.deserializeBinaryFromReader);
      msg.setEndPos(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestQueryPathing.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestQueryPathing.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestQueryPathing} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQueryPathing.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStartPos();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.Point2D.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getEndPos();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      s2clientprotocol_common_pb.Point2D.serializeBinaryToWriter
    );
  }
};


/**
 * optional Point2D start_pos = 1;
 * @return {?proto.SC2APIProtocol.Point2D}
 */
proto.SC2APIProtocol.RequestQueryPathing.prototype.getStartPos = function() {
  return /** @type{?proto.SC2APIProtocol.Point2D} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point2D, 1));
};


/** @param {?proto.SC2APIProtocol.Point2D|undefined} value */
proto.SC2APIProtocol.RequestQueryPathing.prototype.setStartPos = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.SC2APIProtocol.RequestQueryPathing.oneofGroups_[0], value);
};


proto.SC2APIProtocol.RequestQueryPathing.prototype.clearStartPos = function() {
  this.setStartPos(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestQueryPathing.prototype.hasStartPos = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint64 unit_tag = 2;
 * @return {number}
 */
proto.SC2APIProtocol.RequestQueryPathing.prototype.getUnitTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.RequestQueryPathing.prototype.setUnitTag = function(value) {
  jspb.Message.setOneofField(this, 2, proto.SC2APIProtocol.RequestQueryPathing.oneofGroups_[0], value);
};


proto.SC2APIProtocol.RequestQueryPathing.prototype.clearUnitTag = function() {
  jspb.Message.setOneofField(this, 2, proto.SC2APIProtocol.RequestQueryPathing.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestQueryPathing.prototype.hasUnitTag = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Point2D end_pos = 3;
 * @return {?proto.SC2APIProtocol.Point2D}
 */
proto.SC2APIProtocol.RequestQueryPathing.prototype.getEndPos = function() {
  return /** @type{?proto.SC2APIProtocol.Point2D} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point2D, 3));
};


/** @param {?proto.SC2APIProtocol.Point2D|undefined} value */
proto.SC2APIProtocol.RequestQueryPathing.prototype.setEndPos = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.RequestQueryPathing.prototype.clearEndPos = function() {
  this.setEndPos(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestQueryPathing.prototype.hasEndPos = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseQueryPathing = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseQueryPathing, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseQueryPathing.displayName = 'proto.SC2APIProtocol.ResponseQueryPathing';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseQueryPathing.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseQueryPathing.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseQueryPathing} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQueryPathing.toObject = function(includeInstance, msg) {
  var f, obj = {
    distance: jspb.Message.getOptionalFloatingPointField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseQueryPathing}
 */
proto.SC2APIProtocol.ResponseQueryPathing.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseQueryPathing;
  return proto.SC2APIProtocol.ResponseQueryPathing.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseQueryPathing} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseQueryPathing}
 */
proto.SC2APIProtocol.ResponseQueryPathing.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setDistance(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseQueryPathing.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseQueryPathing.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseQueryPathing} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQueryPathing.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeFloat(
      1,
      f
    );
  }
};


/**
 * optional float distance = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ResponseQueryPathing.prototype.getDistance = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 1, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ResponseQueryPathing.prototype.setDistance = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponseQueryPathing.prototype.clearDistance = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseQueryPathing.prototype.hasDistance = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestQueryAvailableAbilities = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestQueryAvailableAbilities, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestQueryAvailableAbilities.displayName = 'proto.SC2APIProtocol.RequestQueryAvailableAbilities';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestQueryAvailableAbilities.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestQueryAvailableAbilities.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestQueryAvailableAbilities} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQueryAvailableAbilities.toObject = function(includeInstance, msg) {
  var f, obj = {
    unitTag: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestQueryAvailableAbilities}
 */
proto.SC2APIProtocol.RequestQueryAvailableAbilities.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestQueryAvailableAbilities;
  return proto.SC2APIProtocol.RequestQueryAvailableAbilities.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestQueryAvailableAbilities} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestQueryAvailableAbilities}
 */
proto.SC2APIProtocol.RequestQueryAvailableAbilities.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setUnitTag(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestQueryAvailableAbilities.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestQueryAvailableAbilities.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestQueryAvailableAbilities} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQueryAvailableAbilities.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint64(
      1,
      f
    );
  }
};


/**
 * optional uint64 unit_tag = 1;
 * @return {number}
 */
proto.SC2APIProtocol.RequestQueryAvailableAbilities.prototype.getUnitTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.RequestQueryAvailableAbilities.prototype.setUnitTag = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.RequestQueryAvailableAbilities.prototype.clearUnitTag = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestQueryAvailableAbilities.prototype.hasUnitTag = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ResponseQueryAvailableAbilities.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseQueryAvailableAbilities, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseQueryAvailableAbilities.displayName = 'proto.SC2APIProtocol.ResponseQueryAvailableAbilities';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseQueryAvailableAbilities.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseQueryAvailableAbilities} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.toObject = function(includeInstance, msg) {
  var f, obj = {
    abilitiesList: jspb.Message.toObjectList(msg.getAbilitiesList(),
    s2clientprotocol_common_pb.AvailableAbility.toObject, includeInstance),
    unitTag: jspb.Message.getField(msg, 2),
    unitTypeId: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseQueryAvailableAbilities}
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseQueryAvailableAbilities;
  return proto.SC2APIProtocol.ResponseQueryAvailableAbilities.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseQueryAvailableAbilities} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseQueryAvailableAbilities}
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.AvailableAbility;
      reader.readMessage(value,s2clientprotocol_common_pb.AvailableAbility.deserializeBinaryFromReader);
      msg.addAbilities(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setUnitTag(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setUnitTypeId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseQueryAvailableAbilities.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseQueryAvailableAbilities} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAbilitiesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      s2clientprotocol_common_pb.AvailableAbility.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * repeated AvailableAbility abilities = 1;
 * @return {!Array.<!proto.SC2APIProtocol.AvailableAbility>}
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.getAbilitiesList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.AvailableAbility>} */ (
    jspb.Message.getRepeatedWrapperField(this, s2clientprotocol_common_pb.AvailableAbility, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.AvailableAbility>} value */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.setAbilitiesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.AvailableAbility=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.AvailableAbility}
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.addAbilities = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.AvailableAbility, opt_index);
};


proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.clearAbilitiesList = function() {
  this.setAbilitiesList([]);
};


/**
 * optional uint64 unit_tag = 2;
 * @return {number}
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.getUnitTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.setUnitTag = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.clearUnitTag = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.hasUnitTag = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 unit_type_id = 3;
 * @return {number}
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.getUnitTypeId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.setUnitTypeId = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.clearUnitTypeId = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseQueryAvailableAbilities.prototype.hasUnitTypeId = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestQueryBuildingPlacement, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestQueryBuildingPlacement.displayName = 'proto.SC2APIProtocol.RequestQueryBuildingPlacement';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestQueryBuildingPlacement.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestQueryBuildingPlacement} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.toObject = function(includeInstance, msg) {
  var f, obj = {
    abilityId: jspb.Message.getField(msg, 1),
    targetPos: (f = msg.getTargetPos()) && s2clientprotocol_common_pb.Point2D.toObject(includeInstance, f),
    placingUnitTag: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestQueryBuildingPlacement}
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestQueryBuildingPlacement;
  return proto.SC2APIProtocol.RequestQueryBuildingPlacement.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestQueryBuildingPlacement} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestQueryBuildingPlacement}
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAbilityId(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.Point2D;
      reader.readMessage(value,s2clientprotocol_common_pb.Point2D.deserializeBinaryFromReader);
      msg.setTargetPos(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setPlacingUnitTag(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestQueryBuildingPlacement.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestQueryBuildingPlacement} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = message.getTargetPos();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.Point2D.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint64(
      3,
      f
    );
  }
};


/**
 * optional int32 ability_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.getAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Point2D target_pos = 2;
 * @return {?proto.SC2APIProtocol.Point2D}
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.getTargetPos = function() {
  return /** @type{?proto.SC2APIProtocol.Point2D} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point2D, 2));
};


/** @param {?proto.SC2APIProtocol.Point2D|undefined} value */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.setTargetPos = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.clearTargetPos = function() {
  this.setTargetPos(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.hasTargetPos = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint64 placing_unit_tag = 3;
 * @return {number}
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.getPlacingUnitTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.setPlacingUnitTag = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.clearPlacingUnitTag = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestQueryBuildingPlacement.prototype.hasPlacingUnitTag = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseQueryBuildingPlacement = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseQueryBuildingPlacement, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseQueryBuildingPlacement.displayName = 'proto.SC2APIProtocol.ResponseQueryBuildingPlacement';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseQueryBuildingPlacement.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseQueryBuildingPlacement.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseQueryBuildingPlacement} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQueryBuildingPlacement.toObject = function(includeInstance, msg) {
  var f, obj = {
    result: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseQueryBuildingPlacement}
 */
proto.SC2APIProtocol.ResponseQueryBuildingPlacement.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseQueryBuildingPlacement;
  return proto.SC2APIProtocol.ResponseQueryBuildingPlacement.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseQueryBuildingPlacement} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseQueryBuildingPlacement}
 */
proto.SC2APIProtocol.ResponseQueryBuildingPlacement.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.ActionResult} */ (reader.readEnum());
      msg.setResult(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseQueryBuildingPlacement.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseQueryBuildingPlacement.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseQueryBuildingPlacement} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQueryBuildingPlacement.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.ActionResult} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
};


/**
 * optional ActionResult result = 1;
 * @return {!proto.SC2APIProtocol.ActionResult}
 */
proto.SC2APIProtocol.ResponseQueryBuildingPlacement.prototype.getResult = function() {
  return /** @type {!proto.SC2APIProtocol.ActionResult} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.ActionResult} value */
proto.SC2APIProtocol.ResponseQueryBuildingPlacement.prototype.setResult = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponseQueryBuildingPlacement.prototype.clearResult = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseQueryBuildingPlacement.prototype.hasResult = function() {
  return jspb.Message.getField(this, 1) != null;
};


goog.object.extend(exports, proto.SC2APIProtocol);

},{"./common_pb.js":104,"./error_pb.js":107,"google-protobuf":68}],109:[function(require,module,exports){
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var s2clientprotocol_common_pb = require('./common_pb.js');
goog.exportSymbol('proto.SC2APIProtocol.ActionRaw', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionRawCameraMove', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionRawToggleAutocast', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionRawUnitCommand', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Alliance', null, global);
goog.exportSymbol('proto.SC2APIProtocol.CloakState', null, global);
goog.exportSymbol('proto.SC2APIProtocol.DisplayType', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Effect', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Event', null, global);
goog.exportSymbol('proto.SC2APIProtocol.MapState', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ObservationRaw', null, global);
goog.exportSymbol('proto.SC2APIProtocol.PassengerUnit', null, global);
goog.exportSymbol('proto.SC2APIProtocol.PlayerRaw', null, global);
goog.exportSymbol('proto.SC2APIProtocol.PowerSource', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RadarRing', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RallyTarget', null, global);
goog.exportSymbol('proto.SC2APIProtocol.StartRaw', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Unit', null, global);
goog.exportSymbol('proto.SC2APIProtocol.UnitOrder', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.StartRaw = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.StartRaw.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.StartRaw, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.StartRaw.displayName = 'proto.SC2APIProtocol.StartRaw';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.StartRaw.repeatedFields_ = [6];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.StartRaw.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.StartRaw.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.StartRaw} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.StartRaw.toObject = function(includeInstance, msg) {
  var f, obj = {
    mapSize: (f = msg.getMapSize()) && s2clientprotocol_common_pb.Size2DI.toObject(includeInstance, f),
    pathingGrid: (f = msg.getPathingGrid()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    terrainHeight: (f = msg.getTerrainHeight()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    placementGrid: (f = msg.getPlacementGrid()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    playableArea: (f = msg.getPlayableArea()) && s2clientprotocol_common_pb.RectangleI.toObject(includeInstance, f),
    startLocationsList: jspb.Message.toObjectList(msg.getStartLocationsList(),
    s2clientprotocol_common_pb.Point2D.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.StartRaw}
 */
proto.SC2APIProtocol.StartRaw.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.StartRaw;
  return proto.SC2APIProtocol.StartRaw.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.StartRaw} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.StartRaw}
 */
proto.SC2APIProtocol.StartRaw.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.Size2DI;
      reader.readMessage(value,s2clientprotocol_common_pb.Size2DI.deserializeBinaryFromReader);
      msg.setMapSize(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setPathingGrid(value);
      break;
    case 3:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setTerrainHeight(value);
      break;
    case 4:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setPlacementGrid(value);
      break;
    case 5:
      var value = new s2clientprotocol_common_pb.RectangleI;
      reader.readMessage(value,s2clientprotocol_common_pb.RectangleI.deserializeBinaryFromReader);
      msg.setPlayableArea(value);
      break;
    case 6:
      var value = new s2clientprotocol_common_pb.Point2D;
      reader.readMessage(value,s2clientprotocol_common_pb.Point2D.deserializeBinaryFromReader);
      msg.addStartLocations(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.StartRaw.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.StartRaw.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.StartRaw} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.StartRaw.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMapSize();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.Size2DI.serializeBinaryToWriter
    );
  }
  f = message.getPathingGrid();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getTerrainHeight();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getPlacementGrid();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getPlayableArea();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      s2clientprotocol_common_pb.RectangleI.serializeBinaryToWriter
    );
  }
  f = message.getStartLocationsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      6,
      f,
      s2clientprotocol_common_pb.Point2D.serializeBinaryToWriter
    );
  }
};


/**
 * optional Size2DI map_size = 1;
 * @return {?proto.SC2APIProtocol.Size2DI}
 */
proto.SC2APIProtocol.StartRaw.prototype.getMapSize = function() {
  return /** @type{?proto.SC2APIProtocol.Size2DI} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Size2DI, 1));
};


/** @param {?proto.SC2APIProtocol.Size2DI|undefined} value */
proto.SC2APIProtocol.StartRaw.prototype.setMapSize = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.StartRaw.prototype.clearMapSize = function() {
  this.setMapSize(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.StartRaw.prototype.hasMapSize = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ImageData pathing_grid = 2;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.StartRaw.prototype.getPathingGrid = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 2));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.StartRaw.prototype.setPathingGrid = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.StartRaw.prototype.clearPathingGrid = function() {
  this.setPathingGrid(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.StartRaw.prototype.hasPathingGrid = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ImageData terrain_height = 3;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.StartRaw.prototype.getTerrainHeight = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 3));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.StartRaw.prototype.setTerrainHeight = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.StartRaw.prototype.clearTerrainHeight = function() {
  this.setTerrainHeight(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.StartRaw.prototype.hasTerrainHeight = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional ImageData placement_grid = 4;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.StartRaw.prototype.getPlacementGrid = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 4));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.StartRaw.prototype.setPlacementGrid = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.SC2APIProtocol.StartRaw.prototype.clearPlacementGrid = function() {
  this.setPlacementGrid(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.StartRaw.prototype.hasPlacementGrid = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional RectangleI playable_area = 5;
 * @return {?proto.SC2APIProtocol.RectangleI}
 */
proto.SC2APIProtocol.StartRaw.prototype.getPlayableArea = function() {
  return /** @type{?proto.SC2APIProtocol.RectangleI} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.RectangleI, 5));
};


/** @param {?proto.SC2APIProtocol.RectangleI|undefined} value */
proto.SC2APIProtocol.StartRaw.prototype.setPlayableArea = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.SC2APIProtocol.StartRaw.prototype.clearPlayableArea = function() {
  this.setPlayableArea(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.StartRaw.prototype.hasPlayableArea = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * repeated Point2D start_locations = 6;
 * @return {!Array.<!proto.SC2APIProtocol.Point2D>}
 */
proto.SC2APIProtocol.StartRaw.prototype.getStartLocationsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.Point2D>} */ (
    jspb.Message.getRepeatedWrapperField(this, s2clientprotocol_common_pb.Point2D, 6));
};


/** @param {!Array.<!proto.SC2APIProtocol.Point2D>} value */
proto.SC2APIProtocol.StartRaw.prototype.setStartLocationsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 6, value);
};


/**
 * @param {!proto.SC2APIProtocol.Point2D=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.Point2D}
 */
proto.SC2APIProtocol.StartRaw.prototype.addStartLocations = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 6, opt_value, proto.SC2APIProtocol.Point2D, opt_index);
};


proto.SC2APIProtocol.StartRaw.prototype.clearStartLocationsList = function() {
  this.setStartLocationsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ObservationRaw = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ObservationRaw.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ObservationRaw, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ObservationRaw.displayName = 'proto.SC2APIProtocol.ObservationRaw';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ObservationRaw.repeatedFields_ = [2,5,6];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ObservationRaw.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ObservationRaw} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ObservationRaw.toObject = function(includeInstance, msg) {
  var f, obj = {
    player: (f = msg.getPlayer()) && proto.SC2APIProtocol.PlayerRaw.toObject(includeInstance, f),
    unitsList: jspb.Message.toObjectList(msg.getUnitsList(),
    proto.SC2APIProtocol.Unit.toObject, includeInstance),
    mapState: (f = msg.getMapState()) && proto.SC2APIProtocol.MapState.toObject(includeInstance, f),
    event: (f = msg.getEvent()) && proto.SC2APIProtocol.Event.toObject(includeInstance, f),
    effectsList: jspb.Message.toObjectList(msg.getEffectsList(),
    proto.SC2APIProtocol.Effect.toObject, includeInstance),
    radarList: jspb.Message.toObjectList(msg.getRadarList(),
    proto.SC2APIProtocol.RadarRing.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ObservationRaw}
 */
proto.SC2APIProtocol.ObservationRaw.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ObservationRaw;
  return proto.SC2APIProtocol.ObservationRaw.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ObservationRaw} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ObservationRaw}
 */
proto.SC2APIProtocol.ObservationRaw.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.PlayerRaw;
      reader.readMessage(value,proto.SC2APIProtocol.PlayerRaw.deserializeBinaryFromReader);
      msg.setPlayer(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.Unit;
      reader.readMessage(value,proto.SC2APIProtocol.Unit.deserializeBinaryFromReader);
      msg.addUnits(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.MapState;
      reader.readMessage(value,proto.SC2APIProtocol.MapState.deserializeBinaryFromReader);
      msg.setMapState(value);
      break;
    case 4:
      var value = new proto.SC2APIProtocol.Event;
      reader.readMessage(value,proto.SC2APIProtocol.Event.deserializeBinaryFromReader);
      msg.setEvent(value);
      break;
    case 5:
      var value = new proto.SC2APIProtocol.Effect;
      reader.readMessage(value,proto.SC2APIProtocol.Effect.deserializeBinaryFromReader);
      msg.addEffects(value);
      break;
    case 6:
      var value = new proto.SC2APIProtocol.RadarRing;
      reader.readMessage(value,proto.SC2APIProtocol.RadarRing.deserializeBinaryFromReader);
      msg.addRadar(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ObservationRaw.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ObservationRaw} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ObservationRaw.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPlayer();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.PlayerRaw.serializeBinaryToWriter
    );
  }
  f = message.getUnitsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.SC2APIProtocol.Unit.serializeBinaryToWriter
    );
  }
  f = message.getMapState();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.MapState.serializeBinaryToWriter
    );
  }
  f = message.getEvent();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.SC2APIProtocol.Event.serializeBinaryToWriter
    );
  }
  f = message.getEffectsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.SC2APIProtocol.Effect.serializeBinaryToWriter
    );
  }
  f = message.getRadarList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      6,
      f,
      proto.SC2APIProtocol.RadarRing.serializeBinaryToWriter
    );
  }
};


/**
 * optional PlayerRaw player = 1;
 * @return {?proto.SC2APIProtocol.PlayerRaw}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.getPlayer = function() {
  return /** @type{?proto.SC2APIProtocol.PlayerRaw} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.PlayerRaw, 1));
};


/** @param {?proto.SC2APIProtocol.PlayerRaw|undefined} value */
proto.SC2APIProtocol.ObservationRaw.prototype.setPlayer = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.ObservationRaw.prototype.clearPlayer = function() {
  this.setPlayer(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.hasPlayer = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated Unit units = 2;
 * @return {!Array.<!proto.SC2APIProtocol.Unit>}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.getUnitsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.Unit>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.Unit, 2));
};


/** @param {!Array.<!proto.SC2APIProtocol.Unit>} value */
proto.SC2APIProtocol.ObservationRaw.prototype.setUnitsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.SC2APIProtocol.Unit=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.Unit}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.addUnits = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.SC2APIProtocol.Unit, opt_index);
};


proto.SC2APIProtocol.ObservationRaw.prototype.clearUnitsList = function() {
  this.setUnitsList([]);
};


/**
 * optional MapState map_state = 3;
 * @return {?proto.SC2APIProtocol.MapState}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.getMapState = function() {
  return /** @type{?proto.SC2APIProtocol.MapState} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.MapState, 3));
};


/** @param {?proto.SC2APIProtocol.MapState|undefined} value */
proto.SC2APIProtocol.ObservationRaw.prototype.setMapState = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.ObservationRaw.prototype.clearMapState = function() {
  this.setMapState(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.hasMapState = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Event event = 4;
 * @return {?proto.SC2APIProtocol.Event}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.getEvent = function() {
  return /** @type{?proto.SC2APIProtocol.Event} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.Event, 4));
};


/** @param {?proto.SC2APIProtocol.Event|undefined} value */
proto.SC2APIProtocol.ObservationRaw.prototype.setEvent = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.SC2APIProtocol.ObservationRaw.prototype.clearEvent = function() {
  this.setEvent(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.hasEvent = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * repeated Effect effects = 5;
 * @return {!Array.<!proto.SC2APIProtocol.Effect>}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.getEffectsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.Effect>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.Effect, 5));
};


/** @param {!Array.<!proto.SC2APIProtocol.Effect>} value */
proto.SC2APIProtocol.ObservationRaw.prototype.setEffectsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.SC2APIProtocol.Effect=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.Effect}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.addEffects = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.SC2APIProtocol.Effect, opt_index);
};


proto.SC2APIProtocol.ObservationRaw.prototype.clearEffectsList = function() {
  this.setEffectsList([]);
};


/**
 * repeated RadarRing radar = 6;
 * @return {!Array.<!proto.SC2APIProtocol.RadarRing>}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.getRadarList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.RadarRing>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.RadarRing, 6));
};


/** @param {!Array.<!proto.SC2APIProtocol.RadarRing>} value */
proto.SC2APIProtocol.ObservationRaw.prototype.setRadarList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 6, value);
};


/**
 * @param {!proto.SC2APIProtocol.RadarRing=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.RadarRing}
 */
proto.SC2APIProtocol.ObservationRaw.prototype.addRadar = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 6, opt_value, proto.SC2APIProtocol.RadarRing, opt_index);
};


proto.SC2APIProtocol.ObservationRaw.prototype.clearRadarList = function() {
  this.setRadarList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RadarRing = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RadarRing, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RadarRing.displayName = 'proto.SC2APIProtocol.RadarRing';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RadarRing.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RadarRing.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RadarRing} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RadarRing.toObject = function(includeInstance, msg) {
  var f, obj = {
    pos: (f = msg.getPos()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f),
    radius: jspb.Message.getOptionalFloatingPointField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RadarRing}
 */
proto.SC2APIProtocol.RadarRing.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RadarRing;
  return proto.SC2APIProtocol.RadarRing.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RadarRing} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RadarRing}
 */
proto.SC2APIProtocol.RadarRing.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setPos(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setRadius(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RadarRing.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RadarRing.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RadarRing} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RadarRing.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPos();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
};


/**
 * optional Point pos = 1;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.RadarRing.prototype.getPos = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 1));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.RadarRing.prototype.setPos = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.RadarRing.prototype.clearPos = function() {
  this.setPos(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RadarRing.prototype.hasPos = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float radius = 2;
 * @return {number}
 */
proto.SC2APIProtocol.RadarRing.prototype.getRadius = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.RadarRing.prototype.setRadius = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.RadarRing.prototype.clearRadius = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RadarRing.prototype.hasRadius = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.PowerSource = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.PowerSource, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.PowerSource.displayName = 'proto.SC2APIProtocol.PowerSource';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.PowerSource.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.PowerSource.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.PowerSource} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PowerSource.toObject = function(includeInstance, msg) {
  var f, obj = {
    pos: (f = msg.getPos()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f),
    radius: jspb.Message.getOptionalFloatingPointField(msg, 2),
    tag: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.PowerSource}
 */
proto.SC2APIProtocol.PowerSource.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.PowerSource;
  return proto.SC2APIProtocol.PowerSource.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.PowerSource} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.PowerSource}
 */
proto.SC2APIProtocol.PowerSource.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setPos(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setRadius(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setTag(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.PowerSource.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.PowerSource.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.PowerSource} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PowerSource.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPos();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint64(
      3,
      f
    );
  }
};


/**
 * optional Point pos = 1;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.PowerSource.prototype.getPos = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 1));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.PowerSource.prototype.setPos = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.PowerSource.prototype.clearPos = function() {
  this.setPos(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PowerSource.prototype.hasPos = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float radius = 2;
 * @return {number}
 */
proto.SC2APIProtocol.PowerSource.prototype.getRadius = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.PowerSource.prototype.setRadius = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.PowerSource.prototype.clearRadius = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PowerSource.prototype.hasRadius = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint64 tag = 3;
 * @return {number}
 */
proto.SC2APIProtocol.PowerSource.prototype.getTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PowerSource.prototype.setTag = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.PowerSource.prototype.clearTag = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PowerSource.prototype.hasTag = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.PlayerRaw = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.PlayerRaw.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.PlayerRaw, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.PlayerRaw.displayName = 'proto.SC2APIProtocol.PlayerRaw';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.PlayerRaw.repeatedFields_ = [1,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.PlayerRaw.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.PlayerRaw.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.PlayerRaw} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PlayerRaw.toObject = function(includeInstance, msg) {
  var f, obj = {
    powerSourcesList: jspb.Message.toObjectList(msg.getPowerSourcesList(),
    proto.SC2APIProtocol.PowerSource.toObject, includeInstance),
    camera: (f = msg.getCamera()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f),
    upgradeIdsList: jspb.Message.getRepeatedField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.PlayerRaw}
 */
proto.SC2APIProtocol.PlayerRaw.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.PlayerRaw;
  return proto.SC2APIProtocol.PlayerRaw.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.PlayerRaw} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.PlayerRaw}
 */
proto.SC2APIProtocol.PlayerRaw.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.PowerSource;
      reader.readMessage(value,proto.SC2APIProtocol.PowerSource.deserializeBinaryFromReader);
      msg.addPowerSources(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setCamera(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addUpgradeIds(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.PlayerRaw.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.PlayerRaw.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.PlayerRaw} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PlayerRaw.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPowerSourcesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.SC2APIProtocol.PowerSource.serializeBinaryToWriter
    );
  }
  f = message.getCamera();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
  f = message.getUpgradeIdsList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      3,
      f
    );
  }
};


/**
 * repeated PowerSource power_sources = 1;
 * @return {!Array.<!proto.SC2APIProtocol.PowerSource>}
 */
proto.SC2APIProtocol.PlayerRaw.prototype.getPowerSourcesList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.PowerSource>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.PowerSource, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.PowerSource>} value */
proto.SC2APIProtocol.PlayerRaw.prototype.setPowerSourcesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.PowerSource=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.PowerSource}
 */
proto.SC2APIProtocol.PlayerRaw.prototype.addPowerSources = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.PowerSource, opt_index);
};


proto.SC2APIProtocol.PlayerRaw.prototype.clearPowerSourcesList = function() {
  this.setPowerSourcesList([]);
};


/**
 * optional Point camera = 2;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.PlayerRaw.prototype.getCamera = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 2));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.PlayerRaw.prototype.setCamera = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.PlayerRaw.prototype.clearCamera = function() {
  this.setCamera(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerRaw.prototype.hasCamera = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * repeated uint32 upgrade_ids = 3;
 * @return {!Array.<number>}
 */
proto.SC2APIProtocol.PlayerRaw.prototype.getUpgradeIdsList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getRepeatedField(this, 3));
};


/** @param {!Array.<number>} value */
proto.SC2APIProtocol.PlayerRaw.prototype.setUpgradeIdsList = function(value) {
  jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.PlayerRaw.prototype.addUpgradeIds = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


proto.SC2APIProtocol.PlayerRaw.prototype.clearUpgradeIdsList = function() {
  this.setUpgradeIdsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.UnitOrder = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.SC2APIProtocol.UnitOrder.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.UnitOrder, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.UnitOrder.displayName = 'proto.SC2APIProtocol.UnitOrder';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.UnitOrder.oneofGroups_ = [[2,3]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.UnitOrder.TargetCase = {
  TARGET_NOT_SET: 0,
  TARGET_WORLD_SPACE_POS: 2,
  TARGET_UNIT_TAG: 3
};

/**
 * @return {proto.SC2APIProtocol.UnitOrder.TargetCase}
 */
proto.SC2APIProtocol.UnitOrder.prototype.getTargetCase = function() {
  return /** @type {proto.SC2APIProtocol.UnitOrder.TargetCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.UnitOrder.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.UnitOrder.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.UnitOrder.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.UnitOrder} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.UnitOrder.toObject = function(includeInstance, msg) {
  var f, obj = {
    abilityId: jspb.Message.getField(msg, 1),
    targetWorldSpacePos: (f = msg.getTargetWorldSpacePos()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f),
    targetUnitTag: jspb.Message.getField(msg, 3),
    progress: jspb.Message.getOptionalFloatingPointField(msg, 4)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.UnitOrder}
 */
proto.SC2APIProtocol.UnitOrder.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.UnitOrder;
  return proto.SC2APIProtocol.UnitOrder.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.UnitOrder} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.UnitOrder}
 */
proto.SC2APIProtocol.UnitOrder.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAbilityId(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setTargetWorldSpacePos(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setTargetUnitTag(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setProgress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.UnitOrder.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.UnitOrder.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.UnitOrder} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.UnitOrder.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getTargetWorldSpacePos();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeFloat(
      4,
      f
    );
  }
};


/**
 * optional uint32 ability_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.UnitOrder.prototype.getAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitOrder.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.UnitOrder.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitOrder.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Point target_world_space_pos = 2;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.UnitOrder.prototype.getTargetWorldSpacePos = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 2));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.UnitOrder.prototype.setTargetWorldSpacePos = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.SC2APIProtocol.UnitOrder.oneofGroups_[0], value);
};


proto.SC2APIProtocol.UnitOrder.prototype.clearTargetWorldSpacePos = function() {
  this.setTargetWorldSpacePos(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitOrder.prototype.hasTargetWorldSpacePos = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint64 target_unit_tag = 3;
 * @return {number}
 */
proto.SC2APIProtocol.UnitOrder.prototype.getTargetUnitTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitOrder.prototype.setTargetUnitTag = function(value) {
  jspb.Message.setOneofField(this, 3, proto.SC2APIProtocol.UnitOrder.oneofGroups_[0], value);
};


proto.SC2APIProtocol.UnitOrder.prototype.clearTargetUnitTag = function() {
  jspb.Message.setOneofField(this, 3, proto.SC2APIProtocol.UnitOrder.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitOrder.prototype.hasTargetUnitTag = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional float progress = 4;
 * @return {number}
 */
proto.SC2APIProtocol.UnitOrder.prototype.getProgress = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 4, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitOrder.prototype.setProgress = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.UnitOrder.prototype.clearProgress = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitOrder.prototype.hasProgress = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.PassengerUnit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.PassengerUnit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.PassengerUnit.displayName = 'proto.SC2APIProtocol.PassengerUnit';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.PassengerUnit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.PassengerUnit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PassengerUnit.toObject = function(includeInstance, msg) {
  var f, obj = {
    tag: jspb.Message.getField(msg, 1),
    health: jspb.Message.getOptionalFloatingPointField(msg, 2),
    healthMax: jspb.Message.getOptionalFloatingPointField(msg, 3),
    shield: jspb.Message.getOptionalFloatingPointField(msg, 4),
    shieldMax: jspb.Message.getOptionalFloatingPointField(msg, 7),
    energy: jspb.Message.getOptionalFloatingPointField(msg, 5),
    energyMax: jspb.Message.getOptionalFloatingPointField(msg, 8),
    unitType: jspb.Message.getField(msg, 6)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.PassengerUnit}
 */
proto.SC2APIProtocol.PassengerUnit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.PassengerUnit;
  return proto.SC2APIProtocol.PassengerUnit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.PassengerUnit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.PassengerUnit}
 */
proto.SC2APIProtocol.PassengerUnit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setTag(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setHealth(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setHealthMax(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setShield(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setShieldMax(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setEnergy(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setEnergyMax(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setUnitType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.PassengerUnit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.PassengerUnit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PassengerUnit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeFloat(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeFloat(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeFloat(
      7,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeFloat(
      5,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeFloat(
      8,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeUint32(
      6,
      f
    );
  }
};


/**
 * optional uint64 tag = 1;
 * @return {number}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.getTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PassengerUnit.prototype.setTag = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.PassengerUnit.prototype.clearTag = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.hasTag = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float health = 2;
 * @return {number}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.getHealth = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.PassengerUnit.prototype.setHealth = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.PassengerUnit.prototype.clearHealth = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.hasHealth = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional float health_max = 3;
 * @return {number}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.getHealthMax = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 3, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.PassengerUnit.prototype.setHealthMax = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.PassengerUnit.prototype.clearHealthMax = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.hasHealthMax = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional float shield = 4;
 * @return {number}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.getShield = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 4, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.PassengerUnit.prototype.setShield = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.PassengerUnit.prototype.clearShield = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.hasShield = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional float shield_max = 7;
 * @return {number}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.getShieldMax = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 7, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.PassengerUnit.prototype.setShieldMax = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.PassengerUnit.prototype.clearShieldMax = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.hasShieldMax = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional float energy = 5;
 * @return {number}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.getEnergy = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 5, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.PassengerUnit.prototype.setEnergy = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.PassengerUnit.prototype.clearEnergy = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.hasEnergy = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional float energy_max = 8;
 * @return {number}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.getEnergyMax = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 8, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.PassengerUnit.prototype.setEnergyMax = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.SC2APIProtocol.PassengerUnit.prototype.clearEnergyMax = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.hasEnergyMax = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional uint32 unit_type = 6;
 * @return {number}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.getUnitType = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PassengerUnit.prototype.setUnitType = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.PassengerUnit.prototype.clearUnitType = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PassengerUnit.prototype.hasUnitType = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RallyTarget = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RallyTarget, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RallyTarget.displayName = 'proto.SC2APIProtocol.RallyTarget';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RallyTarget.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RallyTarget.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RallyTarget} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RallyTarget.toObject = function(includeInstance, msg) {
  var f, obj = {
    point: (f = msg.getPoint()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f),
    tag: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RallyTarget}
 */
proto.SC2APIProtocol.RallyTarget.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RallyTarget;
  return proto.SC2APIProtocol.RallyTarget.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RallyTarget} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RallyTarget}
 */
proto.SC2APIProtocol.RallyTarget.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setPoint(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setTag(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RallyTarget.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RallyTarget.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RallyTarget} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RallyTarget.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPoint();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint64(
      2,
      f
    );
  }
};


/**
 * optional Point point = 1;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.RallyTarget.prototype.getPoint = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 1));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.RallyTarget.prototype.setPoint = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.RallyTarget.prototype.clearPoint = function() {
  this.setPoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RallyTarget.prototype.hasPoint = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint64 tag = 2;
 * @return {number}
 */
proto.SC2APIProtocol.RallyTarget.prototype.getTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.RallyTarget.prototype.setTag = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.RallyTarget.prototype.clearTag = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RallyTarget.prototype.hasTag = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Unit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.Unit.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.Unit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Unit.displayName = 'proto.SC2APIProtocol.Unit';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.Unit.repeatedFields_ = [27,22,24,45];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Unit.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Unit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Unit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Unit.toObject = function(includeInstance, msg) {
  var f, obj = {
    displayType: jspb.Message.getField(msg, 1),
    alliance: jspb.Message.getField(msg, 2),
    tag: jspb.Message.getField(msg, 3),
    unitType: jspb.Message.getField(msg, 4),
    owner: jspb.Message.getField(msg, 5),
    pos: (f = msg.getPos()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f),
    facing: jspb.Message.getOptionalFloatingPointField(msg, 7),
    radius: jspb.Message.getOptionalFloatingPointField(msg, 8),
    buildProgress: jspb.Message.getOptionalFloatingPointField(msg, 9),
    cloak: jspb.Message.getField(msg, 10),
    buffIdsList: jspb.Message.getRepeatedField(msg, 27),
    detectRange: jspb.Message.getOptionalFloatingPointField(msg, 31),
    radarRange: jspb.Message.getOptionalFloatingPointField(msg, 32),
    isSelected: jspb.Message.getField(msg, 11),
    isOnScreen: jspb.Message.getField(msg, 12),
    isBlip: jspb.Message.getField(msg, 13),
    isPowered: jspb.Message.getField(msg, 35),
    isActive: jspb.Message.getField(msg, 39),
    attackUpgradeLevel: jspb.Message.getField(msg, 40),
    armorUpgradeLevel: jspb.Message.getField(msg, 41),
    shieldUpgradeLevel: jspb.Message.getField(msg, 42),
    health: jspb.Message.getOptionalFloatingPointField(msg, 14),
    healthMax: jspb.Message.getOptionalFloatingPointField(msg, 15),
    shield: jspb.Message.getOptionalFloatingPointField(msg, 16),
    shieldMax: jspb.Message.getOptionalFloatingPointField(msg, 36),
    energy: jspb.Message.getOptionalFloatingPointField(msg, 17),
    energyMax: jspb.Message.getOptionalFloatingPointField(msg, 37),
    mineralContents: jspb.Message.getField(msg, 18),
    vespeneContents: jspb.Message.getField(msg, 19),
    isFlying: jspb.Message.getField(msg, 20),
    isBurrowed: jspb.Message.getField(msg, 21),
    isHallucination: jspb.Message.getField(msg, 38),
    ordersList: jspb.Message.toObjectList(msg.getOrdersList(),
    proto.SC2APIProtocol.UnitOrder.toObject, includeInstance),
    addOnTag: jspb.Message.getField(msg, 23),
    passengersList: jspb.Message.toObjectList(msg.getPassengersList(),
    proto.SC2APIProtocol.PassengerUnit.toObject, includeInstance),
    cargoSpaceTaken: jspb.Message.getField(msg, 25),
    cargoSpaceMax: jspb.Message.getField(msg, 26),
    assignedHarvesters: jspb.Message.getField(msg, 28),
    idealHarvesters: jspb.Message.getField(msg, 29),
    weaponCooldown: jspb.Message.getOptionalFloatingPointField(msg, 30),
    engagedTargetTag: jspb.Message.getField(msg, 34),
    buffDurationRemain: jspb.Message.getField(msg, 43),
    buffDurationMax: jspb.Message.getField(msg, 44),
    rallyTargetsList: jspb.Message.toObjectList(msg.getRallyTargetsList(),
    proto.SC2APIProtocol.RallyTarget.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Unit}
 */
proto.SC2APIProtocol.Unit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Unit;
  return proto.SC2APIProtocol.Unit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Unit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Unit}
 */
proto.SC2APIProtocol.Unit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.DisplayType} */ (reader.readEnum());
      msg.setDisplayType(value);
      break;
    case 2:
      var value = /** @type {!proto.SC2APIProtocol.Alliance} */ (reader.readEnum());
      msg.setAlliance(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setTag(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setUnitType(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setOwner(value);
      break;
    case 6:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setPos(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setFacing(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setRadius(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setBuildProgress(value);
      break;
    case 10:
      var value = /** @type {!proto.SC2APIProtocol.CloakState} */ (reader.readEnum());
      msg.setCloak(value);
      break;
    case 27:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addBuffIds(value);
      break;
    case 31:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setDetectRange(value);
      break;
    case 32:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setRadarRange(value);
      break;
    case 11:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsSelected(value);
      break;
    case 12:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsOnScreen(value);
      break;
    case 13:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsBlip(value);
      break;
    case 35:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsPowered(value);
      break;
    case 39:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsActive(value);
      break;
    case 40:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAttackUpgradeLevel(value);
      break;
    case 41:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setArmorUpgradeLevel(value);
      break;
    case 42:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setShieldUpgradeLevel(value);
      break;
    case 14:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setHealth(value);
      break;
    case 15:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setHealthMax(value);
      break;
    case 16:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setShield(value);
      break;
    case 36:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setShieldMax(value);
      break;
    case 17:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setEnergy(value);
      break;
    case 37:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setEnergyMax(value);
      break;
    case 18:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMineralContents(value);
      break;
    case 19:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setVespeneContents(value);
      break;
    case 20:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsFlying(value);
      break;
    case 21:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsBurrowed(value);
      break;
    case 38:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsHallucination(value);
      break;
    case 22:
      var value = new proto.SC2APIProtocol.UnitOrder;
      reader.readMessage(value,proto.SC2APIProtocol.UnitOrder.deserializeBinaryFromReader);
      msg.addOrders(value);
      break;
    case 23:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAddOnTag(value);
      break;
    case 24:
      var value = new proto.SC2APIProtocol.PassengerUnit;
      reader.readMessage(value,proto.SC2APIProtocol.PassengerUnit.deserializeBinaryFromReader);
      msg.addPassengers(value);
      break;
    case 25:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setCargoSpaceTaken(value);
      break;
    case 26:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setCargoSpaceMax(value);
      break;
    case 28:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAssignedHarvesters(value);
      break;
    case 29:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setIdealHarvesters(value);
      break;
    case 30:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setWeaponCooldown(value);
      break;
    case 34:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setEngagedTargetTag(value);
      break;
    case 43:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBuffDurationRemain(value);
      break;
    case 44:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBuffDurationMax(value);
      break;
    case 45:
      var value = new proto.SC2APIProtocol.RallyTarget;
      reader.readMessage(value,proto.SC2APIProtocol.RallyTarget.deserializeBinaryFromReader);
      msg.addRallyTargets(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Unit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Unit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Unit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Unit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.DisplayType} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.Alliance} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeInt32(
      5,
      f
    );
  }
  f = message.getPos();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeFloat(
      7,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeFloat(
      8,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeFloat(
      9,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.CloakState} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeEnum(
      10,
      f
    );
  }
  f = message.getBuffIdsList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      27,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 31));
  if (f != null) {
    writer.writeFloat(
      31,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 32));
  if (f != null) {
    writer.writeFloat(
      32,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 11));
  if (f != null) {
    writer.writeBool(
      11,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 12));
  if (f != null) {
    writer.writeBool(
      12,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 13));
  if (f != null) {
    writer.writeBool(
      13,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 35));
  if (f != null) {
    writer.writeBool(
      35,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 39));
  if (f != null) {
    writer.writeBool(
      39,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 40));
  if (f != null) {
    writer.writeInt32(
      40,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 41));
  if (f != null) {
    writer.writeInt32(
      41,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 42));
  if (f != null) {
    writer.writeInt32(
      42,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 14));
  if (f != null) {
    writer.writeFloat(
      14,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 15));
  if (f != null) {
    writer.writeFloat(
      15,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 16));
  if (f != null) {
    writer.writeFloat(
      16,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 36));
  if (f != null) {
    writer.writeFloat(
      36,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 17));
  if (f != null) {
    writer.writeFloat(
      17,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 37));
  if (f != null) {
    writer.writeFloat(
      37,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 18));
  if (f != null) {
    writer.writeInt32(
      18,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 19));
  if (f != null) {
    writer.writeInt32(
      19,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 20));
  if (f != null) {
    writer.writeBool(
      20,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 21));
  if (f != null) {
    writer.writeBool(
      21,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 38));
  if (f != null) {
    writer.writeBool(
      38,
      f
    );
  }
  f = message.getOrdersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      22,
      f,
      proto.SC2APIProtocol.UnitOrder.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 23));
  if (f != null) {
    writer.writeUint64(
      23,
      f
    );
  }
  f = message.getPassengersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      24,
      f,
      proto.SC2APIProtocol.PassengerUnit.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 25));
  if (f != null) {
    writer.writeInt32(
      25,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 26));
  if (f != null) {
    writer.writeInt32(
      26,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 28));
  if (f != null) {
    writer.writeInt32(
      28,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 29));
  if (f != null) {
    writer.writeInt32(
      29,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 30));
  if (f != null) {
    writer.writeFloat(
      30,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 34));
  if (f != null) {
    writer.writeUint64(
      34,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 43));
  if (f != null) {
    writer.writeInt32(
      43,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 44));
  if (f != null) {
    writer.writeInt32(
      44,
      f
    );
  }
  f = message.getRallyTargetsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      45,
      f,
      proto.SC2APIProtocol.RallyTarget.serializeBinaryToWriter
    );
  }
};


/**
 * optional DisplayType display_type = 1;
 * @return {!proto.SC2APIProtocol.DisplayType}
 */
proto.SC2APIProtocol.Unit.prototype.getDisplayType = function() {
  return /** @type {!proto.SC2APIProtocol.DisplayType} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.DisplayType} value */
proto.SC2APIProtocol.Unit.prototype.setDisplayType = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.Unit.prototype.clearDisplayType = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasDisplayType = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Alliance alliance = 2;
 * @return {!proto.SC2APIProtocol.Alliance}
 */
proto.SC2APIProtocol.Unit.prototype.getAlliance = function() {
  return /** @type {!proto.SC2APIProtocol.Alliance} */ (jspb.Message.getFieldWithDefault(this, 2, 1));
};


/** @param {!proto.SC2APIProtocol.Alliance} value */
proto.SC2APIProtocol.Unit.prototype.setAlliance = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.Unit.prototype.clearAlliance = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasAlliance = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint64 tag = 3;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setTag = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.Unit.prototype.clearTag = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasTag = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional uint32 unit_type = 4;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getUnitType = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setUnitType = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.Unit.prototype.clearUnitType = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasUnitType = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional int32 owner = 5;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getOwner = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setOwner = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.Unit.prototype.clearOwner = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasOwner = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional Point pos = 6;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.Unit.prototype.getPos = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 6));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.Unit.prototype.setPos = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


proto.SC2APIProtocol.Unit.prototype.clearPos = function() {
  this.setPos(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasPos = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional float facing = 7;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getFacing = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 7, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setFacing = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.Unit.prototype.clearFacing = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasFacing = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional float radius = 8;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getRadius = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 8, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setRadius = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.SC2APIProtocol.Unit.prototype.clearRadius = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasRadius = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional float build_progress = 9;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getBuildProgress = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 9, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setBuildProgress = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.SC2APIProtocol.Unit.prototype.clearBuildProgress = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasBuildProgress = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional CloakState cloak = 10;
 * @return {!proto.SC2APIProtocol.CloakState}
 */
proto.SC2APIProtocol.Unit.prototype.getCloak = function() {
  return /** @type {!proto.SC2APIProtocol.CloakState} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {!proto.SC2APIProtocol.CloakState} value */
proto.SC2APIProtocol.Unit.prototype.setCloak = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.SC2APIProtocol.Unit.prototype.clearCloak = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasCloak = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * repeated uint32 buff_ids = 27;
 * @return {!Array.<number>}
 */
proto.SC2APIProtocol.Unit.prototype.getBuffIdsList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getRepeatedField(this, 27));
};


/** @param {!Array.<number>} value */
proto.SC2APIProtocol.Unit.prototype.setBuffIdsList = function(value) {
  jspb.Message.setField(this, 27, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.Unit.prototype.addBuffIds = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 27, value, opt_index);
};


proto.SC2APIProtocol.Unit.prototype.clearBuffIdsList = function() {
  this.setBuffIdsList([]);
};


/**
 * optional float detect_range = 31;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getDetectRange = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 31, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setDetectRange = function(value) {
  jspb.Message.setField(this, 31, value);
};


proto.SC2APIProtocol.Unit.prototype.clearDetectRange = function() {
  jspb.Message.setField(this, 31, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasDetectRange = function() {
  return jspb.Message.getField(this, 31) != null;
};


/**
 * optional float radar_range = 32;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getRadarRange = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 32, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setRadarRange = function(value) {
  jspb.Message.setField(this, 32, value);
};


proto.SC2APIProtocol.Unit.prototype.clearRadarRange = function() {
  jspb.Message.setField(this, 32, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasRadarRange = function() {
  return jspb.Message.getField(this, 32) != null;
};


/**
 * optional bool is_selected = 11;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.Unit.prototype.getIsSelected = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 11, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.Unit.prototype.setIsSelected = function(value) {
  jspb.Message.setField(this, 11, value);
};


proto.SC2APIProtocol.Unit.prototype.clearIsSelected = function() {
  jspb.Message.setField(this, 11, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasIsSelected = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional bool is_on_screen = 12;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.Unit.prototype.getIsOnScreen = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 12, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.Unit.prototype.setIsOnScreen = function(value) {
  jspb.Message.setField(this, 12, value);
};


proto.SC2APIProtocol.Unit.prototype.clearIsOnScreen = function() {
  jspb.Message.setField(this, 12, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasIsOnScreen = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional bool is_blip = 13;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.Unit.prototype.getIsBlip = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 13, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.Unit.prototype.setIsBlip = function(value) {
  jspb.Message.setField(this, 13, value);
};


proto.SC2APIProtocol.Unit.prototype.clearIsBlip = function() {
  jspb.Message.setField(this, 13, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasIsBlip = function() {
  return jspb.Message.getField(this, 13) != null;
};


/**
 * optional bool is_powered = 35;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.Unit.prototype.getIsPowered = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 35, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.Unit.prototype.setIsPowered = function(value) {
  jspb.Message.setField(this, 35, value);
};


proto.SC2APIProtocol.Unit.prototype.clearIsPowered = function() {
  jspb.Message.setField(this, 35, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasIsPowered = function() {
  return jspb.Message.getField(this, 35) != null;
};


/**
 * optional bool is_active = 39;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.Unit.prototype.getIsActive = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 39, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.Unit.prototype.setIsActive = function(value) {
  jspb.Message.setField(this, 39, value);
};


proto.SC2APIProtocol.Unit.prototype.clearIsActive = function() {
  jspb.Message.setField(this, 39, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasIsActive = function() {
  return jspb.Message.getField(this, 39) != null;
};


/**
 * optional int32 attack_upgrade_level = 40;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getAttackUpgradeLevel = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 40, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setAttackUpgradeLevel = function(value) {
  jspb.Message.setField(this, 40, value);
};


proto.SC2APIProtocol.Unit.prototype.clearAttackUpgradeLevel = function() {
  jspb.Message.setField(this, 40, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasAttackUpgradeLevel = function() {
  return jspb.Message.getField(this, 40) != null;
};


/**
 * optional int32 armor_upgrade_level = 41;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getArmorUpgradeLevel = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 41, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setArmorUpgradeLevel = function(value) {
  jspb.Message.setField(this, 41, value);
};


proto.SC2APIProtocol.Unit.prototype.clearArmorUpgradeLevel = function() {
  jspb.Message.setField(this, 41, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasArmorUpgradeLevel = function() {
  return jspb.Message.getField(this, 41) != null;
};


/**
 * optional int32 shield_upgrade_level = 42;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getShieldUpgradeLevel = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 42, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setShieldUpgradeLevel = function(value) {
  jspb.Message.setField(this, 42, value);
};


proto.SC2APIProtocol.Unit.prototype.clearShieldUpgradeLevel = function() {
  jspb.Message.setField(this, 42, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasShieldUpgradeLevel = function() {
  return jspb.Message.getField(this, 42) != null;
};


/**
 * optional float health = 14;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getHealth = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 14, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setHealth = function(value) {
  jspb.Message.setField(this, 14, value);
};


proto.SC2APIProtocol.Unit.prototype.clearHealth = function() {
  jspb.Message.setField(this, 14, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasHealth = function() {
  return jspb.Message.getField(this, 14) != null;
};


/**
 * optional float health_max = 15;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getHealthMax = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 15, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setHealthMax = function(value) {
  jspb.Message.setField(this, 15, value);
};


proto.SC2APIProtocol.Unit.prototype.clearHealthMax = function() {
  jspb.Message.setField(this, 15, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasHealthMax = function() {
  return jspb.Message.getField(this, 15) != null;
};


/**
 * optional float shield = 16;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getShield = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 16, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setShield = function(value) {
  jspb.Message.setField(this, 16, value);
};


proto.SC2APIProtocol.Unit.prototype.clearShield = function() {
  jspb.Message.setField(this, 16, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasShield = function() {
  return jspb.Message.getField(this, 16) != null;
};


/**
 * optional float shield_max = 36;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getShieldMax = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 36, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setShieldMax = function(value) {
  jspb.Message.setField(this, 36, value);
};


proto.SC2APIProtocol.Unit.prototype.clearShieldMax = function() {
  jspb.Message.setField(this, 36, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasShieldMax = function() {
  return jspb.Message.getField(this, 36) != null;
};


/**
 * optional float energy = 17;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getEnergy = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 17, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setEnergy = function(value) {
  jspb.Message.setField(this, 17, value);
};


proto.SC2APIProtocol.Unit.prototype.clearEnergy = function() {
  jspb.Message.setField(this, 17, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasEnergy = function() {
  return jspb.Message.getField(this, 17) != null;
};


/**
 * optional float energy_max = 37;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getEnergyMax = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 37, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setEnergyMax = function(value) {
  jspb.Message.setField(this, 37, value);
};


proto.SC2APIProtocol.Unit.prototype.clearEnergyMax = function() {
  jspb.Message.setField(this, 37, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasEnergyMax = function() {
  return jspb.Message.getField(this, 37) != null;
};


/**
 * optional int32 mineral_contents = 18;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getMineralContents = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 18, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setMineralContents = function(value) {
  jspb.Message.setField(this, 18, value);
};


proto.SC2APIProtocol.Unit.prototype.clearMineralContents = function() {
  jspb.Message.setField(this, 18, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasMineralContents = function() {
  return jspb.Message.getField(this, 18) != null;
};


/**
 * optional int32 vespene_contents = 19;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getVespeneContents = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 19, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setVespeneContents = function(value) {
  jspb.Message.setField(this, 19, value);
};


proto.SC2APIProtocol.Unit.prototype.clearVespeneContents = function() {
  jspb.Message.setField(this, 19, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasVespeneContents = function() {
  return jspb.Message.getField(this, 19) != null;
};


/**
 * optional bool is_flying = 20;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.Unit.prototype.getIsFlying = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 20, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.Unit.prototype.setIsFlying = function(value) {
  jspb.Message.setField(this, 20, value);
};


proto.SC2APIProtocol.Unit.prototype.clearIsFlying = function() {
  jspb.Message.setField(this, 20, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasIsFlying = function() {
  return jspb.Message.getField(this, 20) != null;
};


/**
 * optional bool is_burrowed = 21;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.Unit.prototype.getIsBurrowed = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 21, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.Unit.prototype.setIsBurrowed = function(value) {
  jspb.Message.setField(this, 21, value);
};


proto.SC2APIProtocol.Unit.prototype.clearIsBurrowed = function() {
  jspb.Message.setField(this, 21, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasIsBurrowed = function() {
  return jspb.Message.getField(this, 21) != null;
};


/**
 * optional bool is_hallucination = 38;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.Unit.prototype.getIsHallucination = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 38, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.Unit.prototype.setIsHallucination = function(value) {
  jspb.Message.setField(this, 38, value);
};


proto.SC2APIProtocol.Unit.prototype.clearIsHallucination = function() {
  jspb.Message.setField(this, 38, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasIsHallucination = function() {
  return jspb.Message.getField(this, 38) != null;
};


/**
 * repeated UnitOrder orders = 22;
 * @return {!Array.<!proto.SC2APIProtocol.UnitOrder>}
 */
proto.SC2APIProtocol.Unit.prototype.getOrdersList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.UnitOrder>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.UnitOrder, 22));
};


/** @param {!Array.<!proto.SC2APIProtocol.UnitOrder>} value */
proto.SC2APIProtocol.Unit.prototype.setOrdersList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 22, value);
};


/**
 * @param {!proto.SC2APIProtocol.UnitOrder=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.UnitOrder}
 */
proto.SC2APIProtocol.Unit.prototype.addOrders = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 22, opt_value, proto.SC2APIProtocol.UnitOrder, opt_index);
};


proto.SC2APIProtocol.Unit.prototype.clearOrdersList = function() {
  this.setOrdersList([]);
};


/**
 * optional uint64 add_on_tag = 23;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getAddOnTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 23, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setAddOnTag = function(value) {
  jspb.Message.setField(this, 23, value);
};


proto.SC2APIProtocol.Unit.prototype.clearAddOnTag = function() {
  jspb.Message.setField(this, 23, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasAddOnTag = function() {
  return jspb.Message.getField(this, 23) != null;
};


/**
 * repeated PassengerUnit passengers = 24;
 * @return {!Array.<!proto.SC2APIProtocol.PassengerUnit>}
 */
proto.SC2APIProtocol.Unit.prototype.getPassengersList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.PassengerUnit>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.PassengerUnit, 24));
};


/** @param {!Array.<!proto.SC2APIProtocol.PassengerUnit>} value */
proto.SC2APIProtocol.Unit.prototype.setPassengersList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 24, value);
};


/**
 * @param {!proto.SC2APIProtocol.PassengerUnit=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.PassengerUnit}
 */
proto.SC2APIProtocol.Unit.prototype.addPassengers = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 24, opt_value, proto.SC2APIProtocol.PassengerUnit, opt_index);
};


proto.SC2APIProtocol.Unit.prototype.clearPassengersList = function() {
  this.setPassengersList([]);
};


/**
 * optional int32 cargo_space_taken = 25;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getCargoSpaceTaken = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 25, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setCargoSpaceTaken = function(value) {
  jspb.Message.setField(this, 25, value);
};


proto.SC2APIProtocol.Unit.prototype.clearCargoSpaceTaken = function() {
  jspb.Message.setField(this, 25, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasCargoSpaceTaken = function() {
  return jspb.Message.getField(this, 25) != null;
};


/**
 * optional int32 cargo_space_max = 26;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getCargoSpaceMax = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 26, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setCargoSpaceMax = function(value) {
  jspb.Message.setField(this, 26, value);
};


proto.SC2APIProtocol.Unit.prototype.clearCargoSpaceMax = function() {
  jspb.Message.setField(this, 26, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasCargoSpaceMax = function() {
  return jspb.Message.getField(this, 26) != null;
};


/**
 * optional int32 assigned_harvesters = 28;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getAssignedHarvesters = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 28, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setAssignedHarvesters = function(value) {
  jspb.Message.setField(this, 28, value);
};


proto.SC2APIProtocol.Unit.prototype.clearAssignedHarvesters = function() {
  jspb.Message.setField(this, 28, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasAssignedHarvesters = function() {
  return jspb.Message.getField(this, 28) != null;
};


/**
 * optional int32 ideal_harvesters = 29;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getIdealHarvesters = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 29, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setIdealHarvesters = function(value) {
  jspb.Message.setField(this, 29, value);
};


proto.SC2APIProtocol.Unit.prototype.clearIdealHarvesters = function() {
  jspb.Message.setField(this, 29, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasIdealHarvesters = function() {
  return jspb.Message.getField(this, 29) != null;
};


/**
 * optional float weapon_cooldown = 30;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getWeaponCooldown = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 30, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setWeaponCooldown = function(value) {
  jspb.Message.setField(this, 30, value);
};


proto.SC2APIProtocol.Unit.prototype.clearWeaponCooldown = function() {
  jspb.Message.setField(this, 30, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasWeaponCooldown = function() {
  return jspb.Message.getField(this, 30) != null;
};


/**
 * optional uint64 engaged_target_tag = 34;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getEngagedTargetTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 34, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setEngagedTargetTag = function(value) {
  jspb.Message.setField(this, 34, value);
};


proto.SC2APIProtocol.Unit.prototype.clearEngagedTargetTag = function() {
  jspb.Message.setField(this, 34, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasEngagedTargetTag = function() {
  return jspb.Message.getField(this, 34) != null;
};


/**
 * optional int32 buff_duration_remain = 43;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getBuffDurationRemain = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 43, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setBuffDurationRemain = function(value) {
  jspb.Message.setField(this, 43, value);
};


proto.SC2APIProtocol.Unit.prototype.clearBuffDurationRemain = function() {
  jspb.Message.setField(this, 43, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasBuffDurationRemain = function() {
  return jspb.Message.getField(this, 43) != null;
};


/**
 * optional int32 buff_duration_max = 44;
 * @return {number}
 */
proto.SC2APIProtocol.Unit.prototype.getBuffDurationMax = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 44, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Unit.prototype.setBuffDurationMax = function(value) {
  jspb.Message.setField(this, 44, value);
};


proto.SC2APIProtocol.Unit.prototype.clearBuffDurationMax = function() {
  jspb.Message.setField(this, 44, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Unit.prototype.hasBuffDurationMax = function() {
  return jspb.Message.getField(this, 44) != null;
};


/**
 * repeated RallyTarget rally_targets = 45;
 * @return {!Array.<!proto.SC2APIProtocol.RallyTarget>}
 */
proto.SC2APIProtocol.Unit.prototype.getRallyTargetsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.RallyTarget>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.RallyTarget, 45));
};


/** @param {!Array.<!proto.SC2APIProtocol.RallyTarget>} value */
proto.SC2APIProtocol.Unit.prototype.setRallyTargetsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 45, value);
};


/**
 * @param {!proto.SC2APIProtocol.RallyTarget=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.RallyTarget}
 */
proto.SC2APIProtocol.Unit.prototype.addRallyTargets = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 45, opt_value, proto.SC2APIProtocol.RallyTarget, opt_index);
};


proto.SC2APIProtocol.Unit.prototype.clearRallyTargetsList = function() {
  this.setRallyTargetsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.MapState = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.MapState, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.MapState.displayName = 'proto.SC2APIProtocol.MapState';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.MapState.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.MapState.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.MapState} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.MapState.toObject = function(includeInstance, msg) {
  var f, obj = {
    visibility: (f = msg.getVisibility()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    creep: (f = msg.getCreep()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.MapState}
 */
proto.SC2APIProtocol.MapState.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.MapState;
  return proto.SC2APIProtocol.MapState.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.MapState} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.MapState}
 */
proto.SC2APIProtocol.MapState.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setVisibility(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setCreep(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.MapState.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.MapState.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.MapState} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.MapState.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVisibility();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getCreep();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
};


/**
 * optional ImageData visibility = 1;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.MapState.prototype.getVisibility = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 1));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.MapState.prototype.setVisibility = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.MapState.prototype.clearVisibility = function() {
  this.setVisibility(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.MapState.prototype.hasVisibility = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ImageData creep = 2;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.MapState.prototype.getCreep = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 2));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.MapState.prototype.setCreep = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.MapState.prototype.clearCreep = function() {
  this.setCreep(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.MapState.prototype.hasCreep = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Event = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.Event.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.Event, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Event.displayName = 'proto.SC2APIProtocol.Event';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.Event.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Event.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Event.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Event} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Event.toObject = function(includeInstance, msg) {
  var f, obj = {
    deadUnitsList: jspb.Message.getRepeatedField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Event}
 */
proto.SC2APIProtocol.Event.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Event;
  return proto.SC2APIProtocol.Event.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Event} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Event}
 */
proto.SC2APIProtocol.Event.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.addDeadUnits(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Event.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Event.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Event} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Event.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDeadUnitsList();
  if (f.length > 0) {
    writer.writeRepeatedUint64(
      1,
      f
    );
  }
};


/**
 * repeated uint64 dead_units = 1;
 * @return {!Array.<number>}
 */
proto.SC2APIProtocol.Event.prototype.getDeadUnitsList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array.<number>} value */
proto.SC2APIProtocol.Event.prototype.setDeadUnitsList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.Event.prototype.addDeadUnits = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.SC2APIProtocol.Event.prototype.clearDeadUnitsList = function() {
  this.setDeadUnitsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Effect = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.Effect.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.Effect, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Effect.displayName = 'proto.SC2APIProtocol.Effect';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.Effect.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Effect.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Effect.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Effect} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Effect.toObject = function(includeInstance, msg) {
  var f, obj = {
    effectId: jspb.Message.getField(msg, 1),
    posList: jspb.Message.toObjectList(msg.getPosList(),
    s2clientprotocol_common_pb.Point2D.toObject, includeInstance),
    alliance: jspb.Message.getField(msg, 3),
    owner: jspb.Message.getField(msg, 4),
    radius: jspb.Message.getOptionalFloatingPointField(msg, 5)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Effect}
 */
proto.SC2APIProtocol.Effect.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Effect;
  return proto.SC2APIProtocol.Effect.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Effect} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Effect}
 */
proto.SC2APIProtocol.Effect.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setEffectId(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.Point2D;
      reader.readMessage(value,s2clientprotocol_common_pb.Point2D.deserializeBinaryFromReader);
      msg.addPos(value);
      break;
    case 3:
      var value = /** @type {!proto.SC2APIProtocol.Alliance} */ (reader.readEnum());
      msg.setAlliance(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setOwner(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setRadius(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Effect.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Effect.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Effect} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Effect.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getPosList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      s2clientprotocol_common_pb.Point2D.serializeBinaryToWriter
    );
  }
  f = /** @type {!proto.SC2APIProtocol.Alliance} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeEnum(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeFloat(
      5,
      f
    );
  }
};


/**
 * optional uint32 effect_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.Effect.prototype.getEffectId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Effect.prototype.setEffectId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.Effect.prototype.clearEffectId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Effect.prototype.hasEffectId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated Point2D pos = 2;
 * @return {!Array.<!proto.SC2APIProtocol.Point2D>}
 */
proto.SC2APIProtocol.Effect.prototype.getPosList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.Point2D>} */ (
    jspb.Message.getRepeatedWrapperField(this, s2clientprotocol_common_pb.Point2D, 2));
};


/** @param {!Array.<!proto.SC2APIProtocol.Point2D>} value */
proto.SC2APIProtocol.Effect.prototype.setPosList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.SC2APIProtocol.Point2D=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.Point2D}
 */
proto.SC2APIProtocol.Effect.prototype.addPos = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.SC2APIProtocol.Point2D, opt_index);
};


proto.SC2APIProtocol.Effect.prototype.clearPosList = function() {
  this.setPosList([]);
};


/**
 * optional Alliance alliance = 3;
 * @return {!proto.SC2APIProtocol.Alliance}
 */
proto.SC2APIProtocol.Effect.prototype.getAlliance = function() {
  return /** @type {!proto.SC2APIProtocol.Alliance} */ (jspb.Message.getFieldWithDefault(this, 3, 1));
};


/** @param {!proto.SC2APIProtocol.Alliance} value */
proto.SC2APIProtocol.Effect.prototype.setAlliance = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.Effect.prototype.clearAlliance = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Effect.prototype.hasAlliance = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional int32 owner = 4;
 * @return {number}
 */
proto.SC2APIProtocol.Effect.prototype.getOwner = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Effect.prototype.setOwner = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.Effect.prototype.clearOwner = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Effect.prototype.hasOwner = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional float radius = 5;
 * @return {number}
 */
proto.SC2APIProtocol.Effect.prototype.getRadius = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 5, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.Effect.prototype.setRadius = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.Effect.prototype.clearRadius = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Effect.prototype.hasRadius = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionRaw = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.SC2APIProtocol.ActionRaw.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.ActionRaw, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionRaw.displayName = 'proto.SC2APIProtocol.ActionRaw';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.ActionRaw.oneofGroups_ = [[1,2,3]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.ActionRaw.ActionCase = {
  ACTION_NOT_SET: 0,
  UNIT_COMMAND: 1,
  CAMERA_MOVE: 2,
  TOGGLE_AUTOCAST: 3
};

/**
 * @return {proto.SC2APIProtocol.ActionRaw.ActionCase}
 */
proto.SC2APIProtocol.ActionRaw.prototype.getActionCase = function() {
  return /** @type {proto.SC2APIProtocol.ActionRaw.ActionCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.ActionRaw.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionRaw.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionRaw.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionRaw} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionRaw.toObject = function(includeInstance, msg) {
  var f, obj = {
    unitCommand: (f = msg.getUnitCommand()) && proto.SC2APIProtocol.ActionRawUnitCommand.toObject(includeInstance, f),
    cameraMove: (f = msg.getCameraMove()) && proto.SC2APIProtocol.ActionRawCameraMove.toObject(includeInstance, f),
    toggleAutocast: (f = msg.getToggleAutocast()) && proto.SC2APIProtocol.ActionRawToggleAutocast.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionRaw}
 */
proto.SC2APIProtocol.ActionRaw.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionRaw;
  return proto.SC2APIProtocol.ActionRaw.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionRaw} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionRaw}
 */
proto.SC2APIProtocol.ActionRaw.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.ActionRawUnitCommand;
      reader.readMessage(value,proto.SC2APIProtocol.ActionRawUnitCommand.deserializeBinaryFromReader);
      msg.setUnitCommand(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.ActionRawCameraMove;
      reader.readMessage(value,proto.SC2APIProtocol.ActionRawCameraMove.deserializeBinaryFromReader);
      msg.setCameraMove(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.ActionRawToggleAutocast;
      reader.readMessage(value,proto.SC2APIProtocol.ActionRawToggleAutocast.deserializeBinaryFromReader);
      msg.setToggleAutocast(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionRaw.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionRaw.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionRaw} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionRaw.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUnitCommand();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.ActionRawUnitCommand.serializeBinaryToWriter
    );
  }
  f = message.getCameraMove();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.SC2APIProtocol.ActionRawCameraMove.serializeBinaryToWriter
    );
  }
  f = message.getToggleAutocast();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.ActionRawToggleAutocast.serializeBinaryToWriter
    );
  }
};


/**
 * optional ActionRawUnitCommand unit_command = 1;
 * @return {?proto.SC2APIProtocol.ActionRawUnitCommand}
 */
proto.SC2APIProtocol.ActionRaw.prototype.getUnitCommand = function() {
  return /** @type{?proto.SC2APIProtocol.ActionRawUnitCommand} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionRawUnitCommand, 1));
};


/** @param {?proto.SC2APIProtocol.ActionRawUnitCommand|undefined} value */
proto.SC2APIProtocol.ActionRaw.prototype.setUnitCommand = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.SC2APIProtocol.ActionRaw.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionRaw.prototype.clearUnitCommand = function() {
  this.setUnitCommand(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionRaw.prototype.hasUnitCommand = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ActionRawCameraMove camera_move = 2;
 * @return {?proto.SC2APIProtocol.ActionRawCameraMove}
 */
proto.SC2APIProtocol.ActionRaw.prototype.getCameraMove = function() {
  return /** @type{?proto.SC2APIProtocol.ActionRawCameraMove} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionRawCameraMove, 2));
};


/** @param {?proto.SC2APIProtocol.ActionRawCameraMove|undefined} value */
proto.SC2APIProtocol.ActionRaw.prototype.setCameraMove = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.SC2APIProtocol.ActionRaw.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionRaw.prototype.clearCameraMove = function() {
  this.setCameraMove(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionRaw.prototype.hasCameraMove = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ActionRawToggleAutocast toggle_autocast = 3;
 * @return {?proto.SC2APIProtocol.ActionRawToggleAutocast}
 */
proto.SC2APIProtocol.ActionRaw.prototype.getToggleAutocast = function() {
  return /** @type{?proto.SC2APIProtocol.ActionRawToggleAutocast} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionRawToggleAutocast, 3));
};


/** @param {?proto.SC2APIProtocol.ActionRawToggleAutocast|undefined} value */
proto.SC2APIProtocol.ActionRaw.prototype.setToggleAutocast = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.SC2APIProtocol.ActionRaw.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionRaw.prototype.clearToggleAutocast = function() {
  this.setToggleAutocast(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionRaw.prototype.hasToggleAutocast = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionRawUnitCommand = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ActionRawUnitCommand.repeatedFields_, proto.SC2APIProtocol.ActionRawUnitCommand.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.ActionRawUnitCommand, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionRawUnitCommand.displayName = 'proto.SC2APIProtocol.ActionRawUnitCommand';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ActionRawUnitCommand.repeatedFields_ = [4];

/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.ActionRawUnitCommand.oneofGroups_ = [[2,3]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.TargetCase = {
  TARGET_NOT_SET: 0,
  TARGET_WORLD_SPACE_POS: 2,
  TARGET_UNIT_TAG: 3
};

/**
 * @return {proto.SC2APIProtocol.ActionRawUnitCommand.TargetCase}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.getTargetCase = function() {
  return /** @type {proto.SC2APIProtocol.ActionRawUnitCommand.TargetCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.ActionRawUnitCommand.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionRawUnitCommand.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionRawUnitCommand} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionRawUnitCommand.toObject = function(includeInstance, msg) {
  var f, obj = {
    abilityId: jspb.Message.getField(msg, 1),
    targetWorldSpacePos: (f = msg.getTargetWorldSpacePos()) && s2clientprotocol_common_pb.Point2D.toObject(includeInstance, f),
    targetUnitTag: jspb.Message.getField(msg, 3),
    unitTagsList: jspb.Message.getRepeatedField(msg, 4),
    queueCommand: jspb.Message.getField(msg, 5)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionRawUnitCommand}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionRawUnitCommand;
  return proto.SC2APIProtocol.ActionRawUnitCommand.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionRawUnitCommand} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionRawUnitCommand}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAbilityId(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.Point2D;
      reader.readMessage(value,s2clientprotocol_common_pb.Point2D.deserializeBinaryFromReader);
      msg.setTargetWorldSpacePos(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setTargetUnitTag(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.addUnitTags(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setQueueCommand(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionRawUnitCommand.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionRawUnitCommand} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionRawUnitCommand.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = message.getTargetWorldSpacePos();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.Point2D.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = message.getUnitTagsList();
  if (f.length > 0) {
    writer.writeRepeatedUint64(
      4,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeBool(
      5,
      f
    );
  }
};


/**
 * optional int32 ability_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.getAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionRawUnitCommand.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Point2D target_world_space_pos = 2;
 * @return {?proto.SC2APIProtocol.Point2D}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.getTargetWorldSpacePos = function() {
  return /** @type{?proto.SC2APIProtocol.Point2D} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point2D, 2));
};


/** @param {?proto.SC2APIProtocol.Point2D|undefined} value */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.setTargetWorldSpacePos = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.SC2APIProtocol.ActionRawUnitCommand.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionRawUnitCommand.prototype.clearTargetWorldSpacePos = function() {
  this.setTargetWorldSpacePos(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.hasTargetWorldSpacePos = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint64 target_unit_tag = 3;
 * @return {number}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.getTargetUnitTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.setTargetUnitTag = function(value) {
  jspb.Message.setOneofField(this, 3, proto.SC2APIProtocol.ActionRawUnitCommand.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionRawUnitCommand.prototype.clearTargetUnitTag = function() {
  jspb.Message.setOneofField(this, 3, proto.SC2APIProtocol.ActionRawUnitCommand.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.hasTargetUnitTag = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * repeated uint64 unit_tags = 4;
 * @return {!Array.<number>}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.getUnitTagsList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getRepeatedField(this, 4));
};


/** @param {!Array.<number>} value */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.setUnitTagsList = function(value) {
  jspb.Message.setField(this, 4, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.addUnitTags = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 4, value, opt_index);
};


proto.SC2APIProtocol.ActionRawUnitCommand.prototype.clearUnitTagsList = function() {
  this.setUnitTagsList([]);
};


/**
 * optional bool queue_command = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.getQueueCommand = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.setQueueCommand = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.ActionRawUnitCommand.prototype.clearQueueCommand = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionRawUnitCommand.prototype.hasQueueCommand = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionRawCameraMove = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionRawCameraMove, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionRawCameraMove.displayName = 'proto.SC2APIProtocol.ActionRawCameraMove';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionRawCameraMove.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionRawCameraMove.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionRawCameraMove} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionRawCameraMove.toObject = function(includeInstance, msg) {
  var f, obj = {
    centerWorldSpace: (f = msg.getCenterWorldSpace()) && s2clientprotocol_common_pb.Point.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionRawCameraMove}
 */
proto.SC2APIProtocol.ActionRawCameraMove.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionRawCameraMove;
  return proto.SC2APIProtocol.ActionRawCameraMove.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionRawCameraMove} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionRawCameraMove}
 */
proto.SC2APIProtocol.ActionRawCameraMove.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.Point;
      reader.readMessage(value,s2clientprotocol_common_pb.Point.deserializeBinaryFromReader);
      msg.setCenterWorldSpace(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionRawCameraMove.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionRawCameraMove.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionRawCameraMove} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionRawCameraMove.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCenterWorldSpace();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.Point.serializeBinaryToWriter
    );
  }
};


/**
 * optional Point center_world_space = 1;
 * @return {?proto.SC2APIProtocol.Point}
 */
proto.SC2APIProtocol.ActionRawCameraMove.prototype.getCenterWorldSpace = function() {
  return /** @type{?proto.SC2APIProtocol.Point} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point, 1));
};


/** @param {?proto.SC2APIProtocol.Point|undefined} value */
proto.SC2APIProtocol.ActionRawCameraMove.prototype.setCenterWorldSpace = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.ActionRawCameraMove.prototype.clearCenterWorldSpace = function() {
  this.setCenterWorldSpace(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionRawCameraMove.prototype.hasCenterWorldSpace = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionRawToggleAutocast = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ActionRawToggleAutocast.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ActionRawToggleAutocast, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionRawToggleAutocast.displayName = 'proto.SC2APIProtocol.ActionRawToggleAutocast';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ActionRawToggleAutocast.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionRawToggleAutocast.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionRawToggleAutocast.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionRawToggleAutocast} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionRawToggleAutocast.toObject = function(includeInstance, msg) {
  var f, obj = {
    abilityId: jspb.Message.getField(msg, 1),
    unitTagsList: jspb.Message.getRepeatedField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionRawToggleAutocast}
 */
proto.SC2APIProtocol.ActionRawToggleAutocast.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionRawToggleAutocast;
  return proto.SC2APIProtocol.ActionRawToggleAutocast.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionRawToggleAutocast} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionRawToggleAutocast}
 */
proto.SC2APIProtocol.ActionRawToggleAutocast.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAbilityId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.addUnitTags(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionRawToggleAutocast.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionRawToggleAutocast.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionRawToggleAutocast} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionRawToggleAutocast.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = message.getUnitTagsList();
  if (f.length > 0) {
    writer.writeRepeatedUint64(
      2,
      f
    );
  }
};


/**
 * optional int32 ability_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ActionRawToggleAutocast.prototype.getAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionRawToggleAutocast.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionRawToggleAutocast.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionRawToggleAutocast.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated uint64 unit_tags = 2;
 * @return {!Array.<number>}
 */
proto.SC2APIProtocol.ActionRawToggleAutocast.prototype.getUnitTagsList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getRepeatedField(this, 2));
};


/** @param {!Array.<number>} value */
proto.SC2APIProtocol.ActionRawToggleAutocast.prototype.setUnitTagsList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.ActionRawToggleAutocast.prototype.addUnitTags = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.SC2APIProtocol.ActionRawToggleAutocast.prototype.clearUnitTagsList = function() {
  this.setUnitTagsList([]);
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.DisplayType = {
  VISIBLE: 1,
  SNAPSHOT: 2,
  HIDDEN: 3,
  PLACEHOLDER: 4
};

/**
 * @enum {number}
 */
proto.SC2APIProtocol.Alliance = {
  SELF: 1,
  ALLY: 2,
  NEUTRAL: 3,
  ENEMY: 4
};

/**
 * @enum {number}
 */
proto.SC2APIProtocol.CloakState = {
  CLOAKEDUNKNOWN: 0,
  CLOAKED: 1,
  CLOAKEDDETECTED: 2,
  NOTCLOAKED: 3,
  CLOAKEDALLIED: 4
};

goog.object.extend(exports, proto.SC2APIProtocol);

},{"./common_pb.js":104,"google-protobuf":68}],110:[function(require,module,exports){
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var s2clientprotocol_common_pb = require('./common_pb.js');
var s2clientprotocol_data_pb = require('./data_pb.js');
var s2clientprotocol_debug_pb = require('./debug_pb.js');
var s2clientprotocol_error_pb = require('./error_pb.js');
var s2clientprotocol_query_pb = require('./query_pb.js');
var s2clientprotocol_raw_pb = require('./raw_pb.js');
var s2clientprotocol_score_pb = require('./score_pb.js');
var s2clientprotocol_spatial_pb = require('./spatial_pb.js');
var s2clientprotocol_ui_pb = require('./ui_pb.js');
goog.exportSymbol('proto.SC2APIProtocol.AIBuild', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Action', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionChat', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionChat.Channel', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionError', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionObserverCameraFollowPlayer', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionObserverCameraFollowUnits', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionObserverCameraMove', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionObserverPlayerPerspective', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Alert', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ChatReceived', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Difficulty', null, global);
goog.exportSymbol('proto.SC2APIProtocol.InterfaceOptions', null, global);
goog.exportSymbol('proto.SC2APIProtocol.LocalMap', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Observation', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ObserverAction', null, global);
goog.exportSymbol('proto.SC2APIProtocol.PlayerCommon', null, global);
goog.exportSymbol('proto.SC2APIProtocol.PlayerInfo', null, global);
goog.exportSymbol('proto.SC2APIProtocol.PlayerInfoExtra', null, global);
goog.exportSymbol('proto.SC2APIProtocol.PlayerResult', null, global);
goog.exportSymbol('proto.SC2APIProtocol.PlayerSetup', null, global);
goog.exportSymbol('proto.SC2APIProtocol.PlayerType', null, global);
goog.exportSymbol('proto.SC2APIProtocol.PortSet', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Request', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestAction', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestAvailableMaps', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestCreateGame', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestData', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestDebug', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestGameInfo', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestJoinGame', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestLeaveGame', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestMapCommand', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestObservation', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestObserverAction', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestPing', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestQuickLoad', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestQuickSave', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestQuit', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestReplayInfo', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestRestartGame', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestSaveMap', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestSaveReplay', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestStartReplay', null, global);
goog.exportSymbol('proto.SC2APIProtocol.RequestStep', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Response', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseAction', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseAvailableMaps', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseCreateGame', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseCreateGame.Error', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseData', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseDebug', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseGameInfo', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseJoinGame', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseJoinGame.Error', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseLeaveGame', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseMapCommand', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseMapCommand.Error', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseObservation', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseObserverAction', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponsePing', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseQuickLoad', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseQuickSave', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseQuit', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseReplayInfo', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseReplayInfo.Error', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseRestartGame', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseRestartGame.Error', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseSaveMap', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseSaveMap.Error', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseSaveReplay', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseStartReplay', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseStartReplay.Error', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ResponseStep', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Result', null, global);
goog.exportSymbol('proto.SC2APIProtocol.SpatialCameraSetup', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Status', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Request = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.SC2APIProtocol.Request.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.Request, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Request.displayName = 'proto.SC2APIProtocol.Request';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.Request.oneofGroups_ = [[1,2,3,4,5,6,7,8,9,10,11,21,12,13,14,15,22,16,17,18,19,20]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.Request.RequestCase = {
  REQUEST_NOT_SET: 0,
  CREATE_GAME: 1,
  JOIN_GAME: 2,
  RESTART_GAME: 3,
  START_REPLAY: 4,
  LEAVE_GAME: 5,
  QUICK_SAVE: 6,
  QUICK_LOAD: 7,
  QUIT: 8,
  GAME_INFO: 9,
  OBSERVATION: 10,
  ACTION: 11,
  OBS_ACTION: 21,
  STEP: 12,
  DATA: 13,
  QUERY: 14,
  SAVE_REPLAY: 15,
  MAP_COMMAND: 22,
  REPLAY_INFO: 16,
  AVAILABLE_MAPS: 17,
  SAVE_MAP: 18,
  PING: 19,
  DEBUG: 20
};

/**
 * @return {proto.SC2APIProtocol.Request.RequestCase}
 */
proto.SC2APIProtocol.Request.prototype.getRequestCase = function() {
  return /** @type {proto.SC2APIProtocol.Request.RequestCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.Request.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Request.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Request.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Request} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Request.toObject = function(includeInstance, msg) {
  var f, obj = {
    createGame: (f = msg.getCreateGame()) && proto.SC2APIProtocol.RequestCreateGame.toObject(includeInstance, f),
    joinGame: (f = msg.getJoinGame()) && proto.SC2APIProtocol.RequestJoinGame.toObject(includeInstance, f),
    restartGame: (f = msg.getRestartGame()) && proto.SC2APIProtocol.RequestRestartGame.toObject(includeInstance, f),
    startReplay: (f = msg.getStartReplay()) && proto.SC2APIProtocol.RequestStartReplay.toObject(includeInstance, f),
    leaveGame: (f = msg.getLeaveGame()) && proto.SC2APIProtocol.RequestLeaveGame.toObject(includeInstance, f),
    quickSave: (f = msg.getQuickSave()) && proto.SC2APIProtocol.RequestQuickSave.toObject(includeInstance, f),
    quickLoad: (f = msg.getQuickLoad()) && proto.SC2APIProtocol.RequestQuickLoad.toObject(includeInstance, f),
    quit: (f = msg.getQuit()) && proto.SC2APIProtocol.RequestQuit.toObject(includeInstance, f),
    gameInfo: (f = msg.getGameInfo()) && proto.SC2APIProtocol.RequestGameInfo.toObject(includeInstance, f),
    observation: (f = msg.getObservation()) && proto.SC2APIProtocol.RequestObservation.toObject(includeInstance, f),
    action: (f = msg.getAction()) && proto.SC2APIProtocol.RequestAction.toObject(includeInstance, f),
    obsAction: (f = msg.getObsAction()) && proto.SC2APIProtocol.RequestObserverAction.toObject(includeInstance, f),
    step: (f = msg.getStep()) && proto.SC2APIProtocol.RequestStep.toObject(includeInstance, f),
    data: (f = msg.getData()) && proto.SC2APIProtocol.RequestData.toObject(includeInstance, f),
    query: (f = msg.getQuery()) && s2clientprotocol_query_pb.RequestQuery.toObject(includeInstance, f),
    saveReplay: (f = msg.getSaveReplay()) && proto.SC2APIProtocol.RequestSaveReplay.toObject(includeInstance, f),
    mapCommand: (f = msg.getMapCommand()) && proto.SC2APIProtocol.RequestMapCommand.toObject(includeInstance, f),
    replayInfo: (f = msg.getReplayInfo()) && proto.SC2APIProtocol.RequestReplayInfo.toObject(includeInstance, f),
    availableMaps: (f = msg.getAvailableMaps()) && proto.SC2APIProtocol.RequestAvailableMaps.toObject(includeInstance, f),
    saveMap: (f = msg.getSaveMap()) && proto.SC2APIProtocol.RequestSaveMap.toObject(includeInstance, f),
    ping: (f = msg.getPing()) && proto.SC2APIProtocol.RequestPing.toObject(includeInstance, f),
    debug: (f = msg.getDebug()) && proto.SC2APIProtocol.RequestDebug.toObject(includeInstance, f),
    id: jspb.Message.getField(msg, 97)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Request}
 */
proto.SC2APIProtocol.Request.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Request;
  return proto.SC2APIProtocol.Request.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Request} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Request}
 */
proto.SC2APIProtocol.Request.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.RequestCreateGame;
      reader.readMessage(value,proto.SC2APIProtocol.RequestCreateGame.deserializeBinaryFromReader);
      msg.setCreateGame(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.RequestJoinGame;
      reader.readMessage(value,proto.SC2APIProtocol.RequestJoinGame.deserializeBinaryFromReader);
      msg.setJoinGame(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.RequestRestartGame;
      reader.readMessage(value,proto.SC2APIProtocol.RequestRestartGame.deserializeBinaryFromReader);
      msg.setRestartGame(value);
      break;
    case 4:
      var value = new proto.SC2APIProtocol.RequestStartReplay;
      reader.readMessage(value,proto.SC2APIProtocol.RequestStartReplay.deserializeBinaryFromReader);
      msg.setStartReplay(value);
      break;
    case 5:
      var value = new proto.SC2APIProtocol.RequestLeaveGame;
      reader.readMessage(value,proto.SC2APIProtocol.RequestLeaveGame.deserializeBinaryFromReader);
      msg.setLeaveGame(value);
      break;
    case 6:
      var value = new proto.SC2APIProtocol.RequestQuickSave;
      reader.readMessage(value,proto.SC2APIProtocol.RequestQuickSave.deserializeBinaryFromReader);
      msg.setQuickSave(value);
      break;
    case 7:
      var value = new proto.SC2APIProtocol.RequestQuickLoad;
      reader.readMessage(value,proto.SC2APIProtocol.RequestQuickLoad.deserializeBinaryFromReader);
      msg.setQuickLoad(value);
      break;
    case 8:
      var value = new proto.SC2APIProtocol.RequestQuit;
      reader.readMessage(value,proto.SC2APIProtocol.RequestQuit.deserializeBinaryFromReader);
      msg.setQuit(value);
      break;
    case 9:
      var value = new proto.SC2APIProtocol.RequestGameInfo;
      reader.readMessage(value,proto.SC2APIProtocol.RequestGameInfo.deserializeBinaryFromReader);
      msg.setGameInfo(value);
      break;
    case 10:
      var value = new proto.SC2APIProtocol.RequestObservation;
      reader.readMessage(value,proto.SC2APIProtocol.RequestObservation.deserializeBinaryFromReader);
      msg.setObservation(value);
      break;
    case 11:
      var value = new proto.SC2APIProtocol.RequestAction;
      reader.readMessage(value,proto.SC2APIProtocol.RequestAction.deserializeBinaryFromReader);
      msg.setAction(value);
      break;
    case 21:
      var value = new proto.SC2APIProtocol.RequestObserverAction;
      reader.readMessage(value,proto.SC2APIProtocol.RequestObserverAction.deserializeBinaryFromReader);
      msg.setObsAction(value);
      break;
    case 12:
      var value = new proto.SC2APIProtocol.RequestStep;
      reader.readMessage(value,proto.SC2APIProtocol.RequestStep.deserializeBinaryFromReader);
      msg.setStep(value);
      break;
    case 13:
      var value = new proto.SC2APIProtocol.RequestData;
      reader.readMessage(value,proto.SC2APIProtocol.RequestData.deserializeBinaryFromReader);
      msg.setData(value);
      break;
    case 14:
      var value = new s2clientprotocol_query_pb.RequestQuery;
      reader.readMessage(value,s2clientprotocol_query_pb.RequestQuery.deserializeBinaryFromReader);
      msg.setQuery(value);
      break;
    case 15:
      var value = new proto.SC2APIProtocol.RequestSaveReplay;
      reader.readMessage(value,proto.SC2APIProtocol.RequestSaveReplay.deserializeBinaryFromReader);
      msg.setSaveReplay(value);
      break;
    case 22:
      var value = new proto.SC2APIProtocol.RequestMapCommand;
      reader.readMessage(value,proto.SC2APIProtocol.RequestMapCommand.deserializeBinaryFromReader);
      msg.setMapCommand(value);
      break;
    case 16:
      var value = new proto.SC2APIProtocol.RequestReplayInfo;
      reader.readMessage(value,proto.SC2APIProtocol.RequestReplayInfo.deserializeBinaryFromReader);
      msg.setReplayInfo(value);
      break;
    case 17:
      var value = new proto.SC2APIProtocol.RequestAvailableMaps;
      reader.readMessage(value,proto.SC2APIProtocol.RequestAvailableMaps.deserializeBinaryFromReader);
      msg.setAvailableMaps(value);
      break;
    case 18:
      var value = new proto.SC2APIProtocol.RequestSaveMap;
      reader.readMessage(value,proto.SC2APIProtocol.RequestSaveMap.deserializeBinaryFromReader);
      msg.setSaveMap(value);
      break;
    case 19:
      var value = new proto.SC2APIProtocol.RequestPing;
      reader.readMessage(value,proto.SC2APIProtocol.RequestPing.deserializeBinaryFromReader);
      msg.setPing(value);
      break;
    case 20:
      var value = new proto.SC2APIProtocol.RequestDebug;
      reader.readMessage(value,proto.SC2APIProtocol.RequestDebug.deserializeBinaryFromReader);
      msg.setDebug(value);
      break;
    case 97:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Request.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Request.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Request} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Request.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCreateGame();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.RequestCreateGame.serializeBinaryToWriter
    );
  }
  f = message.getJoinGame();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.SC2APIProtocol.RequestJoinGame.serializeBinaryToWriter
    );
  }
  f = message.getRestartGame();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.RequestRestartGame.serializeBinaryToWriter
    );
  }
  f = message.getStartReplay();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.SC2APIProtocol.RequestStartReplay.serializeBinaryToWriter
    );
  }
  f = message.getLeaveGame();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.SC2APIProtocol.RequestLeaveGame.serializeBinaryToWriter
    );
  }
  f = message.getQuickSave();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.SC2APIProtocol.RequestQuickSave.serializeBinaryToWriter
    );
  }
  f = message.getQuickLoad();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.SC2APIProtocol.RequestQuickLoad.serializeBinaryToWriter
    );
  }
  f = message.getQuit();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.SC2APIProtocol.RequestQuit.serializeBinaryToWriter
    );
  }
  f = message.getGameInfo();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      proto.SC2APIProtocol.RequestGameInfo.serializeBinaryToWriter
    );
  }
  f = message.getObservation();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      proto.SC2APIProtocol.RequestObservation.serializeBinaryToWriter
    );
  }
  f = message.getAction();
  if (f != null) {
    writer.writeMessage(
      11,
      f,
      proto.SC2APIProtocol.RequestAction.serializeBinaryToWriter
    );
  }
  f = message.getObsAction();
  if (f != null) {
    writer.writeMessage(
      21,
      f,
      proto.SC2APIProtocol.RequestObserverAction.serializeBinaryToWriter
    );
  }
  f = message.getStep();
  if (f != null) {
    writer.writeMessage(
      12,
      f,
      proto.SC2APIProtocol.RequestStep.serializeBinaryToWriter
    );
  }
  f = message.getData();
  if (f != null) {
    writer.writeMessage(
      13,
      f,
      proto.SC2APIProtocol.RequestData.serializeBinaryToWriter
    );
  }
  f = message.getQuery();
  if (f != null) {
    writer.writeMessage(
      14,
      f,
      s2clientprotocol_query_pb.RequestQuery.serializeBinaryToWriter
    );
  }
  f = message.getSaveReplay();
  if (f != null) {
    writer.writeMessage(
      15,
      f,
      proto.SC2APIProtocol.RequestSaveReplay.serializeBinaryToWriter
    );
  }
  f = message.getMapCommand();
  if (f != null) {
    writer.writeMessage(
      22,
      f,
      proto.SC2APIProtocol.RequestMapCommand.serializeBinaryToWriter
    );
  }
  f = message.getReplayInfo();
  if (f != null) {
    writer.writeMessage(
      16,
      f,
      proto.SC2APIProtocol.RequestReplayInfo.serializeBinaryToWriter
    );
  }
  f = message.getAvailableMaps();
  if (f != null) {
    writer.writeMessage(
      17,
      f,
      proto.SC2APIProtocol.RequestAvailableMaps.serializeBinaryToWriter
    );
  }
  f = message.getSaveMap();
  if (f != null) {
    writer.writeMessage(
      18,
      f,
      proto.SC2APIProtocol.RequestSaveMap.serializeBinaryToWriter
    );
  }
  f = message.getPing();
  if (f != null) {
    writer.writeMessage(
      19,
      f,
      proto.SC2APIProtocol.RequestPing.serializeBinaryToWriter
    );
  }
  f = message.getDebug();
  if (f != null) {
    writer.writeMessage(
      20,
      f,
      proto.SC2APIProtocol.RequestDebug.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 97));
  if (f != null) {
    writer.writeUint32(
      97,
      f
    );
  }
};


/**
 * optional RequestCreateGame create_game = 1;
 * @return {?proto.SC2APIProtocol.RequestCreateGame}
 */
proto.SC2APIProtocol.Request.prototype.getCreateGame = function() {
  return /** @type{?proto.SC2APIProtocol.RequestCreateGame} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestCreateGame, 1));
};


/** @param {?proto.SC2APIProtocol.RequestCreateGame|undefined} value */
proto.SC2APIProtocol.Request.prototype.setCreateGame = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearCreateGame = function() {
  this.setCreateGame(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasCreateGame = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional RequestJoinGame join_game = 2;
 * @return {?proto.SC2APIProtocol.RequestJoinGame}
 */
proto.SC2APIProtocol.Request.prototype.getJoinGame = function() {
  return /** @type{?proto.SC2APIProtocol.RequestJoinGame} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestJoinGame, 2));
};


/** @param {?proto.SC2APIProtocol.RequestJoinGame|undefined} value */
proto.SC2APIProtocol.Request.prototype.setJoinGame = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearJoinGame = function() {
  this.setJoinGame(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasJoinGame = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional RequestRestartGame restart_game = 3;
 * @return {?proto.SC2APIProtocol.RequestRestartGame}
 */
proto.SC2APIProtocol.Request.prototype.getRestartGame = function() {
  return /** @type{?proto.SC2APIProtocol.RequestRestartGame} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestRestartGame, 3));
};


/** @param {?proto.SC2APIProtocol.RequestRestartGame|undefined} value */
proto.SC2APIProtocol.Request.prototype.setRestartGame = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearRestartGame = function() {
  this.setRestartGame(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasRestartGame = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional RequestStartReplay start_replay = 4;
 * @return {?proto.SC2APIProtocol.RequestStartReplay}
 */
proto.SC2APIProtocol.Request.prototype.getStartReplay = function() {
  return /** @type{?proto.SC2APIProtocol.RequestStartReplay} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestStartReplay, 4));
};


/** @param {?proto.SC2APIProtocol.RequestStartReplay|undefined} value */
proto.SC2APIProtocol.Request.prototype.setStartReplay = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearStartReplay = function() {
  this.setStartReplay(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasStartReplay = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional RequestLeaveGame leave_game = 5;
 * @return {?proto.SC2APIProtocol.RequestLeaveGame}
 */
proto.SC2APIProtocol.Request.prototype.getLeaveGame = function() {
  return /** @type{?proto.SC2APIProtocol.RequestLeaveGame} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestLeaveGame, 5));
};


/** @param {?proto.SC2APIProtocol.RequestLeaveGame|undefined} value */
proto.SC2APIProtocol.Request.prototype.setLeaveGame = function(value) {
  jspb.Message.setOneofWrapperField(this, 5, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearLeaveGame = function() {
  this.setLeaveGame(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasLeaveGame = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional RequestQuickSave quick_save = 6;
 * @return {?proto.SC2APIProtocol.RequestQuickSave}
 */
proto.SC2APIProtocol.Request.prototype.getQuickSave = function() {
  return /** @type{?proto.SC2APIProtocol.RequestQuickSave} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestQuickSave, 6));
};


/** @param {?proto.SC2APIProtocol.RequestQuickSave|undefined} value */
proto.SC2APIProtocol.Request.prototype.setQuickSave = function(value) {
  jspb.Message.setOneofWrapperField(this, 6, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearQuickSave = function() {
  this.setQuickSave(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasQuickSave = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional RequestQuickLoad quick_load = 7;
 * @return {?proto.SC2APIProtocol.RequestQuickLoad}
 */
proto.SC2APIProtocol.Request.prototype.getQuickLoad = function() {
  return /** @type{?proto.SC2APIProtocol.RequestQuickLoad} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestQuickLoad, 7));
};


/** @param {?proto.SC2APIProtocol.RequestQuickLoad|undefined} value */
proto.SC2APIProtocol.Request.prototype.setQuickLoad = function(value) {
  jspb.Message.setOneofWrapperField(this, 7, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearQuickLoad = function() {
  this.setQuickLoad(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasQuickLoad = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional RequestQuit quit = 8;
 * @return {?proto.SC2APIProtocol.RequestQuit}
 */
proto.SC2APIProtocol.Request.prototype.getQuit = function() {
  return /** @type{?proto.SC2APIProtocol.RequestQuit} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestQuit, 8));
};


/** @param {?proto.SC2APIProtocol.RequestQuit|undefined} value */
proto.SC2APIProtocol.Request.prototype.setQuit = function(value) {
  jspb.Message.setOneofWrapperField(this, 8, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearQuit = function() {
  this.setQuit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasQuit = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional RequestGameInfo game_info = 9;
 * @return {?proto.SC2APIProtocol.RequestGameInfo}
 */
proto.SC2APIProtocol.Request.prototype.getGameInfo = function() {
  return /** @type{?proto.SC2APIProtocol.RequestGameInfo} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestGameInfo, 9));
};


/** @param {?proto.SC2APIProtocol.RequestGameInfo|undefined} value */
proto.SC2APIProtocol.Request.prototype.setGameInfo = function(value) {
  jspb.Message.setOneofWrapperField(this, 9, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearGameInfo = function() {
  this.setGameInfo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasGameInfo = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional RequestObservation observation = 10;
 * @return {?proto.SC2APIProtocol.RequestObservation}
 */
proto.SC2APIProtocol.Request.prototype.getObservation = function() {
  return /** @type{?proto.SC2APIProtocol.RequestObservation} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestObservation, 10));
};


/** @param {?proto.SC2APIProtocol.RequestObservation|undefined} value */
proto.SC2APIProtocol.Request.prototype.setObservation = function(value) {
  jspb.Message.setOneofWrapperField(this, 10, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearObservation = function() {
  this.setObservation(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasObservation = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional RequestAction action = 11;
 * @return {?proto.SC2APIProtocol.RequestAction}
 */
proto.SC2APIProtocol.Request.prototype.getAction = function() {
  return /** @type{?proto.SC2APIProtocol.RequestAction} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestAction, 11));
};


/** @param {?proto.SC2APIProtocol.RequestAction|undefined} value */
proto.SC2APIProtocol.Request.prototype.setAction = function(value) {
  jspb.Message.setOneofWrapperField(this, 11, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearAction = function() {
  this.setAction(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasAction = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional RequestObserverAction obs_action = 21;
 * @return {?proto.SC2APIProtocol.RequestObserverAction}
 */
proto.SC2APIProtocol.Request.prototype.getObsAction = function() {
  return /** @type{?proto.SC2APIProtocol.RequestObserverAction} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestObserverAction, 21));
};


/** @param {?proto.SC2APIProtocol.RequestObserverAction|undefined} value */
proto.SC2APIProtocol.Request.prototype.setObsAction = function(value) {
  jspb.Message.setOneofWrapperField(this, 21, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearObsAction = function() {
  this.setObsAction(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasObsAction = function() {
  return jspb.Message.getField(this, 21) != null;
};


/**
 * optional RequestStep step = 12;
 * @return {?proto.SC2APIProtocol.RequestStep}
 */
proto.SC2APIProtocol.Request.prototype.getStep = function() {
  return /** @type{?proto.SC2APIProtocol.RequestStep} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestStep, 12));
};


/** @param {?proto.SC2APIProtocol.RequestStep|undefined} value */
proto.SC2APIProtocol.Request.prototype.setStep = function(value) {
  jspb.Message.setOneofWrapperField(this, 12, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearStep = function() {
  this.setStep(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasStep = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional RequestData data = 13;
 * @return {?proto.SC2APIProtocol.RequestData}
 */
proto.SC2APIProtocol.Request.prototype.getData = function() {
  return /** @type{?proto.SC2APIProtocol.RequestData} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestData, 13));
};


/** @param {?proto.SC2APIProtocol.RequestData|undefined} value */
proto.SC2APIProtocol.Request.prototype.setData = function(value) {
  jspb.Message.setOneofWrapperField(this, 13, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearData = function() {
  this.setData(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasData = function() {
  return jspb.Message.getField(this, 13) != null;
};


/**
 * optional RequestQuery query = 14;
 * @return {?proto.SC2APIProtocol.RequestQuery}
 */
proto.SC2APIProtocol.Request.prototype.getQuery = function() {
  return /** @type{?proto.SC2APIProtocol.RequestQuery} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_query_pb.RequestQuery, 14));
};


/** @param {?proto.SC2APIProtocol.RequestQuery|undefined} value */
proto.SC2APIProtocol.Request.prototype.setQuery = function(value) {
  jspb.Message.setOneofWrapperField(this, 14, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearQuery = function() {
  this.setQuery(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasQuery = function() {
  return jspb.Message.getField(this, 14) != null;
};


/**
 * optional RequestSaveReplay save_replay = 15;
 * @return {?proto.SC2APIProtocol.RequestSaveReplay}
 */
proto.SC2APIProtocol.Request.prototype.getSaveReplay = function() {
  return /** @type{?proto.SC2APIProtocol.RequestSaveReplay} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestSaveReplay, 15));
};


/** @param {?proto.SC2APIProtocol.RequestSaveReplay|undefined} value */
proto.SC2APIProtocol.Request.prototype.setSaveReplay = function(value) {
  jspb.Message.setOneofWrapperField(this, 15, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearSaveReplay = function() {
  this.setSaveReplay(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasSaveReplay = function() {
  return jspb.Message.getField(this, 15) != null;
};


/**
 * optional RequestMapCommand map_command = 22;
 * @return {?proto.SC2APIProtocol.RequestMapCommand}
 */
proto.SC2APIProtocol.Request.prototype.getMapCommand = function() {
  return /** @type{?proto.SC2APIProtocol.RequestMapCommand} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestMapCommand, 22));
};


/** @param {?proto.SC2APIProtocol.RequestMapCommand|undefined} value */
proto.SC2APIProtocol.Request.prototype.setMapCommand = function(value) {
  jspb.Message.setOneofWrapperField(this, 22, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearMapCommand = function() {
  this.setMapCommand(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasMapCommand = function() {
  return jspb.Message.getField(this, 22) != null;
};


/**
 * optional RequestReplayInfo replay_info = 16;
 * @return {?proto.SC2APIProtocol.RequestReplayInfo}
 */
proto.SC2APIProtocol.Request.prototype.getReplayInfo = function() {
  return /** @type{?proto.SC2APIProtocol.RequestReplayInfo} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestReplayInfo, 16));
};


/** @param {?proto.SC2APIProtocol.RequestReplayInfo|undefined} value */
proto.SC2APIProtocol.Request.prototype.setReplayInfo = function(value) {
  jspb.Message.setOneofWrapperField(this, 16, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearReplayInfo = function() {
  this.setReplayInfo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasReplayInfo = function() {
  return jspb.Message.getField(this, 16) != null;
};


/**
 * optional RequestAvailableMaps available_maps = 17;
 * @return {?proto.SC2APIProtocol.RequestAvailableMaps}
 */
proto.SC2APIProtocol.Request.prototype.getAvailableMaps = function() {
  return /** @type{?proto.SC2APIProtocol.RequestAvailableMaps} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestAvailableMaps, 17));
};


/** @param {?proto.SC2APIProtocol.RequestAvailableMaps|undefined} value */
proto.SC2APIProtocol.Request.prototype.setAvailableMaps = function(value) {
  jspb.Message.setOneofWrapperField(this, 17, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearAvailableMaps = function() {
  this.setAvailableMaps(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasAvailableMaps = function() {
  return jspb.Message.getField(this, 17) != null;
};


/**
 * optional RequestSaveMap save_map = 18;
 * @return {?proto.SC2APIProtocol.RequestSaveMap}
 */
proto.SC2APIProtocol.Request.prototype.getSaveMap = function() {
  return /** @type{?proto.SC2APIProtocol.RequestSaveMap} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestSaveMap, 18));
};


/** @param {?proto.SC2APIProtocol.RequestSaveMap|undefined} value */
proto.SC2APIProtocol.Request.prototype.setSaveMap = function(value) {
  jspb.Message.setOneofWrapperField(this, 18, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearSaveMap = function() {
  this.setSaveMap(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasSaveMap = function() {
  return jspb.Message.getField(this, 18) != null;
};


/**
 * optional RequestPing ping = 19;
 * @return {?proto.SC2APIProtocol.RequestPing}
 */
proto.SC2APIProtocol.Request.prototype.getPing = function() {
  return /** @type{?proto.SC2APIProtocol.RequestPing} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestPing, 19));
};


/** @param {?proto.SC2APIProtocol.RequestPing|undefined} value */
proto.SC2APIProtocol.Request.prototype.setPing = function(value) {
  jspb.Message.setOneofWrapperField(this, 19, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearPing = function() {
  this.setPing(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasPing = function() {
  return jspb.Message.getField(this, 19) != null;
};


/**
 * optional RequestDebug debug = 20;
 * @return {?proto.SC2APIProtocol.RequestDebug}
 */
proto.SC2APIProtocol.Request.prototype.getDebug = function() {
  return /** @type{?proto.SC2APIProtocol.RequestDebug} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.RequestDebug, 20));
};


/** @param {?proto.SC2APIProtocol.RequestDebug|undefined} value */
proto.SC2APIProtocol.Request.prototype.setDebug = function(value) {
  jspb.Message.setOneofWrapperField(this, 20, proto.SC2APIProtocol.Request.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Request.prototype.clearDebug = function() {
  this.setDebug(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasDebug = function() {
  return jspb.Message.getField(this, 20) != null;
};


/**
 * optional uint32 id = 97;
 * @return {number}
 */
proto.SC2APIProtocol.Request.prototype.getId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 97, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Request.prototype.setId = function(value) {
  jspb.Message.setField(this, 97, value);
};


proto.SC2APIProtocol.Request.prototype.clearId = function() {
  jspb.Message.setField(this, 97, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Request.prototype.hasId = function() {
  return jspb.Message.getField(this, 97) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Response = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.Response.repeatedFields_, proto.SC2APIProtocol.Response.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.Response, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Response.displayName = 'proto.SC2APIProtocol.Response';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.Response.repeatedFields_ = [98];

/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.Response.oneofGroups_ = [[1,2,3,4,5,6,7,8,9,10,11,21,12,13,14,15,16,17,18,22,19,20]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.Response.ResponseCase = {
  RESPONSE_NOT_SET: 0,
  CREATE_GAME: 1,
  JOIN_GAME: 2,
  RESTART_GAME: 3,
  START_REPLAY: 4,
  LEAVE_GAME: 5,
  QUICK_SAVE: 6,
  QUICK_LOAD: 7,
  QUIT: 8,
  GAME_INFO: 9,
  OBSERVATION: 10,
  ACTION: 11,
  OBS_ACTION: 21,
  STEP: 12,
  DATA: 13,
  QUERY: 14,
  SAVE_REPLAY: 15,
  REPLAY_INFO: 16,
  AVAILABLE_MAPS: 17,
  SAVE_MAP: 18,
  MAP_COMMAND: 22,
  PING: 19,
  DEBUG: 20
};

/**
 * @return {proto.SC2APIProtocol.Response.ResponseCase}
 */
proto.SC2APIProtocol.Response.prototype.getResponseCase = function() {
  return /** @type {proto.SC2APIProtocol.Response.ResponseCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.Response.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Response.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Response.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Response} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Response.toObject = function(includeInstance, msg) {
  var f, obj = {
    createGame: (f = msg.getCreateGame()) && proto.SC2APIProtocol.ResponseCreateGame.toObject(includeInstance, f),
    joinGame: (f = msg.getJoinGame()) && proto.SC2APIProtocol.ResponseJoinGame.toObject(includeInstance, f),
    restartGame: (f = msg.getRestartGame()) && proto.SC2APIProtocol.ResponseRestartGame.toObject(includeInstance, f),
    startReplay: (f = msg.getStartReplay()) && proto.SC2APIProtocol.ResponseStartReplay.toObject(includeInstance, f),
    leaveGame: (f = msg.getLeaveGame()) && proto.SC2APIProtocol.ResponseLeaveGame.toObject(includeInstance, f),
    quickSave: (f = msg.getQuickSave()) && proto.SC2APIProtocol.ResponseQuickSave.toObject(includeInstance, f),
    quickLoad: (f = msg.getQuickLoad()) && proto.SC2APIProtocol.ResponseQuickLoad.toObject(includeInstance, f),
    quit: (f = msg.getQuit()) && proto.SC2APIProtocol.ResponseQuit.toObject(includeInstance, f),
    gameInfo: (f = msg.getGameInfo()) && proto.SC2APIProtocol.ResponseGameInfo.toObject(includeInstance, f),
    observation: (f = msg.getObservation()) && proto.SC2APIProtocol.ResponseObservation.toObject(includeInstance, f),
    action: (f = msg.getAction()) && proto.SC2APIProtocol.ResponseAction.toObject(includeInstance, f),
    obsAction: (f = msg.getObsAction()) && proto.SC2APIProtocol.ResponseObserverAction.toObject(includeInstance, f),
    step: (f = msg.getStep()) && proto.SC2APIProtocol.ResponseStep.toObject(includeInstance, f),
    data: (f = msg.getData()) && proto.SC2APIProtocol.ResponseData.toObject(includeInstance, f),
    query: (f = msg.getQuery()) && s2clientprotocol_query_pb.ResponseQuery.toObject(includeInstance, f),
    saveReplay: (f = msg.getSaveReplay()) && proto.SC2APIProtocol.ResponseSaveReplay.toObject(includeInstance, f),
    replayInfo: (f = msg.getReplayInfo()) && proto.SC2APIProtocol.ResponseReplayInfo.toObject(includeInstance, f),
    availableMaps: (f = msg.getAvailableMaps()) && proto.SC2APIProtocol.ResponseAvailableMaps.toObject(includeInstance, f),
    saveMap: (f = msg.getSaveMap()) && proto.SC2APIProtocol.ResponseSaveMap.toObject(includeInstance, f),
    mapCommand: (f = msg.getMapCommand()) && proto.SC2APIProtocol.ResponseMapCommand.toObject(includeInstance, f),
    ping: (f = msg.getPing()) && proto.SC2APIProtocol.ResponsePing.toObject(includeInstance, f),
    debug: (f = msg.getDebug()) && proto.SC2APIProtocol.ResponseDebug.toObject(includeInstance, f),
    id: jspb.Message.getField(msg, 97),
    errorList: jspb.Message.getRepeatedField(msg, 98),
    status: jspb.Message.getField(msg, 99)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Response}
 */
proto.SC2APIProtocol.Response.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Response;
  return proto.SC2APIProtocol.Response.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Response} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Response}
 */
proto.SC2APIProtocol.Response.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.ResponseCreateGame;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseCreateGame.deserializeBinaryFromReader);
      msg.setCreateGame(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.ResponseJoinGame;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseJoinGame.deserializeBinaryFromReader);
      msg.setJoinGame(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.ResponseRestartGame;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseRestartGame.deserializeBinaryFromReader);
      msg.setRestartGame(value);
      break;
    case 4:
      var value = new proto.SC2APIProtocol.ResponseStartReplay;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseStartReplay.deserializeBinaryFromReader);
      msg.setStartReplay(value);
      break;
    case 5:
      var value = new proto.SC2APIProtocol.ResponseLeaveGame;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseLeaveGame.deserializeBinaryFromReader);
      msg.setLeaveGame(value);
      break;
    case 6:
      var value = new proto.SC2APIProtocol.ResponseQuickSave;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseQuickSave.deserializeBinaryFromReader);
      msg.setQuickSave(value);
      break;
    case 7:
      var value = new proto.SC2APIProtocol.ResponseQuickLoad;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseQuickLoad.deserializeBinaryFromReader);
      msg.setQuickLoad(value);
      break;
    case 8:
      var value = new proto.SC2APIProtocol.ResponseQuit;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseQuit.deserializeBinaryFromReader);
      msg.setQuit(value);
      break;
    case 9:
      var value = new proto.SC2APIProtocol.ResponseGameInfo;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseGameInfo.deserializeBinaryFromReader);
      msg.setGameInfo(value);
      break;
    case 10:
      var value = new proto.SC2APIProtocol.ResponseObservation;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseObservation.deserializeBinaryFromReader);
      msg.setObservation(value);
      break;
    case 11:
      var value = new proto.SC2APIProtocol.ResponseAction;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseAction.deserializeBinaryFromReader);
      msg.setAction(value);
      break;
    case 21:
      var value = new proto.SC2APIProtocol.ResponseObserverAction;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseObserverAction.deserializeBinaryFromReader);
      msg.setObsAction(value);
      break;
    case 12:
      var value = new proto.SC2APIProtocol.ResponseStep;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseStep.deserializeBinaryFromReader);
      msg.setStep(value);
      break;
    case 13:
      var value = new proto.SC2APIProtocol.ResponseData;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseData.deserializeBinaryFromReader);
      msg.setData(value);
      break;
    case 14:
      var value = new s2clientprotocol_query_pb.ResponseQuery;
      reader.readMessage(value,s2clientprotocol_query_pb.ResponseQuery.deserializeBinaryFromReader);
      msg.setQuery(value);
      break;
    case 15:
      var value = new proto.SC2APIProtocol.ResponseSaveReplay;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseSaveReplay.deserializeBinaryFromReader);
      msg.setSaveReplay(value);
      break;
    case 16:
      var value = new proto.SC2APIProtocol.ResponseReplayInfo;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseReplayInfo.deserializeBinaryFromReader);
      msg.setReplayInfo(value);
      break;
    case 17:
      var value = new proto.SC2APIProtocol.ResponseAvailableMaps;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseAvailableMaps.deserializeBinaryFromReader);
      msg.setAvailableMaps(value);
      break;
    case 18:
      var value = new proto.SC2APIProtocol.ResponseSaveMap;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseSaveMap.deserializeBinaryFromReader);
      msg.setSaveMap(value);
      break;
    case 22:
      var value = new proto.SC2APIProtocol.ResponseMapCommand;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseMapCommand.deserializeBinaryFromReader);
      msg.setMapCommand(value);
      break;
    case 19:
      var value = new proto.SC2APIProtocol.ResponsePing;
      reader.readMessage(value,proto.SC2APIProtocol.ResponsePing.deserializeBinaryFromReader);
      msg.setPing(value);
      break;
    case 20:
      var value = new proto.SC2APIProtocol.ResponseDebug;
      reader.readMessage(value,proto.SC2APIProtocol.ResponseDebug.deserializeBinaryFromReader);
      msg.setDebug(value);
      break;
    case 97:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setId(value);
      break;
    case 98:
      var value = /** @type {string} */ (reader.readString());
      msg.addError(value);
      break;
    case 99:
      var value = /** @type {!proto.SC2APIProtocol.Status} */ (reader.readEnum());
      msg.setStatus(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Response.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Response.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Response} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Response.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCreateGame();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.ResponseCreateGame.serializeBinaryToWriter
    );
  }
  f = message.getJoinGame();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.SC2APIProtocol.ResponseJoinGame.serializeBinaryToWriter
    );
  }
  f = message.getRestartGame();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.ResponseRestartGame.serializeBinaryToWriter
    );
  }
  f = message.getStartReplay();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.SC2APIProtocol.ResponseStartReplay.serializeBinaryToWriter
    );
  }
  f = message.getLeaveGame();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.SC2APIProtocol.ResponseLeaveGame.serializeBinaryToWriter
    );
  }
  f = message.getQuickSave();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.SC2APIProtocol.ResponseQuickSave.serializeBinaryToWriter
    );
  }
  f = message.getQuickLoad();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.SC2APIProtocol.ResponseQuickLoad.serializeBinaryToWriter
    );
  }
  f = message.getQuit();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.SC2APIProtocol.ResponseQuit.serializeBinaryToWriter
    );
  }
  f = message.getGameInfo();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      proto.SC2APIProtocol.ResponseGameInfo.serializeBinaryToWriter
    );
  }
  f = message.getObservation();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      proto.SC2APIProtocol.ResponseObservation.serializeBinaryToWriter
    );
  }
  f = message.getAction();
  if (f != null) {
    writer.writeMessage(
      11,
      f,
      proto.SC2APIProtocol.ResponseAction.serializeBinaryToWriter
    );
  }
  f = message.getObsAction();
  if (f != null) {
    writer.writeMessage(
      21,
      f,
      proto.SC2APIProtocol.ResponseObserverAction.serializeBinaryToWriter
    );
  }
  f = message.getStep();
  if (f != null) {
    writer.writeMessage(
      12,
      f,
      proto.SC2APIProtocol.ResponseStep.serializeBinaryToWriter
    );
  }
  f = message.getData();
  if (f != null) {
    writer.writeMessage(
      13,
      f,
      proto.SC2APIProtocol.ResponseData.serializeBinaryToWriter
    );
  }
  f = message.getQuery();
  if (f != null) {
    writer.writeMessage(
      14,
      f,
      s2clientprotocol_query_pb.ResponseQuery.serializeBinaryToWriter
    );
  }
  f = message.getSaveReplay();
  if (f != null) {
    writer.writeMessage(
      15,
      f,
      proto.SC2APIProtocol.ResponseSaveReplay.serializeBinaryToWriter
    );
  }
  f = message.getReplayInfo();
  if (f != null) {
    writer.writeMessage(
      16,
      f,
      proto.SC2APIProtocol.ResponseReplayInfo.serializeBinaryToWriter
    );
  }
  f = message.getAvailableMaps();
  if (f != null) {
    writer.writeMessage(
      17,
      f,
      proto.SC2APIProtocol.ResponseAvailableMaps.serializeBinaryToWriter
    );
  }
  f = message.getSaveMap();
  if (f != null) {
    writer.writeMessage(
      18,
      f,
      proto.SC2APIProtocol.ResponseSaveMap.serializeBinaryToWriter
    );
  }
  f = message.getMapCommand();
  if (f != null) {
    writer.writeMessage(
      22,
      f,
      proto.SC2APIProtocol.ResponseMapCommand.serializeBinaryToWriter
    );
  }
  f = message.getPing();
  if (f != null) {
    writer.writeMessage(
      19,
      f,
      proto.SC2APIProtocol.ResponsePing.serializeBinaryToWriter
    );
  }
  f = message.getDebug();
  if (f != null) {
    writer.writeMessage(
      20,
      f,
      proto.SC2APIProtocol.ResponseDebug.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 97));
  if (f != null) {
    writer.writeUint32(
      97,
      f
    );
  }
  f = message.getErrorList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      98,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.Status} */ (jspb.Message.getField(message, 99));
  if (f != null) {
    writer.writeEnum(
      99,
      f
    );
  }
};


/**
 * optional ResponseCreateGame create_game = 1;
 * @return {?proto.SC2APIProtocol.ResponseCreateGame}
 */
proto.SC2APIProtocol.Response.prototype.getCreateGame = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseCreateGame} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseCreateGame, 1));
};


/** @param {?proto.SC2APIProtocol.ResponseCreateGame|undefined} value */
proto.SC2APIProtocol.Response.prototype.setCreateGame = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearCreateGame = function() {
  this.setCreateGame(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasCreateGame = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ResponseJoinGame join_game = 2;
 * @return {?proto.SC2APIProtocol.ResponseJoinGame}
 */
proto.SC2APIProtocol.Response.prototype.getJoinGame = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseJoinGame} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseJoinGame, 2));
};


/** @param {?proto.SC2APIProtocol.ResponseJoinGame|undefined} value */
proto.SC2APIProtocol.Response.prototype.setJoinGame = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearJoinGame = function() {
  this.setJoinGame(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasJoinGame = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ResponseRestartGame restart_game = 3;
 * @return {?proto.SC2APIProtocol.ResponseRestartGame}
 */
proto.SC2APIProtocol.Response.prototype.getRestartGame = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseRestartGame} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseRestartGame, 3));
};


/** @param {?proto.SC2APIProtocol.ResponseRestartGame|undefined} value */
proto.SC2APIProtocol.Response.prototype.setRestartGame = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearRestartGame = function() {
  this.setRestartGame(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasRestartGame = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional ResponseStartReplay start_replay = 4;
 * @return {?proto.SC2APIProtocol.ResponseStartReplay}
 */
proto.SC2APIProtocol.Response.prototype.getStartReplay = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseStartReplay} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseStartReplay, 4));
};


/** @param {?proto.SC2APIProtocol.ResponseStartReplay|undefined} value */
proto.SC2APIProtocol.Response.prototype.setStartReplay = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearStartReplay = function() {
  this.setStartReplay(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasStartReplay = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional ResponseLeaveGame leave_game = 5;
 * @return {?proto.SC2APIProtocol.ResponseLeaveGame}
 */
proto.SC2APIProtocol.Response.prototype.getLeaveGame = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseLeaveGame} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseLeaveGame, 5));
};


/** @param {?proto.SC2APIProtocol.ResponseLeaveGame|undefined} value */
proto.SC2APIProtocol.Response.prototype.setLeaveGame = function(value) {
  jspb.Message.setOneofWrapperField(this, 5, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearLeaveGame = function() {
  this.setLeaveGame(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasLeaveGame = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional ResponseQuickSave quick_save = 6;
 * @return {?proto.SC2APIProtocol.ResponseQuickSave}
 */
proto.SC2APIProtocol.Response.prototype.getQuickSave = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseQuickSave} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseQuickSave, 6));
};


/** @param {?proto.SC2APIProtocol.ResponseQuickSave|undefined} value */
proto.SC2APIProtocol.Response.prototype.setQuickSave = function(value) {
  jspb.Message.setOneofWrapperField(this, 6, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearQuickSave = function() {
  this.setQuickSave(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasQuickSave = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional ResponseQuickLoad quick_load = 7;
 * @return {?proto.SC2APIProtocol.ResponseQuickLoad}
 */
proto.SC2APIProtocol.Response.prototype.getQuickLoad = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseQuickLoad} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseQuickLoad, 7));
};


/** @param {?proto.SC2APIProtocol.ResponseQuickLoad|undefined} value */
proto.SC2APIProtocol.Response.prototype.setQuickLoad = function(value) {
  jspb.Message.setOneofWrapperField(this, 7, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearQuickLoad = function() {
  this.setQuickLoad(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasQuickLoad = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional ResponseQuit quit = 8;
 * @return {?proto.SC2APIProtocol.ResponseQuit}
 */
proto.SC2APIProtocol.Response.prototype.getQuit = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseQuit} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseQuit, 8));
};


/** @param {?proto.SC2APIProtocol.ResponseQuit|undefined} value */
proto.SC2APIProtocol.Response.prototype.setQuit = function(value) {
  jspb.Message.setOneofWrapperField(this, 8, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearQuit = function() {
  this.setQuit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasQuit = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional ResponseGameInfo game_info = 9;
 * @return {?proto.SC2APIProtocol.ResponseGameInfo}
 */
proto.SC2APIProtocol.Response.prototype.getGameInfo = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseGameInfo} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseGameInfo, 9));
};


/** @param {?proto.SC2APIProtocol.ResponseGameInfo|undefined} value */
proto.SC2APIProtocol.Response.prototype.setGameInfo = function(value) {
  jspb.Message.setOneofWrapperField(this, 9, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearGameInfo = function() {
  this.setGameInfo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasGameInfo = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional ResponseObservation observation = 10;
 * @return {?proto.SC2APIProtocol.ResponseObservation}
 */
proto.SC2APIProtocol.Response.prototype.getObservation = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseObservation} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseObservation, 10));
};


/** @param {?proto.SC2APIProtocol.ResponseObservation|undefined} value */
proto.SC2APIProtocol.Response.prototype.setObservation = function(value) {
  jspb.Message.setOneofWrapperField(this, 10, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearObservation = function() {
  this.setObservation(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasObservation = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional ResponseAction action = 11;
 * @return {?proto.SC2APIProtocol.ResponseAction}
 */
proto.SC2APIProtocol.Response.prototype.getAction = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseAction} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseAction, 11));
};


/** @param {?proto.SC2APIProtocol.ResponseAction|undefined} value */
proto.SC2APIProtocol.Response.prototype.setAction = function(value) {
  jspb.Message.setOneofWrapperField(this, 11, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearAction = function() {
  this.setAction(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasAction = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional ResponseObserverAction obs_action = 21;
 * @return {?proto.SC2APIProtocol.ResponseObserverAction}
 */
proto.SC2APIProtocol.Response.prototype.getObsAction = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseObserverAction} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseObserverAction, 21));
};


/** @param {?proto.SC2APIProtocol.ResponseObserverAction|undefined} value */
proto.SC2APIProtocol.Response.prototype.setObsAction = function(value) {
  jspb.Message.setOneofWrapperField(this, 21, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearObsAction = function() {
  this.setObsAction(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasObsAction = function() {
  return jspb.Message.getField(this, 21) != null;
};


/**
 * optional ResponseStep step = 12;
 * @return {?proto.SC2APIProtocol.ResponseStep}
 */
proto.SC2APIProtocol.Response.prototype.getStep = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseStep} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseStep, 12));
};


/** @param {?proto.SC2APIProtocol.ResponseStep|undefined} value */
proto.SC2APIProtocol.Response.prototype.setStep = function(value) {
  jspb.Message.setOneofWrapperField(this, 12, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearStep = function() {
  this.setStep(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasStep = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional ResponseData data = 13;
 * @return {?proto.SC2APIProtocol.ResponseData}
 */
proto.SC2APIProtocol.Response.prototype.getData = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseData} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseData, 13));
};


/** @param {?proto.SC2APIProtocol.ResponseData|undefined} value */
proto.SC2APIProtocol.Response.prototype.setData = function(value) {
  jspb.Message.setOneofWrapperField(this, 13, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearData = function() {
  this.setData(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasData = function() {
  return jspb.Message.getField(this, 13) != null;
};


/**
 * optional ResponseQuery query = 14;
 * @return {?proto.SC2APIProtocol.ResponseQuery}
 */
proto.SC2APIProtocol.Response.prototype.getQuery = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseQuery} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_query_pb.ResponseQuery, 14));
};


/** @param {?proto.SC2APIProtocol.ResponseQuery|undefined} value */
proto.SC2APIProtocol.Response.prototype.setQuery = function(value) {
  jspb.Message.setOneofWrapperField(this, 14, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearQuery = function() {
  this.setQuery(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasQuery = function() {
  return jspb.Message.getField(this, 14) != null;
};


/**
 * optional ResponseSaveReplay save_replay = 15;
 * @return {?proto.SC2APIProtocol.ResponseSaveReplay}
 */
proto.SC2APIProtocol.Response.prototype.getSaveReplay = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseSaveReplay} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseSaveReplay, 15));
};


/** @param {?proto.SC2APIProtocol.ResponseSaveReplay|undefined} value */
proto.SC2APIProtocol.Response.prototype.setSaveReplay = function(value) {
  jspb.Message.setOneofWrapperField(this, 15, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearSaveReplay = function() {
  this.setSaveReplay(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasSaveReplay = function() {
  return jspb.Message.getField(this, 15) != null;
};


/**
 * optional ResponseReplayInfo replay_info = 16;
 * @return {?proto.SC2APIProtocol.ResponseReplayInfo}
 */
proto.SC2APIProtocol.Response.prototype.getReplayInfo = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseReplayInfo} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseReplayInfo, 16));
};


/** @param {?proto.SC2APIProtocol.ResponseReplayInfo|undefined} value */
proto.SC2APIProtocol.Response.prototype.setReplayInfo = function(value) {
  jspb.Message.setOneofWrapperField(this, 16, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearReplayInfo = function() {
  this.setReplayInfo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasReplayInfo = function() {
  return jspb.Message.getField(this, 16) != null;
};


/**
 * optional ResponseAvailableMaps available_maps = 17;
 * @return {?proto.SC2APIProtocol.ResponseAvailableMaps}
 */
proto.SC2APIProtocol.Response.prototype.getAvailableMaps = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseAvailableMaps} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseAvailableMaps, 17));
};


/** @param {?proto.SC2APIProtocol.ResponseAvailableMaps|undefined} value */
proto.SC2APIProtocol.Response.prototype.setAvailableMaps = function(value) {
  jspb.Message.setOneofWrapperField(this, 17, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearAvailableMaps = function() {
  this.setAvailableMaps(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasAvailableMaps = function() {
  return jspb.Message.getField(this, 17) != null;
};


/**
 * optional ResponseSaveMap save_map = 18;
 * @return {?proto.SC2APIProtocol.ResponseSaveMap}
 */
proto.SC2APIProtocol.Response.prototype.getSaveMap = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseSaveMap} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseSaveMap, 18));
};


/** @param {?proto.SC2APIProtocol.ResponseSaveMap|undefined} value */
proto.SC2APIProtocol.Response.prototype.setSaveMap = function(value) {
  jspb.Message.setOneofWrapperField(this, 18, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearSaveMap = function() {
  this.setSaveMap(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasSaveMap = function() {
  return jspb.Message.getField(this, 18) != null;
};


/**
 * optional ResponseMapCommand map_command = 22;
 * @return {?proto.SC2APIProtocol.ResponseMapCommand}
 */
proto.SC2APIProtocol.Response.prototype.getMapCommand = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseMapCommand} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseMapCommand, 22));
};


/** @param {?proto.SC2APIProtocol.ResponseMapCommand|undefined} value */
proto.SC2APIProtocol.Response.prototype.setMapCommand = function(value) {
  jspb.Message.setOneofWrapperField(this, 22, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearMapCommand = function() {
  this.setMapCommand(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasMapCommand = function() {
  return jspb.Message.getField(this, 22) != null;
};


/**
 * optional ResponsePing ping = 19;
 * @return {?proto.SC2APIProtocol.ResponsePing}
 */
proto.SC2APIProtocol.Response.prototype.getPing = function() {
  return /** @type{?proto.SC2APIProtocol.ResponsePing} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponsePing, 19));
};


/** @param {?proto.SC2APIProtocol.ResponsePing|undefined} value */
proto.SC2APIProtocol.Response.prototype.setPing = function(value) {
  jspb.Message.setOneofWrapperField(this, 19, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearPing = function() {
  this.setPing(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasPing = function() {
  return jspb.Message.getField(this, 19) != null;
};


/**
 * optional ResponseDebug debug = 20;
 * @return {?proto.SC2APIProtocol.ResponseDebug}
 */
proto.SC2APIProtocol.Response.prototype.getDebug = function() {
  return /** @type{?proto.SC2APIProtocol.ResponseDebug} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ResponseDebug, 20));
};


/** @param {?proto.SC2APIProtocol.ResponseDebug|undefined} value */
proto.SC2APIProtocol.Response.prototype.setDebug = function(value) {
  jspb.Message.setOneofWrapperField(this, 20, proto.SC2APIProtocol.Response.oneofGroups_[0], value);
};


proto.SC2APIProtocol.Response.prototype.clearDebug = function() {
  this.setDebug(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasDebug = function() {
  return jspb.Message.getField(this, 20) != null;
};


/**
 * optional uint32 id = 97;
 * @return {number}
 */
proto.SC2APIProtocol.Response.prototype.getId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 97, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Response.prototype.setId = function(value) {
  jspb.Message.setField(this, 97, value);
};


proto.SC2APIProtocol.Response.prototype.clearId = function() {
  jspb.Message.setField(this, 97, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasId = function() {
  return jspb.Message.getField(this, 97) != null;
};


/**
 * repeated string error = 98;
 * @return {!Array.<string>}
 */
proto.SC2APIProtocol.Response.prototype.getErrorList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 98));
};


/** @param {!Array.<string>} value */
proto.SC2APIProtocol.Response.prototype.setErrorList = function(value) {
  jspb.Message.setField(this, 98, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.Response.prototype.addError = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 98, value, opt_index);
};


proto.SC2APIProtocol.Response.prototype.clearErrorList = function() {
  this.setErrorList([]);
};


/**
 * optional Status status = 99;
 * @return {!proto.SC2APIProtocol.Status}
 */
proto.SC2APIProtocol.Response.prototype.getStatus = function() {
  return /** @type {!proto.SC2APIProtocol.Status} */ (jspb.Message.getFieldWithDefault(this, 99, 1));
};


/** @param {!proto.SC2APIProtocol.Status} value */
proto.SC2APIProtocol.Response.prototype.setStatus = function(value) {
  jspb.Message.setField(this, 99, value);
};


proto.SC2APIProtocol.Response.prototype.clearStatus = function() {
  jspb.Message.setField(this, 99, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Response.prototype.hasStatus = function() {
  return jspb.Message.getField(this, 99) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestCreateGame = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.RequestCreateGame.repeatedFields_, proto.SC2APIProtocol.RequestCreateGame.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.RequestCreateGame, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestCreateGame.displayName = 'proto.SC2APIProtocol.RequestCreateGame';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.RequestCreateGame.repeatedFields_ = [3];

/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.RequestCreateGame.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.RequestCreateGame.MapCase = {
  MAP_NOT_SET: 0,
  LOCAL_MAP: 1,
  BATTLENET_MAP_NAME: 2
};

/**
 * @return {proto.SC2APIProtocol.RequestCreateGame.MapCase}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.getMapCase = function() {
  return /** @type {proto.SC2APIProtocol.RequestCreateGame.MapCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.RequestCreateGame.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestCreateGame.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestCreateGame} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestCreateGame.toObject = function(includeInstance, msg) {
  var f, obj = {
    localMap: (f = msg.getLocalMap()) && proto.SC2APIProtocol.LocalMap.toObject(includeInstance, f),
    battlenetMapName: jspb.Message.getField(msg, 2),
    playerSetupList: jspb.Message.toObjectList(msg.getPlayerSetupList(),
    proto.SC2APIProtocol.PlayerSetup.toObject, includeInstance),
    disableFog: jspb.Message.getField(msg, 4),
    randomSeed: jspb.Message.getField(msg, 5),
    realtime: jspb.Message.getField(msg, 6)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestCreateGame}
 */
proto.SC2APIProtocol.RequestCreateGame.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestCreateGame;
  return proto.SC2APIProtocol.RequestCreateGame.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestCreateGame} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestCreateGame}
 */
proto.SC2APIProtocol.RequestCreateGame.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.LocalMap;
      reader.readMessage(value,proto.SC2APIProtocol.LocalMap.deserializeBinaryFromReader);
      msg.setLocalMap(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setBattlenetMapName(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.PlayerSetup;
      reader.readMessage(value,proto.SC2APIProtocol.PlayerSetup.deserializeBinaryFromReader);
      msg.addPlayerSetup(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDisableFog(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRandomSeed(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRealtime(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestCreateGame.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestCreateGame} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestCreateGame.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLocalMap();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.LocalMap.serializeBinaryToWriter
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getPlayerSetupList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.SC2APIProtocol.PlayerSetup.serializeBinaryToWriter
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBool(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeBool(
      6,
      f
    );
  }
};


/**
 * optional LocalMap local_map = 1;
 * @return {?proto.SC2APIProtocol.LocalMap}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.getLocalMap = function() {
  return /** @type{?proto.SC2APIProtocol.LocalMap} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.LocalMap, 1));
};


/** @param {?proto.SC2APIProtocol.LocalMap|undefined} value */
proto.SC2APIProtocol.RequestCreateGame.prototype.setLocalMap = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.SC2APIProtocol.RequestCreateGame.oneofGroups_[0], value);
};


proto.SC2APIProtocol.RequestCreateGame.prototype.clearLocalMap = function() {
  this.setLocalMap(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.hasLocalMap = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string battlenet_map_name = 2;
 * @return {string}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.getBattlenetMapName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.RequestCreateGame.prototype.setBattlenetMapName = function(value) {
  jspb.Message.setOneofField(this, 2, proto.SC2APIProtocol.RequestCreateGame.oneofGroups_[0], value);
};


proto.SC2APIProtocol.RequestCreateGame.prototype.clearBattlenetMapName = function() {
  jspb.Message.setOneofField(this, 2, proto.SC2APIProtocol.RequestCreateGame.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.hasBattlenetMapName = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * repeated PlayerSetup player_setup = 3;
 * @return {!Array.<!proto.SC2APIProtocol.PlayerSetup>}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.getPlayerSetupList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.PlayerSetup>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.PlayerSetup, 3));
};


/** @param {!Array.<!proto.SC2APIProtocol.PlayerSetup>} value */
proto.SC2APIProtocol.RequestCreateGame.prototype.setPlayerSetupList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.SC2APIProtocol.PlayerSetup=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.PlayerSetup}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.addPlayerSetup = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.SC2APIProtocol.PlayerSetup, opt_index);
};


proto.SC2APIProtocol.RequestCreateGame.prototype.clearPlayerSetupList = function() {
  this.setPlayerSetupList([]);
};


/**
 * optional bool disable_fog = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.getDisableFog = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestCreateGame.prototype.setDisableFog = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.RequestCreateGame.prototype.clearDisableFog = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.hasDisableFog = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional uint32 random_seed = 5;
 * @return {number}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.getRandomSeed = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.RequestCreateGame.prototype.setRandomSeed = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.RequestCreateGame.prototype.clearRandomSeed = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.hasRandomSeed = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional bool realtime = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.getRealtime = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestCreateGame.prototype.setRealtime = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.RequestCreateGame.prototype.clearRealtime = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestCreateGame.prototype.hasRealtime = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.LocalMap = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.LocalMap, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.LocalMap.displayName = 'proto.SC2APIProtocol.LocalMap';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.LocalMap.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.LocalMap.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.LocalMap} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.LocalMap.toObject = function(includeInstance, msg) {
  var f, obj = {
    mapPath: jspb.Message.getField(msg, 1),
    mapData: msg.getMapData_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.LocalMap}
 */
proto.SC2APIProtocol.LocalMap.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.LocalMap;
  return proto.SC2APIProtocol.LocalMap.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.LocalMap} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.LocalMap}
 */
proto.SC2APIProtocol.LocalMap.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMapPath(value);
      break;
    case 7:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMapData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.LocalMap.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.LocalMap.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.LocalMap} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.LocalMap.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeBytes(
      7,
      f
    );
  }
};


/**
 * optional string map_path = 1;
 * @return {string}
 */
proto.SC2APIProtocol.LocalMap.prototype.getMapPath = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.LocalMap.prototype.setMapPath = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.LocalMap.prototype.clearMapPath = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.LocalMap.prototype.hasMapPath = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes map_data = 7;
 * @return {!(string|Uint8Array)}
 */
proto.SC2APIProtocol.LocalMap.prototype.getMapData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * optional bytes map_data = 7;
 * This is a type-conversion wrapper around `getMapData()`
 * @return {string}
 */
proto.SC2APIProtocol.LocalMap.prototype.getMapData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMapData()));
};


/**
 * optional bytes map_data = 7;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMapData()`
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.LocalMap.prototype.getMapData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMapData()));
};


/** @param {!(string|Uint8Array)} value */
proto.SC2APIProtocol.LocalMap.prototype.setMapData = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.LocalMap.prototype.clearMapData = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.LocalMap.prototype.hasMapData = function() {
  return jspb.Message.getField(this, 7) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseCreateGame = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseCreateGame, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseCreateGame.displayName = 'proto.SC2APIProtocol.ResponseCreateGame';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseCreateGame.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseCreateGame.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseCreateGame} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseCreateGame.toObject = function(includeInstance, msg) {
  var f, obj = {
    error: jspb.Message.getField(msg, 1),
    errorDetails: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseCreateGame}
 */
proto.SC2APIProtocol.ResponseCreateGame.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseCreateGame;
  return proto.SC2APIProtocol.ResponseCreateGame.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseCreateGame} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseCreateGame}
 */
proto.SC2APIProtocol.ResponseCreateGame.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.ResponseCreateGame.Error} */ (reader.readEnum());
      msg.setError(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setErrorDetails(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseCreateGame.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseCreateGame.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseCreateGame} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseCreateGame.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.ResponseCreateGame.Error} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.ResponseCreateGame.Error = {
  MISSINGMAP: 1,
  INVALIDMAPPATH: 2,
  INVALIDMAPDATA: 3,
  INVALIDMAPNAME: 4,
  INVALIDMAPHANDLE: 5,
  MISSINGPLAYERSETUP: 6,
  INVALIDPLAYERSETUP: 7,
  MULTIPLAYERUNSUPPORTED: 8
};

/**
 * optional Error error = 1;
 * @return {!proto.SC2APIProtocol.ResponseCreateGame.Error}
 */
proto.SC2APIProtocol.ResponseCreateGame.prototype.getError = function() {
  return /** @type {!proto.SC2APIProtocol.ResponseCreateGame.Error} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.ResponseCreateGame.Error} value */
proto.SC2APIProtocol.ResponseCreateGame.prototype.setError = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponseCreateGame.prototype.clearError = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseCreateGame.prototype.hasError = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string error_details = 2;
 * @return {string}
 */
proto.SC2APIProtocol.ResponseCreateGame.prototype.getErrorDetails = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponseCreateGame.prototype.setErrorDetails = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ResponseCreateGame.prototype.clearErrorDetails = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseCreateGame.prototype.hasErrorDetails = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestJoinGame = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.RequestJoinGame.repeatedFields_, proto.SC2APIProtocol.RequestJoinGame.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.RequestJoinGame, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestJoinGame.displayName = 'proto.SC2APIProtocol.RequestJoinGame';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.RequestJoinGame.repeatedFields_ = [5];

/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.RequestJoinGame.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.RequestJoinGame.ParticipationCase = {
  PARTICIPATION_NOT_SET: 0,
  RACE: 1,
  OBSERVED_PLAYER_ID: 2
};

/**
 * @return {proto.SC2APIProtocol.RequestJoinGame.ParticipationCase}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.getParticipationCase = function() {
  return /** @type {proto.SC2APIProtocol.RequestJoinGame.ParticipationCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.RequestJoinGame.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestJoinGame.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestJoinGame} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestJoinGame.toObject = function(includeInstance, msg) {
  var f, obj = {
    race: jspb.Message.getField(msg, 1),
    observedPlayerId: jspb.Message.getField(msg, 2),
    options: (f = msg.getOptions()) && proto.SC2APIProtocol.InterfaceOptions.toObject(includeInstance, f),
    serverPorts: (f = msg.getServerPorts()) && proto.SC2APIProtocol.PortSet.toObject(includeInstance, f),
    clientPortsList: jspb.Message.toObjectList(msg.getClientPortsList(),
    proto.SC2APIProtocol.PortSet.toObject, includeInstance),
    sharedPort: jspb.Message.getField(msg, 6),
    playerName: jspb.Message.getField(msg, 7),
    hostIp: jspb.Message.getField(msg, 8)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestJoinGame}
 */
proto.SC2APIProtocol.RequestJoinGame.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestJoinGame;
  return proto.SC2APIProtocol.RequestJoinGame.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestJoinGame} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestJoinGame}
 */
proto.SC2APIProtocol.RequestJoinGame.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.Race} */ (reader.readEnum());
      msg.setRace(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setObservedPlayerId(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.InterfaceOptions;
      reader.readMessage(value,proto.SC2APIProtocol.InterfaceOptions.deserializeBinaryFromReader);
      msg.setOptions(value);
      break;
    case 4:
      var value = new proto.SC2APIProtocol.PortSet;
      reader.readMessage(value,proto.SC2APIProtocol.PortSet.deserializeBinaryFromReader);
      msg.setServerPorts(value);
      break;
    case 5:
      var value = new proto.SC2APIProtocol.PortSet;
      reader.readMessage(value,proto.SC2APIProtocol.PortSet.deserializeBinaryFromReader);
      msg.addClientPorts(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setSharedPort(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setPlayerName(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setHostIp(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestJoinGame.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestJoinGame} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestJoinGame.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.Race} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getOptions();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.InterfaceOptions.serializeBinaryToWriter
    );
  }
  f = message.getServerPorts();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.SC2APIProtocol.PortSet.serializeBinaryToWriter
    );
  }
  f = message.getClientPortsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.SC2APIProtocol.PortSet.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeInt32(
      6,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeString(
      7,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeString(
      8,
      f
    );
  }
};


/**
 * optional Race race = 1;
 * @return {!proto.SC2APIProtocol.Race}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.getRace = function() {
  return /** @type {!proto.SC2APIProtocol.Race} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.SC2APIProtocol.Race} value */
proto.SC2APIProtocol.RequestJoinGame.prototype.setRace = function(value) {
  jspb.Message.setOneofField(this, 1, proto.SC2APIProtocol.RequestJoinGame.oneofGroups_[0], value);
};


proto.SC2APIProtocol.RequestJoinGame.prototype.clearRace = function() {
  jspb.Message.setOneofField(this, 1, proto.SC2APIProtocol.RequestJoinGame.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.hasRace = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 observed_player_id = 2;
 * @return {number}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.getObservedPlayerId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.RequestJoinGame.prototype.setObservedPlayerId = function(value) {
  jspb.Message.setOneofField(this, 2, proto.SC2APIProtocol.RequestJoinGame.oneofGroups_[0], value);
};


proto.SC2APIProtocol.RequestJoinGame.prototype.clearObservedPlayerId = function() {
  jspb.Message.setOneofField(this, 2, proto.SC2APIProtocol.RequestJoinGame.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.hasObservedPlayerId = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional InterfaceOptions options = 3;
 * @return {?proto.SC2APIProtocol.InterfaceOptions}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.getOptions = function() {
  return /** @type{?proto.SC2APIProtocol.InterfaceOptions} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.InterfaceOptions, 3));
};


/** @param {?proto.SC2APIProtocol.InterfaceOptions|undefined} value */
proto.SC2APIProtocol.RequestJoinGame.prototype.setOptions = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.RequestJoinGame.prototype.clearOptions = function() {
  this.setOptions(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.hasOptions = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional PortSet server_ports = 4;
 * @return {?proto.SC2APIProtocol.PortSet}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.getServerPorts = function() {
  return /** @type{?proto.SC2APIProtocol.PortSet} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.PortSet, 4));
};


/** @param {?proto.SC2APIProtocol.PortSet|undefined} value */
proto.SC2APIProtocol.RequestJoinGame.prototype.setServerPorts = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.SC2APIProtocol.RequestJoinGame.prototype.clearServerPorts = function() {
  this.setServerPorts(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.hasServerPorts = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * repeated PortSet client_ports = 5;
 * @return {!Array.<!proto.SC2APIProtocol.PortSet>}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.getClientPortsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.PortSet>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.PortSet, 5));
};


/** @param {!Array.<!proto.SC2APIProtocol.PortSet>} value */
proto.SC2APIProtocol.RequestJoinGame.prototype.setClientPortsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.SC2APIProtocol.PortSet=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.PortSet}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.addClientPorts = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.SC2APIProtocol.PortSet, opt_index);
};


proto.SC2APIProtocol.RequestJoinGame.prototype.clearClientPortsList = function() {
  this.setClientPortsList([]);
};


/**
 * optional int32 shared_port = 6;
 * @return {number}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.getSharedPort = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.RequestJoinGame.prototype.setSharedPort = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.RequestJoinGame.prototype.clearSharedPort = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.hasSharedPort = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional string player_name = 7;
 * @return {string}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.getPlayerName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.RequestJoinGame.prototype.setPlayerName = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.RequestJoinGame.prototype.clearPlayerName = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.hasPlayerName = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional string host_ip = 8;
 * @return {string}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.getHostIp = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.RequestJoinGame.prototype.setHostIp = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.SC2APIProtocol.RequestJoinGame.prototype.clearHostIp = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestJoinGame.prototype.hasHostIp = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.PortSet = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.PortSet, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.PortSet.displayName = 'proto.SC2APIProtocol.PortSet';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.PortSet.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.PortSet.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.PortSet} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PortSet.toObject = function(includeInstance, msg) {
  var f, obj = {
    gamePort: jspb.Message.getField(msg, 1),
    basePort: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.PortSet}
 */
proto.SC2APIProtocol.PortSet.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.PortSet;
  return proto.SC2APIProtocol.PortSet.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.PortSet} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.PortSet}
 */
proto.SC2APIProtocol.PortSet.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setGamePort(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBasePort(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.PortSet.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.PortSet.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.PortSet} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PortSet.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional int32 game_port = 1;
 * @return {number}
 */
proto.SC2APIProtocol.PortSet.prototype.getGamePort = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PortSet.prototype.setGamePort = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.PortSet.prototype.clearGamePort = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PortSet.prototype.hasGamePort = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int32 base_port = 2;
 * @return {number}
 */
proto.SC2APIProtocol.PortSet.prototype.getBasePort = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PortSet.prototype.setBasePort = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.PortSet.prototype.clearBasePort = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PortSet.prototype.hasBasePort = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseJoinGame = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseJoinGame, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseJoinGame.displayName = 'proto.SC2APIProtocol.ResponseJoinGame';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseJoinGame.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseJoinGame.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseJoinGame} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseJoinGame.toObject = function(includeInstance, msg) {
  var f, obj = {
    playerId: jspb.Message.getField(msg, 1),
    error: jspb.Message.getField(msg, 2),
    errorDetails: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseJoinGame}
 */
proto.SC2APIProtocol.ResponseJoinGame.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseJoinGame;
  return proto.SC2APIProtocol.ResponseJoinGame.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseJoinGame} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseJoinGame}
 */
proto.SC2APIProtocol.ResponseJoinGame.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPlayerId(value);
      break;
    case 2:
      var value = /** @type {!proto.SC2APIProtocol.ResponseJoinGame.Error} */ (reader.readEnum());
      msg.setError(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setErrorDetails(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseJoinGame.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseJoinGame.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseJoinGame} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseJoinGame.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.ResponseJoinGame.Error} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.ResponseJoinGame.Error = {
  MISSINGPARTICIPATION: 1,
  INVALIDOBSERVEDPLAYERID: 2,
  MISSINGOPTIONS: 3,
  MISSINGPORTS: 4,
  GAMEFULL: 5,
  LAUNCHERROR: 6,
  FEATUREUNSUPPORTED: 7,
  NOSPACEFORUSER: 8,
  MAPDOESNOTEXIST: 9,
  CANNOTOPENMAP: 10,
  CHECKSUMERROR: 11,
  NETWORKERROR: 12,
  OTHERERROR: 13
};

/**
 * optional uint32 player_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ResponseJoinGame.prototype.getPlayerId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ResponseJoinGame.prototype.setPlayerId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponseJoinGame.prototype.clearPlayerId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseJoinGame.prototype.hasPlayerId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Error error = 2;
 * @return {!proto.SC2APIProtocol.ResponseJoinGame.Error}
 */
proto.SC2APIProtocol.ResponseJoinGame.prototype.getError = function() {
  return /** @type {!proto.SC2APIProtocol.ResponseJoinGame.Error} */ (jspb.Message.getFieldWithDefault(this, 2, 1));
};


/** @param {!proto.SC2APIProtocol.ResponseJoinGame.Error} value */
proto.SC2APIProtocol.ResponseJoinGame.prototype.setError = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ResponseJoinGame.prototype.clearError = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseJoinGame.prototype.hasError = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string error_details = 3;
 * @return {string}
 */
proto.SC2APIProtocol.ResponseJoinGame.prototype.getErrorDetails = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponseJoinGame.prototype.setErrorDetails = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.ResponseJoinGame.prototype.clearErrorDetails = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseJoinGame.prototype.hasErrorDetails = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestRestartGame = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestRestartGame, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestRestartGame.displayName = 'proto.SC2APIProtocol.RequestRestartGame';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestRestartGame.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestRestartGame.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestRestartGame} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestRestartGame.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestRestartGame}
 */
proto.SC2APIProtocol.RequestRestartGame.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestRestartGame;
  return proto.SC2APIProtocol.RequestRestartGame.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestRestartGame} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestRestartGame}
 */
proto.SC2APIProtocol.RequestRestartGame.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestRestartGame.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestRestartGame.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestRestartGame} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestRestartGame.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseRestartGame = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseRestartGame, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseRestartGame.displayName = 'proto.SC2APIProtocol.ResponseRestartGame';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseRestartGame.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseRestartGame.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseRestartGame} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseRestartGame.toObject = function(includeInstance, msg) {
  var f, obj = {
    error: jspb.Message.getField(msg, 1),
    errorDetails: jspb.Message.getField(msg, 2),
    needHardReset: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseRestartGame}
 */
proto.SC2APIProtocol.ResponseRestartGame.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseRestartGame;
  return proto.SC2APIProtocol.ResponseRestartGame.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseRestartGame} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseRestartGame}
 */
proto.SC2APIProtocol.ResponseRestartGame.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.ResponseRestartGame.Error} */ (reader.readEnum());
      msg.setError(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setErrorDetails(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setNeedHardReset(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseRestartGame.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseRestartGame.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseRestartGame} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseRestartGame.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.ResponseRestartGame.Error} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.ResponseRestartGame.Error = {
  LAUNCHERROR: 1
};

/**
 * optional Error error = 1;
 * @return {!proto.SC2APIProtocol.ResponseRestartGame.Error}
 */
proto.SC2APIProtocol.ResponseRestartGame.prototype.getError = function() {
  return /** @type {!proto.SC2APIProtocol.ResponseRestartGame.Error} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.ResponseRestartGame.Error} value */
proto.SC2APIProtocol.ResponseRestartGame.prototype.setError = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponseRestartGame.prototype.clearError = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseRestartGame.prototype.hasError = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string error_details = 2;
 * @return {string}
 */
proto.SC2APIProtocol.ResponseRestartGame.prototype.getErrorDetails = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponseRestartGame.prototype.setErrorDetails = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ResponseRestartGame.prototype.clearErrorDetails = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseRestartGame.prototype.hasErrorDetails = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool need_hard_reset = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.ResponseRestartGame.prototype.getNeedHardReset = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.ResponseRestartGame.prototype.setNeedHardReset = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.ResponseRestartGame.prototype.clearNeedHardReset = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseRestartGame.prototype.hasNeedHardReset = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestStartReplay = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.SC2APIProtocol.RequestStartReplay.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.RequestStartReplay, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestStartReplay.displayName = 'proto.SC2APIProtocol.RequestStartReplay';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.RequestStartReplay.oneofGroups_ = [[1,5]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.RequestStartReplay.ReplayCase = {
  REPLAY_NOT_SET: 0,
  REPLAY_PATH: 1,
  REPLAY_DATA: 5
};

/**
 * @return {proto.SC2APIProtocol.RequestStartReplay.ReplayCase}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getReplayCase = function() {
  return /** @type {proto.SC2APIProtocol.RequestStartReplay.ReplayCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.RequestStartReplay.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestStartReplay.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestStartReplay} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestStartReplay.toObject = function(includeInstance, msg) {
  var f, obj = {
    replayPath: jspb.Message.getField(msg, 1),
    replayData: msg.getReplayData_asB64(),
    mapData: msg.getMapData_asB64(),
    observedPlayerId: jspb.Message.getField(msg, 2),
    options: (f = msg.getOptions()) && proto.SC2APIProtocol.InterfaceOptions.toObject(includeInstance, f),
    disableFog: jspb.Message.getField(msg, 4),
    realtime: jspb.Message.getField(msg, 7),
    recordReplay: jspb.Message.getField(msg, 8)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestStartReplay}
 */
proto.SC2APIProtocol.RequestStartReplay.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestStartReplay;
  return proto.SC2APIProtocol.RequestStartReplay.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestStartReplay} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestStartReplay}
 */
proto.SC2APIProtocol.RequestStartReplay.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setReplayPath(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setReplayData(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMapData(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setObservedPlayerId(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.InterfaceOptions;
      reader.readMessage(value,proto.SC2APIProtocol.InterfaceOptions.deserializeBinaryFromReader);
      msg.setOptions(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDisableFog(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRealtime(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRecordReplay(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestStartReplay.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestStartReplay} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestStartReplay.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeBytes(
      6,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getOptions();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.InterfaceOptions.serializeBinaryToWriter
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBool(
      4,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeBool(
      7,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeBool(
      8,
      f
    );
  }
};


/**
 * optional string replay_path = 1;
 * @return {string}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getReplayPath = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.RequestStartReplay.prototype.setReplayPath = function(value) {
  jspb.Message.setOneofField(this, 1, proto.SC2APIProtocol.RequestStartReplay.oneofGroups_[0], value);
};


proto.SC2APIProtocol.RequestStartReplay.prototype.clearReplayPath = function() {
  jspb.Message.setOneofField(this, 1, proto.SC2APIProtocol.RequestStartReplay.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.hasReplayPath = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes replay_data = 5;
 * @return {!(string|Uint8Array)}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getReplayData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes replay_data = 5;
 * This is a type-conversion wrapper around `getReplayData()`
 * @return {string}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getReplayData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getReplayData()));
};


/**
 * optional bytes replay_data = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getReplayData()`
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getReplayData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getReplayData()));
};


/** @param {!(string|Uint8Array)} value */
proto.SC2APIProtocol.RequestStartReplay.prototype.setReplayData = function(value) {
  jspb.Message.setOneofField(this, 5, proto.SC2APIProtocol.RequestStartReplay.oneofGroups_[0], value);
};


proto.SC2APIProtocol.RequestStartReplay.prototype.clearReplayData = function() {
  jspb.Message.setOneofField(this, 5, proto.SC2APIProtocol.RequestStartReplay.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.hasReplayData = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional bytes map_data = 6;
 * @return {!(string|Uint8Array)}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getMapData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes map_data = 6;
 * This is a type-conversion wrapper around `getMapData()`
 * @return {string}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getMapData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMapData()));
};


/**
 * optional bytes map_data = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMapData()`
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getMapData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMapData()));
};


/** @param {!(string|Uint8Array)} value */
proto.SC2APIProtocol.RequestStartReplay.prototype.setMapData = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.RequestStartReplay.prototype.clearMapData = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.hasMapData = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional int32 observed_player_id = 2;
 * @return {number}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getObservedPlayerId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.RequestStartReplay.prototype.setObservedPlayerId = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.RequestStartReplay.prototype.clearObservedPlayerId = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.hasObservedPlayerId = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional InterfaceOptions options = 3;
 * @return {?proto.SC2APIProtocol.InterfaceOptions}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getOptions = function() {
  return /** @type{?proto.SC2APIProtocol.InterfaceOptions} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.InterfaceOptions, 3));
};


/** @param {?proto.SC2APIProtocol.InterfaceOptions|undefined} value */
proto.SC2APIProtocol.RequestStartReplay.prototype.setOptions = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.RequestStartReplay.prototype.clearOptions = function() {
  this.setOptions(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.hasOptions = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bool disable_fog = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getDisableFog = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestStartReplay.prototype.setDisableFog = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.RequestStartReplay.prototype.clearDisableFog = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.hasDisableFog = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bool realtime = 7;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getRealtime = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 7, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestStartReplay.prototype.setRealtime = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.RequestStartReplay.prototype.clearRealtime = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.hasRealtime = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional bool record_replay = 8;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.getRecordReplay = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 8, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestStartReplay.prototype.setRecordReplay = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.SC2APIProtocol.RequestStartReplay.prototype.clearRecordReplay = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestStartReplay.prototype.hasRecordReplay = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseStartReplay = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseStartReplay, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseStartReplay.displayName = 'proto.SC2APIProtocol.ResponseStartReplay';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseStartReplay.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseStartReplay.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseStartReplay} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseStartReplay.toObject = function(includeInstance, msg) {
  var f, obj = {
    error: jspb.Message.getField(msg, 1),
    errorDetails: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseStartReplay}
 */
proto.SC2APIProtocol.ResponseStartReplay.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseStartReplay;
  return proto.SC2APIProtocol.ResponseStartReplay.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseStartReplay} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseStartReplay}
 */
proto.SC2APIProtocol.ResponseStartReplay.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.ResponseStartReplay.Error} */ (reader.readEnum());
      msg.setError(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setErrorDetails(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseStartReplay.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseStartReplay.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseStartReplay} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseStartReplay.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.ResponseStartReplay.Error} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.ResponseStartReplay.Error = {
  MISSINGREPLAY: 1,
  INVALIDREPLAYPATH: 2,
  INVALIDREPLAYDATA: 3,
  INVALIDMAPDATA: 4,
  INVALIDOBSERVEDPLAYERID: 5,
  MISSINGOPTIONS: 6,
  LAUNCHERROR: 7
};

/**
 * optional Error error = 1;
 * @return {!proto.SC2APIProtocol.ResponseStartReplay.Error}
 */
proto.SC2APIProtocol.ResponseStartReplay.prototype.getError = function() {
  return /** @type {!proto.SC2APIProtocol.ResponseStartReplay.Error} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.ResponseStartReplay.Error} value */
proto.SC2APIProtocol.ResponseStartReplay.prototype.setError = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponseStartReplay.prototype.clearError = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseStartReplay.prototype.hasError = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string error_details = 2;
 * @return {string}
 */
proto.SC2APIProtocol.ResponseStartReplay.prototype.getErrorDetails = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponseStartReplay.prototype.setErrorDetails = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ResponseStartReplay.prototype.clearErrorDetails = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseStartReplay.prototype.hasErrorDetails = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestMapCommand = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestMapCommand, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestMapCommand.displayName = 'proto.SC2APIProtocol.RequestMapCommand';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestMapCommand.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestMapCommand.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestMapCommand} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestMapCommand.toObject = function(includeInstance, msg) {
  var f, obj = {
    triggerCmd: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestMapCommand}
 */
proto.SC2APIProtocol.RequestMapCommand.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestMapCommand;
  return proto.SC2APIProtocol.RequestMapCommand.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestMapCommand} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestMapCommand}
 */
proto.SC2APIProtocol.RequestMapCommand.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTriggerCmd(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestMapCommand.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestMapCommand.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestMapCommand} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestMapCommand.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string trigger_cmd = 1;
 * @return {string}
 */
proto.SC2APIProtocol.RequestMapCommand.prototype.getTriggerCmd = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.RequestMapCommand.prototype.setTriggerCmd = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.RequestMapCommand.prototype.clearTriggerCmd = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestMapCommand.prototype.hasTriggerCmd = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseMapCommand = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseMapCommand, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseMapCommand.displayName = 'proto.SC2APIProtocol.ResponseMapCommand';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseMapCommand.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseMapCommand.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseMapCommand} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseMapCommand.toObject = function(includeInstance, msg) {
  var f, obj = {
    error: jspb.Message.getField(msg, 1),
    errorDetails: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseMapCommand}
 */
proto.SC2APIProtocol.ResponseMapCommand.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseMapCommand;
  return proto.SC2APIProtocol.ResponseMapCommand.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseMapCommand} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseMapCommand}
 */
proto.SC2APIProtocol.ResponseMapCommand.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.ResponseMapCommand.Error} */ (reader.readEnum());
      msg.setError(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setErrorDetails(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseMapCommand.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseMapCommand.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseMapCommand} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseMapCommand.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.ResponseMapCommand.Error} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.ResponseMapCommand.Error = {
  NOTRIGGERERROR: 1
};

/**
 * optional Error error = 1;
 * @return {!proto.SC2APIProtocol.ResponseMapCommand.Error}
 */
proto.SC2APIProtocol.ResponseMapCommand.prototype.getError = function() {
  return /** @type {!proto.SC2APIProtocol.ResponseMapCommand.Error} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.ResponseMapCommand.Error} value */
proto.SC2APIProtocol.ResponseMapCommand.prototype.setError = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponseMapCommand.prototype.clearError = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseMapCommand.prototype.hasError = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string error_details = 2;
 * @return {string}
 */
proto.SC2APIProtocol.ResponseMapCommand.prototype.getErrorDetails = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponseMapCommand.prototype.setErrorDetails = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ResponseMapCommand.prototype.clearErrorDetails = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseMapCommand.prototype.hasErrorDetails = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestLeaveGame = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestLeaveGame, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestLeaveGame.displayName = 'proto.SC2APIProtocol.RequestLeaveGame';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestLeaveGame.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestLeaveGame.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestLeaveGame} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestLeaveGame.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestLeaveGame}
 */
proto.SC2APIProtocol.RequestLeaveGame.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestLeaveGame;
  return proto.SC2APIProtocol.RequestLeaveGame.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestLeaveGame} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestLeaveGame}
 */
proto.SC2APIProtocol.RequestLeaveGame.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestLeaveGame.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestLeaveGame.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestLeaveGame} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestLeaveGame.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseLeaveGame = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseLeaveGame, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseLeaveGame.displayName = 'proto.SC2APIProtocol.ResponseLeaveGame';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseLeaveGame.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseLeaveGame.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseLeaveGame} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseLeaveGame.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseLeaveGame}
 */
proto.SC2APIProtocol.ResponseLeaveGame.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseLeaveGame;
  return proto.SC2APIProtocol.ResponseLeaveGame.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseLeaveGame} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseLeaveGame}
 */
proto.SC2APIProtocol.ResponseLeaveGame.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseLeaveGame.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseLeaveGame.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseLeaveGame} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseLeaveGame.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestQuickSave = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestQuickSave, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestQuickSave.displayName = 'proto.SC2APIProtocol.RequestQuickSave';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestQuickSave.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestQuickSave.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestQuickSave} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQuickSave.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestQuickSave}
 */
proto.SC2APIProtocol.RequestQuickSave.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestQuickSave;
  return proto.SC2APIProtocol.RequestQuickSave.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestQuickSave} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestQuickSave}
 */
proto.SC2APIProtocol.RequestQuickSave.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestQuickSave.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestQuickSave.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestQuickSave} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQuickSave.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseQuickSave = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseQuickSave, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseQuickSave.displayName = 'proto.SC2APIProtocol.ResponseQuickSave';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseQuickSave.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseQuickSave.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseQuickSave} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQuickSave.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseQuickSave}
 */
proto.SC2APIProtocol.ResponseQuickSave.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseQuickSave;
  return proto.SC2APIProtocol.ResponseQuickSave.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseQuickSave} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseQuickSave}
 */
proto.SC2APIProtocol.ResponseQuickSave.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseQuickSave.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseQuickSave.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseQuickSave} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQuickSave.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestQuickLoad = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestQuickLoad, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestQuickLoad.displayName = 'proto.SC2APIProtocol.RequestQuickLoad';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestQuickLoad.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestQuickLoad.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestQuickLoad} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQuickLoad.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestQuickLoad}
 */
proto.SC2APIProtocol.RequestQuickLoad.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestQuickLoad;
  return proto.SC2APIProtocol.RequestQuickLoad.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestQuickLoad} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestQuickLoad}
 */
proto.SC2APIProtocol.RequestQuickLoad.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestQuickLoad.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestQuickLoad.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestQuickLoad} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQuickLoad.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseQuickLoad = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseQuickLoad, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseQuickLoad.displayName = 'proto.SC2APIProtocol.ResponseQuickLoad';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseQuickLoad.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseQuickLoad.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseQuickLoad} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQuickLoad.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseQuickLoad}
 */
proto.SC2APIProtocol.ResponseQuickLoad.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseQuickLoad;
  return proto.SC2APIProtocol.ResponseQuickLoad.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseQuickLoad} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseQuickLoad}
 */
proto.SC2APIProtocol.ResponseQuickLoad.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseQuickLoad.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseQuickLoad.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseQuickLoad} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQuickLoad.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestQuit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestQuit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestQuit.displayName = 'proto.SC2APIProtocol.RequestQuit';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestQuit.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestQuit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestQuit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQuit.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestQuit}
 */
proto.SC2APIProtocol.RequestQuit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestQuit;
  return proto.SC2APIProtocol.RequestQuit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestQuit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestQuit}
 */
proto.SC2APIProtocol.RequestQuit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestQuit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestQuit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestQuit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestQuit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseQuit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseQuit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseQuit.displayName = 'proto.SC2APIProtocol.ResponseQuit';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseQuit.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseQuit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseQuit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQuit.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseQuit}
 */
proto.SC2APIProtocol.ResponseQuit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseQuit;
  return proto.SC2APIProtocol.ResponseQuit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseQuit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseQuit}
 */
proto.SC2APIProtocol.ResponseQuit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseQuit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseQuit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseQuit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseQuit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestGameInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestGameInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestGameInfo.displayName = 'proto.SC2APIProtocol.RequestGameInfo';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestGameInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestGameInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestGameInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestGameInfo.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestGameInfo}
 */
proto.SC2APIProtocol.RequestGameInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestGameInfo;
  return proto.SC2APIProtocol.RequestGameInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestGameInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestGameInfo}
 */
proto.SC2APIProtocol.RequestGameInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestGameInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestGameInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestGameInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestGameInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseGameInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ResponseGameInfo.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseGameInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseGameInfo.displayName = 'proto.SC2APIProtocol.ResponseGameInfo';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ResponseGameInfo.repeatedFields_ = [6,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseGameInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseGameInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseGameInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    mapName: jspb.Message.getField(msg, 1),
    modNamesList: jspb.Message.getRepeatedField(msg, 6),
    localMapPath: jspb.Message.getField(msg, 2),
    playerInfoList: jspb.Message.toObjectList(msg.getPlayerInfoList(),
    proto.SC2APIProtocol.PlayerInfo.toObject, includeInstance),
    startRaw: (f = msg.getStartRaw()) && s2clientprotocol_raw_pb.StartRaw.toObject(includeInstance, f),
    options: (f = msg.getOptions()) && proto.SC2APIProtocol.InterfaceOptions.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseGameInfo}
 */
proto.SC2APIProtocol.ResponseGameInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseGameInfo;
  return proto.SC2APIProtocol.ResponseGameInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseGameInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseGameInfo}
 */
proto.SC2APIProtocol.ResponseGameInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMapName(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.addModNames(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setLocalMapPath(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.PlayerInfo;
      reader.readMessage(value,proto.SC2APIProtocol.PlayerInfo.deserializeBinaryFromReader);
      msg.addPlayerInfo(value);
      break;
    case 4:
      var value = new s2clientprotocol_raw_pb.StartRaw;
      reader.readMessage(value,s2clientprotocol_raw_pb.StartRaw.deserializeBinaryFromReader);
      msg.setStartRaw(value);
      break;
    case 5:
      var value = new proto.SC2APIProtocol.InterfaceOptions;
      reader.readMessage(value,proto.SC2APIProtocol.InterfaceOptions.deserializeBinaryFromReader);
      msg.setOptions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseGameInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseGameInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseGameInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getModNamesList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      6,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getPlayerInfoList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.SC2APIProtocol.PlayerInfo.serializeBinaryToWriter
    );
  }
  f = message.getStartRaw();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      s2clientprotocol_raw_pb.StartRaw.serializeBinaryToWriter
    );
  }
  f = message.getOptions();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.SC2APIProtocol.InterfaceOptions.serializeBinaryToWriter
    );
  }
};


/**
 * optional string map_name = 1;
 * @return {string}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.getMapName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponseGameInfo.prototype.setMapName = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponseGameInfo.prototype.clearMapName = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.hasMapName = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated string mod_names = 6;
 * @return {!Array.<string>}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.getModNamesList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 6));
};


/** @param {!Array.<string>} value */
proto.SC2APIProtocol.ResponseGameInfo.prototype.setModNamesList = function(value) {
  jspb.Message.setField(this, 6, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.addModNames = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 6, value, opt_index);
};


proto.SC2APIProtocol.ResponseGameInfo.prototype.clearModNamesList = function() {
  this.setModNamesList([]);
};


/**
 * optional string local_map_path = 2;
 * @return {string}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.getLocalMapPath = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponseGameInfo.prototype.setLocalMapPath = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ResponseGameInfo.prototype.clearLocalMapPath = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.hasLocalMapPath = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * repeated PlayerInfo player_info = 3;
 * @return {!Array.<!proto.SC2APIProtocol.PlayerInfo>}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.getPlayerInfoList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.PlayerInfo>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.PlayerInfo, 3));
};


/** @param {!Array.<!proto.SC2APIProtocol.PlayerInfo>} value */
proto.SC2APIProtocol.ResponseGameInfo.prototype.setPlayerInfoList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.SC2APIProtocol.PlayerInfo=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.PlayerInfo}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.addPlayerInfo = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.SC2APIProtocol.PlayerInfo, opt_index);
};


proto.SC2APIProtocol.ResponseGameInfo.prototype.clearPlayerInfoList = function() {
  this.setPlayerInfoList([]);
};


/**
 * optional StartRaw start_raw = 4;
 * @return {?proto.SC2APIProtocol.StartRaw}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.getStartRaw = function() {
  return /** @type{?proto.SC2APIProtocol.StartRaw} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_raw_pb.StartRaw, 4));
};


/** @param {?proto.SC2APIProtocol.StartRaw|undefined} value */
proto.SC2APIProtocol.ResponseGameInfo.prototype.setStartRaw = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.SC2APIProtocol.ResponseGameInfo.prototype.clearStartRaw = function() {
  this.setStartRaw(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.hasStartRaw = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional InterfaceOptions options = 5;
 * @return {?proto.SC2APIProtocol.InterfaceOptions}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.getOptions = function() {
  return /** @type{?proto.SC2APIProtocol.InterfaceOptions} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.InterfaceOptions, 5));
};


/** @param {?proto.SC2APIProtocol.InterfaceOptions|undefined} value */
proto.SC2APIProtocol.ResponseGameInfo.prototype.setOptions = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.SC2APIProtocol.ResponseGameInfo.prototype.clearOptions = function() {
  this.setOptions(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseGameInfo.prototype.hasOptions = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestObservation = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestObservation, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestObservation.displayName = 'proto.SC2APIProtocol.RequestObservation';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestObservation.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestObservation.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestObservation} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestObservation.toObject = function(includeInstance, msg) {
  var f, obj = {
    disableFog: jspb.Message.getField(msg, 1),
    gameLoop: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestObservation}
 */
proto.SC2APIProtocol.RequestObservation.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestObservation;
  return proto.SC2APIProtocol.RequestObservation.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestObservation} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestObservation}
 */
proto.SC2APIProtocol.RequestObservation.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDisableFog(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setGameLoop(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestObservation.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestObservation.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestObservation} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestObservation.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {boolean} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBool(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * optional bool disable_fog = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestObservation.prototype.getDisableFog = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestObservation.prototype.setDisableFog = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.RequestObservation.prototype.clearDisableFog = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestObservation.prototype.hasDisableFog = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 game_loop = 2;
 * @return {number}
 */
proto.SC2APIProtocol.RequestObservation.prototype.getGameLoop = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.RequestObservation.prototype.setGameLoop = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.RequestObservation.prototype.clearGameLoop = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestObservation.prototype.hasGameLoop = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseObservation = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ResponseObservation.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseObservation, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseObservation.displayName = 'proto.SC2APIProtocol.ResponseObservation';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ResponseObservation.repeatedFields_ = [1,2,4,5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseObservation.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseObservation.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseObservation} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseObservation.toObject = function(includeInstance, msg) {
  var f, obj = {
    actionsList: jspb.Message.toObjectList(msg.getActionsList(),
    proto.SC2APIProtocol.Action.toObject, includeInstance),
    actionErrorsList: jspb.Message.toObjectList(msg.getActionErrorsList(),
    proto.SC2APIProtocol.ActionError.toObject, includeInstance),
    observation: (f = msg.getObservation()) && proto.SC2APIProtocol.Observation.toObject(includeInstance, f),
    playerResultList: jspb.Message.toObjectList(msg.getPlayerResultList(),
    proto.SC2APIProtocol.PlayerResult.toObject, includeInstance),
    chatList: jspb.Message.toObjectList(msg.getChatList(),
    proto.SC2APIProtocol.ChatReceived.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseObservation}
 */
proto.SC2APIProtocol.ResponseObservation.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseObservation;
  return proto.SC2APIProtocol.ResponseObservation.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseObservation} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseObservation}
 */
proto.SC2APIProtocol.ResponseObservation.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.Action;
      reader.readMessage(value,proto.SC2APIProtocol.Action.deserializeBinaryFromReader);
      msg.addActions(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.ActionError;
      reader.readMessage(value,proto.SC2APIProtocol.ActionError.deserializeBinaryFromReader);
      msg.addActionErrors(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.Observation;
      reader.readMessage(value,proto.SC2APIProtocol.Observation.deserializeBinaryFromReader);
      msg.setObservation(value);
      break;
    case 4:
      var value = new proto.SC2APIProtocol.PlayerResult;
      reader.readMessage(value,proto.SC2APIProtocol.PlayerResult.deserializeBinaryFromReader);
      msg.addPlayerResult(value);
      break;
    case 5:
      var value = new proto.SC2APIProtocol.ChatReceived;
      reader.readMessage(value,proto.SC2APIProtocol.ChatReceived.deserializeBinaryFromReader);
      msg.addChat(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseObservation.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseObservation.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseObservation} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseObservation.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getActionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.SC2APIProtocol.Action.serializeBinaryToWriter
    );
  }
  f = message.getActionErrorsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.SC2APIProtocol.ActionError.serializeBinaryToWriter
    );
  }
  f = message.getObservation();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.Observation.serializeBinaryToWriter
    );
  }
  f = message.getPlayerResultList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.SC2APIProtocol.PlayerResult.serializeBinaryToWriter
    );
  }
  f = message.getChatList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.SC2APIProtocol.ChatReceived.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Action actions = 1;
 * @return {!Array.<!proto.SC2APIProtocol.Action>}
 */
proto.SC2APIProtocol.ResponseObservation.prototype.getActionsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.Action>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.Action, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.Action>} value */
proto.SC2APIProtocol.ResponseObservation.prototype.setActionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.Action=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.Action}
 */
proto.SC2APIProtocol.ResponseObservation.prototype.addActions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.Action, opt_index);
};


proto.SC2APIProtocol.ResponseObservation.prototype.clearActionsList = function() {
  this.setActionsList([]);
};


/**
 * repeated ActionError action_errors = 2;
 * @return {!Array.<!proto.SC2APIProtocol.ActionError>}
 */
proto.SC2APIProtocol.ResponseObservation.prototype.getActionErrorsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.ActionError>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.ActionError, 2));
};


/** @param {!Array.<!proto.SC2APIProtocol.ActionError>} value */
proto.SC2APIProtocol.ResponseObservation.prototype.setActionErrorsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.SC2APIProtocol.ActionError=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.ActionError}
 */
proto.SC2APIProtocol.ResponseObservation.prototype.addActionErrors = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.SC2APIProtocol.ActionError, opt_index);
};


proto.SC2APIProtocol.ResponseObservation.prototype.clearActionErrorsList = function() {
  this.setActionErrorsList([]);
};


/**
 * optional Observation observation = 3;
 * @return {?proto.SC2APIProtocol.Observation}
 */
proto.SC2APIProtocol.ResponseObservation.prototype.getObservation = function() {
  return /** @type{?proto.SC2APIProtocol.Observation} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.Observation, 3));
};


/** @param {?proto.SC2APIProtocol.Observation|undefined} value */
proto.SC2APIProtocol.ResponseObservation.prototype.setObservation = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.ResponseObservation.prototype.clearObservation = function() {
  this.setObservation(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseObservation.prototype.hasObservation = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * repeated PlayerResult player_result = 4;
 * @return {!Array.<!proto.SC2APIProtocol.PlayerResult>}
 */
proto.SC2APIProtocol.ResponseObservation.prototype.getPlayerResultList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.PlayerResult>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.PlayerResult, 4));
};


/** @param {!Array.<!proto.SC2APIProtocol.PlayerResult>} value */
proto.SC2APIProtocol.ResponseObservation.prototype.setPlayerResultList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.SC2APIProtocol.PlayerResult=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.PlayerResult}
 */
proto.SC2APIProtocol.ResponseObservation.prototype.addPlayerResult = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.SC2APIProtocol.PlayerResult, opt_index);
};


proto.SC2APIProtocol.ResponseObservation.prototype.clearPlayerResultList = function() {
  this.setPlayerResultList([]);
};


/**
 * repeated ChatReceived chat = 5;
 * @return {!Array.<!proto.SC2APIProtocol.ChatReceived>}
 */
proto.SC2APIProtocol.ResponseObservation.prototype.getChatList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.ChatReceived>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.ChatReceived, 5));
};


/** @param {!Array.<!proto.SC2APIProtocol.ChatReceived>} value */
proto.SC2APIProtocol.ResponseObservation.prototype.setChatList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.SC2APIProtocol.ChatReceived=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.ChatReceived}
 */
proto.SC2APIProtocol.ResponseObservation.prototype.addChat = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.SC2APIProtocol.ChatReceived, opt_index);
};


proto.SC2APIProtocol.ResponseObservation.prototype.clearChatList = function() {
  this.setChatList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ChatReceived = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ChatReceived, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ChatReceived.displayName = 'proto.SC2APIProtocol.ChatReceived';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ChatReceived.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ChatReceived.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ChatReceived} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ChatReceived.toObject = function(includeInstance, msg) {
  var f, obj = {
    playerId: jspb.Message.getField(msg, 1),
    message: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ChatReceived}
 */
proto.SC2APIProtocol.ChatReceived.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ChatReceived;
  return proto.SC2APIProtocol.ChatReceived.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ChatReceived} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ChatReceived}
 */
proto.SC2APIProtocol.ChatReceived.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPlayerId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ChatReceived.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ChatReceived.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ChatReceived} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ChatReceived.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional uint32 player_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ChatReceived.prototype.getPlayerId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ChatReceived.prototype.setPlayerId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ChatReceived.prototype.clearPlayerId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ChatReceived.prototype.hasPlayerId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string message = 2;
 * @return {string}
 */
proto.SC2APIProtocol.ChatReceived.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ChatReceived.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ChatReceived.prototype.clearMessage = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ChatReceived.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestAction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.RequestAction.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.RequestAction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestAction.displayName = 'proto.SC2APIProtocol.RequestAction';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.RequestAction.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestAction.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestAction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestAction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestAction.toObject = function(includeInstance, msg) {
  var f, obj = {
    actionsList: jspb.Message.toObjectList(msg.getActionsList(),
    proto.SC2APIProtocol.Action.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestAction}
 */
proto.SC2APIProtocol.RequestAction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestAction;
  return proto.SC2APIProtocol.RequestAction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestAction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestAction}
 */
proto.SC2APIProtocol.RequestAction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.Action;
      reader.readMessage(value,proto.SC2APIProtocol.Action.deserializeBinaryFromReader);
      msg.addActions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestAction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestAction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestAction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestAction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getActionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.SC2APIProtocol.Action.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Action actions = 1;
 * @return {!Array.<!proto.SC2APIProtocol.Action>}
 */
proto.SC2APIProtocol.RequestAction.prototype.getActionsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.Action>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.Action, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.Action>} value */
proto.SC2APIProtocol.RequestAction.prototype.setActionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.Action=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.Action}
 */
proto.SC2APIProtocol.RequestAction.prototype.addActions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.Action, opt_index);
};


proto.SC2APIProtocol.RequestAction.prototype.clearActionsList = function() {
  this.setActionsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseAction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ResponseAction.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseAction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseAction.displayName = 'proto.SC2APIProtocol.ResponseAction';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ResponseAction.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseAction.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseAction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseAction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseAction.toObject = function(includeInstance, msg) {
  var f, obj = {
    resultList: jspb.Message.getRepeatedField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseAction}
 */
proto.SC2APIProtocol.ResponseAction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseAction;
  return proto.SC2APIProtocol.ResponseAction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseAction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseAction}
 */
proto.SC2APIProtocol.ResponseAction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.ActionResult} */ (reader.readEnum());
      msg.addResult(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseAction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseAction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseAction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseAction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getResultList();
  if (f.length > 0) {
    writer.writeRepeatedEnum(
      1,
      f
    );
  }
};


/**
 * repeated ActionResult result = 1;
 * @return {!Array.<!proto.SC2APIProtocol.ActionResult>}
 */
proto.SC2APIProtocol.ResponseAction.prototype.getResultList = function() {
  return /** @type {!Array.<!proto.SC2APIProtocol.ActionResult>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.ActionResult>} value */
proto.SC2APIProtocol.ResponseAction.prototype.setResultList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!proto.SC2APIProtocol.ActionResult} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.ResponseAction.prototype.addResult = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.SC2APIProtocol.ResponseAction.prototype.clearResultList = function() {
  this.setResultList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestObserverAction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.RequestObserverAction.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.RequestObserverAction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestObserverAction.displayName = 'proto.SC2APIProtocol.RequestObserverAction';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.RequestObserverAction.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestObserverAction.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestObserverAction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestObserverAction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestObserverAction.toObject = function(includeInstance, msg) {
  var f, obj = {
    actionsList: jspb.Message.toObjectList(msg.getActionsList(),
    proto.SC2APIProtocol.ObserverAction.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestObserverAction}
 */
proto.SC2APIProtocol.RequestObserverAction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestObserverAction;
  return proto.SC2APIProtocol.RequestObserverAction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestObserverAction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestObserverAction}
 */
proto.SC2APIProtocol.RequestObserverAction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.ObserverAction;
      reader.readMessage(value,proto.SC2APIProtocol.ObserverAction.deserializeBinaryFromReader);
      msg.addActions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestObserverAction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestObserverAction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestObserverAction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestObserverAction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getActionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.SC2APIProtocol.ObserverAction.serializeBinaryToWriter
    );
  }
};


/**
 * repeated ObserverAction actions = 1;
 * @return {!Array.<!proto.SC2APIProtocol.ObserverAction>}
 */
proto.SC2APIProtocol.RequestObserverAction.prototype.getActionsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.ObserverAction>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.ObserverAction, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.ObserverAction>} value */
proto.SC2APIProtocol.RequestObserverAction.prototype.setActionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.ObserverAction=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.ObserverAction}
 */
proto.SC2APIProtocol.RequestObserverAction.prototype.addActions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.ObserverAction, opt_index);
};


proto.SC2APIProtocol.RequestObserverAction.prototype.clearActionsList = function() {
  this.setActionsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseObserverAction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseObserverAction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseObserverAction.displayName = 'proto.SC2APIProtocol.ResponseObserverAction';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseObserverAction.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseObserverAction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseObserverAction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseObserverAction.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseObserverAction}
 */
proto.SC2APIProtocol.ResponseObserverAction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseObserverAction;
  return proto.SC2APIProtocol.ResponseObserverAction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseObserverAction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseObserverAction}
 */
proto.SC2APIProtocol.ResponseObserverAction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseObserverAction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseObserverAction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseObserverAction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseObserverAction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestStep = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestStep, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestStep.displayName = 'proto.SC2APIProtocol.RequestStep';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestStep.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestStep.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestStep} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestStep.toObject = function(includeInstance, msg) {
  var f, obj = {
    count: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestStep}
 */
proto.SC2APIProtocol.RequestStep.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestStep;
  return proto.SC2APIProtocol.RequestStep.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestStep} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestStep}
 */
proto.SC2APIProtocol.RequestStep.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestStep.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestStep.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestStep} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestStep.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 count = 1;
 * @return {number}
 */
proto.SC2APIProtocol.RequestStep.prototype.getCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.RequestStep.prototype.setCount = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.RequestStep.prototype.clearCount = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestStep.prototype.hasCount = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseStep = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseStep, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseStep.displayName = 'proto.SC2APIProtocol.ResponseStep';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseStep.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseStep.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseStep} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseStep.toObject = function(includeInstance, msg) {
  var f, obj = {
    simulationLoop: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseStep}
 */
proto.SC2APIProtocol.ResponseStep.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseStep;
  return proto.SC2APIProtocol.ResponseStep.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseStep} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseStep}
 */
proto.SC2APIProtocol.ResponseStep.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSimulationLoop(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseStep.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseStep.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseStep} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseStep.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 simulation_loop = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ResponseStep.prototype.getSimulationLoop = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ResponseStep.prototype.setSimulationLoop = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponseStep.prototype.clearSimulationLoop = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseStep.prototype.hasSimulationLoop = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestData.displayName = 'proto.SC2APIProtocol.RequestData';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestData.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestData.toObject = function(includeInstance, msg) {
  var f, obj = {
    abilityId: jspb.Message.getField(msg, 1),
    unitTypeId: jspb.Message.getField(msg, 2),
    upgradeId: jspb.Message.getField(msg, 3),
    buffId: jspb.Message.getField(msg, 4),
    effectId: jspb.Message.getField(msg, 5)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestData}
 */
proto.SC2APIProtocol.RequestData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestData;
  return proto.SC2APIProtocol.RequestData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestData}
 */
proto.SC2APIProtocol.RequestData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAbilityId(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setUnitTypeId(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setUpgradeId(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setBuffId(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setEffectId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {boolean} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBool(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBool(
      4,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeBool(
      5,
      f
    );
  }
};


/**
 * optional bool ability_id = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestData.prototype.getAbilityId = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestData.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.RequestData.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestData.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool unit_type_id = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestData.prototype.getUnitTypeId = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestData.prototype.setUnitTypeId = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.RequestData.prototype.clearUnitTypeId = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestData.prototype.hasUnitTypeId = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool upgrade_id = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestData.prototype.getUpgradeId = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestData.prototype.setUpgradeId = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.RequestData.prototype.clearUpgradeId = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestData.prototype.hasUpgradeId = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bool buff_id = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestData.prototype.getBuffId = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestData.prototype.setBuffId = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.RequestData.prototype.clearBuffId = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestData.prototype.hasBuffId = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bool effect_id = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestData.prototype.getEffectId = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestData.prototype.setEffectId = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.RequestData.prototype.clearEffectId = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestData.prototype.hasEffectId = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ResponseData.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseData.displayName = 'proto.SC2APIProtocol.ResponseData';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ResponseData.repeatedFields_ = [1,2,3,4,5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseData.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseData.toObject = function(includeInstance, msg) {
  var f, obj = {
    abilitiesList: jspb.Message.toObjectList(msg.getAbilitiesList(),
    s2clientprotocol_data_pb.AbilityData.toObject, includeInstance),
    unitsList: jspb.Message.toObjectList(msg.getUnitsList(),
    s2clientprotocol_data_pb.UnitTypeData.toObject, includeInstance),
    upgradesList: jspb.Message.toObjectList(msg.getUpgradesList(),
    s2clientprotocol_data_pb.UpgradeData.toObject, includeInstance),
    buffsList: jspb.Message.toObjectList(msg.getBuffsList(),
    s2clientprotocol_data_pb.BuffData.toObject, includeInstance),
    effectsList: jspb.Message.toObjectList(msg.getEffectsList(),
    s2clientprotocol_data_pb.EffectData.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseData}
 */
proto.SC2APIProtocol.ResponseData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseData;
  return proto.SC2APIProtocol.ResponseData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseData}
 */
proto.SC2APIProtocol.ResponseData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_data_pb.AbilityData;
      reader.readMessage(value,s2clientprotocol_data_pb.AbilityData.deserializeBinaryFromReader);
      msg.addAbilities(value);
      break;
    case 2:
      var value = new s2clientprotocol_data_pb.UnitTypeData;
      reader.readMessage(value,s2clientprotocol_data_pb.UnitTypeData.deserializeBinaryFromReader);
      msg.addUnits(value);
      break;
    case 3:
      var value = new s2clientprotocol_data_pb.UpgradeData;
      reader.readMessage(value,s2clientprotocol_data_pb.UpgradeData.deserializeBinaryFromReader);
      msg.addUpgrades(value);
      break;
    case 4:
      var value = new s2clientprotocol_data_pb.BuffData;
      reader.readMessage(value,s2clientprotocol_data_pb.BuffData.deserializeBinaryFromReader);
      msg.addBuffs(value);
      break;
    case 5:
      var value = new s2clientprotocol_data_pb.EffectData;
      reader.readMessage(value,s2clientprotocol_data_pb.EffectData.deserializeBinaryFromReader);
      msg.addEffects(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAbilitiesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      s2clientprotocol_data_pb.AbilityData.serializeBinaryToWriter
    );
  }
  f = message.getUnitsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      s2clientprotocol_data_pb.UnitTypeData.serializeBinaryToWriter
    );
  }
  f = message.getUpgradesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      s2clientprotocol_data_pb.UpgradeData.serializeBinaryToWriter
    );
  }
  f = message.getBuffsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      s2clientprotocol_data_pb.BuffData.serializeBinaryToWriter
    );
  }
  f = message.getEffectsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      s2clientprotocol_data_pb.EffectData.serializeBinaryToWriter
    );
  }
};


/**
 * repeated AbilityData abilities = 1;
 * @return {!Array.<!proto.SC2APIProtocol.AbilityData>}
 */
proto.SC2APIProtocol.ResponseData.prototype.getAbilitiesList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.AbilityData>} */ (
    jspb.Message.getRepeatedWrapperField(this, s2clientprotocol_data_pb.AbilityData, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.AbilityData>} value */
proto.SC2APIProtocol.ResponseData.prototype.setAbilitiesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.AbilityData=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.AbilityData}
 */
proto.SC2APIProtocol.ResponseData.prototype.addAbilities = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.AbilityData, opt_index);
};


proto.SC2APIProtocol.ResponseData.prototype.clearAbilitiesList = function() {
  this.setAbilitiesList([]);
};


/**
 * repeated UnitTypeData units = 2;
 * @return {!Array.<!proto.SC2APIProtocol.UnitTypeData>}
 */
proto.SC2APIProtocol.ResponseData.prototype.getUnitsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.UnitTypeData>} */ (
    jspb.Message.getRepeatedWrapperField(this, s2clientprotocol_data_pb.UnitTypeData, 2));
};


/** @param {!Array.<!proto.SC2APIProtocol.UnitTypeData>} value */
proto.SC2APIProtocol.ResponseData.prototype.setUnitsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.SC2APIProtocol.UnitTypeData=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.UnitTypeData}
 */
proto.SC2APIProtocol.ResponseData.prototype.addUnits = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.SC2APIProtocol.UnitTypeData, opt_index);
};


proto.SC2APIProtocol.ResponseData.prototype.clearUnitsList = function() {
  this.setUnitsList([]);
};


/**
 * repeated UpgradeData upgrades = 3;
 * @return {!Array.<!proto.SC2APIProtocol.UpgradeData>}
 */
proto.SC2APIProtocol.ResponseData.prototype.getUpgradesList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.UpgradeData>} */ (
    jspb.Message.getRepeatedWrapperField(this, s2clientprotocol_data_pb.UpgradeData, 3));
};


/** @param {!Array.<!proto.SC2APIProtocol.UpgradeData>} value */
proto.SC2APIProtocol.ResponseData.prototype.setUpgradesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.SC2APIProtocol.UpgradeData=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.UpgradeData}
 */
proto.SC2APIProtocol.ResponseData.prototype.addUpgrades = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.SC2APIProtocol.UpgradeData, opt_index);
};


proto.SC2APIProtocol.ResponseData.prototype.clearUpgradesList = function() {
  this.setUpgradesList([]);
};


/**
 * repeated BuffData buffs = 4;
 * @return {!Array.<!proto.SC2APIProtocol.BuffData>}
 */
proto.SC2APIProtocol.ResponseData.prototype.getBuffsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.BuffData>} */ (
    jspb.Message.getRepeatedWrapperField(this, s2clientprotocol_data_pb.BuffData, 4));
};


/** @param {!Array.<!proto.SC2APIProtocol.BuffData>} value */
proto.SC2APIProtocol.ResponseData.prototype.setBuffsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.SC2APIProtocol.BuffData=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.BuffData}
 */
proto.SC2APIProtocol.ResponseData.prototype.addBuffs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.SC2APIProtocol.BuffData, opt_index);
};


proto.SC2APIProtocol.ResponseData.prototype.clearBuffsList = function() {
  this.setBuffsList([]);
};


/**
 * repeated EffectData effects = 5;
 * @return {!Array.<!proto.SC2APIProtocol.EffectData>}
 */
proto.SC2APIProtocol.ResponseData.prototype.getEffectsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.EffectData>} */ (
    jspb.Message.getRepeatedWrapperField(this, s2clientprotocol_data_pb.EffectData, 5));
};


/** @param {!Array.<!proto.SC2APIProtocol.EffectData>} value */
proto.SC2APIProtocol.ResponseData.prototype.setEffectsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.SC2APIProtocol.EffectData=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.EffectData}
 */
proto.SC2APIProtocol.ResponseData.prototype.addEffects = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.SC2APIProtocol.EffectData, opt_index);
};


proto.SC2APIProtocol.ResponseData.prototype.clearEffectsList = function() {
  this.setEffectsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestSaveReplay = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestSaveReplay, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestSaveReplay.displayName = 'proto.SC2APIProtocol.RequestSaveReplay';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestSaveReplay.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestSaveReplay.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestSaveReplay} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestSaveReplay.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestSaveReplay}
 */
proto.SC2APIProtocol.RequestSaveReplay.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestSaveReplay;
  return proto.SC2APIProtocol.RequestSaveReplay.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestSaveReplay} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestSaveReplay}
 */
proto.SC2APIProtocol.RequestSaveReplay.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestSaveReplay.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestSaveReplay.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestSaveReplay} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestSaveReplay.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseSaveReplay = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseSaveReplay, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseSaveReplay.displayName = 'proto.SC2APIProtocol.ResponseSaveReplay';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseSaveReplay.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseSaveReplay.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseSaveReplay} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseSaveReplay.toObject = function(includeInstance, msg) {
  var f, obj = {
    data: msg.getData_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseSaveReplay}
 */
proto.SC2APIProtocol.ResponseSaveReplay.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseSaveReplay;
  return proto.SC2APIProtocol.ResponseSaveReplay.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseSaveReplay} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseSaveReplay}
 */
proto.SC2APIProtocol.ResponseSaveReplay.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseSaveReplay.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseSaveReplay.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseSaveReplay} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseSaveReplay.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes data = 1;
 * @return {!(string|Uint8Array)}
 */
proto.SC2APIProtocol.ResponseSaveReplay.prototype.getData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes data = 1;
 * This is a type-conversion wrapper around `getData()`
 * @return {string}
 */
proto.SC2APIProtocol.ResponseSaveReplay.prototype.getData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getData()));
};


/**
 * optional bytes data = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getData()`
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseSaveReplay.prototype.getData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getData()));
};


/** @param {!(string|Uint8Array)} value */
proto.SC2APIProtocol.ResponseSaveReplay.prototype.setData = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponseSaveReplay.prototype.clearData = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseSaveReplay.prototype.hasData = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestReplayInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.SC2APIProtocol.RequestReplayInfo.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.RequestReplayInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestReplayInfo.displayName = 'proto.SC2APIProtocol.RequestReplayInfo';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.RequestReplayInfo.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.RequestReplayInfo.ReplayCase = {
  REPLAY_NOT_SET: 0,
  REPLAY_PATH: 1,
  REPLAY_DATA: 2
};

/**
 * @return {proto.SC2APIProtocol.RequestReplayInfo.ReplayCase}
 */
proto.SC2APIProtocol.RequestReplayInfo.prototype.getReplayCase = function() {
  return /** @type {proto.SC2APIProtocol.RequestReplayInfo.ReplayCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.RequestReplayInfo.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestReplayInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestReplayInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestReplayInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestReplayInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    replayPath: jspb.Message.getField(msg, 1),
    replayData: msg.getReplayData_asB64(),
    downloadData: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestReplayInfo}
 */
proto.SC2APIProtocol.RequestReplayInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestReplayInfo;
  return proto.SC2APIProtocol.RequestReplayInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestReplayInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestReplayInfo}
 */
proto.SC2APIProtocol.RequestReplayInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setReplayPath(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setReplayData(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDownloadData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestReplayInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestReplayInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestReplayInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestReplayInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
};


/**
 * optional string replay_path = 1;
 * @return {string}
 */
proto.SC2APIProtocol.RequestReplayInfo.prototype.getReplayPath = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.RequestReplayInfo.prototype.setReplayPath = function(value) {
  jspb.Message.setOneofField(this, 1, proto.SC2APIProtocol.RequestReplayInfo.oneofGroups_[0], value);
};


proto.SC2APIProtocol.RequestReplayInfo.prototype.clearReplayPath = function() {
  jspb.Message.setOneofField(this, 1, proto.SC2APIProtocol.RequestReplayInfo.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestReplayInfo.prototype.hasReplayPath = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes replay_data = 2;
 * @return {!(string|Uint8Array)}
 */
proto.SC2APIProtocol.RequestReplayInfo.prototype.getReplayData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes replay_data = 2;
 * This is a type-conversion wrapper around `getReplayData()`
 * @return {string}
 */
proto.SC2APIProtocol.RequestReplayInfo.prototype.getReplayData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getReplayData()));
};


/**
 * optional bytes replay_data = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getReplayData()`
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestReplayInfo.prototype.getReplayData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getReplayData()));
};


/** @param {!(string|Uint8Array)} value */
proto.SC2APIProtocol.RequestReplayInfo.prototype.setReplayData = function(value) {
  jspb.Message.setOneofField(this, 2, proto.SC2APIProtocol.RequestReplayInfo.oneofGroups_[0], value);
};


proto.SC2APIProtocol.RequestReplayInfo.prototype.clearReplayData = function() {
  jspb.Message.setOneofField(this, 2, proto.SC2APIProtocol.RequestReplayInfo.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestReplayInfo.prototype.hasReplayData = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool download_data = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.RequestReplayInfo.prototype.getDownloadData = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.RequestReplayInfo.prototype.setDownloadData = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.RequestReplayInfo.prototype.clearDownloadData = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestReplayInfo.prototype.hasDownloadData = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.PlayerInfoExtra = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.PlayerInfoExtra, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.PlayerInfoExtra.displayName = 'proto.SC2APIProtocol.PlayerInfoExtra';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.PlayerInfoExtra.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.PlayerInfoExtra} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PlayerInfoExtra.toObject = function(includeInstance, msg) {
  var f, obj = {
    playerInfo: (f = msg.getPlayerInfo()) && proto.SC2APIProtocol.PlayerInfo.toObject(includeInstance, f),
    playerResult: (f = msg.getPlayerResult()) && proto.SC2APIProtocol.PlayerResult.toObject(includeInstance, f),
    playerMmr: jspb.Message.getField(msg, 3),
    playerApm: jspb.Message.getField(msg, 4)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.PlayerInfoExtra}
 */
proto.SC2APIProtocol.PlayerInfoExtra.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.PlayerInfoExtra;
  return proto.SC2APIProtocol.PlayerInfoExtra.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.PlayerInfoExtra} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.PlayerInfoExtra}
 */
proto.SC2APIProtocol.PlayerInfoExtra.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.PlayerInfo;
      reader.readMessage(value,proto.SC2APIProtocol.PlayerInfo.deserializeBinaryFromReader);
      msg.setPlayerInfo(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.PlayerResult;
      reader.readMessage(value,proto.SC2APIProtocol.PlayerResult.deserializeBinaryFromReader);
      msg.setPlayerResult(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setPlayerMmr(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setPlayerApm(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.PlayerInfoExtra.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.PlayerInfoExtra} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PlayerInfoExtra.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPlayerInfo();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.PlayerInfo.serializeBinaryToWriter
    );
  }
  f = message.getPlayerResult();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.SC2APIProtocol.PlayerResult.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeInt32(
      4,
      f
    );
  }
};


/**
 * optional PlayerInfo player_info = 1;
 * @return {?proto.SC2APIProtocol.PlayerInfo}
 */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.getPlayerInfo = function() {
  return /** @type{?proto.SC2APIProtocol.PlayerInfo} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.PlayerInfo, 1));
};


/** @param {?proto.SC2APIProtocol.PlayerInfo|undefined} value */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.setPlayerInfo = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.PlayerInfoExtra.prototype.clearPlayerInfo = function() {
  this.setPlayerInfo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.hasPlayerInfo = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional PlayerResult player_result = 2;
 * @return {?proto.SC2APIProtocol.PlayerResult}
 */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.getPlayerResult = function() {
  return /** @type{?proto.SC2APIProtocol.PlayerResult} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.PlayerResult, 2));
};


/** @param {?proto.SC2APIProtocol.PlayerResult|undefined} value */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.setPlayerResult = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.PlayerInfoExtra.prototype.clearPlayerResult = function() {
  this.setPlayerResult(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.hasPlayerResult = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional int32 player_mmr = 3;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.getPlayerMmr = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.setPlayerMmr = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.PlayerInfoExtra.prototype.clearPlayerMmr = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.hasPlayerMmr = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional int32 player_apm = 4;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.getPlayerApm = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.setPlayerApm = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.PlayerInfoExtra.prototype.clearPlayerApm = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerInfoExtra.prototype.hasPlayerApm = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseReplayInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ResponseReplayInfo.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseReplayInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseReplayInfo.displayName = 'proto.SC2APIProtocol.ResponseReplayInfo';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ResponseReplayInfo.repeatedFields_ = [3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseReplayInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseReplayInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseReplayInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    mapName: jspb.Message.getField(msg, 1),
    localMapPath: jspb.Message.getField(msg, 2),
    playerInfoList: jspb.Message.toObjectList(msg.getPlayerInfoList(),
    proto.SC2APIProtocol.PlayerInfoExtra.toObject, includeInstance),
    gameDurationLoops: jspb.Message.getField(msg, 4),
    gameDurationSeconds: jspb.Message.getOptionalFloatingPointField(msg, 5),
    gameVersion: jspb.Message.getField(msg, 6),
    dataVersion: jspb.Message.getField(msg, 11),
    dataBuild: jspb.Message.getField(msg, 7),
    baseBuild: jspb.Message.getField(msg, 8),
    error: jspb.Message.getField(msg, 9),
    errorDetails: jspb.Message.getField(msg, 10)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseReplayInfo}
 */
proto.SC2APIProtocol.ResponseReplayInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseReplayInfo;
  return proto.SC2APIProtocol.ResponseReplayInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseReplayInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseReplayInfo}
 */
proto.SC2APIProtocol.ResponseReplayInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMapName(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setLocalMapPath(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.PlayerInfoExtra;
      reader.readMessage(value,proto.SC2APIProtocol.PlayerInfoExtra.deserializeBinaryFromReader);
      msg.addPlayerInfo(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setGameDurationLoops(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setGameDurationSeconds(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setGameVersion(value);
      break;
    case 11:
      var value = /** @type {string} */ (reader.readString());
      msg.setDataVersion(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDataBuild(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBaseBuild(value);
      break;
    case 9:
      var value = /** @type {!proto.SC2APIProtocol.ResponseReplayInfo.Error} */ (reader.readEnum());
      msg.setError(value);
      break;
    case 10:
      var value = /** @type {string} */ (reader.readString());
      msg.setErrorDetails(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseReplayInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseReplayInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseReplayInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getPlayerInfoList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.SC2APIProtocol.PlayerInfoExtra.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeFloat(
      5,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeString(
      6,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 11));
  if (f != null) {
    writer.writeString(
      11,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeUint32(
      8,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.ResponseReplayInfo.Error} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeEnum(
      9,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeString(
      10,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.ResponseReplayInfo.Error = {
  MISSINGREPLAY: 1,
  INVALIDREPLAYPATH: 2,
  INVALIDREPLAYDATA: 3,
  PARSINGERROR: 4,
  DOWNLOADERROR: 5
};

/**
 * optional string map_name = 1;
 * @return {string}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.getMapName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.setMapName = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponseReplayInfo.prototype.clearMapName = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.hasMapName = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string local_map_path = 2;
 * @return {string}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.getLocalMapPath = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.setLocalMapPath = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ResponseReplayInfo.prototype.clearLocalMapPath = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.hasLocalMapPath = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * repeated PlayerInfoExtra player_info = 3;
 * @return {!Array.<!proto.SC2APIProtocol.PlayerInfoExtra>}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.getPlayerInfoList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.PlayerInfoExtra>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.PlayerInfoExtra, 3));
};


/** @param {!Array.<!proto.SC2APIProtocol.PlayerInfoExtra>} value */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.setPlayerInfoList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.SC2APIProtocol.PlayerInfoExtra=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.PlayerInfoExtra}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.addPlayerInfo = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.SC2APIProtocol.PlayerInfoExtra, opt_index);
};


proto.SC2APIProtocol.ResponseReplayInfo.prototype.clearPlayerInfoList = function() {
  this.setPlayerInfoList([]);
};


/**
 * optional uint32 game_duration_loops = 4;
 * @return {number}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.getGameDurationLoops = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.setGameDurationLoops = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.ResponseReplayInfo.prototype.clearGameDurationLoops = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.hasGameDurationLoops = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional float game_duration_seconds = 5;
 * @return {number}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.getGameDurationSeconds = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 5, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.setGameDurationSeconds = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.ResponseReplayInfo.prototype.clearGameDurationSeconds = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.hasGameDurationSeconds = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional string game_version = 6;
 * @return {string}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.getGameVersion = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.setGameVersion = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.ResponseReplayInfo.prototype.clearGameVersion = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.hasGameVersion = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional string data_version = 11;
 * @return {string}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.getDataVersion = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 11, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.setDataVersion = function(value) {
  jspb.Message.setField(this, 11, value);
};


proto.SC2APIProtocol.ResponseReplayInfo.prototype.clearDataVersion = function() {
  jspb.Message.setField(this, 11, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.hasDataVersion = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional uint32 data_build = 7;
 * @return {number}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.getDataBuild = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.setDataBuild = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.ResponseReplayInfo.prototype.clearDataBuild = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.hasDataBuild = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional uint32 base_build = 8;
 * @return {number}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.getBaseBuild = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.setBaseBuild = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.SC2APIProtocol.ResponseReplayInfo.prototype.clearBaseBuild = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.hasBaseBuild = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional Error error = 9;
 * @return {!proto.SC2APIProtocol.ResponseReplayInfo.Error}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.getError = function() {
  return /** @type {!proto.SC2APIProtocol.ResponseReplayInfo.Error} */ (jspb.Message.getFieldWithDefault(this, 9, 1));
};


/** @param {!proto.SC2APIProtocol.ResponseReplayInfo.Error} value */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.setError = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.SC2APIProtocol.ResponseReplayInfo.prototype.clearError = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.hasError = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional string error_details = 10;
 * @return {string}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.getErrorDetails = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 10, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.setErrorDetails = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.SC2APIProtocol.ResponseReplayInfo.prototype.clearErrorDetails = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseReplayInfo.prototype.hasErrorDetails = function() {
  return jspb.Message.getField(this, 10) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestAvailableMaps = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestAvailableMaps, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestAvailableMaps.displayName = 'proto.SC2APIProtocol.RequestAvailableMaps';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestAvailableMaps.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestAvailableMaps.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestAvailableMaps} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestAvailableMaps.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestAvailableMaps}
 */
proto.SC2APIProtocol.RequestAvailableMaps.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestAvailableMaps;
  return proto.SC2APIProtocol.RequestAvailableMaps.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestAvailableMaps} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestAvailableMaps}
 */
proto.SC2APIProtocol.RequestAvailableMaps.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestAvailableMaps.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestAvailableMaps.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestAvailableMaps} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestAvailableMaps.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseAvailableMaps = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ResponseAvailableMaps.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseAvailableMaps, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseAvailableMaps.displayName = 'proto.SC2APIProtocol.ResponseAvailableMaps';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ResponseAvailableMaps.repeatedFields_ = [1,2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseAvailableMaps.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseAvailableMaps.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseAvailableMaps} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseAvailableMaps.toObject = function(includeInstance, msg) {
  var f, obj = {
    localMapPathsList: jspb.Message.getRepeatedField(msg, 1),
    battlenetMapNamesList: jspb.Message.getRepeatedField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseAvailableMaps}
 */
proto.SC2APIProtocol.ResponseAvailableMaps.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseAvailableMaps;
  return proto.SC2APIProtocol.ResponseAvailableMaps.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseAvailableMaps} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseAvailableMaps}
 */
proto.SC2APIProtocol.ResponseAvailableMaps.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.addLocalMapPaths(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.addBattlenetMapNames(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseAvailableMaps.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseAvailableMaps.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseAvailableMaps} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseAvailableMaps.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLocalMapPathsList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      1,
      f
    );
  }
  f = message.getBattlenetMapNamesList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      2,
      f
    );
  }
};


/**
 * repeated string local_map_paths = 1;
 * @return {!Array.<string>}
 */
proto.SC2APIProtocol.ResponseAvailableMaps.prototype.getLocalMapPathsList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array.<string>} value */
proto.SC2APIProtocol.ResponseAvailableMaps.prototype.setLocalMapPathsList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.ResponseAvailableMaps.prototype.addLocalMapPaths = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.SC2APIProtocol.ResponseAvailableMaps.prototype.clearLocalMapPathsList = function() {
  this.setLocalMapPathsList([]);
};


/**
 * repeated string battlenet_map_names = 2;
 * @return {!Array.<string>}
 */
proto.SC2APIProtocol.ResponseAvailableMaps.prototype.getBattlenetMapNamesList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 2));
};


/** @param {!Array.<string>} value */
proto.SC2APIProtocol.ResponseAvailableMaps.prototype.setBattlenetMapNamesList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.ResponseAvailableMaps.prototype.addBattlenetMapNames = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.SC2APIProtocol.ResponseAvailableMaps.prototype.clearBattlenetMapNamesList = function() {
  this.setBattlenetMapNamesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestSaveMap = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestSaveMap, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestSaveMap.displayName = 'proto.SC2APIProtocol.RequestSaveMap';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestSaveMap.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestSaveMap.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestSaveMap} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestSaveMap.toObject = function(includeInstance, msg) {
  var f, obj = {
    mapPath: jspb.Message.getField(msg, 1),
    mapData: msg.getMapData_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestSaveMap}
 */
proto.SC2APIProtocol.RequestSaveMap.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestSaveMap;
  return proto.SC2APIProtocol.RequestSaveMap.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestSaveMap} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestSaveMap}
 */
proto.SC2APIProtocol.RequestSaveMap.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMapPath(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMapData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestSaveMap.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestSaveMap.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestSaveMap} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestSaveMap.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional string map_path = 1;
 * @return {string}
 */
proto.SC2APIProtocol.RequestSaveMap.prototype.getMapPath = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.RequestSaveMap.prototype.setMapPath = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.RequestSaveMap.prototype.clearMapPath = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestSaveMap.prototype.hasMapPath = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes map_data = 2;
 * @return {!(string|Uint8Array)}
 */
proto.SC2APIProtocol.RequestSaveMap.prototype.getMapData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes map_data = 2;
 * This is a type-conversion wrapper around `getMapData()`
 * @return {string}
 */
proto.SC2APIProtocol.RequestSaveMap.prototype.getMapData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMapData()));
};


/**
 * optional bytes map_data = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMapData()`
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestSaveMap.prototype.getMapData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMapData()));
};


/** @param {!(string|Uint8Array)} value */
proto.SC2APIProtocol.RequestSaveMap.prototype.setMapData = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.RequestSaveMap.prototype.clearMapData = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.RequestSaveMap.prototype.hasMapData = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseSaveMap = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseSaveMap, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseSaveMap.displayName = 'proto.SC2APIProtocol.ResponseSaveMap';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseSaveMap.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseSaveMap.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseSaveMap} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseSaveMap.toObject = function(includeInstance, msg) {
  var f, obj = {
    error: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseSaveMap}
 */
proto.SC2APIProtocol.ResponseSaveMap.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseSaveMap;
  return proto.SC2APIProtocol.ResponseSaveMap.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseSaveMap} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseSaveMap}
 */
proto.SC2APIProtocol.ResponseSaveMap.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.ResponseSaveMap.Error} */ (reader.readEnum());
      msg.setError(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseSaveMap.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseSaveMap.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseSaveMap} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseSaveMap.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.ResponseSaveMap.Error} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.ResponseSaveMap.Error = {
  INVALIDMAPDATA: 1
};

/**
 * optional Error error = 1;
 * @return {!proto.SC2APIProtocol.ResponseSaveMap.Error}
 */
proto.SC2APIProtocol.ResponseSaveMap.prototype.getError = function() {
  return /** @type {!proto.SC2APIProtocol.ResponseSaveMap.Error} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.ResponseSaveMap.Error} value */
proto.SC2APIProtocol.ResponseSaveMap.prototype.setError = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponseSaveMap.prototype.clearError = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponseSaveMap.prototype.hasError = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestPing = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.RequestPing, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestPing.displayName = 'proto.SC2APIProtocol.RequestPing';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestPing.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestPing.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestPing} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestPing.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestPing}
 */
proto.SC2APIProtocol.RequestPing.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestPing;
  return proto.SC2APIProtocol.RequestPing.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestPing} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestPing}
 */
proto.SC2APIProtocol.RequestPing.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestPing.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestPing.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestPing} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestPing.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponsePing = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponsePing, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponsePing.displayName = 'proto.SC2APIProtocol.ResponsePing';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponsePing.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponsePing.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponsePing} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponsePing.toObject = function(includeInstance, msg) {
  var f, obj = {
    gameVersion: jspb.Message.getField(msg, 1),
    dataVersion: jspb.Message.getField(msg, 2),
    dataBuild: jspb.Message.getField(msg, 3),
    baseBuild: jspb.Message.getField(msg, 4)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponsePing}
 */
proto.SC2APIProtocol.ResponsePing.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponsePing;
  return proto.SC2APIProtocol.ResponsePing.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponsePing} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponsePing}
 */
proto.SC2APIProtocol.ResponsePing.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setGameVersion(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDataVersion(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDataBuild(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBaseBuild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponsePing.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponsePing.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponsePing} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponsePing.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
};


/**
 * optional string game_version = 1;
 * @return {string}
 */
proto.SC2APIProtocol.ResponsePing.prototype.getGameVersion = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponsePing.prototype.setGameVersion = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ResponsePing.prototype.clearGameVersion = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponsePing.prototype.hasGameVersion = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string data_version = 2;
 * @return {string}
 */
proto.SC2APIProtocol.ResponsePing.prototype.getDataVersion = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ResponsePing.prototype.setDataVersion = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ResponsePing.prototype.clearDataVersion = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponsePing.prototype.hasDataVersion = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 data_build = 3;
 * @return {number}
 */
proto.SC2APIProtocol.ResponsePing.prototype.getDataBuild = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ResponsePing.prototype.setDataBuild = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.ResponsePing.prototype.clearDataBuild = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponsePing.prototype.hasDataBuild = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional uint32 base_build = 4;
 * @return {number}
 */
proto.SC2APIProtocol.ResponsePing.prototype.getBaseBuild = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ResponsePing.prototype.setBaseBuild = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.ResponsePing.prototype.clearBaseBuild = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ResponsePing.prototype.hasBaseBuild = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.RequestDebug = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.RequestDebug.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.RequestDebug, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.RequestDebug.displayName = 'proto.SC2APIProtocol.RequestDebug';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.RequestDebug.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.RequestDebug.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.RequestDebug.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.RequestDebug} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestDebug.toObject = function(includeInstance, msg) {
  var f, obj = {
    debugList: jspb.Message.toObjectList(msg.getDebugList(),
    s2clientprotocol_debug_pb.DebugCommand.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.RequestDebug}
 */
proto.SC2APIProtocol.RequestDebug.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.RequestDebug;
  return proto.SC2APIProtocol.RequestDebug.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.RequestDebug} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.RequestDebug}
 */
proto.SC2APIProtocol.RequestDebug.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_debug_pb.DebugCommand;
      reader.readMessage(value,s2clientprotocol_debug_pb.DebugCommand.deserializeBinaryFromReader);
      msg.addDebug(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.RequestDebug.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.RequestDebug.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.RequestDebug} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.RequestDebug.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDebugList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      s2clientprotocol_debug_pb.DebugCommand.serializeBinaryToWriter
    );
  }
};


/**
 * repeated DebugCommand debug = 1;
 * @return {!Array.<!proto.SC2APIProtocol.DebugCommand>}
 */
proto.SC2APIProtocol.RequestDebug.prototype.getDebugList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.DebugCommand>} */ (
    jspb.Message.getRepeatedWrapperField(this, s2clientprotocol_debug_pb.DebugCommand, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.DebugCommand>} value */
proto.SC2APIProtocol.RequestDebug.prototype.setDebugList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.DebugCommand=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.DebugCommand}
 */
proto.SC2APIProtocol.RequestDebug.prototype.addDebug = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.DebugCommand, opt_index);
};


proto.SC2APIProtocol.RequestDebug.prototype.clearDebugList = function() {
  this.setDebugList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ResponseDebug = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ResponseDebug, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ResponseDebug.displayName = 'proto.SC2APIProtocol.ResponseDebug';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ResponseDebug.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ResponseDebug.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ResponseDebug} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseDebug.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ResponseDebug}
 */
proto.SC2APIProtocol.ResponseDebug.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ResponseDebug;
  return proto.SC2APIProtocol.ResponseDebug.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ResponseDebug} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ResponseDebug}
 */
proto.SC2APIProtocol.ResponseDebug.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ResponseDebug.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ResponseDebug.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ResponseDebug} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ResponseDebug.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.PlayerSetup = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.PlayerSetup, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.PlayerSetup.displayName = 'proto.SC2APIProtocol.PlayerSetup';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.PlayerSetup.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.PlayerSetup.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.PlayerSetup} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PlayerSetup.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getField(msg, 1),
    race: jspb.Message.getField(msg, 2),
    difficulty: jspb.Message.getField(msg, 3),
    playerName: jspb.Message.getField(msg, 4),
    aiBuild: jspb.Message.getField(msg, 5)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.PlayerSetup}
 */
proto.SC2APIProtocol.PlayerSetup.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.PlayerSetup;
  return proto.SC2APIProtocol.PlayerSetup.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.PlayerSetup} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.PlayerSetup}
 */
proto.SC2APIProtocol.PlayerSetup.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.PlayerType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {!proto.SC2APIProtocol.Race} */ (reader.readEnum());
      msg.setRace(value);
      break;
    case 3:
      var value = /** @type {!proto.SC2APIProtocol.Difficulty} */ (reader.readEnum());
      msg.setDifficulty(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setPlayerName(value);
      break;
    case 5:
      var value = /** @type {!proto.SC2APIProtocol.AIBuild} */ (reader.readEnum());
      msg.setAiBuild(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.PlayerSetup.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.PlayerSetup.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.PlayerSetup} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PlayerSetup.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.PlayerType} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.Race} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.Difficulty} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeEnum(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.AIBuild} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeEnum(
      5,
      f
    );
  }
};


/**
 * optional PlayerType type = 1;
 * @return {!proto.SC2APIProtocol.PlayerType}
 */
proto.SC2APIProtocol.PlayerSetup.prototype.getType = function() {
  return /** @type {!proto.SC2APIProtocol.PlayerType} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.PlayerType} value */
proto.SC2APIProtocol.PlayerSetup.prototype.setType = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.PlayerSetup.prototype.clearType = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerSetup.prototype.hasType = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Race race = 2;
 * @return {!proto.SC2APIProtocol.Race}
 */
proto.SC2APIProtocol.PlayerSetup.prototype.getRace = function() {
  return /** @type {!proto.SC2APIProtocol.Race} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {!proto.SC2APIProtocol.Race} value */
proto.SC2APIProtocol.PlayerSetup.prototype.setRace = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.PlayerSetup.prototype.clearRace = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerSetup.prototype.hasRace = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Difficulty difficulty = 3;
 * @return {!proto.SC2APIProtocol.Difficulty}
 */
proto.SC2APIProtocol.PlayerSetup.prototype.getDifficulty = function() {
  return /** @type {!proto.SC2APIProtocol.Difficulty} */ (jspb.Message.getFieldWithDefault(this, 3, 1));
};


/** @param {!proto.SC2APIProtocol.Difficulty} value */
proto.SC2APIProtocol.PlayerSetup.prototype.setDifficulty = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.PlayerSetup.prototype.clearDifficulty = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerSetup.prototype.hasDifficulty = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional string player_name = 4;
 * @return {string}
 */
proto.SC2APIProtocol.PlayerSetup.prototype.getPlayerName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.PlayerSetup.prototype.setPlayerName = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.PlayerSetup.prototype.clearPlayerName = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerSetup.prototype.hasPlayerName = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional AIBuild ai_build = 5;
 * @return {!proto.SC2APIProtocol.AIBuild}
 */
proto.SC2APIProtocol.PlayerSetup.prototype.getAiBuild = function() {
  return /** @type {!proto.SC2APIProtocol.AIBuild} */ (jspb.Message.getFieldWithDefault(this, 5, 1));
};


/** @param {!proto.SC2APIProtocol.AIBuild} value */
proto.SC2APIProtocol.PlayerSetup.prototype.setAiBuild = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.PlayerSetup.prototype.clearAiBuild = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerSetup.prototype.hasAiBuild = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.SpatialCameraSetup = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.SpatialCameraSetup, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.SpatialCameraSetup.displayName = 'proto.SC2APIProtocol.SpatialCameraSetup';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.SpatialCameraSetup.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.SpatialCameraSetup} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.SpatialCameraSetup.toObject = function(includeInstance, msg) {
  var f, obj = {
    resolution: (f = msg.getResolution()) && s2clientprotocol_common_pb.Size2DI.toObject(includeInstance, f),
    minimapResolution: (f = msg.getMinimapResolution()) && s2clientprotocol_common_pb.Size2DI.toObject(includeInstance, f),
    width: jspb.Message.getOptionalFloatingPointField(msg, 1),
    cropToPlayableArea: jspb.Message.getField(msg, 4),
    allowCheatingLayers: jspb.Message.getField(msg, 5)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.SpatialCameraSetup}
 */
proto.SC2APIProtocol.SpatialCameraSetup.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.SpatialCameraSetup;
  return proto.SC2APIProtocol.SpatialCameraSetup.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.SpatialCameraSetup} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.SpatialCameraSetup}
 */
proto.SC2APIProtocol.SpatialCameraSetup.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 2:
      var value = new s2clientprotocol_common_pb.Size2DI;
      reader.readMessage(value,s2clientprotocol_common_pb.Size2DI.deserializeBinaryFromReader);
      msg.setResolution(value);
      break;
    case 3:
      var value = new s2clientprotocol_common_pb.Size2DI;
      reader.readMessage(value,s2clientprotocol_common_pb.Size2DI.deserializeBinaryFromReader);
      msg.setMinimapResolution(value);
      break;
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setWidth(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setCropToPlayableArea(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAllowCheatingLayers(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.SpatialCameraSetup.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.SpatialCameraSetup} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.SpatialCameraSetup.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getResolution();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.Size2DI.serializeBinaryToWriter
    );
  }
  f = message.getMinimapResolution();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      s2clientprotocol_common_pb.Size2DI.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBool(
      4,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeBool(
      5,
      f
    );
  }
};


/**
 * optional Size2DI resolution = 2;
 * @return {?proto.SC2APIProtocol.Size2DI}
 */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.getResolution = function() {
  return /** @type{?proto.SC2APIProtocol.Size2DI} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Size2DI, 2));
};


/** @param {?proto.SC2APIProtocol.Size2DI|undefined} value */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.setResolution = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.SpatialCameraSetup.prototype.clearResolution = function() {
  this.setResolution(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.hasResolution = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Size2DI minimap_resolution = 3;
 * @return {?proto.SC2APIProtocol.Size2DI}
 */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.getMinimapResolution = function() {
  return /** @type{?proto.SC2APIProtocol.Size2DI} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Size2DI, 3));
};


/** @param {?proto.SC2APIProtocol.Size2DI|undefined} value */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.setMinimapResolution = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.SpatialCameraSetup.prototype.clearMinimapResolution = function() {
  this.setMinimapResolution(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.hasMinimapResolution = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional float width = 1;
 * @return {number}
 */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.getWidth = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 1, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.setWidth = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.SpatialCameraSetup.prototype.clearWidth = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.hasWidth = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool crop_to_playable_area = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.getCropToPlayableArea = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.setCropToPlayableArea = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.SpatialCameraSetup.prototype.clearCropToPlayableArea = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.hasCropToPlayableArea = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bool allow_cheating_layers = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.getAllowCheatingLayers = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.setAllowCheatingLayers = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.SpatialCameraSetup.prototype.clearAllowCheatingLayers = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.SpatialCameraSetup.prototype.hasAllowCheatingLayers = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.InterfaceOptions = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.InterfaceOptions, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.InterfaceOptions.displayName = 'proto.SC2APIProtocol.InterfaceOptions';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.InterfaceOptions.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.InterfaceOptions} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.InterfaceOptions.toObject = function(includeInstance, msg) {
  var f, obj = {
    raw: jspb.Message.getField(msg, 1),
    score: jspb.Message.getField(msg, 2),
    featureLayer: (f = msg.getFeatureLayer()) && proto.SC2APIProtocol.SpatialCameraSetup.toObject(includeInstance, f),
    render: (f = msg.getRender()) && proto.SC2APIProtocol.SpatialCameraSetup.toObject(includeInstance, f),
    showCloaked: jspb.Message.getField(msg, 5),
    showBurrowedShadows: jspb.Message.getField(msg, 9),
    showPlaceholders: jspb.Message.getField(msg, 8),
    rawAffectsSelection: jspb.Message.getField(msg, 6),
    rawCropToPlayableArea: jspb.Message.getField(msg, 7)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.InterfaceOptions}
 */
proto.SC2APIProtocol.InterfaceOptions.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.InterfaceOptions;
  return proto.SC2APIProtocol.InterfaceOptions.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.InterfaceOptions} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.InterfaceOptions}
 */
proto.SC2APIProtocol.InterfaceOptions.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRaw(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setScore(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.SpatialCameraSetup;
      reader.readMessage(value,proto.SC2APIProtocol.SpatialCameraSetup.deserializeBinaryFromReader);
      msg.setFeatureLayer(value);
      break;
    case 4:
      var value = new proto.SC2APIProtocol.SpatialCameraSetup;
      reader.readMessage(value,proto.SC2APIProtocol.SpatialCameraSetup.deserializeBinaryFromReader);
      msg.setRender(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setShowCloaked(value);
      break;
    case 9:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setShowBurrowedShadows(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setShowPlaceholders(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRawAffectsSelection(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRawCropToPlayableArea(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.InterfaceOptions.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.InterfaceOptions} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.InterfaceOptions.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {boolean} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBool(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getFeatureLayer();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.SpatialCameraSetup.serializeBinaryToWriter
    );
  }
  f = message.getRender();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.SC2APIProtocol.SpatialCameraSetup.serializeBinaryToWriter
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeBool(
      5,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeBool(
      9,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeBool(
      8,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeBool(
      6,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeBool(
      7,
      f
    );
  }
};


/**
 * optional bool raw = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.getRaw = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.InterfaceOptions.prototype.setRaw = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.InterfaceOptions.prototype.clearRaw = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.hasRaw = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool score = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.getScore = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.InterfaceOptions.prototype.setScore = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.InterfaceOptions.prototype.clearScore = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.hasScore = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional SpatialCameraSetup feature_layer = 3;
 * @return {?proto.SC2APIProtocol.SpatialCameraSetup}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.getFeatureLayer = function() {
  return /** @type{?proto.SC2APIProtocol.SpatialCameraSetup} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.SpatialCameraSetup, 3));
};


/** @param {?proto.SC2APIProtocol.SpatialCameraSetup|undefined} value */
proto.SC2APIProtocol.InterfaceOptions.prototype.setFeatureLayer = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.InterfaceOptions.prototype.clearFeatureLayer = function() {
  this.setFeatureLayer(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.hasFeatureLayer = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional SpatialCameraSetup render = 4;
 * @return {?proto.SC2APIProtocol.SpatialCameraSetup}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.getRender = function() {
  return /** @type{?proto.SC2APIProtocol.SpatialCameraSetup} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.SpatialCameraSetup, 4));
};


/** @param {?proto.SC2APIProtocol.SpatialCameraSetup|undefined} value */
proto.SC2APIProtocol.InterfaceOptions.prototype.setRender = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.SC2APIProtocol.InterfaceOptions.prototype.clearRender = function() {
  this.setRender(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.hasRender = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bool show_cloaked = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.getShowCloaked = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.InterfaceOptions.prototype.setShowCloaked = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.InterfaceOptions.prototype.clearShowCloaked = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.hasShowCloaked = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional bool show_burrowed_shadows = 9;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.getShowBurrowedShadows = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 9, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.InterfaceOptions.prototype.setShowBurrowedShadows = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.SC2APIProtocol.InterfaceOptions.prototype.clearShowBurrowedShadows = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.hasShowBurrowedShadows = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional bool show_placeholders = 8;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.getShowPlaceholders = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 8, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.InterfaceOptions.prototype.setShowPlaceholders = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.SC2APIProtocol.InterfaceOptions.prototype.clearShowPlaceholders = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.hasShowPlaceholders = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional bool raw_affects_selection = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.getRawAffectsSelection = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.InterfaceOptions.prototype.setRawAffectsSelection = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.InterfaceOptions.prototype.clearRawAffectsSelection = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.hasRawAffectsSelection = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional bool raw_crop_to_playable_area = 7;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.getRawCropToPlayableArea = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 7, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.InterfaceOptions.prototype.setRawCropToPlayableArea = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.InterfaceOptions.prototype.clearRawCropToPlayableArea = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.InterfaceOptions.prototype.hasRawCropToPlayableArea = function() {
  return jspb.Message.getField(this, 7) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.PlayerInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.PlayerInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.PlayerInfo.displayName = 'proto.SC2APIProtocol.PlayerInfo';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.PlayerInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.PlayerInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PlayerInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    playerId: jspb.Message.getField(msg, 1),
    type: jspb.Message.getField(msg, 2),
    raceRequested: jspb.Message.getField(msg, 3),
    raceActual: jspb.Message.getField(msg, 4),
    difficulty: jspb.Message.getField(msg, 5),
    aiBuild: jspb.Message.getField(msg, 7),
    playerName: jspb.Message.getField(msg, 6)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.PlayerInfo}
 */
proto.SC2APIProtocol.PlayerInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.PlayerInfo;
  return proto.SC2APIProtocol.PlayerInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.PlayerInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.PlayerInfo}
 */
proto.SC2APIProtocol.PlayerInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPlayerId(value);
      break;
    case 2:
      var value = /** @type {!proto.SC2APIProtocol.PlayerType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 3:
      var value = /** @type {!proto.SC2APIProtocol.Race} */ (reader.readEnum());
      msg.setRaceRequested(value);
      break;
    case 4:
      var value = /** @type {!proto.SC2APIProtocol.Race} */ (reader.readEnum());
      msg.setRaceActual(value);
      break;
    case 5:
      var value = /** @type {!proto.SC2APIProtocol.Difficulty} */ (reader.readEnum());
      msg.setDifficulty(value);
      break;
    case 7:
      var value = /** @type {!proto.SC2APIProtocol.AIBuild} */ (reader.readEnum());
      msg.setAiBuild(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setPlayerName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.PlayerInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.PlayerInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PlayerInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.PlayerType} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.Race} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeEnum(
      3,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.Race} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeEnum(
      4,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.Difficulty} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeEnum(
      5,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.AIBuild} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeEnum(
      7,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeString(
      6,
      f
    );
  }
};


/**
 * optional uint32 player_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.getPlayerId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerInfo.prototype.setPlayerId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.PlayerInfo.prototype.clearPlayerId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.hasPlayerId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional PlayerType type = 2;
 * @return {!proto.SC2APIProtocol.PlayerType}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.getType = function() {
  return /** @type {!proto.SC2APIProtocol.PlayerType} */ (jspb.Message.getFieldWithDefault(this, 2, 1));
};


/** @param {!proto.SC2APIProtocol.PlayerType} value */
proto.SC2APIProtocol.PlayerInfo.prototype.setType = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.PlayerInfo.prototype.clearType = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.hasType = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Race race_requested = 3;
 * @return {!proto.SC2APIProtocol.Race}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.getRaceRequested = function() {
  return /** @type {!proto.SC2APIProtocol.Race} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {!proto.SC2APIProtocol.Race} value */
proto.SC2APIProtocol.PlayerInfo.prototype.setRaceRequested = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.PlayerInfo.prototype.clearRaceRequested = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.hasRaceRequested = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Race race_actual = 4;
 * @return {!proto.SC2APIProtocol.Race}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.getRaceActual = function() {
  return /** @type {!proto.SC2APIProtocol.Race} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {!proto.SC2APIProtocol.Race} value */
proto.SC2APIProtocol.PlayerInfo.prototype.setRaceActual = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.PlayerInfo.prototype.clearRaceActual = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.hasRaceActual = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional Difficulty difficulty = 5;
 * @return {!proto.SC2APIProtocol.Difficulty}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.getDifficulty = function() {
  return /** @type {!proto.SC2APIProtocol.Difficulty} */ (jspb.Message.getFieldWithDefault(this, 5, 1));
};


/** @param {!proto.SC2APIProtocol.Difficulty} value */
proto.SC2APIProtocol.PlayerInfo.prototype.setDifficulty = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.PlayerInfo.prototype.clearDifficulty = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.hasDifficulty = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional AIBuild ai_build = 7;
 * @return {!proto.SC2APIProtocol.AIBuild}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.getAiBuild = function() {
  return /** @type {!proto.SC2APIProtocol.AIBuild} */ (jspb.Message.getFieldWithDefault(this, 7, 1));
};


/** @param {!proto.SC2APIProtocol.AIBuild} value */
proto.SC2APIProtocol.PlayerInfo.prototype.setAiBuild = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.PlayerInfo.prototype.clearAiBuild = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.hasAiBuild = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional string player_name = 6;
 * @return {string}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.getPlayerName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.PlayerInfo.prototype.setPlayerName = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.PlayerInfo.prototype.clearPlayerName = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerInfo.prototype.hasPlayerName = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.PlayerCommon = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.PlayerCommon, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.PlayerCommon.displayName = 'proto.SC2APIProtocol.PlayerCommon';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.PlayerCommon.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.PlayerCommon} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PlayerCommon.toObject = function(includeInstance, msg) {
  var f, obj = {
    playerId: jspb.Message.getField(msg, 1),
    minerals: jspb.Message.getField(msg, 2),
    vespene: jspb.Message.getField(msg, 3),
    foodCap: jspb.Message.getField(msg, 4),
    foodUsed: jspb.Message.getField(msg, 5),
    foodArmy: jspb.Message.getField(msg, 6),
    foodWorkers: jspb.Message.getField(msg, 7),
    idleWorkerCount: jspb.Message.getField(msg, 8),
    armyCount: jspb.Message.getField(msg, 9),
    warpGateCount: jspb.Message.getField(msg, 10),
    larvaCount: jspb.Message.getField(msg, 11)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.PlayerCommon}
 */
proto.SC2APIProtocol.PlayerCommon.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.PlayerCommon;
  return proto.SC2APIProtocol.PlayerCommon.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.PlayerCommon} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.PlayerCommon}
 */
proto.SC2APIProtocol.PlayerCommon.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPlayerId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMinerals(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVespene(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setFoodCap(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setFoodUsed(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setFoodArmy(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setFoodWorkers(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIdleWorkerCount(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setArmyCount(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setWarpGateCount(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLarvaCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.PlayerCommon.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.PlayerCommon} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PlayerCommon.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeUint32(
      8,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeUint32(
      10,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 11));
  if (f != null) {
    writer.writeUint32(
      11,
      f
    );
  }
};


/**
 * optional uint32 player_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.getPlayerId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerCommon.prototype.setPlayerId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.PlayerCommon.prototype.clearPlayerId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.hasPlayerId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 minerals = 2;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.getMinerals = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerCommon.prototype.setMinerals = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.PlayerCommon.prototype.clearMinerals = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.hasMinerals = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 vespene = 3;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.getVespene = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerCommon.prototype.setVespene = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.PlayerCommon.prototype.clearVespene = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.hasVespene = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional uint32 food_cap = 4;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.getFoodCap = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerCommon.prototype.setFoodCap = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.PlayerCommon.prototype.clearFoodCap = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.hasFoodCap = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional uint32 food_used = 5;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.getFoodUsed = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerCommon.prototype.setFoodUsed = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.PlayerCommon.prototype.clearFoodUsed = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.hasFoodUsed = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional uint32 food_army = 6;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.getFoodArmy = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerCommon.prototype.setFoodArmy = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.PlayerCommon.prototype.clearFoodArmy = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.hasFoodArmy = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional uint32 food_workers = 7;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.getFoodWorkers = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerCommon.prototype.setFoodWorkers = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.PlayerCommon.prototype.clearFoodWorkers = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.hasFoodWorkers = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional uint32 idle_worker_count = 8;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.getIdleWorkerCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerCommon.prototype.setIdleWorkerCount = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.SC2APIProtocol.PlayerCommon.prototype.clearIdleWorkerCount = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.hasIdleWorkerCount = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional uint32 army_count = 9;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.getArmyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerCommon.prototype.setArmyCount = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.SC2APIProtocol.PlayerCommon.prototype.clearArmyCount = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.hasArmyCount = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional uint32 warp_gate_count = 10;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.getWarpGateCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerCommon.prototype.setWarpGateCount = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.SC2APIProtocol.PlayerCommon.prototype.clearWarpGateCount = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.hasWarpGateCount = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional uint32 larva_count = 11;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.getLarvaCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerCommon.prototype.setLarvaCount = function(value) {
  jspb.Message.setField(this, 11, value);
};


proto.SC2APIProtocol.PlayerCommon.prototype.clearLarvaCount = function() {
  jspb.Message.setField(this, 11, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerCommon.prototype.hasLarvaCount = function() {
  return jspb.Message.getField(this, 11) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Observation = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.Observation.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.Observation, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Observation.displayName = 'proto.SC2APIProtocol.Observation';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.Observation.repeatedFields_ = [10,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Observation.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Observation.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Observation} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Observation.toObject = function(includeInstance, msg) {
  var f, obj = {
    gameLoop: jspb.Message.getField(msg, 9),
    playerCommon: (f = msg.getPlayerCommon()) && proto.SC2APIProtocol.PlayerCommon.toObject(includeInstance, f),
    alertsList: jspb.Message.getRepeatedField(msg, 10),
    abilitiesList: jspb.Message.toObjectList(msg.getAbilitiesList(),
    s2clientprotocol_common_pb.AvailableAbility.toObject, includeInstance),
    score: (f = msg.getScore()) && s2clientprotocol_score_pb.Score.toObject(includeInstance, f),
    rawData: (f = msg.getRawData()) && s2clientprotocol_raw_pb.ObservationRaw.toObject(includeInstance, f),
    featureLayerData: (f = msg.getFeatureLayerData()) && s2clientprotocol_spatial_pb.ObservationFeatureLayer.toObject(includeInstance, f),
    renderData: (f = msg.getRenderData()) && s2clientprotocol_spatial_pb.ObservationRender.toObject(includeInstance, f),
    uiData: (f = msg.getUiData()) && s2clientprotocol_ui_pb.ObservationUI.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Observation}
 */
proto.SC2APIProtocol.Observation.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Observation;
  return proto.SC2APIProtocol.Observation.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Observation} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Observation}
 */
proto.SC2APIProtocol.Observation.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setGameLoop(value);
      break;
    case 1:
      var value = new proto.SC2APIProtocol.PlayerCommon;
      reader.readMessage(value,proto.SC2APIProtocol.PlayerCommon.deserializeBinaryFromReader);
      msg.setPlayerCommon(value);
      break;
    case 10:
      var value = /** @type {!proto.SC2APIProtocol.Alert} */ (reader.readEnum());
      msg.addAlerts(value);
      break;
    case 3:
      var value = new s2clientprotocol_common_pb.AvailableAbility;
      reader.readMessage(value,s2clientprotocol_common_pb.AvailableAbility.deserializeBinaryFromReader);
      msg.addAbilities(value);
      break;
    case 4:
      var value = new s2clientprotocol_score_pb.Score;
      reader.readMessage(value,s2clientprotocol_score_pb.Score.deserializeBinaryFromReader);
      msg.setScore(value);
      break;
    case 5:
      var value = new s2clientprotocol_raw_pb.ObservationRaw;
      reader.readMessage(value,s2clientprotocol_raw_pb.ObservationRaw.deserializeBinaryFromReader);
      msg.setRawData(value);
      break;
    case 6:
      var value = new s2clientprotocol_spatial_pb.ObservationFeatureLayer;
      reader.readMessage(value,s2clientprotocol_spatial_pb.ObservationFeatureLayer.deserializeBinaryFromReader);
      msg.setFeatureLayerData(value);
      break;
    case 7:
      var value = new s2clientprotocol_spatial_pb.ObservationRender;
      reader.readMessage(value,s2clientprotocol_spatial_pb.ObservationRender.deserializeBinaryFromReader);
      msg.setRenderData(value);
      break;
    case 8:
      var value = new s2clientprotocol_ui_pb.ObservationUI;
      reader.readMessage(value,s2clientprotocol_ui_pb.ObservationUI.deserializeBinaryFromReader);
      msg.setUiData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Observation.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Observation.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Observation} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Observation.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = message.getPlayerCommon();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.PlayerCommon.serializeBinaryToWriter
    );
  }
  f = message.getAlertsList();
  if (f.length > 0) {
    writer.writeRepeatedEnum(
      10,
      f
    );
  }
  f = message.getAbilitiesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      s2clientprotocol_common_pb.AvailableAbility.serializeBinaryToWriter
    );
  }
  f = message.getScore();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      s2clientprotocol_score_pb.Score.serializeBinaryToWriter
    );
  }
  f = message.getRawData();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      s2clientprotocol_raw_pb.ObservationRaw.serializeBinaryToWriter
    );
  }
  f = message.getFeatureLayerData();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      s2clientprotocol_spatial_pb.ObservationFeatureLayer.serializeBinaryToWriter
    );
  }
  f = message.getRenderData();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      s2clientprotocol_spatial_pb.ObservationRender.serializeBinaryToWriter
    );
  }
  f = message.getUiData();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      s2clientprotocol_ui_pb.ObservationUI.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint32 game_loop = 9;
 * @return {number}
 */
proto.SC2APIProtocol.Observation.prototype.getGameLoop = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Observation.prototype.setGameLoop = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.SC2APIProtocol.Observation.prototype.clearGameLoop = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Observation.prototype.hasGameLoop = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional PlayerCommon player_common = 1;
 * @return {?proto.SC2APIProtocol.PlayerCommon}
 */
proto.SC2APIProtocol.Observation.prototype.getPlayerCommon = function() {
  return /** @type{?proto.SC2APIProtocol.PlayerCommon} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.PlayerCommon, 1));
};


/** @param {?proto.SC2APIProtocol.PlayerCommon|undefined} value */
proto.SC2APIProtocol.Observation.prototype.setPlayerCommon = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.Observation.prototype.clearPlayerCommon = function() {
  this.setPlayerCommon(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Observation.prototype.hasPlayerCommon = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated Alert alerts = 10;
 * @return {!Array.<!proto.SC2APIProtocol.Alert>}
 */
proto.SC2APIProtocol.Observation.prototype.getAlertsList = function() {
  return /** @type {!Array.<!proto.SC2APIProtocol.Alert>} */ (jspb.Message.getRepeatedField(this, 10));
};


/** @param {!Array.<!proto.SC2APIProtocol.Alert>} value */
proto.SC2APIProtocol.Observation.prototype.setAlertsList = function(value) {
  jspb.Message.setField(this, 10, value || []);
};


/**
 * @param {!proto.SC2APIProtocol.Alert} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.Observation.prototype.addAlerts = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 10, value, opt_index);
};


proto.SC2APIProtocol.Observation.prototype.clearAlertsList = function() {
  this.setAlertsList([]);
};


/**
 * repeated AvailableAbility abilities = 3;
 * @return {!Array.<!proto.SC2APIProtocol.AvailableAbility>}
 */
proto.SC2APIProtocol.Observation.prototype.getAbilitiesList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.AvailableAbility>} */ (
    jspb.Message.getRepeatedWrapperField(this, s2clientprotocol_common_pb.AvailableAbility, 3));
};


/** @param {!Array.<!proto.SC2APIProtocol.AvailableAbility>} value */
proto.SC2APIProtocol.Observation.prototype.setAbilitiesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.SC2APIProtocol.AvailableAbility=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.AvailableAbility}
 */
proto.SC2APIProtocol.Observation.prototype.addAbilities = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.SC2APIProtocol.AvailableAbility, opt_index);
};


proto.SC2APIProtocol.Observation.prototype.clearAbilitiesList = function() {
  this.setAbilitiesList([]);
};


/**
 * optional Score score = 4;
 * @return {?proto.SC2APIProtocol.Score}
 */
proto.SC2APIProtocol.Observation.prototype.getScore = function() {
  return /** @type{?proto.SC2APIProtocol.Score} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_score_pb.Score, 4));
};


/** @param {?proto.SC2APIProtocol.Score|undefined} value */
proto.SC2APIProtocol.Observation.prototype.setScore = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.SC2APIProtocol.Observation.prototype.clearScore = function() {
  this.setScore(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Observation.prototype.hasScore = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional ObservationRaw raw_data = 5;
 * @return {?proto.SC2APIProtocol.ObservationRaw}
 */
proto.SC2APIProtocol.Observation.prototype.getRawData = function() {
  return /** @type{?proto.SC2APIProtocol.ObservationRaw} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_raw_pb.ObservationRaw, 5));
};


/** @param {?proto.SC2APIProtocol.ObservationRaw|undefined} value */
proto.SC2APIProtocol.Observation.prototype.setRawData = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.SC2APIProtocol.Observation.prototype.clearRawData = function() {
  this.setRawData(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Observation.prototype.hasRawData = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional ObservationFeatureLayer feature_layer_data = 6;
 * @return {?proto.SC2APIProtocol.ObservationFeatureLayer}
 */
proto.SC2APIProtocol.Observation.prototype.getFeatureLayerData = function() {
  return /** @type{?proto.SC2APIProtocol.ObservationFeatureLayer} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_spatial_pb.ObservationFeatureLayer, 6));
};


/** @param {?proto.SC2APIProtocol.ObservationFeatureLayer|undefined} value */
proto.SC2APIProtocol.Observation.prototype.setFeatureLayerData = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


proto.SC2APIProtocol.Observation.prototype.clearFeatureLayerData = function() {
  this.setFeatureLayerData(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Observation.prototype.hasFeatureLayerData = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional ObservationRender render_data = 7;
 * @return {?proto.SC2APIProtocol.ObservationRender}
 */
proto.SC2APIProtocol.Observation.prototype.getRenderData = function() {
  return /** @type{?proto.SC2APIProtocol.ObservationRender} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_spatial_pb.ObservationRender, 7));
};


/** @param {?proto.SC2APIProtocol.ObservationRender|undefined} value */
proto.SC2APIProtocol.Observation.prototype.setRenderData = function(value) {
  jspb.Message.setWrapperField(this, 7, value);
};


proto.SC2APIProtocol.Observation.prototype.clearRenderData = function() {
  this.setRenderData(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Observation.prototype.hasRenderData = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional ObservationUI ui_data = 8;
 * @return {?proto.SC2APIProtocol.ObservationUI}
 */
proto.SC2APIProtocol.Observation.prototype.getUiData = function() {
  return /** @type{?proto.SC2APIProtocol.ObservationUI} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_ui_pb.ObservationUI, 8));
};


/** @param {?proto.SC2APIProtocol.ObservationUI|undefined} value */
proto.SC2APIProtocol.Observation.prototype.setUiData = function(value) {
  jspb.Message.setWrapperField(this, 8, value);
};


proto.SC2APIProtocol.Observation.prototype.clearUiData = function() {
  this.setUiData(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Observation.prototype.hasUiData = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Action = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.Action, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Action.displayName = 'proto.SC2APIProtocol.Action';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Action.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Action.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Action} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Action.toObject = function(includeInstance, msg) {
  var f, obj = {
    actionRaw: (f = msg.getActionRaw()) && s2clientprotocol_raw_pb.ActionRaw.toObject(includeInstance, f),
    actionFeatureLayer: (f = msg.getActionFeatureLayer()) && s2clientprotocol_spatial_pb.ActionSpatial.toObject(includeInstance, f),
    actionRender: (f = msg.getActionRender()) && s2clientprotocol_spatial_pb.ActionSpatial.toObject(includeInstance, f),
    actionUi: (f = msg.getActionUi()) && s2clientprotocol_ui_pb.ActionUI.toObject(includeInstance, f),
    actionChat: (f = msg.getActionChat()) && proto.SC2APIProtocol.ActionChat.toObject(includeInstance, f),
    gameLoop: jspb.Message.getField(msg, 7)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Action}
 */
proto.SC2APIProtocol.Action.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Action;
  return proto.SC2APIProtocol.Action.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Action} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Action}
 */
proto.SC2APIProtocol.Action.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_raw_pb.ActionRaw;
      reader.readMessage(value,s2clientprotocol_raw_pb.ActionRaw.deserializeBinaryFromReader);
      msg.setActionRaw(value);
      break;
    case 2:
      var value = new s2clientprotocol_spatial_pb.ActionSpatial;
      reader.readMessage(value,s2clientprotocol_spatial_pb.ActionSpatial.deserializeBinaryFromReader);
      msg.setActionFeatureLayer(value);
      break;
    case 3:
      var value = new s2clientprotocol_spatial_pb.ActionSpatial;
      reader.readMessage(value,s2clientprotocol_spatial_pb.ActionSpatial.deserializeBinaryFromReader);
      msg.setActionRender(value);
      break;
    case 4:
      var value = new s2clientprotocol_ui_pb.ActionUI;
      reader.readMessage(value,s2clientprotocol_ui_pb.ActionUI.deserializeBinaryFromReader);
      msg.setActionUi(value);
      break;
    case 6:
      var value = new proto.SC2APIProtocol.ActionChat;
      reader.readMessage(value,proto.SC2APIProtocol.ActionChat.deserializeBinaryFromReader);
      msg.setActionChat(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setGameLoop(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Action.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Action.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Action} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Action.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getActionRaw();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_raw_pb.ActionRaw.serializeBinaryToWriter
    );
  }
  f = message.getActionFeatureLayer();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_spatial_pb.ActionSpatial.serializeBinaryToWriter
    );
  }
  f = message.getActionRender();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      s2clientprotocol_spatial_pb.ActionSpatial.serializeBinaryToWriter
    );
  }
  f = message.getActionUi();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      s2clientprotocol_ui_pb.ActionUI.serializeBinaryToWriter
    );
  }
  f = message.getActionChat();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.SC2APIProtocol.ActionChat.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeUint32(
      7,
      f
    );
  }
};


/**
 * optional ActionRaw action_raw = 1;
 * @return {?proto.SC2APIProtocol.ActionRaw}
 */
proto.SC2APIProtocol.Action.prototype.getActionRaw = function() {
  return /** @type{?proto.SC2APIProtocol.ActionRaw} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_raw_pb.ActionRaw, 1));
};


/** @param {?proto.SC2APIProtocol.ActionRaw|undefined} value */
proto.SC2APIProtocol.Action.prototype.setActionRaw = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.Action.prototype.clearActionRaw = function() {
  this.setActionRaw(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Action.prototype.hasActionRaw = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ActionSpatial action_feature_layer = 2;
 * @return {?proto.SC2APIProtocol.ActionSpatial}
 */
proto.SC2APIProtocol.Action.prototype.getActionFeatureLayer = function() {
  return /** @type{?proto.SC2APIProtocol.ActionSpatial} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_spatial_pb.ActionSpatial, 2));
};


/** @param {?proto.SC2APIProtocol.ActionSpatial|undefined} value */
proto.SC2APIProtocol.Action.prototype.setActionFeatureLayer = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.Action.prototype.clearActionFeatureLayer = function() {
  this.setActionFeatureLayer(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Action.prototype.hasActionFeatureLayer = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ActionSpatial action_render = 3;
 * @return {?proto.SC2APIProtocol.ActionSpatial}
 */
proto.SC2APIProtocol.Action.prototype.getActionRender = function() {
  return /** @type{?proto.SC2APIProtocol.ActionSpatial} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_spatial_pb.ActionSpatial, 3));
};


/** @param {?proto.SC2APIProtocol.ActionSpatial|undefined} value */
proto.SC2APIProtocol.Action.prototype.setActionRender = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.Action.prototype.clearActionRender = function() {
  this.setActionRender(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Action.prototype.hasActionRender = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional ActionUI action_ui = 4;
 * @return {?proto.SC2APIProtocol.ActionUI}
 */
proto.SC2APIProtocol.Action.prototype.getActionUi = function() {
  return /** @type{?proto.SC2APIProtocol.ActionUI} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_ui_pb.ActionUI, 4));
};


/** @param {?proto.SC2APIProtocol.ActionUI|undefined} value */
proto.SC2APIProtocol.Action.prototype.setActionUi = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.SC2APIProtocol.Action.prototype.clearActionUi = function() {
  this.setActionUi(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Action.prototype.hasActionUi = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional ActionChat action_chat = 6;
 * @return {?proto.SC2APIProtocol.ActionChat}
 */
proto.SC2APIProtocol.Action.prototype.getActionChat = function() {
  return /** @type{?proto.SC2APIProtocol.ActionChat} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionChat, 6));
};


/** @param {?proto.SC2APIProtocol.ActionChat|undefined} value */
proto.SC2APIProtocol.Action.prototype.setActionChat = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


proto.SC2APIProtocol.Action.prototype.clearActionChat = function() {
  this.setActionChat(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Action.prototype.hasActionChat = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional uint32 game_loop = 7;
 * @return {number}
 */
proto.SC2APIProtocol.Action.prototype.getGameLoop = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Action.prototype.setGameLoop = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.Action.prototype.clearGameLoop = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Action.prototype.hasGameLoop = function() {
  return jspb.Message.getField(this, 7) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionChat = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionChat, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionChat.displayName = 'proto.SC2APIProtocol.ActionChat';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionChat.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionChat.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionChat} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionChat.toObject = function(includeInstance, msg) {
  var f, obj = {
    channel: jspb.Message.getField(msg, 1),
    message: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionChat}
 */
proto.SC2APIProtocol.ActionChat.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionChat;
  return proto.SC2APIProtocol.ActionChat.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionChat} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionChat}
 */
proto.SC2APIProtocol.ActionChat.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.ActionChat.Channel} */ (reader.readEnum());
      msg.setChannel(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionChat.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionChat.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionChat} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionChat.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.ActionChat.Channel} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.ActionChat.Channel = {
  BROADCAST: 1,
  TEAM: 2
};

/**
 * optional Channel channel = 1;
 * @return {!proto.SC2APIProtocol.ActionChat.Channel}
 */
proto.SC2APIProtocol.ActionChat.prototype.getChannel = function() {
  return /** @type {!proto.SC2APIProtocol.ActionChat.Channel} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.ActionChat.Channel} value */
proto.SC2APIProtocol.ActionChat.prototype.setChannel = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionChat.prototype.clearChannel = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionChat.prototype.hasChannel = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string message = 2;
 * @return {string}
 */
proto.SC2APIProtocol.ActionChat.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.SC2APIProtocol.ActionChat.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ActionChat.prototype.clearMessage = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionChat.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionError = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionError, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionError.displayName = 'proto.SC2APIProtocol.ActionError';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionError.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionError.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionError} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionError.toObject = function(includeInstance, msg) {
  var f, obj = {
    unitTag: jspb.Message.getField(msg, 1),
    abilityId: jspb.Message.getField(msg, 2),
    result: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionError}
 */
proto.SC2APIProtocol.ActionError.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionError;
  return proto.SC2APIProtocol.ActionError.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionError} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionError}
 */
proto.SC2APIProtocol.ActionError.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setUnitTag(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAbilityId(value);
      break;
    case 3:
      var value = /** @type {!proto.SC2APIProtocol.ActionResult} */ (reader.readEnum());
      msg.setResult(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionError.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionError.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionError} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionError.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.ActionResult} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeEnum(
      3,
      f
    );
  }
};


/**
 * optional uint64 unit_tag = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ActionError.prototype.getUnitTag = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionError.prototype.setUnitTag = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionError.prototype.clearUnitTag = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionError.prototype.hasUnitTag = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint64 ability_id = 2;
 * @return {number}
 */
proto.SC2APIProtocol.ActionError.prototype.getAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionError.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ActionError.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionError.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ActionResult result = 3;
 * @return {!proto.SC2APIProtocol.ActionResult}
 */
proto.SC2APIProtocol.ActionError.prototype.getResult = function() {
  return /** @type {!proto.SC2APIProtocol.ActionResult} */ (jspb.Message.getFieldWithDefault(this, 3, 1));
};


/** @param {!proto.SC2APIProtocol.ActionResult} value */
proto.SC2APIProtocol.ActionError.prototype.setResult = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.ActionError.prototype.clearResult = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionError.prototype.hasResult = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ObserverAction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.SC2APIProtocol.ObserverAction.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.ObserverAction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ObserverAction.displayName = 'proto.SC2APIProtocol.ObserverAction';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.ObserverAction.oneofGroups_ = [[1,2,3,4]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.ObserverAction.ActionCase = {
  ACTION_NOT_SET: 0,
  PLAYER_PERSPECTIVE: 1,
  CAMERA_MOVE: 2,
  CAMERA_FOLLOW_PLAYER: 3,
  CAMERA_FOLLOW_UNITS: 4
};

/**
 * @return {proto.SC2APIProtocol.ObserverAction.ActionCase}
 */
proto.SC2APIProtocol.ObserverAction.prototype.getActionCase = function() {
  return /** @type {proto.SC2APIProtocol.ObserverAction.ActionCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.ObserverAction.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ObserverAction.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ObserverAction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ObserverAction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ObserverAction.toObject = function(includeInstance, msg) {
  var f, obj = {
    playerPerspective: (f = msg.getPlayerPerspective()) && proto.SC2APIProtocol.ActionObserverPlayerPerspective.toObject(includeInstance, f),
    cameraMove: (f = msg.getCameraMove()) && proto.SC2APIProtocol.ActionObserverCameraMove.toObject(includeInstance, f),
    cameraFollowPlayer: (f = msg.getCameraFollowPlayer()) && proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.toObject(includeInstance, f),
    cameraFollowUnits: (f = msg.getCameraFollowUnits()) && proto.SC2APIProtocol.ActionObserverCameraFollowUnits.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ObserverAction}
 */
proto.SC2APIProtocol.ObserverAction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ObserverAction;
  return proto.SC2APIProtocol.ObserverAction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ObserverAction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ObserverAction}
 */
proto.SC2APIProtocol.ObserverAction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.ActionObserverPlayerPerspective;
      reader.readMessage(value,proto.SC2APIProtocol.ActionObserverPlayerPerspective.deserializeBinaryFromReader);
      msg.setPlayerPerspective(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.ActionObserverCameraMove;
      reader.readMessage(value,proto.SC2APIProtocol.ActionObserverCameraMove.deserializeBinaryFromReader);
      msg.setCameraMove(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.ActionObserverCameraFollowPlayer;
      reader.readMessage(value,proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.deserializeBinaryFromReader);
      msg.setCameraFollowPlayer(value);
      break;
    case 4:
      var value = new proto.SC2APIProtocol.ActionObserverCameraFollowUnits;
      reader.readMessage(value,proto.SC2APIProtocol.ActionObserverCameraFollowUnits.deserializeBinaryFromReader);
      msg.setCameraFollowUnits(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ObserverAction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ObserverAction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ObserverAction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ObserverAction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPlayerPerspective();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.ActionObserverPlayerPerspective.serializeBinaryToWriter
    );
  }
  f = message.getCameraMove();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.SC2APIProtocol.ActionObserverCameraMove.serializeBinaryToWriter
    );
  }
  f = message.getCameraFollowPlayer();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.serializeBinaryToWriter
    );
  }
  f = message.getCameraFollowUnits();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.SC2APIProtocol.ActionObserverCameraFollowUnits.serializeBinaryToWriter
    );
  }
};


/**
 * optional ActionObserverPlayerPerspective player_perspective = 1;
 * @return {?proto.SC2APIProtocol.ActionObserverPlayerPerspective}
 */
proto.SC2APIProtocol.ObserverAction.prototype.getPlayerPerspective = function() {
  return /** @type{?proto.SC2APIProtocol.ActionObserverPlayerPerspective} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionObserverPlayerPerspective, 1));
};


/** @param {?proto.SC2APIProtocol.ActionObserverPlayerPerspective|undefined} value */
proto.SC2APIProtocol.ObserverAction.prototype.setPlayerPerspective = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.SC2APIProtocol.ObserverAction.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ObserverAction.prototype.clearPlayerPerspective = function() {
  this.setPlayerPerspective(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObserverAction.prototype.hasPlayerPerspective = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ActionObserverCameraMove camera_move = 2;
 * @return {?proto.SC2APIProtocol.ActionObserverCameraMove}
 */
proto.SC2APIProtocol.ObserverAction.prototype.getCameraMove = function() {
  return /** @type{?proto.SC2APIProtocol.ActionObserverCameraMove} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionObserverCameraMove, 2));
};


/** @param {?proto.SC2APIProtocol.ActionObserverCameraMove|undefined} value */
proto.SC2APIProtocol.ObserverAction.prototype.setCameraMove = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.SC2APIProtocol.ObserverAction.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ObserverAction.prototype.clearCameraMove = function() {
  this.setCameraMove(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObserverAction.prototype.hasCameraMove = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ActionObserverCameraFollowPlayer camera_follow_player = 3;
 * @return {?proto.SC2APIProtocol.ActionObserverCameraFollowPlayer}
 */
proto.SC2APIProtocol.ObserverAction.prototype.getCameraFollowPlayer = function() {
  return /** @type{?proto.SC2APIProtocol.ActionObserverCameraFollowPlayer} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionObserverCameraFollowPlayer, 3));
};


/** @param {?proto.SC2APIProtocol.ActionObserverCameraFollowPlayer|undefined} value */
proto.SC2APIProtocol.ObserverAction.prototype.setCameraFollowPlayer = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.SC2APIProtocol.ObserverAction.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ObserverAction.prototype.clearCameraFollowPlayer = function() {
  this.setCameraFollowPlayer(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObserverAction.prototype.hasCameraFollowPlayer = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional ActionObserverCameraFollowUnits camera_follow_units = 4;
 * @return {?proto.SC2APIProtocol.ActionObserverCameraFollowUnits}
 */
proto.SC2APIProtocol.ObserverAction.prototype.getCameraFollowUnits = function() {
  return /** @type{?proto.SC2APIProtocol.ActionObserverCameraFollowUnits} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionObserverCameraFollowUnits, 4));
};


/** @param {?proto.SC2APIProtocol.ActionObserverCameraFollowUnits|undefined} value */
proto.SC2APIProtocol.ObserverAction.prototype.setCameraFollowUnits = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.SC2APIProtocol.ObserverAction.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ObserverAction.prototype.clearCameraFollowUnits = function() {
  this.setCameraFollowUnits(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObserverAction.prototype.hasCameraFollowUnits = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionObserverPlayerPerspective = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionObserverPlayerPerspective, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionObserverPlayerPerspective.displayName = 'proto.SC2APIProtocol.ActionObserverPlayerPerspective';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionObserverPlayerPerspective.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionObserverPlayerPerspective.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionObserverPlayerPerspective} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionObserverPlayerPerspective.toObject = function(includeInstance, msg) {
  var f, obj = {
    playerId: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionObserverPlayerPerspective}
 */
proto.SC2APIProtocol.ActionObserverPlayerPerspective.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionObserverPlayerPerspective;
  return proto.SC2APIProtocol.ActionObserverPlayerPerspective.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionObserverPlayerPerspective} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionObserverPlayerPerspective}
 */
proto.SC2APIProtocol.ActionObserverPlayerPerspective.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPlayerId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionObserverPlayerPerspective.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionObserverPlayerPerspective.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionObserverPlayerPerspective} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionObserverPlayerPerspective.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 player_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ActionObserverPlayerPerspective.prototype.getPlayerId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionObserverPlayerPerspective.prototype.setPlayerId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionObserverPlayerPerspective.prototype.clearPlayerId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionObserverPlayerPerspective.prototype.hasPlayerId = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionObserverCameraMove = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionObserverCameraMove, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionObserverCameraMove.displayName = 'proto.SC2APIProtocol.ActionObserverCameraMove';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionObserverCameraMove.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionObserverCameraMove.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionObserverCameraMove} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionObserverCameraMove.toObject = function(includeInstance, msg) {
  var f, obj = {
    worldPos: (f = msg.getWorldPos()) && s2clientprotocol_common_pb.Point2D.toObject(includeInstance, f),
    distance: jspb.Message.getOptionalFloatingPointField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionObserverCameraMove}
 */
proto.SC2APIProtocol.ActionObserverCameraMove.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionObserverCameraMove;
  return proto.SC2APIProtocol.ActionObserverCameraMove.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionObserverCameraMove} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionObserverCameraMove}
 */
proto.SC2APIProtocol.ActionObserverCameraMove.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.Point2D;
      reader.readMessage(value,s2clientprotocol_common_pb.Point2D.deserializeBinaryFromReader);
      msg.setWorldPos(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setDistance(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionObserverCameraMove.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionObserverCameraMove.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionObserverCameraMove} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionObserverCameraMove.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWorldPos();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.Point2D.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
};


/**
 * optional Point2D world_pos = 1;
 * @return {?proto.SC2APIProtocol.Point2D}
 */
proto.SC2APIProtocol.ActionObserverCameraMove.prototype.getWorldPos = function() {
  return /** @type{?proto.SC2APIProtocol.Point2D} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.Point2D, 1));
};


/** @param {?proto.SC2APIProtocol.Point2D|undefined} value */
proto.SC2APIProtocol.ActionObserverCameraMove.prototype.setWorldPos = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.ActionObserverCameraMove.prototype.clearWorldPos = function() {
  this.setWorldPos(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionObserverCameraMove.prototype.hasWorldPos = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float distance = 2;
 * @return {number}
 */
proto.SC2APIProtocol.ActionObserverCameraMove.prototype.getDistance = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionObserverCameraMove.prototype.setDistance = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ActionObserverCameraMove.prototype.clearDistance = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionObserverCameraMove.prototype.hasDistance = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionObserverCameraFollowPlayer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionObserverCameraFollowPlayer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.displayName = 'proto.SC2APIProtocol.ActionObserverCameraFollowPlayer';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionObserverCameraFollowPlayer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.toObject = function(includeInstance, msg) {
  var f, obj = {
    playerId: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionObserverCameraFollowPlayer}
 */
proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionObserverCameraFollowPlayer;
  return proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionObserverCameraFollowPlayer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionObserverCameraFollowPlayer}
 */
proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPlayerId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionObserverCameraFollowPlayer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 player_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.prototype.getPlayerId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.prototype.setPlayerId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.prototype.clearPlayerId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionObserverCameraFollowPlayer.prototype.hasPlayerId = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionObserverCameraFollowUnits = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ActionObserverCameraFollowUnits.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ActionObserverCameraFollowUnits, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionObserverCameraFollowUnits.displayName = 'proto.SC2APIProtocol.ActionObserverCameraFollowUnits';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ActionObserverCameraFollowUnits.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionObserverCameraFollowUnits.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionObserverCameraFollowUnits.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionObserverCameraFollowUnits} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionObserverCameraFollowUnits.toObject = function(includeInstance, msg) {
  var f, obj = {
    unitTagsList: jspb.Message.getRepeatedField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionObserverCameraFollowUnits}
 */
proto.SC2APIProtocol.ActionObserverCameraFollowUnits.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionObserverCameraFollowUnits;
  return proto.SC2APIProtocol.ActionObserverCameraFollowUnits.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionObserverCameraFollowUnits} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionObserverCameraFollowUnits}
 */
proto.SC2APIProtocol.ActionObserverCameraFollowUnits.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.addUnitTags(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionObserverCameraFollowUnits.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionObserverCameraFollowUnits.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionObserverCameraFollowUnits} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionObserverCameraFollowUnits.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUnitTagsList();
  if (f.length > 0) {
    writer.writeRepeatedUint64(
      1,
      f
    );
  }
};


/**
 * repeated uint64 unit_tags = 1;
 * @return {!Array.<number>}
 */
proto.SC2APIProtocol.ActionObserverCameraFollowUnits.prototype.getUnitTagsList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array.<number>} value */
proto.SC2APIProtocol.ActionObserverCameraFollowUnits.prototype.setUnitTagsList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.ActionObserverCameraFollowUnits.prototype.addUnitTags = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.SC2APIProtocol.ActionObserverCameraFollowUnits.prototype.clearUnitTagsList = function() {
  this.setUnitTagsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.PlayerResult = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.PlayerResult, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.PlayerResult.displayName = 'proto.SC2APIProtocol.PlayerResult';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.PlayerResult.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.PlayerResult.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.PlayerResult} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PlayerResult.toObject = function(includeInstance, msg) {
  var f, obj = {
    playerId: jspb.Message.getField(msg, 1),
    result: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.PlayerResult}
 */
proto.SC2APIProtocol.PlayerResult.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.PlayerResult;
  return proto.SC2APIProtocol.PlayerResult.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.PlayerResult} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.PlayerResult}
 */
proto.SC2APIProtocol.PlayerResult.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPlayerId(value);
      break;
    case 2:
      var value = /** @type {!proto.SC2APIProtocol.Result} */ (reader.readEnum());
      msg.setResult(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.PlayerResult.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.PlayerResult.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.PlayerResult} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.PlayerResult.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {!proto.SC2APIProtocol.Result} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeEnum(
      2,
      f
    );
  }
};


/**
 * optional uint32 player_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.PlayerResult.prototype.getPlayerId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.PlayerResult.prototype.setPlayerId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.PlayerResult.prototype.clearPlayerId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerResult.prototype.hasPlayerId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Result result = 2;
 * @return {!proto.SC2APIProtocol.Result}
 */
proto.SC2APIProtocol.PlayerResult.prototype.getResult = function() {
  return /** @type {!proto.SC2APIProtocol.Result} */ (jspb.Message.getFieldWithDefault(this, 2, 1));
};


/** @param {!proto.SC2APIProtocol.Result} value */
proto.SC2APIProtocol.PlayerResult.prototype.setResult = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.PlayerResult.prototype.clearResult = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.PlayerResult.prototype.hasResult = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.Status = {
  LAUNCHED: 1,
  INIT_GAME: 2,
  IN_GAME: 3,
  IN_REPLAY: 4,
  ENDED: 5,
  QUIT: 6,
  UNKNOWN: 99
};

/**
 * @enum {number}
 */
proto.SC2APIProtocol.Difficulty = {
  VERYEASY: 1,
  EASY: 2,
  MEDIUM: 3,
  MEDIUMHARD: 4,
  HARD: 5,
  HARDER: 6,
  VERYHARD: 7,
  CHEATVISION: 8,
  CHEATMONEY: 9,
  CHEATINSANE: 10
};

/**
 * @enum {number}
 */
proto.SC2APIProtocol.PlayerType = {
  PARTICIPANT: 1,
  COMPUTER: 2,
  OBSERVER: 3
};

/**
 * @enum {number}
 */
proto.SC2APIProtocol.AIBuild = {
  RANDOMBUILD: 1,
  RUSH: 2,
  TIMING: 3,
  POWER: 4,
  MACRO: 5,
  AIR: 6
};

/**
 * @enum {number}
 */
proto.SC2APIProtocol.Alert = {
  ALERTERROR: 3,
  ADDONCOMPLETE: 4,
  BUILDINGCOMPLETE: 5,
  BUILDINGUNDERATTACK: 6,
  LARVAHATCHED: 7,
  MERGECOMPLETE: 8,
  MINERALSEXHAUSTED: 9,
  MORPHCOMPLETE: 10,
  MOTHERSHIPCOMPLETE: 11,
  MULEEXPIRED: 12,
  NUCLEARLAUNCHDETECTED: 1,
  NUKECOMPLETE: 13,
  NYDUSWORMDETECTED: 2,
  RESEARCHCOMPLETE: 14,
  TRAINERROR: 15,
  TRAINUNITCOMPLETE: 16,
  TRAINWORKERCOMPLETE: 17,
  TRANSFORMATIONCOMPLETE: 18,
  UNITUNDERATTACK: 19,
  UPGRADECOMPLETE: 20,
  VESPENEEXHAUSTED: 21,
  WARPINCOMPLETE: 22
};

/**
 * @enum {number}
 */
proto.SC2APIProtocol.Result = {
  VICTORY: 1,
  DEFEAT: 2,
  TIE: 3,
  UNDECIDED: 4
};

goog.object.extend(exports, proto.SC2APIProtocol);

},{"./common_pb.js":104,"./data_pb.js":105,"./debug_pb.js":106,"./error_pb.js":107,"./query_pb.js":108,"./raw_pb.js":109,"./score_pb.js":111,"./spatial_pb.js":112,"./ui_pb.js":113,"google-protobuf":68}],111:[function(require,module,exports){
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.SC2APIProtocol.CategoryScoreDetails', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Score', null, global);
goog.exportSymbol('proto.SC2APIProtocol.Score.ScoreType', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ScoreDetails', null, global);
goog.exportSymbol('proto.SC2APIProtocol.VitalScoreDetails', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.Score = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.Score, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.Score.displayName = 'proto.SC2APIProtocol.Score';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.Score.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.Score.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.Score} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Score.toObject = function(includeInstance, msg) {
  var f, obj = {
    scoreType: jspb.Message.getField(msg, 6),
    score: jspb.Message.getField(msg, 7),
    scoreDetails: (f = msg.getScoreDetails()) && proto.SC2APIProtocol.ScoreDetails.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.Score}
 */
proto.SC2APIProtocol.Score.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.Score;
  return proto.SC2APIProtocol.Score.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.Score} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.Score}
 */
proto.SC2APIProtocol.Score.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 6:
      var value = /** @type {!proto.SC2APIProtocol.Score.ScoreType} */ (reader.readEnum());
      msg.setScoreType(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setScore(value);
      break;
    case 8:
      var value = new proto.SC2APIProtocol.ScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.ScoreDetails.deserializeBinaryFromReader);
      msg.setScoreDetails(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.Score.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.Score.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.Score} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.Score.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.Score.ScoreType} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeEnum(
      6,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeInt32(
      7,
      f
    );
  }
  f = message.getScoreDetails();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.SC2APIProtocol.ScoreDetails.serializeBinaryToWriter
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.Score.ScoreType = {
  CURRICULUM: 1,
  MELEE: 2
};

/**
 * optional ScoreType score_type = 6;
 * @return {!proto.SC2APIProtocol.Score.ScoreType}
 */
proto.SC2APIProtocol.Score.prototype.getScoreType = function() {
  return /** @type {!proto.SC2APIProtocol.Score.ScoreType} */ (jspb.Message.getFieldWithDefault(this, 6, 1));
};


/** @param {!proto.SC2APIProtocol.Score.ScoreType} value */
proto.SC2APIProtocol.Score.prototype.setScoreType = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.Score.prototype.clearScoreType = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Score.prototype.hasScoreType = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional int32 score = 7;
 * @return {number}
 */
proto.SC2APIProtocol.Score.prototype.getScore = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.Score.prototype.setScore = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.Score.prototype.clearScore = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Score.prototype.hasScore = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional ScoreDetails score_details = 8;
 * @return {?proto.SC2APIProtocol.ScoreDetails}
 */
proto.SC2APIProtocol.Score.prototype.getScoreDetails = function() {
  return /** @type{?proto.SC2APIProtocol.ScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ScoreDetails, 8));
};


/** @param {?proto.SC2APIProtocol.ScoreDetails|undefined} value */
proto.SC2APIProtocol.Score.prototype.setScoreDetails = function(value) {
  jspb.Message.setWrapperField(this, 8, value);
};


proto.SC2APIProtocol.Score.prototype.clearScoreDetails = function() {
  this.setScoreDetails(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.Score.prototype.hasScoreDetails = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.CategoryScoreDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.CategoryScoreDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.CategoryScoreDetails.displayName = 'proto.SC2APIProtocol.CategoryScoreDetails';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.CategoryScoreDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.CategoryScoreDetails} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.CategoryScoreDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    none: jspb.Message.getOptionalFloatingPointField(msg, 1),
    army: jspb.Message.getOptionalFloatingPointField(msg, 2),
    economy: jspb.Message.getOptionalFloatingPointField(msg, 3),
    technology: jspb.Message.getOptionalFloatingPointField(msg, 4),
    upgrade: jspb.Message.getOptionalFloatingPointField(msg, 5)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.CategoryScoreDetails;
  return proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.CategoryScoreDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setNone(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setArmy(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setEconomy(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setTechnology(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setUpgrade(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.CategoryScoreDetails} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeFloat(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeFloat(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeFloat(
      5,
      f
    );
  }
};


/**
 * optional float none = 1;
 * @return {number}
 */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.getNone = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 1, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.setNone = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.CategoryScoreDetails.prototype.clearNone = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.hasNone = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float army = 2;
 * @return {number}
 */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.getArmy = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.setArmy = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.CategoryScoreDetails.prototype.clearArmy = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.hasArmy = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional float economy = 3;
 * @return {number}
 */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.getEconomy = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 3, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.setEconomy = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.CategoryScoreDetails.prototype.clearEconomy = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.hasEconomy = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional float technology = 4;
 * @return {number}
 */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.getTechnology = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 4, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.setTechnology = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.CategoryScoreDetails.prototype.clearTechnology = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.hasTechnology = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional float upgrade = 5;
 * @return {number}
 */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.getUpgrade = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 5, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.setUpgrade = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.CategoryScoreDetails.prototype.clearUpgrade = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.CategoryScoreDetails.prototype.hasUpgrade = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.VitalScoreDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.VitalScoreDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.VitalScoreDetails.displayName = 'proto.SC2APIProtocol.VitalScoreDetails';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.VitalScoreDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.VitalScoreDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.VitalScoreDetails} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.VitalScoreDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    life: jspb.Message.getOptionalFloatingPointField(msg, 1),
    shields: jspb.Message.getOptionalFloatingPointField(msg, 2),
    energy: jspb.Message.getOptionalFloatingPointField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.VitalScoreDetails}
 */
proto.SC2APIProtocol.VitalScoreDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.VitalScoreDetails;
  return proto.SC2APIProtocol.VitalScoreDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.VitalScoreDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.VitalScoreDetails}
 */
proto.SC2APIProtocol.VitalScoreDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setLife(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setShields(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setEnergy(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.VitalScoreDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.VitalScoreDetails.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.VitalScoreDetails} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.VitalScoreDetails.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeFloat(
      3,
      f
    );
  }
};


/**
 * optional float life = 1;
 * @return {number}
 */
proto.SC2APIProtocol.VitalScoreDetails.prototype.getLife = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 1, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.VitalScoreDetails.prototype.setLife = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.VitalScoreDetails.prototype.clearLife = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.VitalScoreDetails.prototype.hasLife = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float shields = 2;
 * @return {number}
 */
proto.SC2APIProtocol.VitalScoreDetails.prototype.getShields = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.VitalScoreDetails.prototype.setShields = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.VitalScoreDetails.prototype.clearShields = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.VitalScoreDetails.prototype.hasShields = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional float energy = 3;
 * @return {number}
 */
proto.SC2APIProtocol.VitalScoreDetails.prototype.getEnergy = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 3, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.VitalScoreDetails.prototype.setEnergy = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.VitalScoreDetails.prototype.clearEnergy = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.VitalScoreDetails.prototype.hasEnergy = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ScoreDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ScoreDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ScoreDetails.displayName = 'proto.SC2APIProtocol.ScoreDetails';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ScoreDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ScoreDetails} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ScoreDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    idleProductionTime: jspb.Message.getOptionalFloatingPointField(msg, 1),
    idleWorkerTime: jspb.Message.getOptionalFloatingPointField(msg, 2),
    totalValueUnits: jspb.Message.getOptionalFloatingPointField(msg, 3),
    totalValueStructures: jspb.Message.getOptionalFloatingPointField(msg, 4),
    killedValueUnits: jspb.Message.getOptionalFloatingPointField(msg, 5),
    killedValueStructures: jspb.Message.getOptionalFloatingPointField(msg, 6),
    collectedMinerals: jspb.Message.getOptionalFloatingPointField(msg, 7),
    collectedVespene: jspb.Message.getOptionalFloatingPointField(msg, 8),
    collectionRateMinerals: jspb.Message.getOptionalFloatingPointField(msg, 9),
    collectionRateVespene: jspb.Message.getOptionalFloatingPointField(msg, 10),
    spentMinerals: jspb.Message.getOptionalFloatingPointField(msg, 11),
    spentVespene: jspb.Message.getOptionalFloatingPointField(msg, 12),
    foodUsed: (f = msg.getFoodUsed()) && proto.SC2APIProtocol.CategoryScoreDetails.toObject(includeInstance, f),
    killedMinerals: (f = msg.getKilledMinerals()) && proto.SC2APIProtocol.CategoryScoreDetails.toObject(includeInstance, f),
    killedVespene: (f = msg.getKilledVespene()) && proto.SC2APIProtocol.CategoryScoreDetails.toObject(includeInstance, f),
    lostMinerals: (f = msg.getLostMinerals()) && proto.SC2APIProtocol.CategoryScoreDetails.toObject(includeInstance, f),
    lostVespene: (f = msg.getLostVespene()) && proto.SC2APIProtocol.CategoryScoreDetails.toObject(includeInstance, f),
    friendlyFireMinerals: (f = msg.getFriendlyFireMinerals()) && proto.SC2APIProtocol.CategoryScoreDetails.toObject(includeInstance, f),
    friendlyFireVespene: (f = msg.getFriendlyFireVespene()) && proto.SC2APIProtocol.CategoryScoreDetails.toObject(includeInstance, f),
    usedMinerals: (f = msg.getUsedMinerals()) && proto.SC2APIProtocol.CategoryScoreDetails.toObject(includeInstance, f),
    usedVespene: (f = msg.getUsedVespene()) && proto.SC2APIProtocol.CategoryScoreDetails.toObject(includeInstance, f),
    totalUsedMinerals: (f = msg.getTotalUsedMinerals()) && proto.SC2APIProtocol.CategoryScoreDetails.toObject(includeInstance, f),
    totalUsedVespene: (f = msg.getTotalUsedVespene()) && proto.SC2APIProtocol.CategoryScoreDetails.toObject(includeInstance, f),
    totalDamageDealt: (f = msg.getTotalDamageDealt()) && proto.SC2APIProtocol.VitalScoreDetails.toObject(includeInstance, f),
    totalDamageTaken: (f = msg.getTotalDamageTaken()) && proto.SC2APIProtocol.VitalScoreDetails.toObject(includeInstance, f),
    totalHealed: (f = msg.getTotalHealed()) && proto.SC2APIProtocol.VitalScoreDetails.toObject(includeInstance, f),
    currentApm: jspb.Message.getOptionalFloatingPointField(msg, 27),
    currentEffectiveApm: jspb.Message.getOptionalFloatingPointField(msg, 28)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ScoreDetails;
  return proto.SC2APIProtocol.ScoreDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ScoreDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setIdleProductionTime(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setIdleWorkerTime(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setTotalValueUnits(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setTotalValueStructures(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setKilledValueUnits(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setKilledValueStructures(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setCollectedMinerals(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setCollectedVespene(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setCollectionRateMinerals(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setCollectionRateVespene(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setSpentMinerals(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setSpentVespene(value);
      break;
    case 13:
      var value = new proto.SC2APIProtocol.CategoryScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader);
      msg.setFoodUsed(value);
      break;
    case 14:
      var value = new proto.SC2APIProtocol.CategoryScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader);
      msg.setKilledMinerals(value);
      break;
    case 15:
      var value = new proto.SC2APIProtocol.CategoryScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader);
      msg.setKilledVespene(value);
      break;
    case 16:
      var value = new proto.SC2APIProtocol.CategoryScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader);
      msg.setLostMinerals(value);
      break;
    case 17:
      var value = new proto.SC2APIProtocol.CategoryScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader);
      msg.setLostVespene(value);
      break;
    case 18:
      var value = new proto.SC2APIProtocol.CategoryScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader);
      msg.setFriendlyFireMinerals(value);
      break;
    case 19:
      var value = new proto.SC2APIProtocol.CategoryScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader);
      msg.setFriendlyFireVespene(value);
      break;
    case 20:
      var value = new proto.SC2APIProtocol.CategoryScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader);
      msg.setUsedMinerals(value);
      break;
    case 21:
      var value = new proto.SC2APIProtocol.CategoryScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader);
      msg.setUsedVespene(value);
      break;
    case 22:
      var value = new proto.SC2APIProtocol.CategoryScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader);
      msg.setTotalUsedMinerals(value);
      break;
    case 23:
      var value = new proto.SC2APIProtocol.CategoryScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.CategoryScoreDetails.deserializeBinaryFromReader);
      msg.setTotalUsedVespene(value);
      break;
    case 24:
      var value = new proto.SC2APIProtocol.VitalScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.VitalScoreDetails.deserializeBinaryFromReader);
      msg.setTotalDamageDealt(value);
      break;
    case 25:
      var value = new proto.SC2APIProtocol.VitalScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.VitalScoreDetails.deserializeBinaryFromReader);
      msg.setTotalDamageTaken(value);
      break;
    case 26:
      var value = new proto.SC2APIProtocol.VitalScoreDetails;
      reader.readMessage(value,proto.SC2APIProtocol.VitalScoreDetails.deserializeBinaryFromReader);
      msg.setTotalHealed(value);
      break;
    case 27:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setCurrentApm(value);
      break;
    case 28:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setCurrentEffectiveApm(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ScoreDetails.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ScoreDetails} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ScoreDetails.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeFloat(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeFloat(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeFloat(
      5,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeFloat(
      6,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeFloat(
      7,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeFloat(
      8,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeFloat(
      9,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeFloat(
      10,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 11));
  if (f != null) {
    writer.writeFloat(
      11,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 12));
  if (f != null) {
    writer.writeFloat(
      12,
      f
    );
  }
  f = message.getFoodUsed();
  if (f != null) {
    writer.writeMessage(
      13,
      f,
      proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getKilledMinerals();
  if (f != null) {
    writer.writeMessage(
      14,
      f,
      proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getKilledVespene();
  if (f != null) {
    writer.writeMessage(
      15,
      f,
      proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getLostMinerals();
  if (f != null) {
    writer.writeMessage(
      16,
      f,
      proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getLostVespene();
  if (f != null) {
    writer.writeMessage(
      17,
      f,
      proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getFriendlyFireMinerals();
  if (f != null) {
    writer.writeMessage(
      18,
      f,
      proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getFriendlyFireVespene();
  if (f != null) {
    writer.writeMessage(
      19,
      f,
      proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getUsedMinerals();
  if (f != null) {
    writer.writeMessage(
      20,
      f,
      proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getUsedVespene();
  if (f != null) {
    writer.writeMessage(
      21,
      f,
      proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getTotalUsedMinerals();
  if (f != null) {
    writer.writeMessage(
      22,
      f,
      proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getTotalUsedVespene();
  if (f != null) {
    writer.writeMessage(
      23,
      f,
      proto.SC2APIProtocol.CategoryScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getTotalDamageDealt();
  if (f != null) {
    writer.writeMessage(
      24,
      f,
      proto.SC2APIProtocol.VitalScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getTotalDamageTaken();
  if (f != null) {
    writer.writeMessage(
      25,
      f,
      proto.SC2APIProtocol.VitalScoreDetails.serializeBinaryToWriter
    );
  }
  f = message.getTotalHealed();
  if (f != null) {
    writer.writeMessage(
      26,
      f,
      proto.SC2APIProtocol.VitalScoreDetails.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 27));
  if (f != null) {
    writer.writeFloat(
      27,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 28));
  if (f != null) {
    writer.writeFloat(
      28,
      f
    );
  }
};


/**
 * optional float idle_production_time = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getIdleProductionTime = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 1, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setIdleProductionTime = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearIdleProductionTime = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasIdleProductionTime = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float idle_worker_time = 2;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getIdleWorkerTime = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setIdleWorkerTime = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearIdleWorkerTime = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasIdleWorkerTime = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional float total_value_units = 3;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getTotalValueUnits = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 3, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setTotalValueUnits = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearTotalValueUnits = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasTotalValueUnits = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional float total_value_structures = 4;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getTotalValueStructures = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 4, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setTotalValueStructures = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearTotalValueStructures = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasTotalValueStructures = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional float killed_value_units = 5;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getKilledValueUnits = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 5, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setKilledValueUnits = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearKilledValueUnits = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasKilledValueUnits = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional float killed_value_structures = 6;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getKilledValueStructures = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 6, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setKilledValueStructures = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearKilledValueStructures = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasKilledValueStructures = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional float collected_minerals = 7;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getCollectedMinerals = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 7, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setCollectedMinerals = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearCollectedMinerals = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasCollectedMinerals = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional float collected_vespene = 8;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getCollectedVespene = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 8, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setCollectedVespene = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearCollectedVespene = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasCollectedVespene = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional float collection_rate_minerals = 9;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getCollectionRateMinerals = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 9, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setCollectionRateMinerals = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearCollectionRateMinerals = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasCollectionRateMinerals = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional float collection_rate_vespene = 10;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getCollectionRateVespene = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 10, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setCollectionRateVespene = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearCollectionRateVespene = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasCollectionRateVespene = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional float spent_minerals = 11;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getSpentMinerals = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 11, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setSpentMinerals = function(value) {
  jspb.Message.setField(this, 11, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearSpentMinerals = function() {
  jspb.Message.setField(this, 11, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasSpentMinerals = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional float spent_vespene = 12;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getSpentVespene = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 12, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setSpentVespene = function(value) {
  jspb.Message.setField(this, 12, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearSpentVespene = function() {
  jspb.Message.setField(this, 12, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasSpentVespene = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional CategoryScoreDetails food_used = 13;
 * @return {?proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getFoodUsed = function() {
  return /** @type{?proto.SC2APIProtocol.CategoryScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.CategoryScoreDetails, 13));
};


/** @param {?proto.SC2APIProtocol.CategoryScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setFoodUsed = function(value) {
  jspb.Message.setWrapperField(this, 13, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearFoodUsed = function() {
  this.setFoodUsed(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasFoodUsed = function() {
  return jspb.Message.getField(this, 13) != null;
};


/**
 * optional CategoryScoreDetails killed_minerals = 14;
 * @return {?proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getKilledMinerals = function() {
  return /** @type{?proto.SC2APIProtocol.CategoryScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.CategoryScoreDetails, 14));
};


/** @param {?proto.SC2APIProtocol.CategoryScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setKilledMinerals = function(value) {
  jspb.Message.setWrapperField(this, 14, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearKilledMinerals = function() {
  this.setKilledMinerals(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasKilledMinerals = function() {
  return jspb.Message.getField(this, 14) != null;
};


/**
 * optional CategoryScoreDetails killed_vespene = 15;
 * @return {?proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getKilledVespene = function() {
  return /** @type{?proto.SC2APIProtocol.CategoryScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.CategoryScoreDetails, 15));
};


/** @param {?proto.SC2APIProtocol.CategoryScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setKilledVespene = function(value) {
  jspb.Message.setWrapperField(this, 15, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearKilledVespene = function() {
  this.setKilledVespene(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasKilledVespene = function() {
  return jspb.Message.getField(this, 15) != null;
};


/**
 * optional CategoryScoreDetails lost_minerals = 16;
 * @return {?proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getLostMinerals = function() {
  return /** @type{?proto.SC2APIProtocol.CategoryScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.CategoryScoreDetails, 16));
};


/** @param {?proto.SC2APIProtocol.CategoryScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setLostMinerals = function(value) {
  jspb.Message.setWrapperField(this, 16, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearLostMinerals = function() {
  this.setLostMinerals(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasLostMinerals = function() {
  return jspb.Message.getField(this, 16) != null;
};


/**
 * optional CategoryScoreDetails lost_vespene = 17;
 * @return {?proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getLostVespene = function() {
  return /** @type{?proto.SC2APIProtocol.CategoryScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.CategoryScoreDetails, 17));
};


/** @param {?proto.SC2APIProtocol.CategoryScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setLostVespene = function(value) {
  jspb.Message.setWrapperField(this, 17, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearLostVespene = function() {
  this.setLostVespene(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasLostVespene = function() {
  return jspb.Message.getField(this, 17) != null;
};


/**
 * optional CategoryScoreDetails friendly_fire_minerals = 18;
 * @return {?proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getFriendlyFireMinerals = function() {
  return /** @type{?proto.SC2APIProtocol.CategoryScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.CategoryScoreDetails, 18));
};


/** @param {?proto.SC2APIProtocol.CategoryScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setFriendlyFireMinerals = function(value) {
  jspb.Message.setWrapperField(this, 18, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearFriendlyFireMinerals = function() {
  this.setFriendlyFireMinerals(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasFriendlyFireMinerals = function() {
  return jspb.Message.getField(this, 18) != null;
};


/**
 * optional CategoryScoreDetails friendly_fire_vespene = 19;
 * @return {?proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getFriendlyFireVespene = function() {
  return /** @type{?proto.SC2APIProtocol.CategoryScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.CategoryScoreDetails, 19));
};


/** @param {?proto.SC2APIProtocol.CategoryScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setFriendlyFireVespene = function(value) {
  jspb.Message.setWrapperField(this, 19, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearFriendlyFireVespene = function() {
  this.setFriendlyFireVespene(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasFriendlyFireVespene = function() {
  return jspb.Message.getField(this, 19) != null;
};


/**
 * optional CategoryScoreDetails used_minerals = 20;
 * @return {?proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getUsedMinerals = function() {
  return /** @type{?proto.SC2APIProtocol.CategoryScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.CategoryScoreDetails, 20));
};


/** @param {?proto.SC2APIProtocol.CategoryScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setUsedMinerals = function(value) {
  jspb.Message.setWrapperField(this, 20, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearUsedMinerals = function() {
  this.setUsedMinerals(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasUsedMinerals = function() {
  return jspb.Message.getField(this, 20) != null;
};


/**
 * optional CategoryScoreDetails used_vespene = 21;
 * @return {?proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getUsedVespene = function() {
  return /** @type{?proto.SC2APIProtocol.CategoryScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.CategoryScoreDetails, 21));
};


/** @param {?proto.SC2APIProtocol.CategoryScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setUsedVespene = function(value) {
  jspb.Message.setWrapperField(this, 21, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearUsedVespene = function() {
  this.setUsedVespene(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasUsedVespene = function() {
  return jspb.Message.getField(this, 21) != null;
};


/**
 * optional CategoryScoreDetails total_used_minerals = 22;
 * @return {?proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getTotalUsedMinerals = function() {
  return /** @type{?proto.SC2APIProtocol.CategoryScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.CategoryScoreDetails, 22));
};


/** @param {?proto.SC2APIProtocol.CategoryScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setTotalUsedMinerals = function(value) {
  jspb.Message.setWrapperField(this, 22, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearTotalUsedMinerals = function() {
  this.setTotalUsedMinerals(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasTotalUsedMinerals = function() {
  return jspb.Message.getField(this, 22) != null;
};


/**
 * optional CategoryScoreDetails total_used_vespene = 23;
 * @return {?proto.SC2APIProtocol.CategoryScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getTotalUsedVespene = function() {
  return /** @type{?proto.SC2APIProtocol.CategoryScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.CategoryScoreDetails, 23));
};


/** @param {?proto.SC2APIProtocol.CategoryScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setTotalUsedVespene = function(value) {
  jspb.Message.setWrapperField(this, 23, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearTotalUsedVespene = function() {
  this.setTotalUsedVespene(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasTotalUsedVespene = function() {
  return jspb.Message.getField(this, 23) != null;
};


/**
 * optional VitalScoreDetails total_damage_dealt = 24;
 * @return {?proto.SC2APIProtocol.VitalScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getTotalDamageDealt = function() {
  return /** @type{?proto.SC2APIProtocol.VitalScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.VitalScoreDetails, 24));
};


/** @param {?proto.SC2APIProtocol.VitalScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setTotalDamageDealt = function(value) {
  jspb.Message.setWrapperField(this, 24, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearTotalDamageDealt = function() {
  this.setTotalDamageDealt(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasTotalDamageDealt = function() {
  return jspb.Message.getField(this, 24) != null;
};


/**
 * optional VitalScoreDetails total_damage_taken = 25;
 * @return {?proto.SC2APIProtocol.VitalScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getTotalDamageTaken = function() {
  return /** @type{?proto.SC2APIProtocol.VitalScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.VitalScoreDetails, 25));
};


/** @param {?proto.SC2APIProtocol.VitalScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setTotalDamageTaken = function(value) {
  jspb.Message.setWrapperField(this, 25, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearTotalDamageTaken = function() {
  this.setTotalDamageTaken(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasTotalDamageTaken = function() {
  return jspb.Message.getField(this, 25) != null;
};


/**
 * optional VitalScoreDetails total_healed = 26;
 * @return {?proto.SC2APIProtocol.VitalScoreDetails}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getTotalHealed = function() {
  return /** @type{?proto.SC2APIProtocol.VitalScoreDetails} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.VitalScoreDetails, 26));
};


/** @param {?proto.SC2APIProtocol.VitalScoreDetails|undefined} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setTotalHealed = function(value) {
  jspb.Message.setWrapperField(this, 26, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearTotalHealed = function() {
  this.setTotalHealed(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasTotalHealed = function() {
  return jspb.Message.getField(this, 26) != null;
};


/**
 * optional float current_apm = 27;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getCurrentApm = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 27, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setCurrentApm = function(value) {
  jspb.Message.setField(this, 27, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearCurrentApm = function() {
  jspb.Message.setField(this, 27, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasCurrentApm = function() {
  return jspb.Message.getField(this, 27) != null;
};


/**
 * optional float current_effective_apm = 28;
 * @return {number}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.getCurrentEffectiveApm = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 28, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.ScoreDetails.prototype.setCurrentEffectiveApm = function(value) {
  jspb.Message.setField(this, 28, value);
};


proto.SC2APIProtocol.ScoreDetails.prototype.clearCurrentEffectiveApm = function() {
  jspb.Message.setField(this, 28, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ScoreDetails.prototype.hasCurrentEffectiveApm = function() {
  return jspb.Message.getField(this, 28) != null;
};


goog.object.extend(exports, proto.SC2APIProtocol);

},{"google-protobuf":68}],112:[function(require,module,exports){
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var s2clientprotocol_common_pb = require('./common_pb.js');
goog.exportSymbol('proto.SC2APIProtocol.ActionSpatial', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionSpatialCameraMove', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionSpatialUnitCommand', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionSpatialUnitSelectionRect', null, global);
goog.exportSymbol('proto.SC2APIProtocol.FeatureLayers', null, global);
goog.exportSymbol('proto.SC2APIProtocol.FeatureLayersMinimap', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ObservationFeatureLayer', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ObservationRender', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ObservationFeatureLayer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ObservationFeatureLayer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ObservationFeatureLayer.displayName = 'proto.SC2APIProtocol.ObservationFeatureLayer';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ObservationFeatureLayer.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ObservationFeatureLayer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ObservationFeatureLayer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ObservationFeatureLayer.toObject = function(includeInstance, msg) {
  var f, obj = {
    renders: (f = msg.getRenders()) && proto.SC2APIProtocol.FeatureLayers.toObject(includeInstance, f),
    minimapRenders: (f = msg.getMinimapRenders()) && proto.SC2APIProtocol.FeatureLayersMinimap.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ObservationFeatureLayer}
 */
proto.SC2APIProtocol.ObservationFeatureLayer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ObservationFeatureLayer;
  return proto.SC2APIProtocol.ObservationFeatureLayer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ObservationFeatureLayer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ObservationFeatureLayer}
 */
proto.SC2APIProtocol.ObservationFeatureLayer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.FeatureLayers;
      reader.readMessage(value,proto.SC2APIProtocol.FeatureLayers.deserializeBinaryFromReader);
      msg.setRenders(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.FeatureLayersMinimap;
      reader.readMessage(value,proto.SC2APIProtocol.FeatureLayersMinimap.deserializeBinaryFromReader);
      msg.setMinimapRenders(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ObservationFeatureLayer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ObservationFeatureLayer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ObservationFeatureLayer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ObservationFeatureLayer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRenders();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.FeatureLayers.serializeBinaryToWriter
    );
  }
  f = message.getMinimapRenders();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.SC2APIProtocol.FeatureLayersMinimap.serializeBinaryToWriter
    );
  }
};


/**
 * optional FeatureLayers renders = 1;
 * @return {?proto.SC2APIProtocol.FeatureLayers}
 */
proto.SC2APIProtocol.ObservationFeatureLayer.prototype.getRenders = function() {
  return /** @type{?proto.SC2APIProtocol.FeatureLayers} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.FeatureLayers, 1));
};


/** @param {?proto.SC2APIProtocol.FeatureLayers|undefined} value */
proto.SC2APIProtocol.ObservationFeatureLayer.prototype.setRenders = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.ObservationFeatureLayer.prototype.clearRenders = function() {
  this.setRenders(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObservationFeatureLayer.prototype.hasRenders = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional FeatureLayersMinimap minimap_renders = 2;
 * @return {?proto.SC2APIProtocol.FeatureLayersMinimap}
 */
proto.SC2APIProtocol.ObservationFeatureLayer.prototype.getMinimapRenders = function() {
  return /** @type{?proto.SC2APIProtocol.FeatureLayersMinimap} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.FeatureLayersMinimap, 2));
};


/** @param {?proto.SC2APIProtocol.FeatureLayersMinimap|undefined} value */
proto.SC2APIProtocol.ObservationFeatureLayer.prototype.setMinimapRenders = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.ObservationFeatureLayer.prototype.clearMinimapRenders = function() {
  this.setMinimapRenders(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObservationFeatureLayer.prototype.hasMinimapRenders = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.FeatureLayers = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.FeatureLayers, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.FeatureLayers.displayName = 'proto.SC2APIProtocol.FeatureLayers';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.FeatureLayers.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.FeatureLayers} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.FeatureLayers.toObject = function(includeInstance, msg) {
  var f, obj = {
    heightMap: (f = msg.getHeightMap()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    visibilityMap: (f = msg.getVisibilityMap()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    creep: (f = msg.getCreep()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    power: (f = msg.getPower()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    playerId: (f = msg.getPlayerId()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    unitType: (f = msg.getUnitType()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    selected: (f = msg.getSelected()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    unitHitPoints: (f = msg.getUnitHitPoints()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    unitHitPointsRatio: (f = msg.getUnitHitPointsRatio()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    unitEnergy: (f = msg.getUnitEnergy()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    unitEnergyRatio: (f = msg.getUnitEnergyRatio()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    unitShields: (f = msg.getUnitShields()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    unitShieldsRatio: (f = msg.getUnitShieldsRatio()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    playerRelative: (f = msg.getPlayerRelative()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    unitDensityAa: (f = msg.getUnitDensityAa()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    unitDensity: (f = msg.getUnitDensity()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    effects: (f = msg.getEffects()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    hallucinations: (f = msg.getHallucinations()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    cloaked: (f = msg.getCloaked()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    blip: (f = msg.getBlip()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    buffs: (f = msg.getBuffs()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    buffDuration: (f = msg.getBuffDuration()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    active: (f = msg.getActive()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    buildProgress: (f = msg.getBuildProgress()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    buildable: (f = msg.getBuildable()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    pathable: (f = msg.getPathable()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    placeholder: (f = msg.getPlaceholder()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.FeatureLayers}
 */
proto.SC2APIProtocol.FeatureLayers.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.FeatureLayers;
  return proto.SC2APIProtocol.FeatureLayers.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.FeatureLayers} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.FeatureLayers}
 */
proto.SC2APIProtocol.FeatureLayers.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setHeightMap(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setVisibilityMap(value);
      break;
    case 3:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setCreep(value);
      break;
    case 4:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setPower(value);
      break;
    case 5:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setPlayerId(value);
      break;
    case 6:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setUnitType(value);
      break;
    case 7:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setSelected(value);
      break;
    case 8:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setUnitHitPoints(value);
      break;
    case 17:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setUnitHitPointsRatio(value);
      break;
    case 9:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setUnitEnergy(value);
      break;
    case 18:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setUnitEnergyRatio(value);
      break;
    case 10:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setUnitShields(value);
      break;
    case 19:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setUnitShieldsRatio(value);
      break;
    case 11:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setPlayerRelative(value);
      break;
    case 14:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setUnitDensityAa(value);
      break;
    case 15:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setUnitDensity(value);
      break;
    case 20:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setEffects(value);
      break;
    case 21:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setHallucinations(value);
      break;
    case 22:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setCloaked(value);
      break;
    case 23:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setBlip(value);
      break;
    case 24:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setBuffs(value);
      break;
    case 26:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setBuffDuration(value);
      break;
    case 25:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setActive(value);
      break;
    case 27:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setBuildProgress(value);
      break;
    case 28:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setBuildable(value);
      break;
    case 29:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setPathable(value);
      break;
    case 30:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setPlaceholder(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.FeatureLayers.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.FeatureLayers} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.FeatureLayers.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHeightMap();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getVisibilityMap();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getCreep();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getPower();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getPlayerId();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getUnitType();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getSelected();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getUnitHitPoints();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getUnitHitPointsRatio();
  if (f != null) {
    writer.writeMessage(
      17,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getUnitEnergy();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getUnitEnergyRatio();
  if (f != null) {
    writer.writeMessage(
      18,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getUnitShields();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getUnitShieldsRatio();
  if (f != null) {
    writer.writeMessage(
      19,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getPlayerRelative();
  if (f != null) {
    writer.writeMessage(
      11,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getUnitDensityAa();
  if (f != null) {
    writer.writeMessage(
      14,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getUnitDensity();
  if (f != null) {
    writer.writeMessage(
      15,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getEffects();
  if (f != null) {
    writer.writeMessage(
      20,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getHallucinations();
  if (f != null) {
    writer.writeMessage(
      21,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getCloaked();
  if (f != null) {
    writer.writeMessage(
      22,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getBlip();
  if (f != null) {
    writer.writeMessage(
      23,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getBuffs();
  if (f != null) {
    writer.writeMessage(
      24,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getBuffDuration();
  if (f != null) {
    writer.writeMessage(
      26,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getActive();
  if (f != null) {
    writer.writeMessage(
      25,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getBuildProgress();
  if (f != null) {
    writer.writeMessage(
      27,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getBuildable();
  if (f != null) {
    writer.writeMessage(
      28,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getPathable();
  if (f != null) {
    writer.writeMessage(
      29,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getPlaceholder();
  if (f != null) {
    writer.writeMessage(
      30,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
};


/**
 * optional ImageData height_map = 1;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getHeightMap = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 1));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setHeightMap = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearHeightMap = function() {
  this.setHeightMap(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasHeightMap = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ImageData visibility_map = 2;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getVisibilityMap = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 2));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setVisibilityMap = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearVisibilityMap = function() {
  this.setVisibilityMap(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasVisibilityMap = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ImageData creep = 3;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getCreep = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 3));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setCreep = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearCreep = function() {
  this.setCreep(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasCreep = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional ImageData power = 4;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getPower = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 4));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setPower = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearPower = function() {
  this.setPower(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasPower = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional ImageData player_id = 5;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getPlayerId = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 5));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setPlayerId = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearPlayerId = function() {
  this.setPlayerId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasPlayerId = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional ImageData unit_type = 6;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getUnitType = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 6));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setUnitType = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearUnitType = function() {
  this.setUnitType(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasUnitType = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional ImageData selected = 7;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getSelected = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 7));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setSelected = function(value) {
  jspb.Message.setWrapperField(this, 7, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearSelected = function() {
  this.setSelected(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasSelected = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional ImageData unit_hit_points = 8;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getUnitHitPoints = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 8));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setUnitHitPoints = function(value) {
  jspb.Message.setWrapperField(this, 8, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearUnitHitPoints = function() {
  this.setUnitHitPoints(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasUnitHitPoints = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional ImageData unit_hit_points_ratio = 17;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getUnitHitPointsRatio = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 17));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setUnitHitPointsRatio = function(value) {
  jspb.Message.setWrapperField(this, 17, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearUnitHitPointsRatio = function() {
  this.setUnitHitPointsRatio(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasUnitHitPointsRatio = function() {
  return jspb.Message.getField(this, 17) != null;
};


/**
 * optional ImageData unit_energy = 9;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getUnitEnergy = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 9));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setUnitEnergy = function(value) {
  jspb.Message.setWrapperField(this, 9, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearUnitEnergy = function() {
  this.setUnitEnergy(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasUnitEnergy = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional ImageData unit_energy_ratio = 18;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getUnitEnergyRatio = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 18));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setUnitEnergyRatio = function(value) {
  jspb.Message.setWrapperField(this, 18, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearUnitEnergyRatio = function() {
  this.setUnitEnergyRatio(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasUnitEnergyRatio = function() {
  return jspb.Message.getField(this, 18) != null;
};


/**
 * optional ImageData unit_shields = 10;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getUnitShields = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 10));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setUnitShields = function(value) {
  jspb.Message.setWrapperField(this, 10, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearUnitShields = function() {
  this.setUnitShields(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasUnitShields = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional ImageData unit_shields_ratio = 19;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getUnitShieldsRatio = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 19));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setUnitShieldsRatio = function(value) {
  jspb.Message.setWrapperField(this, 19, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearUnitShieldsRatio = function() {
  this.setUnitShieldsRatio(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasUnitShieldsRatio = function() {
  return jspb.Message.getField(this, 19) != null;
};


/**
 * optional ImageData player_relative = 11;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getPlayerRelative = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 11));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setPlayerRelative = function(value) {
  jspb.Message.setWrapperField(this, 11, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearPlayerRelative = function() {
  this.setPlayerRelative(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasPlayerRelative = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional ImageData unit_density_aa = 14;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getUnitDensityAa = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 14));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setUnitDensityAa = function(value) {
  jspb.Message.setWrapperField(this, 14, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearUnitDensityAa = function() {
  this.setUnitDensityAa(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasUnitDensityAa = function() {
  return jspb.Message.getField(this, 14) != null;
};


/**
 * optional ImageData unit_density = 15;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getUnitDensity = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 15));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setUnitDensity = function(value) {
  jspb.Message.setWrapperField(this, 15, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearUnitDensity = function() {
  this.setUnitDensity(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasUnitDensity = function() {
  return jspb.Message.getField(this, 15) != null;
};


/**
 * optional ImageData effects = 20;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getEffects = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 20));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setEffects = function(value) {
  jspb.Message.setWrapperField(this, 20, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearEffects = function() {
  this.setEffects(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasEffects = function() {
  return jspb.Message.getField(this, 20) != null;
};


/**
 * optional ImageData hallucinations = 21;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getHallucinations = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 21));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setHallucinations = function(value) {
  jspb.Message.setWrapperField(this, 21, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearHallucinations = function() {
  this.setHallucinations(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasHallucinations = function() {
  return jspb.Message.getField(this, 21) != null;
};


/**
 * optional ImageData cloaked = 22;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getCloaked = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 22));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setCloaked = function(value) {
  jspb.Message.setWrapperField(this, 22, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearCloaked = function() {
  this.setCloaked(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasCloaked = function() {
  return jspb.Message.getField(this, 22) != null;
};


/**
 * optional ImageData blip = 23;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getBlip = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 23));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setBlip = function(value) {
  jspb.Message.setWrapperField(this, 23, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearBlip = function() {
  this.setBlip(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasBlip = function() {
  return jspb.Message.getField(this, 23) != null;
};


/**
 * optional ImageData buffs = 24;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getBuffs = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 24));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setBuffs = function(value) {
  jspb.Message.setWrapperField(this, 24, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearBuffs = function() {
  this.setBuffs(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasBuffs = function() {
  return jspb.Message.getField(this, 24) != null;
};


/**
 * optional ImageData buff_duration = 26;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getBuffDuration = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 26));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setBuffDuration = function(value) {
  jspb.Message.setWrapperField(this, 26, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearBuffDuration = function() {
  this.setBuffDuration(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasBuffDuration = function() {
  return jspb.Message.getField(this, 26) != null;
};


/**
 * optional ImageData active = 25;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getActive = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 25));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setActive = function(value) {
  jspb.Message.setWrapperField(this, 25, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearActive = function() {
  this.setActive(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasActive = function() {
  return jspb.Message.getField(this, 25) != null;
};


/**
 * optional ImageData build_progress = 27;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getBuildProgress = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 27));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setBuildProgress = function(value) {
  jspb.Message.setWrapperField(this, 27, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearBuildProgress = function() {
  this.setBuildProgress(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasBuildProgress = function() {
  return jspb.Message.getField(this, 27) != null;
};


/**
 * optional ImageData buildable = 28;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getBuildable = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 28));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setBuildable = function(value) {
  jspb.Message.setWrapperField(this, 28, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearBuildable = function() {
  this.setBuildable(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasBuildable = function() {
  return jspb.Message.getField(this, 28) != null;
};


/**
 * optional ImageData pathable = 29;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getPathable = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 29));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setPathable = function(value) {
  jspb.Message.setWrapperField(this, 29, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearPathable = function() {
  this.setPathable(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasPathable = function() {
  return jspb.Message.getField(this, 29) != null;
};


/**
 * optional ImageData placeholder = 30;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.getPlaceholder = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 30));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayers.prototype.setPlaceholder = function(value) {
  jspb.Message.setWrapperField(this, 30, value);
};


proto.SC2APIProtocol.FeatureLayers.prototype.clearPlaceholder = function() {
  this.setPlaceholder(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayers.prototype.hasPlaceholder = function() {
  return jspb.Message.getField(this, 30) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.FeatureLayersMinimap = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.FeatureLayersMinimap, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.FeatureLayersMinimap.displayName = 'proto.SC2APIProtocol.FeatureLayersMinimap';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.FeatureLayersMinimap.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.FeatureLayersMinimap} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.FeatureLayersMinimap.toObject = function(includeInstance, msg) {
  var f, obj = {
    heightMap: (f = msg.getHeightMap()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    visibilityMap: (f = msg.getVisibilityMap()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    creep: (f = msg.getCreep()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    camera: (f = msg.getCamera()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    playerId: (f = msg.getPlayerId()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    playerRelative: (f = msg.getPlayerRelative()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    selected: (f = msg.getSelected()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    alerts: (f = msg.getAlerts()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    buildable: (f = msg.getBuildable()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    pathable: (f = msg.getPathable()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    unitType: (f = msg.getUnitType()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.FeatureLayersMinimap}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.FeatureLayersMinimap;
  return proto.SC2APIProtocol.FeatureLayersMinimap.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.FeatureLayersMinimap} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.FeatureLayersMinimap}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setHeightMap(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setVisibilityMap(value);
      break;
    case 3:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setCreep(value);
      break;
    case 4:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setCamera(value);
      break;
    case 5:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setPlayerId(value);
      break;
    case 6:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setPlayerRelative(value);
      break;
    case 7:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setSelected(value);
      break;
    case 9:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setAlerts(value);
      break;
    case 10:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setBuildable(value);
      break;
    case 11:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setPathable(value);
      break;
    case 8:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setUnitType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.FeatureLayersMinimap.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.FeatureLayersMinimap} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.FeatureLayersMinimap.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHeightMap();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getVisibilityMap();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getCreep();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getCamera();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getPlayerId();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getPlayerRelative();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getSelected();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getAlerts();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getBuildable();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getPathable();
  if (f != null) {
    writer.writeMessage(
      11,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getUnitType();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
};


/**
 * optional ImageData height_map = 1;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.getHeightMap = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 1));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.setHeightMap = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.FeatureLayersMinimap.prototype.clearHeightMap = function() {
  this.setHeightMap(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.hasHeightMap = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ImageData visibility_map = 2;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.getVisibilityMap = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 2));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.setVisibilityMap = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.FeatureLayersMinimap.prototype.clearVisibilityMap = function() {
  this.setVisibilityMap(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.hasVisibilityMap = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ImageData creep = 3;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.getCreep = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 3));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.setCreep = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.SC2APIProtocol.FeatureLayersMinimap.prototype.clearCreep = function() {
  this.setCreep(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.hasCreep = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional ImageData camera = 4;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.getCamera = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 4));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.setCamera = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.SC2APIProtocol.FeatureLayersMinimap.prototype.clearCamera = function() {
  this.setCamera(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.hasCamera = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional ImageData player_id = 5;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.getPlayerId = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 5));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.setPlayerId = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.SC2APIProtocol.FeatureLayersMinimap.prototype.clearPlayerId = function() {
  this.setPlayerId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.hasPlayerId = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional ImageData player_relative = 6;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.getPlayerRelative = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 6));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.setPlayerRelative = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


proto.SC2APIProtocol.FeatureLayersMinimap.prototype.clearPlayerRelative = function() {
  this.setPlayerRelative(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.hasPlayerRelative = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional ImageData selected = 7;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.getSelected = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 7));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.setSelected = function(value) {
  jspb.Message.setWrapperField(this, 7, value);
};


proto.SC2APIProtocol.FeatureLayersMinimap.prototype.clearSelected = function() {
  this.setSelected(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.hasSelected = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional ImageData alerts = 9;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.getAlerts = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 9));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.setAlerts = function(value) {
  jspb.Message.setWrapperField(this, 9, value);
};


proto.SC2APIProtocol.FeatureLayersMinimap.prototype.clearAlerts = function() {
  this.setAlerts(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.hasAlerts = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional ImageData buildable = 10;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.getBuildable = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 10));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.setBuildable = function(value) {
  jspb.Message.setWrapperField(this, 10, value);
};


proto.SC2APIProtocol.FeatureLayersMinimap.prototype.clearBuildable = function() {
  this.setBuildable(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.hasBuildable = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional ImageData pathable = 11;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.getPathable = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 11));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.setPathable = function(value) {
  jspb.Message.setWrapperField(this, 11, value);
};


proto.SC2APIProtocol.FeatureLayersMinimap.prototype.clearPathable = function() {
  this.setPathable(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.hasPathable = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional ImageData unit_type = 8;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.getUnitType = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 8));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.setUnitType = function(value) {
  jspb.Message.setWrapperField(this, 8, value);
};


proto.SC2APIProtocol.FeatureLayersMinimap.prototype.clearUnitType = function() {
  this.setUnitType(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.FeatureLayersMinimap.prototype.hasUnitType = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ObservationRender = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ObservationRender, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ObservationRender.displayName = 'proto.SC2APIProtocol.ObservationRender';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ObservationRender.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ObservationRender.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ObservationRender} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ObservationRender.toObject = function(includeInstance, msg) {
  var f, obj = {
    map: (f = msg.getMap()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f),
    minimap: (f = msg.getMinimap()) && s2clientprotocol_common_pb.ImageData.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ObservationRender}
 */
proto.SC2APIProtocol.ObservationRender.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ObservationRender;
  return proto.SC2APIProtocol.ObservationRender.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ObservationRender} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ObservationRender}
 */
proto.SC2APIProtocol.ObservationRender.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setMap(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.ImageData;
      reader.readMessage(value,s2clientprotocol_common_pb.ImageData.deserializeBinaryFromReader);
      msg.setMinimap(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ObservationRender.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ObservationRender.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ObservationRender} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ObservationRender.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMap();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
  f = message.getMinimap();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.ImageData.serializeBinaryToWriter
    );
  }
};


/**
 * optional ImageData map = 1;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.ObservationRender.prototype.getMap = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 1));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.ObservationRender.prototype.setMap = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.ObservationRender.prototype.clearMap = function() {
  this.setMap(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObservationRender.prototype.hasMap = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ImageData minimap = 2;
 * @return {?proto.SC2APIProtocol.ImageData}
 */
proto.SC2APIProtocol.ObservationRender.prototype.getMinimap = function() {
  return /** @type{?proto.SC2APIProtocol.ImageData} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.ImageData, 2));
};


/** @param {?proto.SC2APIProtocol.ImageData|undefined} value */
proto.SC2APIProtocol.ObservationRender.prototype.setMinimap = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.SC2APIProtocol.ObservationRender.prototype.clearMinimap = function() {
  this.setMinimap(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObservationRender.prototype.hasMinimap = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionSpatial = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.SC2APIProtocol.ActionSpatial.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.ActionSpatial, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionSpatial.displayName = 'proto.SC2APIProtocol.ActionSpatial';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.ActionSpatial.oneofGroups_ = [[1,2,3,4]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.ActionSpatial.ActionCase = {
  ACTION_NOT_SET: 0,
  UNIT_COMMAND: 1,
  CAMERA_MOVE: 2,
  UNIT_SELECTION_POINT: 3,
  UNIT_SELECTION_RECT: 4
};

/**
 * @return {proto.SC2APIProtocol.ActionSpatial.ActionCase}
 */
proto.SC2APIProtocol.ActionSpatial.prototype.getActionCase = function() {
  return /** @type {proto.SC2APIProtocol.ActionSpatial.ActionCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.ActionSpatial.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionSpatial.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionSpatial.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionSpatial} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSpatial.toObject = function(includeInstance, msg) {
  var f, obj = {
    unitCommand: (f = msg.getUnitCommand()) && proto.SC2APIProtocol.ActionSpatialUnitCommand.toObject(includeInstance, f),
    cameraMove: (f = msg.getCameraMove()) && proto.SC2APIProtocol.ActionSpatialCameraMove.toObject(includeInstance, f),
    unitSelectionPoint: (f = msg.getUnitSelectionPoint()) && proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.toObject(includeInstance, f),
    unitSelectionRect: (f = msg.getUnitSelectionRect()) && proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionSpatial}
 */
proto.SC2APIProtocol.ActionSpatial.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionSpatial;
  return proto.SC2APIProtocol.ActionSpatial.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionSpatial} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionSpatial}
 */
proto.SC2APIProtocol.ActionSpatial.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.ActionSpatialUnitCommand;
      reader.readMessage(value,proto.SC2APIProtocol.ActionSpatialUnitCommand.deserializeBinaryFromReader);
      msg.setUnitCommand(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.ActionSpatialCameraMove;
      reader.readMessage(value,proto.SC2APIProtocol.ActionSpatialCameraMove.deserializeBinaryFromReader);
      msg.setCameraMove(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint;
      reader.readMessage(value,proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.deserializeBinaryFromReader);
      msg.setUnitSelectionPoint(value);
      break;
    case 4:
      var value = new proto.SC2APIProtocol.ActionSpatialUnitSelectionRect;
      reader.readMessage(value,proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.deserializeBinaryFromReader);
      msg.setUnitSelectionRect(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionSpatial.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionSpatial.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionSpatial} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSpatial.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUnitCommand();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.ActionSpatialUnitCommand.serializeBinaryToWriter
    );
  }
  f = message.getCameraMove();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.SC2APIProtocol.ActionSpatialCameraMove.serializeBinaryToWriter
    );
  }
  f = message.getUnitSelectionPoint();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.serializeBinaryToWriter
    );
  }
  f = message.getUnitSelectionRect();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.serializeBinaryToWriter
    );
  }
};


/**
 * optional ActionSpatialUnitCommand unit_command = 1;
 * @return {?proto.SC2APIProtocol.ActionSpatialUnitCommand}
 */
proto.SC2APIProtocol.ActionSpatial.prototype.getUnitCommand = function() {
  return /** @type{?proto.SC2APIProtocol.ActionSpatialUnitCommand} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionSpatialUnitCommand, 1));
};


/** @param {?proto.SC2APIProtocol.ActionSpatialUnitCommand|undefined} value */
proto.SC2APIProtocol.ActionSpatial.prototype.setUnitCommand = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.SC2APIProtocol.ActionSpatial.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionSpatial.prototype.clearUnitCommand = function() {
  this.setUnitCommand(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSpatial.prototype.hasUnitCommand = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ActionSpatialCameraMove camera_move = 2;
 * @return {?proto.SC2APIProtocol.ActionSpatialCameraMove}
 */
proto.SC2APIProtocol.ActionSpatial.prototype.getCameraMove = function() {
  return /** @type{?proto.SC2APIProtocol.ActionSpatialCameraMove} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionSpatialCameraMove, 2));
};


/** @param {?proto.SC2APIProtocol.ActionSpatialCameraMove|undefined} value */
proto.SC2APIProtocol.ActionSpatial.prototype.setCameraMove = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.SC2APIProtocol.ActionSpatial.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionSpatial.prototype.clearCameraMove = function() {
  this.setCameraMove(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSpatial.prototype.hasCameraMove = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ActionSpatialUnitSelectionPoint unit_selection_point = 3;
 * @return {?proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint}
 */
proto.SC2APIProtocol.ActionSpatial.prototype.getUnitSelectionPoint = function() {
  return /** @type{?proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint, 3));
};


/** @param {?proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint|undefined} value */
proto.SC2APIProtocol.ActionSpatial.prototype.setUnitSelectionPoint = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.SC2APIProtocol.ActionSpatial.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionSpatial.prototype.clearUnitSelectionPoint = function() {
  this.setUnitSelectionPoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSpatial.prototype.hasUnitSelectionPoint = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional ActionSpatialUnitSelectionRect unit_selection_rect = 4;
 * @return {?proto.SC2APIProtocol.ActionSpatialUnitSelectionRect}
 */
proto.SC2APIProtocol.ActionSpatial.prototype.getUnitSelectionRect = function() {
  return /** @type{?proto.SC2APIProtocol.ActionSpatialUnitSelectionRect} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionSpatialUnitSelectionRect, 4));
};


/** @param {?proto.SC2APIProtocol.ActionSpatialUnitSelectionRect|undefined} value */
proto.SC2APIProtocol.ActionSpatial.prototype.setUnitSelectionRect = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.SC2APIProtocol.ActionSpatial.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionSpatial.prototype.clearUnitSelectionRect = function() {
  this.setUnitSelectionRect(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSpatial.prototype.hasUnitSelectionRect = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.SC2APIProtocol.ActionSpatialUnitCommand.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.ActionSpatialUnitCommand, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionSpatialUnitCommand.displayName = 'proto.SC2APIProtocol.ActionSpatialUnitCommand';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.oneofGroups_ = [[2,3]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.TargetCase = {
  TARGET_NOT_SET: 0,
  TARGET_SCREEN_COORD: 2,
  TARGET_MINIMAP_COORD: 3
};

/**
 * @return {proto.SC2APIProtocol.ActionSpatialUnitCommand.TargetCase}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.getTargetCase = function() {
  return /** @type {proto.SC2APIProtocol.ActionSpatialUnitCommand.TargetCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.ActionSpatialUnitCommand.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionSpatialUnitCommand.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionSpatialUnitCommand} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.toObject = function(includeInstance, msg) {
  var f, obj = {
    abilityId: jspb.Message.getField(msg, 1),
    targetScreenCoord: (f = msg.getTargetScreenCoord()) && s2clientprotocol_common_pb.PointI.toObject(includeInstance, f),
    targetMinimapCoord: (f = msg.getTargetMinimapCoord()) && s2clientprotocol_common_pb.PointI.toObject(includeInstance, f),
    queueCommand: jspb.Message.getField(msg, 4)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionSpatialUnitCommand}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionSpatialUnitCommand;
  return proto.SC2APIProtocol.ActionSpatialUnitCommand.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionSpatialUnitCommand} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionSpatialUnitCommand}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAbilityId(value);
      break;
    case 2:
      var value = new s2clientprotocol_common_pb.PointI;
      reader.readMessage(value,s2clientprotocol_common_pb.PointI.deserializeBinaryFromReader);
      msg.setTargetScreenCoord(value);
      break;
    case 3:
      var value = new s2clientprotocol_common_pb.PointI;
      reader.readMessage(value,s2clientprotocol_common_pb.PointI.deserializeBinaryFromReader);
      msg.setTargetMinimapCoord(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setQueueCommand(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionSpatialUnitCommand.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionSpatialUnitCommand} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = message.getTargetScreenCoord();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      s2clientprotocol_common_pb.PointI.serializeBinaryToWriter
    );
  }
  f = message.getTargetMinimapCoord();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      s2clientprotocol_common_pb.PointI.serializeBinaryToWriter
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBool(
      4,
      f
    );
  }
};


/**
 * optional int32 ability_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.getAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional PointI target_screen_coord = 2;
 * @return {?proto.SC2APIProtocol.PointI}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.getTargetScreenCoord = function() {
  return /** @type{?proto.SC2APIProtocol.PointI} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.PointI, 2));
};


/** @param {?proto.SC2APIProtocol.PointI|undefined} value */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.setTargetScreenCoord = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.SC2APIProtocol.ActionSpatialUnitCommand.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.clearTargetScreenCoord = function() {
  this.setTargetScreenCoord(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.hasTargetScreenCoord = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional PointI target_minimap_coord = 3;
 * @return {?proto.SC2APIProtocol.PointI}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.getTargetMinimapCoord = function() {
  return /** @type{?proto.SC2APIProtocol.PointI} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.PointI, 3));
};


/** @param {?proto.SC2APIProtocol.PointI|undefined} value */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.setTargetMinimapCoord = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.SC2APIProtocol.ActionSpatialUnitCommand.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.clearTargetMinimapCoord = function() {
  this.setTargetMinimapCoord(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.hasTargetMinimapCoord = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bool queue_command = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.getQueueCommand = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.setQueueCommand = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.clearQueueCommand = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSpatialUnitCommand.prototype.hasQueueCommand = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionSpatialCameraMove = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionSpatialCameraMove, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionSpatialCameraMove.displayName = 'proto.SC2APIProtocol.ActionSpatialCameraMove';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionSpatialCameraMove.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionSpatialCameraMove.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionSpatialCameraMove} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSpatialCameraMove.toObject = function(includeInstance, msg) {
  var f, obj = {
    centerMinimap: (f = msg.getCenterMinimap()) && s2clientprotocol_common_pb.PointI.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionSpatialCameraMove}
 */
proto.SC2APIProtocol.ActionSpatialCameraMove.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionSpatialCameraMove;
  return proto.SC2APIProtocol.ActionSpatialCameraMove.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionSpatialCameraMove} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionSpatialCameraMove}
 */
proto.SC2APIProtocol.ActionSpatialCameraMove.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.PointI;
      reader.readMessage(value,s2clientprotocol_common_pb.PointI.deserializeBinaryFromReader);
      msg.setCenterMinimap(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionSpatialCameraMove.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionSpatialCameraMove.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionSpatialCameraMove} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSpatialCameraMove.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCenterMinimap();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.PointI.serializeBinaryToWriter
    );
  }
};


/**
 * optional PointI center_minimap = 1;
 * @return {?proto.SC2APIProtocol.PointI}
 */
proto.SC2APIProtocol.ActionSpatialCameraMove.prototype.getCenterMinimap = function() {
  return /** @type{?proto.SC2APIProtocol.PointI} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.PointI, 1));
};


/** @param {?proto.SC2APIProtocol.PointI|undefined} value */
proto.SC2APIProtocol.ActionSpatialCameraMove.prototype.setCenterMinimap = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.ActionSpatialCameraMove.prototype.clearCenterMinimap = function() {
  this.setCenterMinimap(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSpatialCameraMove.prototype.hasCenterMinimap = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.displayName = 'proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.toObject = function(includeInstance, msg) {
  var f, obj = {
    selectionScreenCoord: (f = msg.getSelectionScreenCoord()) && s2clientprotocol_common_pb.PointI.toObject(includeInstance, f),
    type: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint;
  return proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.PointI;
      reader.readMessage(value,s2clientprotocol_common_pb.PointI.deserializeBinaryFromReader);
      msg.setSelectionScreenCoord(value);
      break;
    case 2:
      var value = /** @type {!proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type} */ (reader.readEnum());
      msg.setType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSelectionScreenCoord();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      s2clientprotocol_common_pb.PointI.serializeBinaryToWriter
    );
  }
  f = /** @type {!proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeEnum(
      2,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type = {
  SELECT: 1,
  TOGGLE: 2,
  ALLTYPE: 3,
  ADDALLTYPE: 4
};

/**
 * optional PointI selection_screen_coord = 1;
 * @return {?proto.SC2APIProtocol.PointI}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.prototype.getSelectionScreenCoord = function() {
  return /** @type{?proto.SC2APIProtocol.PointI} */ (
    jspb.Message.getWrapperField(this, s2clientprotocol_common_pb.PointI, 1));
};


/** @param {?proto.SC2APIProtocol.PointI|undefined} value */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.prototype.setSelectionScreenCoord = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.prototype.clearSelectionScreenCoord = function() {
  this.setSelectionScreenCoord(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.prototype.hasSelectionScreenCoord = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional Type type = 2;
 * @return {!proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.prototype.getType = function() {
  return /** @type {!proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type} */ (jspb.Message.getFieldWithDefault(this, 2, 1));
};


/** @param {!proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type} value */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.prototype.setType = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.prototype.clearType = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionPoint.prototype.hasType = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ActionSpatialUnitSelectionRect, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.displayName = 'proto.SC2APIProtocol.ActionSpatialUnitSelectionRect';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionSpatialUnitSelectionRect} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.toObject = function(includeInstance, msg) {
  var f, obj = {
    selectionScreenCoordList: jspb.Message.toObjectList(msg.getSelectionScreenCoordList(),
    s2clientprotocol_common_pb.RectangleI.toObject, includeInstance),
    selectionAdd: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionSpatialUnitSelectionRect}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionSpatialUnitSelectionRect;
  return proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionSpatialUnitSelectionRect} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionSpatialUnitSelectionRect}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new s2clientprotocol_common_pb.RectangleI;
      reader.readMessage(value,s2clientprotocol_common_pb.RectangleI.deserializeBinaryFromReader);
      msg.addSelectionScreenCoord(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSelectionAdd(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionSpatialUnitSelectionRect} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSelectionScreenCoordList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      s2clientprotocol_common_pb.RectangleI.serializeBinaryToWriter
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * repeated RectangleI selection_screen_coord = 1;
 * @return {!Array.<!proto.SC2APIProtocol.RectangleI>}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.prototype.getSelectionScreenCoordList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.RectangleI>} */ (
    jspb.Message.getRepeatedWrapperField(this, s2clientprotocol_common_pb.RectangleI, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.RectangleI>} value */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.prototype.setSelectionScreenCoordList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.RectangleI=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.RectangleI}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.prototype.addSelectionScreenCoord = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.RectangleI, opt_index);
};


proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.prototype.clearSelectionScreenCoordList = function() {
  this.setSelectionScreenCoordList([]);
};


/**
 * optional bool selection_add = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.prototype.getSelectionAdd = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.prototype.setSelectionAdd = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.prototype.clearSelectionAdd = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSpatialUnitSelectionRect.prototype.hasSelectionAdd = function() {
  return jspb.Message.getField(this, 2) != null;
};


goog.object.extend(exports, proto.SC2APIProtocol);

},{"./common_pb.js":104,"google-protobuf":68}],113:[function(require,module,exports){
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.SC2APIProtocol.ActionCargoPanelUnload', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionControlGroup', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionControlGroup.ControlGroupAction', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionMultiPanel', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionMultiPanel.Type', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionSelectArmy', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionSelectIdleWorker', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionSelectIdleWorker.Type', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionSelectLarva', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionSelectWarpGates', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionToggleAutocast', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ActionUI', null, global);
goog.exportSymbol('proto.SC2APIProtocol.BuildItem', null, global);
goog.exportSymbol('proto.SC2APIProtocol.CargoPanel', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ControlGroup', null, global);
goog.exportSymbol('proto.SC2APIProtocol.MultiPanel', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ObservationUI', null, global);
goog.exportSymbol('proto.SC2APIProtocol.ProductionPanel', null, global);
goog.exportSymbol('proto.SC2APIProtocol.SinglePanel', null, global);
goog.exportSymbol('proto.SC2APIProtocol.UnitInfo', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ObservationUI = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ObservationUI.repeatedFields_, proto.SC2APIProtocol.ObservationUI.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.ObservationUI, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ObservationUI.displayName = 'proto.SC2APIProtocol.ObservationUI';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ObservationUI.repeatedFields_ = [1];

/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.ObservationUI.oneofGroups_ = [[2,3,4,5]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.ObservationUI.PanelCase = {
  PANEL_NOT_SET: 0,
  SINGLE: 2,
  MULTI: 3,
  CARGO: 4,
  PRODUCTION: 5
};

/**
 * @return {proto.SC2APIProtocol.ObservationUI.PanelCase}
 */
proto.SC2APIProtocol.ObservationUI.prototype.getPanelCase = function() {
  return /** @type {proto.SC2APIProtocol.ObservationUI.PanelCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.ObservationUI.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ObservationUI.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ObservationUI.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ObservationUI} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ObservationUI.toObject = function(includeInstance, msg) {
  var f, obj = {
    groupsList: jspb.Message.toObjectList(msg.getGroupsList(),
    proto.SC2APIProtocol.ControlGroup.toObject, includeInstance),
    single: (f = msg.getSingle()) && proto.SC2APIProtocol.SinglePanel.toObject(includeInstance, f),
    multi: (f = msg.getMulti()) && proto.SC2APIProtocol.MultiPanel.toObject(includeInstance, f),
    cargo: (f = msg.getCargo()) && proto.SC2APIProtocol.CargoPanel.toObject(includeInstance, f),
    production: (f = msg.getProduction()) && proto.SC2APIProtocol.ProductionPanel.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ObservationUI}
 */
proto.SC2APIProtocol.ObservationUI.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ObservationUI;
  return proto.SC2APIProtocol.ObservationUI.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ObservationUI} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ObservationUI}
 */
proto.SC2APIProtocol.ObservationUI.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.ControlGroup;
      reader.readMessage(value,proto.SC2APIProtocol.ControlGroup.deserializeBinaryFromReader);
      msg.addGroups(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.SinglePanel;
      reader.readMessage(value,proto.SC2APIProtocol.SinglePanel.deserializeBinaryFromReader);
      msg.setSingle(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.MultiPanel;
      reader.readMessage(value,proto.SC2APIProtocol.MultiPanel.deserializeBinaryFromReader);
      msg.setMulti(value);
      break;
    case 4:
      var value = new proto.SC2APIProtocol.CargoPanel;
      reader.readMessage(value,proto.SC2APIProtocol.CargoPanel.deserializeBinaryFromReader);
      msg.setCargo(value);
      break;
    case 5:
      var value = new proto.SC2APIProtocol.ProductionPanel;
      reader.readMessage(value,proto.SC2APIProtocol.ProductionPanel.deserializeBinaryFromReader);
      msg.setProduction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ObservationUI.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ObservationUI.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ObservationUI} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ObservationUI.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getGroupsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.SC2APIProtocol.ControlGroup.serializeBinaryToWriter
    );
  }
  f = message.getSingle();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.SC2APIProtocol.SinglePanel.serializeBinaryToWriter
    );
  }
  f = message.getMulti();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.MultiPanel.serializeBinaryToWriter
    );
  }
  f = message.getCargo();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.SC2APIProtocol.CargoPanel.serializeBinaryToWriter
    );
  }
  f = message.getProduction();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.SC2APIProtocol.ProductionPanel.serializeBinaryToWriter
    );
  }
};


/**
 * repeated ControlGroup groups = 1;
 * @return {!Array.<!proto.SC2APIProtocol.ControlGroup>}
 */
proto.SC2APIProtocol.ObservationUI.prototype.getGroupsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.ControlGroup>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.ControlGroup, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.ControlGroup>} value */
proto.SC2APIProtocol.ObservationUI.prototype.setGroupsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.ControlGroup=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.ControlGroup}
 */
proto.SC2APIProtocol.ObservationUI.prototype.addGroups = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.ControlGroup, opt_index);
};


proto.SC2APIProtocol.ObservationUI.prototype.clearGroupsList = function() {
  this.setGroupsList([]);
};


/**
 * optional SinglePanel single = 2;
 * @return {?proto.SC2APIProtocol.SinglePanel}
 */
proto.SC2APIProtocol.ObservationUI.prototype.getSingle = function() {
  return /** @type{?proto.SC2APIProtocol.SinglePanel} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.SinglePanel, 2));
};


/** @param {?proto.SC2APIProtocol.SinglePanel|undefined} value */
proto.SC2APIProtocol.ObservationUI.prototype.setSingle = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.SC2APIProtocol.ObservationUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ObservationUI.prototype.clearSingle = function() {
  this.setSingle(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObservationUI.prototype.hasSingle = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional MultiPanel multi = 3;
 * @return {?proto.SC2APIProtocol.MultiPanel}
 */
proto.SC2APIProtocol.ObservationUI.prototype.getMulti = function() {
  return /** @type{?proto.SC2APIProtocol.MultiPanel} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.MultiPanel, 3));
};


/** @param {?proto.SC2APIProtocol.MultiPanel|undefined} value */
proto.SC2APIProtocol.ObservationUI.prototype.setMulti = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.SC2APIProtocol.ObservationUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ObservationUI.prototype.clearMulti = function() {
  this.setMulti(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObservationUI.prototype.hasMulti = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional CargoPanel cargo = 4;
 * @return {?proto.SC2APIProtocol.CargoPanel}
 */
proto.SC2APIProtocol.ObservationUI.prototype.getCargo = function() {
  return /** @type{?proto.SC2APIProtocol.CargoPanel} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.CargoPanel, 4));
};


/** @param {?proto.SC2APIProtocol.CargoPanel|undefined} value */
proto.SC2APIProtocol.ObservationUI.prototype.setCargo = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.SC2APIProtocol.ObservationUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ObservationUI.prototype.clearCargo = function() {
  this.setCargo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObservationUI.prototype.hasCargo = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional ProductionPanel production = 5;
 * @return {?proto.SC2APIProtocol.ProductionPanel}
 */
proto.SC2APIProtocol.ObservationUI.prototype.getProduction = function() {
  return /** @type{?proto.SC2APIProtocol.ProductionPanel} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ProductionPanel, 5));
};


/** @param {?proto.SC2APIProtocol.ProductionPanel|undefined} value */
proto.SC2APIProtocol.ObservationUI.prototype.setProduction = function(value) {
  jspb.Message.setOneofWrapperField(this, 5, proto.SC2APIProtocol.ObservationUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ObservationUI.prototype.clearProduction = function() {
  this.setProduction(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ObservationUI.prototype.hasProduction = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ControlGroup = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ControlGroup, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ControlGroup.displayName = 'proto.SC2APIProtocol.ControlGroup';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ControlGroup.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ControlGroup.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ControlGroup} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ControlGroup.toObject = function(includeInstance, msg) {
  var f, obj = {
    controlGroupIndex: jspb.Message.getField(msg, 1),
    leaderUnitType: jspb.Message.getField(msg, 2),
    count: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ControlGroup}
 */
proto.SC2APIProtocol.ControlGroup.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ControlGroup;
  return proto.SC2APIProtocol.ControlGroup.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ControlGroup} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ControlGroup}
 */
proto.SC2APIProtocol.ControlGroup.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setControlGroupIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLeaderUnitType(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ControlGroup.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ControlGroup.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ControlGroup} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ControlGroup.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * optional uint32 control_group_index = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ControlGroup.prototype.getControlGroupIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ControlGroup.prototype.setControlGroupIndex = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ControlGroup.prototype.clearControlGroupIndex = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ControlGroup.prototype.hasControlGroupIndex = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 leader_unit_type = 2;
 * @return {number}
 */
proto.SC2APIProtocol.ControlGroup.prototype.getLeaderUnitType = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ControlGroup.prototype.setLeaderUnitType = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ControlGroup.prototype.clearLeaderUnitType = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ControlGroup.prototype.hasLeaderUnitType = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 count = 3;
 * @return {number}
 */
proto.SC2APIProtocol.ControlGroup.prototype.getCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ControlGroup.prototype.setCount = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.ControlGroup.prototype.clearCount = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ControlGroup.prototype.hasCount = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.UnitInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.UnitInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.UnitInfo.displayName = 'proto.SC2APIProtocol.UnitInfo';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.UnitInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.UnitInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.UnitInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.UnitInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    unitType: jspb.Message.getField(msg, 1),
    playerRelative: jspb.Message.getField(msg, 2),
    health: jspb.Message.getField(msg, 3),
    shields: jspb.Message.getField(msg, 4),
    energy: jspb.Message.getField(msg, 5),
    transportSlotsTaken: jspb.Message.getField(msg, 6),
    buildProgress: jspb.Message.getOptionalFloatingPointField(msg, 7),
    addOn: (f = msg.getAddOn()) && proto.SC2APIProtocol.UnitInfo.toObject(includeInstance, f),
    maxHealth: jspb.Message.getField(msg, 9),
    maxShields: jspb.Message.getField(msg, 10),
    maxEnergy: jspb.Message.getField(msg, 11)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.UnitInfo}
 */
proto.SC2APIProtocol.UnitInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.UnitInfo;
  return proto.SC2APIProtocol.UnitInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.UnitInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.UnitInfo}
 */
proto.SC2APIProtocol.UnitInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setUnitType(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPlayerRelative(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setHealth(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setShields(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setEnergy(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTransportSlotsTaken(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setBuildProgress(value);
      break;
    case 8:
      var value = new proto.SC2APIProtocol.UnitInfo;
      reader.readMessage(value,proto.SC2APIProtocol.UnitInfo.deserializeBinaryFromReader);
      msg.setAddOn(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMaxHealth(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMaxShields(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMaxEnergy(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.UnitInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.UnitInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.UnitInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.UnitInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeInt32(
      5,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeInt32(
      6,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeFloat(
      7,
      f
    );
  }
  f = message.getAddOn();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.SC2APIProtocol.UnitInfo.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeInt32(
      9,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeInt32(
      10,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 11));
  if (f != null) {
    writer.writeInt32(
      11,
      f
    );
  }
};


/**
 * optional uint32 unit_type = 1;
 * @return {number}
 */
proto.SC2APIProtocol.UnitInfo.prototype.getUnitType = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitInfo.prototype.setUnitType = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.UnitInfo.prototype.clearUnitType = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitInfo.prototype.hasUnitType = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 player_relative = 2;
 * @return {number}
 */
proto.SC2APIProtocol.UnitInfo.prototype.getPlayerRelative = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitInfo.prototype.setPlayerRelative = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.UnitInfo.prototype.clearPlayerRelative = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitInfo.prototype.hasPlayerRelative = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional int32 health = 3;
 * @return {number}
 */
proto.SC2APIProtocol.UnitInfo.prototype.getHealth = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitInfo.prototype.setHealth = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.UnitInfo.prototype.clearHealth = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitInfo.prototype.hasHealth = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional int32 shields = 4;
 * @return {number}
 */
proto.SC2APIProtocol.UnitInfo.prototype.getShields = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitInfo.prototype.setShields = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.UnitInfo.prototype.clearShields = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitInfo.prototype.hasShields = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional int32 energy = 5;
 * @return {number}
 */
proto.SC2APIProtocol.UnitInfo.prototype.getEnergy = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitInfo.prototype.setEnergy = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SC2APIProtocol.UnitInfo.prototype.clearEnergy = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitInfo.prototype.hasEnergy = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional int32 transport_slots_taken = 6;
 * @return {number}
 */
proto.SC2APIProtocol.UnitInfo.prototype.getTransportSlotsTaken = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitInfo.prototype.setTransportSlotsTaken = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SC2APIProtocol.UnitInfo.prototype.clearTransportSlotsTaken = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitInfo.prototype.hasTransportSlotsTaken = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional float build_progress = 7;
 * @return {number}
 */
proto.SC2APIProtocol.UnitInfo.prototype.getBuildProgress = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 7, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitInfo.prototype.setBuildProgress = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SC2APIProtocol.UnitInfo.prototype.clearBuildProgress = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitInfo.prototype.hasBuildProgress = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional UnitInfo add_on = 8;
 * @return {?proto.SC2APIProtocol.UnitInfo}
 */
proto.SC2APIProtocol.UnitInfo.prototype.getAddOn = function() {
  return /** @type{?proto.SC2APIProtocol.UnitInfo} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.UnitInfo, 8));
};


/** @param {?proto.SC2APIProtocol.UnitInfo|undefined} value */
proto.SC2APIProtocol.UnitInfo.prototype.setAddOn = function(value) {
  jspb.Message.setWrapperField(this, 8, value);
};


proto.SC2APIProtocol.UnitInfo.prototype.clearAddOn = function() {
  this.setAddOn(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitInfo.prototype.hasAddOn = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional int32 max_health = 9;
 * @return {number}
 */
proto.SC2APIProtocol.UnitInfo.prototype.getMaxHealth = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitInfo.prototype.setMaxHealth = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.SC2APIProtocol.UnitInfo.prototype.clearMaxHealth = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitInfo.prototype.hasMaxHealth = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional int32 max_shields = 10;
 * @return {number}
 */
proto.SC2APIProtocol.UnitInfo.prototype.getMaxShields = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitInfo.prototype.setMaxShields = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.SC2APIProtocol.UnitInfo.prototype.clearMaxShields = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitInfo.prototype.hasMaxShields = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional int32 max_energy = 11;
 * @return {number}
 */
proto.SC2APIProtocol.UnitInfo.prototype.getMaxEnergy = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.UnitInfo.prototype.setMaxEnergy = function(value) {
  jspb.Message.setField(this, 11, value);
};


proto.SC2APIProtocol.UnitInfo.prototype.clearMaxEnergy = function() {
  jspb.Message.setField(this, 11, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.UnitInfo.prototype.hasMaxEnergy = function() {
  return jspb.Message.getField(this, 11) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.SinglePanel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.SinglePanel.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.SinglePanel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.SinglePanel.displayName = 'proto.SC2APIProtocol.SinglePanel';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.SinglePanel.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.SinglePanel.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.SinglePanel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.SinglePanel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.SinglePanel.toObject = function(includeInstance, msg) {
  var f, obj = {
    unit: (f = msg.getUnit()) && proto.SC2APIProtocol.UnitInfo.toObject(includeInstance, f),
    attackUpgradeLevel: jspb.Message.getField(msg, 2),
    armorUpgradeLevel: jspb.Message.getField(msg, 3),
    shieldUpgradeLevel: jspb.Message.getField(msg, 4),
    buffsList: jspb.Message.getRepeatedField(msg, 5)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.SinglePanel}
 */
proto.SC2APIProtocol.SinglePanel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.SinglePanel;
  return proto.SC2APIProtocol.SinglePanel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.SinglePanel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.SinglePanel}
 */
proto.SC2APIProtocol.SinglePanel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.UnitInfo;
      reader.readMessage(value,proto.SC2APIProtocol.UnitInfo.deserializeBinaryFromReader);
      msg.setUnit(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAttackUpgradeLevel(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setArmorUpgradeLevel(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setShieldUpgradeLevel(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.addBuffs(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.SinglePanel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.SinglePanel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.SinglePanel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.SinglePanel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUnit();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.UnitInfo.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = message.getBuffsList();
  if (f.length > 0) {
    writer.writeRepeatedInt32(
      5,
      f
    );
  }
};


/**
 * optional UnitInfo unit = 1;
 * @return {?proto.SC2APIProtocol.UnitInfo}
 */
proto.SC2APIProtocol.SinglePanel.prototype.getUnit = function() {
  return /** @type{?proto.SC2APIProtocol.UnitInfo} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.UnitInfo, 1));
};


/** @param {?proto.SC2APIProtocol.UnitInfo|undefined} value */
proto.SC2APIProtocol.SinglePanel.prototype.setUnit = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.SinglePanel.prototype.clearUnit = function() {
  this.setUnit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.SinglePanel.prototype.hasUnit = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int32 attack_upgrade_level = 2;
 * @return {number}
 */
proto.SC2APIProtocol.SinglePanel.prototype.getAttackUpgradeLevel = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.SinglePanel.prototype.setAttackUpgradeLevel = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.SinglePanel.prototype.clearAttackUpgradeLevel = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.SinglePanel.prototype.hasAttackUpgradeLevel = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional int32 armor_upgrade_level = 3;
 * @return {number}
 */
proto.SC2APIProtocol.SinglePanel.prototype.getArmorUpgradeLevel = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.SinglePanel.prototype.setArmorUpgradeLevel = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.SinglePanel.prototype.clearArmorUpgradeLevel = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.SinglePanel.prototype.hasArmorUpgradeLevel = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional int32 shield_upgrade_level = 4;
 * @return {number}
 */
proto.SC2APIProtocol.SinglePanel.prototype.getShieldUpgradeLevel = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.SinglePanel.prototype.setShieldUpgradeLevel = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SC2APIProtocol.SinglePanel.prototype.clearShieldUpgradeLevel = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.SinglePanel.prototype.hasShieldUpgradeLevel = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * repeated int32 buffs = 5;
 * @return {!Array.<number>}
 */
proto.SC2APIProtocol.SinglePanel.prototype.getBuffsList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getRepeatedField(this, 5));
};


/** @param {!Array.<number>} value */
proto.SC2APIProtocol.SinglePanel.prototype.setBuffsList = function(value) {
  jspb.Message.setField(this, 5, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.SC2APIProtocol.SinglePanel.prototype.addBuffs = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 5, value, opt_index);
};


proto.SC2APIProtocol.SinglePanel.prototype.clearBuffsList = function() {
  this.setBuffsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.MultiPanel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.MultiPanel.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.MultiPanel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.MultiPanel.displayName = 'proto.SC2APIProtocol.MultiPanel';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.MultiPanel.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.MultiPanel.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.MultiPanel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.MultiPanel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.MultiPanel.toObject = function(includeInstance, msg) {
  var f, obj = {
    unitsList: jspb.Message.toObjectList(msg.getUnitsList(),
    proto.SC2APIProtocol.UnitInfo.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.MultiPanel}
 */
proto.SC2APIProtocol.MultiPanel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.MultiPanel;
  return proto.SC2APIProtocol.MultiPanel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.MultiPanel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.MultiPanel}
 */
proto.SC2APIProtocol.MultiPanel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.UnitInfo;
      reader.readMessage(value,proto.SC2APIProtocol.UnitInfo.deserializeBinaryFromReader);
      msg.addUnits(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.MultiPanel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.MultiPanel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.MultiPanel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.MultiPanel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUnitsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.SC2APIProtocol.UnitInfo.serializeBinaryToWriter
    );
  }
};


/**
 * repeated UnitInfo units = 1;
 * @return {!Array.<!proto.SC2APIProtocol.UnitInfo>}
 */
proto.SC2APIProtocol.MultiPanel.prototype.getUnitsList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.UnitInfo>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.UnitInfo, 1));
};


/** @param {!Array.<!proto.SC2APIProtocol.UnitInfo>} value */
proto.SC2APIProtocol.MultiPanel.prototype.setUnitsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.SC2APIProtocol.UnitInfo=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.UnitInfo}
 */
proto.SC2APIProtocol.MultiPanel.prototype.addUnits = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.SC2APIProtocol.UnitInfo, opt_index);
};


proto.SC2APIProtocol.MultiPanel.prototype.clearUnitsList = function() {
  this.setUnitsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.CargoPanel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.CargoPanel.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.CargoPanel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.CargoPanel.displayName = 'proto.SC2APIProtocol.CargoPanel';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.CargoPanel.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.CargoPanel.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.CargoPanel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.CargoPanel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.CargoPanel.toObject = function(includeInstance, msg) {
  var f, obj = {
    unit: (f = msg.getUnit()) && proto.SC2APIProtocol.UnitInfo.toObject(includeInstance, f),
    passengersList: jspb.Message.toObjectList(msg.getPassengersList(),
    proto.SC2APIProtocol.UnitInfo.toObject, includeInstance),
    slotsAvailable: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.CargoPanel}
 */
proto.SC2APIProtocol.CargoPanel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.CargoPanel;
  return proto.SC2APIProtocol.CargoPanel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.CargoPanel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.CargoPanel}
 */
proto.SC2APIProtocol.CargoPanel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.UnitInfo;
      reader.readMessage(value,proto.SC2APIProtocol.UnitInfo.deserializeBinaryFromReader);
      msg.setUnit(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.UnitInfo;
      reader.readMessage(value,proto.SC2APIProtocol.UnitInfo.deserializeBinaryFromReader);
      msg.addPassengers(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setSlotsAvailable(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.CargoPanel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.CargoPanel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.CargoPanel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.CargoPanel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUnit();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.UnitInfo.serializeBinaryToWriter
    );
  }
  f = message.getPassengersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.SC2APIProtocol.UnitInfo.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeInt32(
      3,
      f
    );
  }
};


/**
 * optional UnitInfo unit = 1;
 * @return {?proto.SC2APIProtocol.UnitInfo}
 */
proto.SC2APIProtocol.CargoPanel.prototype.getUnit = function() {
  return /** @type{?proto.SC2APIProtocol.UnitInfo} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.UnitInfo, 1));
};


/** @param {?proto.SC2APIProtocol.UnitInfo|undefined} value */
proto.SC2APIProtocol.CargoPanel.prototype.setUnit = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.CargoPanel.prototype.clearUnit = function() {
  this.setUnit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.CargoPanel.prototype.hasUnit = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated UnitInfo passengers = 2;
 * @return {!Array.<!proto.SC2APIProtocol.UnitInfo>}
 */
proto.SC2APIProtocol.CargoPanel.prototype.getPassengersList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.UnitInfo>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.UnitInfo, 2));
};


/** @param {!Array.<!proto.SC2APIProtocol.UnitInfo>} value */
proto.SC2APIProtocol.CargoPanel.prototype.setPassengersList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.SC2APIProtocol.UnitInfo=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.UnitInfo}
 */
proto.SC2APIProtocol.CargoPanel.prototype.addPassengers = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.SC2APIProtocol.UnitInfo, opt_index);
};


proto.SC2APIProtocol.CargoPanel.prototype.clearPassengersList = function() {
  this.setPassengersList([]);
};


/**
 * optional int32 slots_available = 3;
 * @return {number}
 */
proto.SC2APIProtocol.CargoPanel.prototype.getSlotsAvailable = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.CargoPanel.prototype.setSlotsAvailable = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SC2APIProtocol.CargoPanel.prototype.clearSlotsAvailable = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.CargoPanel.prototype.hasSlotsAvailable = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.BuildItem = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.BuildItem, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.BuildItem.displayName = 'proto.SC2APIProtocol.BuildItem';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.BuildItem.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.BuildItem.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.BuildItem} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.BuildItem.toObject = function(includeInstance, msg) {
  var f, obj = {
    abilityId: jspb.Message.getField(msg, 1),
    buildProgress: jspb.Message.getOptionalFloatingPointField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.BuildItem}
 */
proto.SC2APIProtocol.BuildItem.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.BuildItem;
  return proto.SC2APIProtocol.BuildItem.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.BuildItem} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.BuildItem}
 */
proto.SC2APIProtocol.BuildItem.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAbilityId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setBuildProgress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.BuildItem.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.BuildItem.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.BuildItem} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.BuildItem.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeFloat(
      2,
      f
    );
  }
};


/**
 * optional uint32 ability_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.BuildItem.prototype.getAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.BuildItem.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.BuildItem.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.BuildItem.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float build_progress = 2;
 * @return {number}
 */
proto.SC2APIProtocol.BuildItem.prototype.getBuildProgress = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.SC2APIProtocol.BuildItem.prototype.setBuildProgress = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.BuildItem.prototype.clearBuildProgress = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.BuildItem.prototype.hasBuildProgress = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ProductionPanel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SC2APIProtocol.ProductionPanel.repeatedFields_, null);
};
goog.inherits(proto.SC2APIProtocol.ProductionPanel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ProductionPanel.displayName = 'proto.SC2APIProtocol.ProductionPanel';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SC2APIProtocol.ProductionPanel.repeatedFields_ = [2,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ProductionPanel.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ProductionPanel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ProductionPanel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ProductionPanel.toObject = function(includeInstance, msg) {
  var f, obj = {
    unit: (f = msg.getUnit()) && proto.SC2APIProtocol.UnitInfo.toObject(includeInstance, f),
    buildQueueList: jspb.Message.toObjectList(msg.getBuildQueueList(),
    proto.SC2APIProtocol.UnitInfo.toObject, includeInstance),
    productionQueueList: jspb.Message.toObjectList(msg.getProductionQueueList(),
    proto.SC2APIProtocol.BuildItem.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ProductionPanel}
 */
proto.SC2APIProtocol.ProductionPanel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ProductionPanel;
  return proto.SC2APIProtocol.ProductionPanel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ProductionPanel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ProductionPanel}
 */
proto.SC2APIProtocol.ProductionPanel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.UnitInfo;
      reader.readMessage(value,proto.SC2APIProtocol.UnitInfo.deserializeBinaryFromReader);
      msg.setUnit(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.UnitInfo;
      reader.readMessage(value,proto.SC2APIProtocol.UnitInfo.deserializeBinaryFromReader);
      msg.addBuildQueue(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.BuildItem;
      reader.readMessage(value,proto.SC2APIProtocol.BuildItem.deserializeBinaryFromReader);
      msg.addProductionQueue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ProductionPanel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ProductionPanel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ProductionPanel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ProductionPanel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUnit();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.UnitInfo.serializeBinaryToWriter
    );
  }
  f = message.getBuildQueueList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.SC2APIProtocol.UnitInfo.serializeBinaryToWriter
    );
  }
  f = message.getProductionQueueList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.SC2APIProtocol.BuildItem.serializeBinaryToWriter
    );
  }
};


/**
 * optional UnitInfo unit = 1;
 * @return {?proto.SC2APIProtocol.UnitInfo}
 */
proto.SC2APIProtocol.ProductionPanel.prototype.getUnit = function() {
  return /** @type{?proto.SC2APIProtocol.UnitInfo} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.UnitInfo, 1));
};


/** @param {?proto.SC2APIProtocol.UnitInfo|undefined} value */
proto.SC2APIProtocol.ProductionPanel.prototype.setUnit = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SC2APIProtocol.ProductionPanel.prototype.clearUnit = function() {
  this.setUnit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ProductionPanel.prototype.hasUnit = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated UnitInfo build_queue = 2;
 * @return {!Array.<!proto.SC2APIProtocol.UnitInfo>}
 */
proto.SC2APIProtocol.ProductionPanel.prototype.getBuildQueueList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.UnitInfo>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.UnitInfo, 2));
};


/** @param {!Array.<!proto.SC2APIProtocol.UnitInfo>} value */
proto.SC2APIProtocol.ProductionPanel.prototype.setBuildQueueList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.SC2APIProtocol.UnitInfo=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.UnitInfo}
 */
proto.SC2APIProtocol.ProductionPanel.prototype.addBuildQueue = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.SC2APIProtocol.UnitInfo, opt_index);
};


proto.SC2APIProtocol.ProductionPanel.prototype.clearBuildQueueList = function() {
  this.setBuildQueueList([]);
};


/**
 * repeated BuildItem production_queue = 3;
 * @return {!Array.<!proto.SC2APIProtocol.BuildItem>}
 */
proto.SC2APIProtocol.ProductionPanel.prototype.getProductionQueueList = function() {
  return /** @type{!Array.<!proto.SC2APIProtocol.BuildItem>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.SC2APIProtocol.BuildItem, 3));
};


/** @param {!Array.<!proto.SC2APIProtocol.BuildItem>} value */
proto.SC2APIProtocol.ProductionPanel.prototype.setProductionQueueList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.SC2APIProtocol.BuildItem=} opt_value
 * @param {number=} opt_index
 * @return {!proto.SC2APIProtocol.BuildItem}
 */
proto.SC2APIProtocol.ProductionPanel.prototype.addProductionQueue = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.SC2APIProtocol.BuildItem, opt_index);
};


proto.SC2APIProtocol.ProductionPanel.prototype.clearProductionQueueList = function() {
  this.setProductionQueueList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionUI = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.SC2APIProtocol.ActionUI.oneofGroups_);
};
goog.inherits(proto.SC2APIProtocol.ActionUI, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionUI.displayName = 'proto.SC2APIProtocol.ActionUI';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.SC2APIProtocol.ActionUI.oneofGroups_ = [[1,2,3,4,5,6,7,8,9]];

/**
 * @enum {number}
 */
proto.SC2APIProtocol.ActionUI.ActionCase = {
  ACTION_NOT_SET: 0,
  CONTROL_GROUP: 1,
  SELECT_ARMY: 2,
  SELECT_WARP_GATES: 3,
  SELECT_LARVA: 4,
  SELECT_IDLE_WORKER: 5,
  MULTI_PANEL: 6,
  CARGO_PANEL: 7,
  PRODUCTION_PANEL: 8,
  TOGGLE_AUTOCAST: 9
};

/**
 * @return {proto.SC2APIProtocol.ActionUI.ActionCase}
 */
proto.SC2APIProtocol.ActionUI.prototype.getActionCase = function() {
  return /** @type {proto.SC2APIProtocol.ActionUI.ActionCase} */(jspb.Message.computeOneofCase(this, proto.SC2APIProtocol.ActionUI.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionUI.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionUI.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionUI} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionUI.toObject = function(includeInstance, msg) {
  var f, obj = {
    controlGroup: (f = msg.getControlGroup()) && proto.SC2APIProtocol.ActionControlGroup.toObject(includeInstance, f),
    selectArmy: (f = msg.getSelectArmy()) && proto.SC2APIProtocol.ActionSelectArmy.toObject(includeInstance, f),
    selectWarpGates: (f = msg.getSelectWarpGates()) && proto.SC2APIProtocol.ActionSelectWarpGates.toObject(includeInstance, f),
    selectLarva: (f = msg.getSelectLarva()) && proto.SC2APIProtocol.ActionSelectLarva.toObject(includeInstance, f),
    selectIdleWorker: (f = msg.getSelectIdleWorker()) && proto.SC2APIProtocol.ActionSelectIdleWorker.toObject(includeInstance, f),
    multiPanel: (f = msg.getMultiPanel()) && proto.SC2APIProtocol.ActionMultiPanel.toObject(includeInstance, f),
    cargoPanel: (f = msg.getCargoPanel()) && proto.SC2APIProtocol.ActionCargoPanelUnload.toObject(includeInstance, f),
    productionPanel: (f = msg.getProductionPanel()) && proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.toObject(includeInstance, f),
    toggleAutocast: (f = msg.getToggleAutocast()) && proto.SC2APIProtocol.ActionToggleAutocast.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionUI}
 */
proto.SC2APIProtocol.ActionUI.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionUI;
  return proto.SC2APIProtocol.ActionUI.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionUI} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionUI}
 */
proto.SC2APIProtocol.ActionUI.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.SC2APIProtocol.ActionControlGroup;
      reader.readMessage(value,proto.SC2APIProtocol.ActionControlGroup.deserializeBinaryFromReader);
      msg.setControlGroup(value);
      break;
    case 2:
      var value = new proto.SC2APIProtocol.ActionSelectArmy;
      reader.readMessage(value,proto.SC2APIProtocol.ActionSelectArmy.deserializeBinaryFromReader);
      msg.setSelectArmy(value);
      break;
    case 3:
      var value = new proto.SC2APIProtocol.ActionSelectWarpGates;
      reader.readMessage(value,proto.SC2APIProtocol.ActionSelectWarpGates.deserializeBinaryFromReader);
      msg.setSelectWarpGates(value);
      break;
    case 4:
      var value = new proto.SC2APIProtocol.ActionSelectLarva;
      reader.readMessage(value,proto.SC2APIProtocol.ActionSelectLarva.deserializeBinaryFromReader);
      msg.setSelectLarva(value);
      break;
    case 5:
      var value = new proto.SC2APIProtocol.ActionSelectIdleWorker;
      reader.readMessage(value,proto.SC2APIProtocol.ActionSelectIdleWorker.deserializeBinaryFromReader);
      msg.setSelectIdleWorker(value);
      break;
    case 6:
      var value = new proto.SC2APIProtocol.ActionMultiPanel;
      reader.readMessage(value,proto.SC2APIProtocol.ActionMultiPanel.deserializeBinaryFromReader);
      msg.setMultiPanel(value);
      break;
    case 7:
      var value = new proto.SC2APIProtocol.ActionCargoPanelUnload;
      reader.readMessage(value,proto.SC2APIProtocol.ActionCargoPanelUnload.deserializeBinaryFromReader);
      msg.setCargoPanel(value);
      break;
    case 8:
      var value = new proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue;
      reader.readMessage(value,proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.deserializeBinaryFromReader);
      msg.setProductionPanel(value);
      break;
    case 9:
      var value = new proto.SC2APIProtocol.ActionToggleAutocast;
      reader.readMessage(value,proto.SC2APIProtocol.ActionToggleAutocast.deserializeBinaryFromReader);
      msg.setToggleAutocast(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionUI.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionUI.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionUI} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionUI.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getControlGroup();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.SC2APIProtocol.ActionControlGroup.serializeBinaryToWriter
    );
  }
  f = message.getSelectArmy();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.SC2APIProtocol.ActionSelectArmy.serializeBinaryToWriter
    );
  }
  f = message.getSelectWarpGates();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SC2APIProtocol.ActionSelectWarpGates.serializeBinaryToWriter
    );
  }
  f = message.getSelectLarva();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.SC2APIProtocol.ActionSelectLarva.serializeBinaryToWriter
    );
  }
  f = message.getSelectIdleWorker();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.SC2APIProtocol.ActionSelectIdleWorker.serializeBinaryToWriter
    );
  }
  f = message.getMultiPanel();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.SC2APIProtocol.ActionMultiPanel.serializeBinaryToWriter
    );
  }
  f = message.getCargoPanel();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.SC2APIProtocol.ActionCargoPanelUnload.serializeBinaryToWriter
    );
  }
  f = message.getProductionPanel();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.serializeBinaryToWriter
    );
  }
  f = message.getToggleAutocast();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      proto.SC2APIProtocol.ActionToggleAutocast.serializeBinaryToWriter
    );
  }
};


/**
 * optional ActionControlGroup control_group = 1;
 * @return {?proto.SC2APIProtocol.ActionControlGroup}
 */
proto.SC2APIProtocol.ActionUI.prototype.getControlGroup = function() {
  return /** @type{?proto.SC2APIProtocol.ActionControlGroup} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionControlGroup, 1));
};


/** @param {?proto.SC2APIProtocol.ActionControlGroup|undefined} value */
proto.SC2APIProtocol.ActionUI.prototype.setControlGroup = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.SC2APIProtocol.ActionUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionUI.prototype.clearControlGroup = function() {
  this.setControlGroup(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionUI.prototype.hasControlGroup = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ActionSelectArmy select_army = 2;
 * @return {?proto.SC2APIProtocol.ActionSelectArmy}
 */
proto.SC2APIProtocol.ActionUI.prototype.getSelectArmy = function() {
  return /** @type{?proto.SC2APIProtocol.ActionSelectArmy} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionSelectArmy, 2));
};


/** @param {?proto.SC2APIProtocol.ActionSelectArmy|undefined} value */
proto.SC2APIProtocol.ActionUI.prototype.setSelectArmy = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.SC2APIProtocol.ActionUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionUI.prototype.clearSelectArmy = function() {
  this.setSelectArmy(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionUI.prototype.hasSelectArmy = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ActionSelectWarpGates select_warp_gates = 3;
 * @return {?proto.SC2APIProtocol.ActionSelectWarpGates}
 */
proto.SC2APIProtocol.ActionUI.prototype.getSelectWarpGates = function() {
  return /** @type{?proto.SC2APIProtocol.ActionSelectWarpGates} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionSelectWarpGates, 3));
};


/** @param {?proto.SC2APIProtocol.ActionSelectWarpGates|undefined} value */
proto.SC2APIProtocol.ActionUI.prototype.setSelectWarpGates = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.SC2APIProtocol.ActionUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionUI.prototype.clearSelectWarpGates = function() {
  this.setSelectWarpGates(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionUI.prototype.hasSelectWarpGates = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional ActionSelectLarva select_larva = 4;
 * @return {?proto.SC2APIProtocol.ActionSelectLarva}
 */
proto.SC2APIProtocol.ActionUI.prototype.getSelectLarva = function() {
  return /** @type{?proto.SC2APIProtocol.ActionSelectLarva} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionSelectLarva, 4));
};


/** @param {?proto.SC2APIProtocol.ActionSelectLarva|undefined} value */
proto.SC2APIProtocol.ActionUI.prototype.setSelectLarva = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.SC2APIProtocol.ActionUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionUI.prototype.clearSelectLarva = function() {
  this.setSelectLarva(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionUI.prototype.hasSelectLarva = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional ActionSelectIdleWorker select_idle_worker = 5;
 * @return {?proto.SC2APIProtocol.ActionSelectIdleWorker}
 */
proto.SC2APIProtocol.ActionUI.prototype.getSelectIdleWorker = function() {
  return /** @type{?proto.SC2APIProtocol.ActionSelectIdleWorker} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionSelectIdleWorker, 5));
};


/** @param {?proto.SC2APIProtocol.ActionSelectIdleWorker|undefined} value */
proto.SC2APIProtocol.ActionUI.prototype.setSelectIdleWorker = function(value) {
  jspb.Message.setOneofWrapperField(this, 5, proto.SC2APIProtocol.ActionUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionUI.prototype.clearSelectIdleWorker = function() {
  this.setSelectIdleWorker(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionUI.prototype.hasSelectIdleWorker = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional ActionMultiPanel multi_panel = 6;
 * @return {?proto.SC2APIProtocol.ActionMultiPanel}
 */
proto.SC2APIProtocol.ActionUI.prototype.getMultiPanel = function() {
  return /** @type{?proto.SC2APIProtocol.ActionMultiPanel} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionMultiPanel, 6));
};


/** @param {?proto.SC2APIProtocol.ActionMultiPanel|undefined} value */
proto.SC2APIProtocol.ActionUI.prototype.setMultiPanel = function(value) {
  jspb.Message.setOneofWrapperField(this, 6, proto.SC2APIProtocol.ActionUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionUI.prototype.clearMultiPanel = function() {
  this.setMultiPanel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionUI.prototype.hasMultiPanel = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional ActionCargoPanelUnload cargo_panel = 7;
 * @return {?proto.SC2APIProtocol.ActionCargoPanelUnload}
 */
proto.SC2APIProtocol.ActionUI.prototype.getCargoPanel = function() {
  return /** @type{?proto.SC2APIProtocol.ActionCargoPanelUnload} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionCargoPanelUnload, 7));
};


/** @param {?proto.SC2APIProtocol.ActionCargoPanelUnload|undefined} value */
proto.SC2APIProtocol.ActionUI.prototype.setCargoPanel = function(value) {
  jspb.Message.setOneofWrapperField(this, 7, proto.SC2APIProtocol.ActionUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionUI.prototype.clearCargoPanel = function() {
  this.setCargoPanel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionUI.prototype.hasCargoPanel = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional ActionProductionPanelRemoveFromQueue production_panel = 8;
 * @return {?proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue}
 */
proto.SC2APIProtocol.ActionUI.prototype.getProductionPanel = function() {
  return /** @type{?proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue, 8));
};


/** @param {?proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue|undefined} value */
proto.SC2APIProtocol.ActionUI.prototype.setProductionPanel = function(value) {
  jspb.Message.setOneofWrapperField(this, 8, proto.SC2APIProtocol.ActionUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionUI.prototype.clearProductionPanel = function() {
  this.setProductionPanel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionUI.prototype.hasProductionPanel = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional ActionToggleAutocast toggle_autocast = 9;
 * @return {?proto.SC2APIProtocol.ActionToggleAutocast}
 */
proto.SC2APIProtocol.ActionUI.prototype.getToggleAutocast = function() {
  return /** @type{?proto.SC2APIProtocol.ActionToggleAutocast} */ (
    jspb.Message.getWrapperField(this, proto.SC2APIProtocol.ActionToggleAutocast, 9));
};


/** @param {?proto.SC2APIProtocol.ActionToggleAutocast|undefined} value */
proto.SC2APIProtocol.ActionUI.prototype.setToggleAutocast = function(value) {
  jspb.Message.setOneofWrapperField(this, 9, proto.SC2APIProtocol.ActionUI.oneofGroups_[0], value);
};


proto.SC2APIProtocol.ActionUI.prototype.clearToggleAutocast = function() {
  this.setToggleAutocast(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionUI.prototype.hasToggleAutocast = function() {
  return jspb.Message.getField(this, 9) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionControlGroup = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionControlGroup, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionControlGroup.displayName = 'proto.SC2APIProtocol.ActionControlGroup';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionControlGroup.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionControlGroup.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionControlGroup} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionControlGroup.toObject = function(includeInstance, msg) {
  var f, obj = {
    action: jspb.Message.getField(msg, 1),
    controlGroupIndex: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionControlGroup}
 */
proto.SC2APIProtocol.ActionControlGroup.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionControlGroup;
  return proto.SC2APIProtocol.ActionControlGroup.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionControlGroup} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionControlGroup}
 */
proto.SC2APIProtocol.ActionControlGroup.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.ActionControlGroup.ControlGroupAction} */ (reader.readEnum());
      msg.setAction(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setControlGroupIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionControlGroup.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionControlGroup.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionControlGroup} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionControlGroup.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.ActionControlGroup.ControlGroupAction} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.ActionControlGroup.ControlGroupAction = {
  RECALL: 1,
  SET: 2,
  APPEND: 3,
  SETANDSTEAL: 4,
  APPENDANDSTEAL: 5
};

/**
 * optional ControlGroupAction action = 1;
 * @return {!proto.SC2APIProtocol.ActionControlGroup.ControlGroupAction}
 */
proto.SC2APIProtocol.ActionControlGroup.prototype.getAction = function() {
  return /** @type {!proto.SC2APIProtocol.ActionControlGroup.ControlGroupAction} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.ActionControlGroup.ControlGroupAction} value */
proto.SC2APIProtocol.ActionControlGroup.prototype.setAction = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionControlGroup.prototype.clearAction = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionControlGroup.prototype.hasAction = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 control_group_index = 2;
 * @return {number}
 */
proto.SC2APIProtocol.ActionControlGroup.prototype.getControlGroupIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionControlGroup.prototype.setControlGroupIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ActionControlGroup.prototype.clearControlGroupIndex = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionControlGroup.prototype.hasControlGroupIndex = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionSelectArmy = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionSelectArmy, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionSelectArmy.displayName = 'proto.SC2APIProtocol.ActionSelectArmy';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionSelectArmy.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionSelectArmy.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionSelectArmy} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSelectArmy.toObject = function(includeInstance, msg) {
  var f, obj = {
    selectionAdd: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionSelectArmy}
 */
proto.SC2APIProtocol.ActionSelectArmy.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionSelectArmy;
  return proto.SC2APIProtocol.ActionSelectArmy.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionSelectArmy} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionSelectArmy}
 */
proto.SC2APIProtocol.ActionSelectArmy.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSelectionAdd(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionSelectArmy.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionSelectArmy.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionSelectArmy} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSelectArmy.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {boolean} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * optional bool selection_add = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.ActionSelectArmy.prototype.getSelectionAdd = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.ActionSelectArmy.prototype.setSelectionAdd = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionSelectArmy.prototype.clearSelectionAdd = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSelectArmy.prototype.hasSelectionAdd = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionSelectWarpGates = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionSelectWarpGates, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionSelectWarpGates.displayName = 'proto.SC2APIProtocol.ActionSelectWarpGates';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionSelectWarpGates.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionSelectWarpGates.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionSelectWarpGates} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSelectWarpGates.toObject = function(includeInstance, msg) {
  var f, obj = {
    selectionAdd: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionSelectWarpGates}
 */
proto.SC2APIProtocol.ActionSelectWarpGates.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionSelectWarpGates;
  return proto.SC2APIProtocol.ActionSelectWarpGates.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionSelectWarpGates} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionSelectWarpGates}
 */
proto.SC2APIProtocol.ActionSelectWarpGates.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSelectionAdd(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionSelectWarpGates.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionSelectWarpGates.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionSelectWarpGates} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSelectWarpGates.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {boolean} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * optional bool selection_add = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SC2APIProtocol.ActionSelectWarpGates.prototype.getSelectionAdd = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.SC2APIProtocol.ActionSelectWarpGates.prototype.setSelectionAdd = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionSelectWarpGates.prototype.clearSelectionAdd = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSelectWarpGates.prototype.hasSelectionAdd = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionSelectLarva = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionSelectLarva, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionSelectLarva.displayName = 'proto.SC2APIProtocol.ActionSelectLarva';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionSelectLarva.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionSelectLarva.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionSelectLarva} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSelectLarva.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionSelectLarva}
 */
proto.SC2APIProtocol.ActionSelectLarva.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionSelectLarva;
  return proto.SC2APIProtocol.ActionSelectLarva.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionSelectLarva} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionSelectLarva}
 */
proto.SC2APIProtocol.ActionSelectLarva.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionSelectLarva.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionSelectLarva.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionSelectLarva} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSelectLarva.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionSelectIdleWorker = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionSelectIdleWorker, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionSelectIdleWorker.displayName = 'proto.SC2APIProtocol.ActionSelectIdleWorker';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionSelectIdleWorker.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionSelectIdleWorker.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionSelectIdleWorker} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSelectIdleWorker.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionSelectIdleWorker}
 */
proto.SC2APIProtocol.ActionSelectIdleWorker.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionSelectIdleWorker;
  return proto.SC2APIProtocol.ActionSelectIdleWorker.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionSelectIdleWorker} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionSelectIdleWorker}
 */
proto.SC2APIProtocol.ActionSelectIdleWorker.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.ActionSelectIdleWorker.Type} */ (reader.readEnum());
      msg.setType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionSelectIdleWorker.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionSelectIdleWorker.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionSelectIdleWorker} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionSelectIdleWorker.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.ActionSelectIdleWorker.Type} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.ActionSelectIdleWorker.Type = {
  SET: 1,
  ADD: 2,
  ALL: 3,
  ADDALL: 4
};

/**
 * optional Type type = 1;
 * @return {!proto.SC2APIProtocol.ActionSelectIdleWorker.Type}
 */
proto.SC2APIProtocol.ActionSelectIdleWorker.prototype.getType = function() {
  return /** @type {!proto.SC2APIProtocol.ActionSelectIdleWorker.Type} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.ActionSelectIdleWorker.Type} value */
proto.SC2APIProtocol.ActionSelectIdleWorker.prototype.setType = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionSelectIdleWorker.prototype.clearType = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionSelectIdleWorker.prototype.hasType = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionMultiPanel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionMultiPanel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionMultiPanel.displayName = 'proto.SC2APIProtocol.ActionMultiPanel';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionMultiPanel.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionMultiPanel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionMultiPanel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionMultiPanel.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getField(msg, 1),
    unitIndex: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionMultiPanel}
 */
proto.SC2APIProtocol.ActionMultiPanel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionMultiPanel;
  return proto.SC2APIProtocol.ActionMultiPanel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionMultiPanel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionMultiPanel}
 */
proto.SC2APIProtocol.ActionMultiPanel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.SC2APIProtocol.ActionMultiPanel.Type} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setUnitIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionMultiPanel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionMultiPanel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionMultiPanel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionMultiPanel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.SC2APIProtocol.ActionMultiPanel.Type} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.SC2APIProtocol.ActionMultiPanel.Type = {
  SINGLESELECT: 1,
  DESELECTUNIT: 2,
  SELECTALLOFTYPE: 3,
  DESELECTALLOFTYPE: 4
};

/**
 * optional Type type = 1;
 * @return {!proto.SC2APIProtocol.ActionMultiPanel.Type}
 */
proto.SC2APIProtocol.ActionMultiPanel.prototype.getType = function() {
  return /** @type {!proto.SC2APIProtocol.ActionMultiPanel.Type} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.SC2APIProtocol.ActionMultiPanel.Type} value */
proto.SC2APIProtocol.ActionMultiPanel.prototype.setType = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionMultiPanel.prototype.clearType = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionMultiPanel.prototype.hasType = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int32 unit_index = 2;
 * @return {number}
 */
proto.SC2APIProtocol.ActionMultiPanel.prototype.getUnitIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionMultiPanel.prototype.setUnitIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SC2APIProtocol.ActionMultiPanel.prototype.clearUnitIndex = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionMultiPanel.prototype.hasUnitIndex = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionCargoPanelUnload = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionCargoPanelUnload, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionCargoPanelUnload.displayName = 'proto.SC2APIProtocol.ActionCargoPanelUnload';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionCargoPanelUnload.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionCargoPanelUnload.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionCargoPanelUnload} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionCargoPanelUnload.toObject = function(includeInstance, msg) {
  var f, obj = {
    unitIndex: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionCargoPanelUnload}
 */
proto.SC2APIProtocol.ActionCargoPanelUnload.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionCargoPanelUnload;
  return proto.SC2APIProtocol.ActionCargoPanelUnload.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionCargoPanelUnload} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionCargoPanelUnload}
 */
proto.SC2APIProtocol.ActionCargoPanelUnload.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setUnitIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionCargoPanelUnload.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionCargoPanelUnload.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionCargoPanelUnload} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionCargoPanelUnload.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 unit_index = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ActionCargoPanelUnload.prototype.getUnitIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionCargoPanelUnload.prototype.setUnitIndex = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionCargoPanelUnload.prototype.clearUnitIndex = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionCargoPanelUnload.prototype.hasUnitIndex = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.displayName = 'proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.toObject = function(includeInstance, msg) {
  var f, obj = {
    unitIndex: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue}
 */
proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue;
  return proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue}
 */
proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setUnitIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 unit_index = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.prototype.getUnitIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.prototype.setUnitIndex = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.prototype.clearUnitIndex = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.prototype.hasUnitIndex = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SC2APIProtocol.ActionToggleAutocast = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SC2APIProtocol.ActionToggleAutocast, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SC2APIProtocol.ActionToggleAutocast.displayName = 'proto.SC2APIProtocol.ActionToggleAutocast';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SC2APIProtocol.ActionToggleAutocast.prototype.toObject = function(opt_includeInstance) {
  return proto.SC2APIProtocol.ActionToggleAutocast.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SC2APIProtocol.ActionToggleAutocast} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionToggleAutocast.toObject = function(includeInstance, msg) {
  var f, obj = {
    abilityId: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SC2APIProtocol.ActionToggleAutocast}
 */
proto.SC2APIProtocol.ActionToggleAutocast.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SC2APIProtocol.ActionToggleAutocast;
  return proto.SC2APIProtocol.ActionToggleAutocast.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SC2APIProtocol.ActionToggleAutocast} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SC2APIProtocol.ActionToggleAutocast}
 */
proto.SC2APIProtocol.ActionToggleAutocast.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAbilityId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SC2APIProtocol.ActionToggleAutocast.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SC2APIProtocol.ActionToggleAutocast.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SC2APIProtocol.ActionToggleAutocast} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SC2APIProtocol.ActionToggleAutocast.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 ability_id = 1;
 * @return {number}
 */
proto.SC2APIProtocol.ActionToggleAutocast.prototype.getAbilityId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SC2APIProtocol.ActionToggleAutocast.prototype.setAbilityId = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SC2APIProtocol.ActionToggleAutocast.prototype.clearAbilityId = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SC2APIProtocol.ActionToggleAutocast.prototype.hasAbilityId = function() {
  return jspb.Message.getField(this, 1) != null;
};


goog.object.extend(exports, proto.SC2APIProtocol);

},{"google-protobuf":68}],114:[function(require,module,exports){
// Copyright (C) 2011 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Install a leaky WeakMap emulation on platforms that
 * don't provide a built-in one.
 *
 * <p>Assumes that an ES5 platform where, if {@code WeakMap} is
 * already present, then it conforms to the anticipated ES6
 * specification. To run this file on an ES5 or almost ES5
 * implementation where the {@code WeakMap} specification does not
 * quite conform, run <code>repairES5.js</code> first.
 *
 * <p>Even though WeakMapModule is not global, the linter thinks it
 * is, which is why it is in the overrides list below.
 *
 * <p>NOTE: Before using this WeakMap emulation in a non-SES
 * environment, see the note below about hiddenRecord.
 *
 * @author Mark S. Miller
 * @requires crypto, ArrayBuffer, Uint8Array, navigator, console
 * @overrides WeakMap, ses, Proxy
 * @overrides WeakMapModule
 */

/**
 * This {@code WeakMap} emulation is observably equivalent to the
 * ES-Harmony WeakMap, but with leakier garbage collection properties.
 *
 * <p>As with true WeakMaps, in this emulation, a key does not
 * retain maps indexed by that key and (crucially) a map does not
 * retain the keys it indexes. A map by itself also does not retain
 * the values associated with that map.
 *
 * <p>However, the values associated with a key in some map are
 * retained so long as that key is retained and those associations are
 * not overridden. For example, when used to support membranes, all
 * values exported from a given membrane will live for the lifetime
 * they would have had in the absence of an interposed membrane. Even
 * when the membrane is revoked, all objects that would have been
 * reachable in the absence of revocation will still be reachable, as
 * far as the GC can tell, even though they will no longer be relevant
 * to ongoing computation.
 *
 * <p>The API implemented here is approximately the API as implemented
 * in FF6.0a1 and agreed to by MarkM, Andreas Gal, and Dave Herman,
 * rather than the offially approved proposal page. TODO(erights):
 * upgrade the ecmascript WeakMap proposal page to explain this API
 * change and present to EcmaScript committee for their approval.
 *
 * <p>The first difference between the emulation here and that in
 * FF6.0a1 is the presence of non enumerable {@code get___, has___,
 * set___, and delete___} methods on WeakMap instances to represent
 * what would be the hidden internal properties of a primitive
 * implementation. Whereas the FF6.0a1 WeakMap.prototype methods
 * require their {@code this} to be a genuine WeakMap instance (i.e.,
 * an object of {@code [[Class]]} "WeakMap}), since there is nothing
 * unforgeable about the pseudo-internal method names used here,
 * nothing prevents these emulated prototype methods from being
 * applied to non-WeakMaps with pseudo-internal methods of the same
 * names.
 *
 * <p>Another difference is that our emulated {@code
 * WeakMap.prototype} is not itself a WeakMap. A problem with the
 * current FF6.0a1 API is that WeakMap.prototype is itself a WeakMap
 * providing ambient mutability and an ambient communications
 * channel. Thus, if a WeakMap is already present and has this
 * problem, repairES5.js wraps it in a safe wrappper in order to
 * prevent access to this channel. (See
 * PATCH_MUTABLE_FROZEN_WEAKMAP_PROTO in repairES5.js).
 */

/**
 * If this is a full <a href=
 * "http://code.google.com/p/es-lab/wiki/SecureableES5"
 * >secureable ES5</a> platform and the ES-Harmony {@code WeakMap} is
 * absent, install an approximate emulation.
 *
 * <p>If WeakMap is present but cannot store some objects, use our approximate
 * emulation as a wrapper.
 *
 * <p>If this is almost a secureable ES5 platform, then WeakMap.js
 * should be run after repairES5.js.
 *
 * <p>See {@code WeakMap} for documentation of the garbage collection
 * properties of this WeakMap emulation.
 */
(function WeakMapModule() {
  "use strict";

  if (typeof ses !== 'undefined' && ses.ok && !ses.ok()) {
    // already too broken, so give up
    return;
  }

  /**
   * In some cases (current Firefox), we must make a choice betweeen a
   * WeakMap which is capable of using all varieties of host objects as
   * keys and one which is capable of safely using proxies as keys. See
   * comments below about HostWeakMap and DoubleWeakMap for details.
   *
   * This function (which is a global, not exposed to guests) marks a
   * WeakMap as permitted to do what is necessary to index all host
   * objects, at the cost of making it unsafe for proxies.
   *
   * Do not apply this function to anything which is not a genuine
   * fresh WeakMap.
   */
  function weakMapPermitHostObjects(map) {
    // identity of function used as a secret -- good enough and cheap
    if (map.permitHostObjects___) {
      map.permitHostObjects___(weakMapPermitHostObjects);
    }
  }
  if (typeof ses !== 'undefined') {
    ses.weakMapPermitHostObjects = weakMapPermitHostObjects;
  }

  // IE 11 has no Proxy but has a broken WeakMap such that we need to patch
  // it using DoubleWeakMap; this flag tells DoubleWeakMap so.
  var doubleWeakMapCheckSilentFailure = false;

  // Check if there is already a good-enough WeakMap implementation, and if so
  // exit without replacing it.
  if (typeof WeakMap === 'function') {
    var HostWeakMap = WeakMap;
    // There is a WeakMap -- is it good enough?
    if (typeof navigator !== 'undefined' &&
        /Firefox/.test(navigator.userAgent)) {
      // We're now *assuming not*, because as of this writing (2013-05-06)
      // Firefox's WeakMaps have a miscellany of objects they won't accept, and
      // we don't want to make an exhaustive list, and testing for just one
      // will be a problem if that one is fixed alone (as they did for Event).

      // If there is a platform that we *can* reliably test on, here's how to
      // do it:
      //  var problematic = ... ;
      //  var testHostMap = new HostWeakMap();
      //  try {
      //    testHostMap.set(problematic, 1);  // Firefox 20 will throw here
      //    if (testHostMap.get(problematic) === 1) {
      //      return;
      //    }
      //  } catch (e) {}

    } else {
      // IE 11 bug: WeakMaps silently fail to store frozen objects.
      var testMap = new HostWeakMap();
      var testObject = Object.freeze({});
      testMap.set(testObject, 1);
      if (testMap.get(testObject) !== 1) {
        doubleWeakMapCheckSilentFailure = true;
        // Fall through to installing our WeakMap.
      } else {
        module.exports = WeakMap;
        return;
      }
    }
  }

  var hop = Object.prototype.hasOwnProperty;
  var gopn = Object.getOwnPropertyNames;
  var defProp = Object.defineProperty;
  var isExtensible = Object.isExtensible;

  /**
   * Security depends on HIDDEN_NAME being both <i>unguessable</i> and
   * <i>undiscoverable</i> by untrusted code.
   *
   * <p>Given the known weaknesses of Math.random() on existing
   * browsers, it does not generate unguessability we can be confident
   * of.
   *
   * <p>It is the monkey patching logic in this file that is intended
   * to ensure undiscoverability. The basic idea is that there are
   * three fundamental means of discovering properties of an object:
   * The for/in loop, Object.keys(), and Object.getOwnPropertyNames(),
   * as well as some proposed ES6 extensions that appear on our
   * whitelist. The first two only discover enumerable properties, and
   * we only use HIDDEN_NAME to name a non-enumerable property, so the
   * only remaining threat should be getOwnPropertyNames and some
   * proposed ES6 extensions that appear on our whitelist. We monkey
   * patch them to remove HIDDEN_NAME from the list of properties they
   * returns.
   *
   * <p>TODO(erights): On a platform with built-in Proxies, proxies
   * could be used to trap and thereby discover the HIDDEN_NAME, so we
   * need to monkey patch Proxy.create, Proxy.createFunction, etc, in
   * order to wrap the provided handler with the real handler which
   * filters out all traps using HIDDEN_NAME.
   *
   * <p>TODO(erights): Revisit Mike Stay's suggestion that we use an
   * encapsulated function at a not-necessarily-secret name, which
   * uses the Stiegler shared-state rights amplification pattern to
   * reveal the associated value only to the WeakMap in which this key
   * is associated with that value. Since only the key retains the
   * function, the function can also remember the key without causing
   * leakage of the key, so this doesn't violate our general gc
   * goals. In addition, because the name need not be a guarded
   * secret, we could efficiently handle cross-frame frozen keys.
   */
  var HIDDEN_NAME_PREFIX = 'weakmap:';
  var HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'ident:' + Math.random() + '___';

  if (typeof crypto !== 'undefined' &&
      typeof crypto.getRandomValues === 'function' &&
      typeof ArrayBuffer === 'function' &&
      typeof Uint8Array === 'function') {
    var ab = new ArrayBuffer(25);
    var u8s = new Uint8Array(ab);
    crypto.getRandomValues(u8s);
    HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'rand:' +
      Array.prototype.map.call(u8s, function(u8) {
        return (u8 % 36).toString(36);
      }).join('') + '___';
  }

  function isNotHiddenName(name) {
    return !(
        name.substr(0, HIDDEN_NAME_PREFIX.length) == HIDDEN_NAME_PREFIX &&
        name.substr(name.length - 3) === '___');
  }

  /**
   * Monkey patch getOwnPropertyNames to avoid revealing the
   * HIDDEN_NAME.
   *
   * <p>The ES5.1 spec requires each name to appear only once, but as
   * of this writing, this requirement is controversial for ES6, so we
   * made this code robust against this case. If the resulting extra
   * search turns out to be expensive, we can probably relax this once
   * ES6 is adequately supported on all major browsers, iff no browser
   * versions we support at that time have relaxed this constraint
   * without providing built-in ES6 WeakMaps.
   */
  defProp(Object, 'getOwnPropertyNames', {
    value: function fakeGetOwnPropertyNames(obj) {
      return gopn(obj).filter(isNotHiddenName);
    }
  });

  /**
   * getPropertyNames is not in ES5 but it is proposed for ES6 and
   * does appear in our whitelist, so we need to clean it too.
   */
  if ('getPropertyNames' in Object) {
    var originalGetPropertyNames = Object.getPropertyNames;
    defProp(Object, 'getPropertyNames', {
      value: function fakeGetPropertyNames(obj) {
        return originalGetPropertyNames(obj).filter(isNotHiddenName);
      }
    });
  }

  /**
   * <p>To treat objects as identity-keys with reasonable efficiency
   * on ES5 by itself (i.e., without any object-keyed collections), we
   * need to add a hidden property to such key objects when we
   * can. This raises several issues:
   * <ul>
   * <li>Arranging to add this property to objects before we lose the
   *     chance, and
   * <li>Hiding the existence of this new property from most
   *     JavaScript code.
   * <li>Preventing <i>certification theft</i>, where one object is
   *     created falsely claiming to be the key of an association
   *     actually keyed by another object.
   * <li>Preventing <i>value theft</i>, where untrusted code with
   *     access to a key object but not a weak map nevertheless
   *     obtains access to the value associated with that key in that
   *     weak map.
   * </ul>
   * We do so by
   * <ul>
   * <li>Making the name of the hidden property unguessable, so "[]"
   *     indexing, which we cannot intercept, cannot be used to access
   *     a property without knowing the name.
   * <li>Making the hidden property non-enumerable, so we need not
   *     worry about for-in loops or {@code Object.keys},
   * <li>monkey patching those reflective methods that would
   *     prevent extensions, to add this hidden property first,
   * <li>monkey patching those methods that would reveal this
   *     hidden property.
   * </ul>
   * Unfortunately, because of same-origin iframes, we cannot reliably
   * add this hidden property before an object becomes
   * non-extensible. Instead, if we encounter a non-extensible object
   * without a hidden record that we can detect (whether or not it has
   * a hidden record stored under a name secret to us), then we just
   * use the key object itself to represent its identity in a brute
   * force leaky map stored in the weak map, losing all the advantages
   * of weakness for these.
   */
  function getHiddenRecord(key) {
    if (key !== Object(key)) {
      throw new TypeError('Not an object: ' + key);
    }
    var hiddenRecord = key[HIDDEN_NAME];
    if (hiddenRecord && hiddenRecord.key === key) { return hiddenRecord; }
    if (!isExtensible(key)) {
      // Weak map must brute force, as explained in doc-comment above.
      return void 0;
    }

    // The hiddenRecord and the key point directly at each other, via
    // the "key" and HIDDEN_NAME properties respectively. The key
    // field is for quickly verifying that this hidden record is an
    // own property, not a hidden record from up the prototype chain.
    //
    // NOTE: Because this WeakMap emulation is meant only for systems like
    // SES where Object.prototype is frozen without any numeric
    // properties, it is ok to use an object literal for the hiddenRecord.
    // This has two advantages:
    // * It is much faster in a performance critical place
    // * It avoids relying on Object.create(null), which had been
    //   problematic on Chrome 28.0.1480.0. See
    //   https://code.google.com/p/google-caja/issues/detail?id=1687
    hiddenRecord = { key: key };

    // When using this WeakMap emulation on platforms where
    // Object.prototype might not be frozen and Object.create(null) is
    // reliable, use the following two commented out lines instead.
    // hiddenRecord = Object.create(null);
    // hiddenRecord.key = key;

    // Please contact us if you need this to work on platforms where
    // Object.prototype might not be frozen and
    // Object.create(null) might not be reliable.

    try {
      defProp(key, HIDDEN_NAME, {
        value: hiddenRecord,
        writable: false,
        enumerable: false,
        configurable: false
      });
      return hiddenRecord;
    } catch (error) {
      // Under some circumstances, isExtensible seems to misreport whether
      // the HIDDEN_NAME can be defined.
      // The circumstances have not been isolated, but at least affect
      // Node.js v0.10.26 on TravisCI / Linux, but not the same version of
      // Node.js on OS X.
      return void 0;
    }
  }

  /**
   * Monkey patch operations that would make their argument
   * non-extensible.
   *
   * <p>The monkey patched versions throw a TypeError if their
   * argument is not an object, so it should only be done to functions
   * that should throw a TypeError anyway if their argument is not an
   * object.
   */
  (function(){
    var oldFreeze = Object.freeze;
    defProp(Object, 'freeze', {
      value: function identifyingFreeze(obj) {
        getHiddenRecord(obj);
        return oldFreeze(obj);
      }
    });
    var oldSeal = Object.seal;
    defProp(Object, 'seal', {
      value: function identifyingSeal(obj) {
        getHiddenRecord(obj);
        return oldSeal(obj);
      }
    });
    var oldPreventExtensions = Object.preventExtensions;
    defProp(Object, 'preventExtensions', {
      value: function identifyingPreventExtensions(obj) {
        getHiddenRecord(obj);
        return oldPreventExtensions(obj);
      }
    });
  })();

  function constFunc(func) {
    func.prototype = null;
    return Object.freeze(func);
  }

  var calledAsFunctionWarningDone = false;
  function calledAsFunctionWarning() {
    // Future ES6 WeakMap is currently (2013-09-10) expected to reject WeakMap()
    // but we used to permit it and do it ourselves, so warn only.
    if (!calledAsFunctionWarningDone && typeof console !== 'undefined') {
      calledAsFunctionWarningDone = true;
      console.warn('WeakMap should be invoked as new WeakMap(), not ' +
          'WeakMap(). This will be an error in the future.');
    }
  }

  var nextId = 0;

  var OurWeakMap = function() {
    if (!(this instanceof OurWeakMap)) {  // approximate test for new ...()
      calledAsFunctionWarning();
    }

    // We are currently (12/25/2012) never encountering any prematurely
    // non-extensible keys.
    var keys = []; // brute force for prematurely non-extensible keys.
    var values = []; // brute force for corresponding values.
    var id = nextId++;

    function get___(key, opt_default) {
      var index;
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        return id in hiddenRecord ? hiddenRecord[id] : opt_default;
      } else {
        index = keys.indexOf(key);
        return index >= 0 ? values[index] : opt_default;
      }
    }

    function has___(key) {
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        return id in hiddenRecord;
      } else {
        return keys.indexOf(key) >= 0;
      }
    }

    function set___(key, value) {
      var index;
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        hiddenRecord[id] = value;
      } else {
        index = keys.indexOf(key);
        if (index >= 0) {
          values[index] = value;
        } else {
          // Since some browsers preemptively terminate slow turns but
          // then continue computing with presumably corrupted heap
          // state, we here defensively get keys.length first and then
          // use it to update both the values and keys arrays, keeping
          // them in sync.
          index = keys.length;
          values[index] = value;
          // If we crash here, values will be one longer than keys.
          keys[index] = key;
        }
      }
      return this;
    }

    function delete___(key) {
      var hiddenRecord = getHiddenRecord(key);
      var index, lastIndex;
      if (hiddenRecord) {
        return id in hiddenRecord && delete hiddenRecord[id];
      } else {
        index = keys.indexOf(key);
        if (index < 0) {
          return false;
        }
        // Since some browsers preemptively terminate slow turns but
        // then continue computing with potentially corrupted heap
        // state, we here defensively get keys.length first and then use
        // it to update both the keys and the values array, keeping
        // them in sync. We update the two with an order of assignments,
        // such that any prefix of these assignments will preserve the
        // key/value correspondence, either before or after the delete.
        // Note that this needs to work correctly when index === lastIndex.
        lastIndex = keys.length - 1;
        keys[index] = void 0;
        // If we crash here, there's a void 0 in the keys array, but
        // no operation will cause a "keys.indexOf(void 0)", since
        // getHiddenRecord(void 0) will always throw an error first.
        values[index] = values[lastIndex];
        // If we crash here, values[index] cannot be found here,
        // because keys[index] is void 0.
        keys[index] = keys[lastIndex];
        // If index === lastIndex and we crash here, then keys[index]
        // is still void 0, since the aliasing killed the previous key.
        keys.length = lastIndex;
        // If we crash here, keys will be one shorter than values.
        values.length = lastIndex;
        return true;
      }
    }

    return Object.create(OurWeakMap.prototype, {
      get___:    { value: constFunc(get___) },
      has___:    { value: constFunc(has___) },
      set___:    { value: constFunc(set___) },
      delete___: { value: constFunc(delete___) }
    });
  };

  OurWeakMap.prototype = Object.create(Object.prototype, {
    get: {
      /**
       * Return the value most recently associated with key, or
       * opt_default if none.
       */
      value: function get(key, opt_default) {
        return this.get___(key, opt_default);
      },
      writable: true,
      configurable: true
    },

    has: {
      /**
       * Is there a value associated with key in this WeakMap?
       */
      value: function has(key) {
        return this.has___(key);
      },
      writable: true,
      configurable: true
    },

    set: {
      /**
       * Associate value with key in this WeakMap, overwriting any
       * previous association if present.
       */
      value: function set(key, value) {
        return this.set___(key, value);
      },
      writable: true,
      configurable: true
    },

    'delete': {
      /**
       * Remove any association for key in this WeakMap, returning
       * whether there was one.
       *
       * <p>Note that the boolean return here does not work like the
       * {@code delete} operator. The {@code delete} operator returns
       * whether the deletion succeeds at bringing about a state in
       * which the deleted property is absent. The {@code delete}
       * operator therefore returns true if the property was already
       * absent, whereas this {@code delete} method returns false if
       * the association was already absent.
       */
      value: function remove(key) {
        return this.delete___(key);
      },
      writable: true,
      configurable: true
    }
  });

  if (typeof HostWeakMap === 'function') {
    (function() {
      // If we got here, then the platform has a WeakMap but we are concerned
      // that it may refuse to store some key types. Therefore, make a map
      // implementation which makes use of both as possible.

      // In this mode we are always using double maps, so we are not proxy-safe.
      // This combination does not occur in any known browser, but we had best
      // be safe.
      if (doubleWeakMapCheckSilentFailure && typeof Proxy !== 'undefined') {
        Proxy = undefined;
      }

      function DoubleWeakMap() {
        if (!(this instanceof OurWeakMap)) {  // approximate test for new ...()
          calledAsFunctionWarning();
        }

        // Preferable, truly weak map.
        var hmap = new HostWeakMap();

        // Our hidden-property-based pseudo-weak-map. Lazily initialized in the
        // 'set' implementation; thus we can avoid performing extra lookups if
        // we know all entries actually stored are entered in 'hmap'.
        var omap = undefined;

        // Hidden-property maps are not compatible with proxies because proxies
        // can observe the hidden name and either accidentally expose it or fail
        // to allow the hidden property to be set. Therefore, we do not allow
        // arbitrary WeakMaps to switch to using hidden properties, but only
        // those which need the ability, and unprivileged code is not allowed
        // to set the flag.
        //
        // (Except in doubleWeakMapCheckSilentFailure mode in which case we
        // disable proxies.)
        var enableSwitching = false;

        function dget(key, opt_default) {
          if (omap) {
            return hmap.has(key) ? hmap.get(key)
                : omap.get___(key, opt_default);
          } else {
            return hmap.get(key, opt_default);
          }
        }

        function dhas(key) {
          return hmap.has(key) || (omap ? omap.has___(key) : false);
        }

        var dset;
        if (doubleWeakMapCheckSilentFailure) {
          dset = function(key, value) {
            hmap.set(key, value);
            if (!hmap.has(key)) {
              if (!omap) { omap = new OurWeakMap(); }
              omap.set(key, value);
            }
            return this;
          };
        } else {
          dset = function(key, value) {
            if (enableSwitching) {
              try {
                hmap.set(key, value);
              } catch (e) {
                if (!omap) { omap = new OurWeakMap(); }
                omap.set___(key, value);
              }
            } else {
              hmap.set(key, value);
            }
            return this;
          };
        }

        function ddelete(key) {
          var result = !!hmap['delete'](key);
          if (omap) { return omap.delete___(key) || result; }
          return result;
        }

        return Object.create(OurWeakMap.prototype, {
          get___:    { value: constFunc(dget) },
          has___:    { value: constFunc(dhas) },
          set___:    { value: constFunc(dset) },
          delete___: { value: constFunc(ddelete) },
          permitHostObjects___: { value: constFunc(function(token) {
            if (token === weakMapPermitHostObjects) {
              enableSwitching = true;
            } else {
              throw new Error('bogus call to permitHostObjects___');
            }
          })}
        });
      }
      DoubleWeakMap.prototype = OurWeakMap.prototype;
      module.exports = DoubleWeakMap;

      // define .constructor to hide OurWeakMap ctor
      Object.defineProperty(WeakMap.prototype, 'constructor', {
        value: WeakMap,
        enumerable: false,  // as default .constructor is
        configurable: true,
        writable: true
      });
    })();
  } else {
    // There is no host WeakMap, so we must use the emulation.

    // Emulated WeakMaps are incompatible with native proxies (because proxies
    // can observe the hidden name), so we must disable Proxy usage (in
    // ArrayLike and Domado, currently).
    if (typeof Proxy !== 'undefined') {
      Proxy = undefined;
    }

    module.exports = OurWeakMap;
  }
})();

},{}],115:[function(require,module,exports){
'use strict';

module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};

},{}],"gamejs":[function(require,module,exports){
var matrix = require('./gamejs/math/matrix');
var objects = require('./gamejs/utils/objects');
var Callback = require('./gamejs/utils/callback').Callback;

/**
 * @fileoverview  `gamejs.ready()` is maybe the most important function as it kickstarts your app:
 *
 *     var gamejs = require('gamejs');
 *     ready(function() {
 *         gamejs.logging.info('I am ready!')
 *     });
 *
 * If you use images or sounds preload all assets with `gamejs.preload(['./files/foo.png'])` before calling `ready()`.
 *
 * Also in this module is the `Rect` class which is generally useful when dealing with Surfaces and simple rectangles (e.g. for collisions).
 */
// preloading stuff
var gamejs = exports;
var RESOURCES = {};
/**
 * @ignore
 */
exports.thread = require('./gamejs/thread');


/**
 * ReadyFn is called once all modules and assets are loaded.
 * @param {Function} callbackFunction the function to be called once gamejs finished loading
 * @name ready
 */
if (gamejs.thread.inWorker === true) {
   exports.ready = function(readyFn) {
      require('./gamejs/thread')._ready();
      gamejs.init();
      readyFn();
   };
} else {
   exports.ready = function(readyFn) {

      var getMixerProgress = null;
      var getImageProgress = null;

      // init time instantly - we need it for preloaders
      gamejs.time.init();

      // 2.
      function _ready() {
         if (!document.body) {
            return window.setTimeout(_ready, 50);
         }
         getImageProgress = gamejs.image.preload(RESOURCES);
         try {
            getMixerProgress = gamejs.audio.preload(RESOURCES);
         } catch (e) {
            gamejs.debug('Error loading audio files ', e);
         }
         window.setTimeout(_readyResources, 50);
      }

      // 3.
      function _readyResources() {
         if (getImageProgress() < 1 || getMixerProgress() < 1) {
            return window.setTimeout(_readyResources, 100);
         }
         gamejs.display.init();
         gamejs.image.init();
         gamejs.audio.init();
         gamejs.event.init();
         gamejs.math.random.init();
         readyFn();
      }

      // 1.
      window.setTimeout(_ready, 13);

      function getLoadProgress() {
         if (getImageProgress) {
            return (0.5 * getImageProgress()) + (0.5 * getMixerProgress());
         }
         return 0.1;
      }

      return getLoadProgress;
   };
}

/**
 * Initialize all gamejs modules. This is automatically called
 * by `gamejs.ready()`.
 * @returns {Object} the properties of this objecte are the moduleIds that failed, they value are the exceptions
 * @ignore
 */
exports.init = function() {
   var errorModules = {};
   ['time', 'display', 'image', 'audio', 'event'].forEach(function(moduleName) {
      try {
         gamejs[moduleName].init();
      } catch (e) {
         errorModules[moduleName] = e.toString();
      }
   });
   return errorModules;
};

var resourceBaseHref = function() {
    return (window.$g && window.$g.resourceBaseHref) || document.location.href;
};

/**
 * Preload resources.
 * @param {Array} resources list of resources paths
 * @name preload
 */
var preload = exports.preload = function(resources) {
   var uri = require('./gamejs/utils/uri');
   var baseHref = resourceBaseHref();
   resources.forEach(function(res) {
      RESOURCES[res] = uri.resolve(baseHref, res);
   }, this);
   return;
};

/**
 * The function passed to `onTick` will continously be called at a
 * frequency determined by the browser (typically between 1 and 60 times per second).
 * @param {Function} callbackFunction the function you want to be called
 * @param {Function} callbackScope optional scope for the function call
 */
exports.onTick = function(fn, scope) {
  /** ignore **/
  exports.time._CALLBACKS.push(new Callback(fn, scope));
};

/**
 * Normalize various ways to specify a Rect into {left, top, width, height} form.
 * @ignore
 *
 */
var normalizeRectArguments = exports.normalizeRectArguments = function () {
   var left = 0;
   var top = 0;
   var width = 0;
   var height = 0;

   if (arguments.length === 2) {
      if (arguments[0] instanceof Array && arguments[1] instanceof Array) {
         left = arguments[0][0];
         top = arguments[0][1];
         width = arguments[1][0];
         height = arguments[1][1];
      } else {
         left = arguments[0];
         top = arguments[1];
      }
   } else if (arguments.length === 1 && arguments[0] instanceof Array) {
      left = arguments[0][0];
      top = arguments[0][1];
      width = arguments[0][2];
      height = arguments[0][3];
   } else if (arguments.length === 1 && arguments[0] instanceof Rect) {
      left = arguments[0].left;
      top = arguments[0].top;
      width = arguments[0].width;
      height = arguments[0].height;
   } else if (arguments.length === 4) {
      left = arguments[0];
      top = arguments[1];
      width = arguments[2];
      height = arguments[3];
   } else {
      throw new Error('not a valid rectangle specification');
   }
   return {left: left || 0, top: top || 0, width: width || 0, height: height || 0};
};


/**
 * Creates a Rect. Rects are used to hold rectangular areas. There are a couple
 * of convinient ways to create Rects with different arguments and defaults.
 *
 * Any function that requires a `gamejs.Rect` argument also accepts any of the
 * constructor value combinations `Rect` accepts.
 *
 * Rects are used a lot. They are good for collision detection, specifying
 * an area on the screen (for blitting) or just to hold an objects position.
 *
 * The Rect object has several virtual attributes which can be used to move and align the Rect:
 *
 *   top, left, bottom, right
 *   topleft, bottomleft, topright, bottomright
 *   center
 *   width, height
 *   w,h
 *
 * All of these attributes can be assigned to.
 * Assigning to width or height changes the dimensions of the rectangle; all other
 * assignments move the rectangle without resizing it. Notice that some attributes
 * are Numbers and others are pairs of Numbers.
 *
 * @example
 * new Rect([left, top]) // width & height default to 0
 * new Rect(left, top) // width & height default to 0
 * new Rect(left, top, width, height)
 * new Rect([left, top], [width, height])
 * new Rect(oldRect) // clone of oldRect is created
 *
 * @property {Number} right
 * @property {Number} bottom
 * @property {Number} center
 * @constructor
 * @param {Array|gamejs.Rect} position Array holding left and top coordinates
 * @param {Array} dimensions Array holding width and height
 */
var Rect = exports.Rect = function() {

   var args = normalizeRectArguments.apply(this, arguments);

   /**
    * Left, X coordinate
    * @type Number
    */
   this.left = args.left;

   /**
    * Top, Y coordinate
    * @type Number
    */
   this.top = args.top;

   /**
    * Width of rectangle
    * @type Number
    */
   this.width = args.width;

   /**
    * Height of rectangle
    * @type Number
    */
   this.height = args.height;

   return this;
};

objects.accessors(Rect.prototype, {
   /**
    * Bottom, Y coordinate
    * @name Rect.prototype.bottom
    * @type Number
    */
   'bottom': {
      get: function() {
         return this.top + this.height;
      },
      set: function(newValue) {
         this.top = newValue - this.height;
         return;
      }
   },
   /**
    * Right, X coordinate
    * @name Rect.prototype.right
    * @type Number
    */
   'right': {
      get: function() {
         return this.left + this.width;
      },
      set: function(newValue) {
         this.left = newValue - this.width;
      }
   },
   /**
    * Center Position. You can assign a rectangle form.
    * @name Rect.prototype.center
    * @type Array
    */
   'center': {
      get: function() {
         return [this.left + (this.width / 2) | 0,
                 this.top + (this.height / 2) | 0
                ];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.left = args.left - (this.width / 2) | 0;
         this.top = args.top - (this.height / 2) | 0;
         return;
      }
   },
   /**
    * Top-left Position. You can assign a rectangle form.
    * @name Rect.prototype.topleft
    * @type Array
    */
   'topleft': {
      get: function() {
         return [this.left, this.top];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.left = args.left;
         this.top = args.top;
         return;
      }
   },
   /**
    * Bottom-left Position. You can assign a rectangle form.
    * @name Rect.prototype.bottomleft
    * @type Array
    */
   'bottomleft': {
      get: function() {
         return [this.left, this.bottom];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.left = args.left;
         this.bottom = args.top;
         return;
      }
   },
   /**
    * Top-right Position. You can assign a rectangle form.
    * @name Rect.prototype.topright
    * @type Array
    */
   'topright': {
      get: function() {
         return [this.right, this.top];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.right = args.left;
         this.top = args.top;
         return;
      }
   },
   /**
    * Bottom-right Position. You can assign a rectangle form.
    * @name Rect.prototype.bottomright
    * @type Array
    */
   'bottomright': {
      get: function() {
         return [this.right, this.bottom];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.right = args.left;
         this.bottom = args.top;
         return;
      }
   },
   /**
    * Position x value, alias for `left`.
    * @name Rect.prototype.y
    * @type Array
    */
   'x': {
      get: function() {
         return this.left;
      },
      set: function(newValue) {
         this.left = newValue;
         return;
      }
   },
   /**
    * Position y value, alias for `top`.
    * @name Rect.prototype.y
    * @type Array
    */
   'y': {
      get: function() {
         return this.top;
      },
      set: function(newValue) {
         this.top = newValue;
         return;
      }
   }
});

/**
 * Move returns a new Rect, which is a version of this Rect
 * moved by the given amounts. Accepts any rectangle form.
 * as argument.
 *
 * @param {Number|gamejs.Rect} x amount to move on x axis
 * @param {Number} y amount to move on y axis
 */
Rect.prototype.move = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   return new Rect(this.left + args.left, this.top + args.top, this.width, this.height);
};

/**
 * Move this Rect in place - not returning a new Rect like `move(x, y)` would.
 *
 * `moveIp(x,y)` or `moveIp([x,y])`
 *
 * @param {Number|gamejs.Rect} x amount to move on x axis
 * @param {Number} y amount to move on y axis
 */
Rect.prototype.moveIp = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   this.left += args.left;
   this.top += args.top;
   return;
};

/**
 * Return the area in which this Rect and argument Rect overlap.
 *
 * @param {gamejs.Rect} Rect to clip this one into
 * @returns {gamejs.Rect} new Rect which is completely inside the argument Rect,
 * zero sized Rect if the two rectangles do not overlap
 */
Rect.prototype.clip = function(rect) {
   if(!this.collideRect(rect)) {
      return new Rect(0,0,0,0);
   }

   var x, y, width, height;

   // Left
   if ((this.left >= rect.left) && (this.left < rect.right)) {
      x = this.left;
   } else if ((rect.left >= this.left) && (rect.left < this.right)) {
      x = rect.left;
   }

   // Right
   if ((this.right > rect.left) && (this.right <= rect.right)) {
      width = this.right - x;
   } else if ((rect.right > this.left) && (rect.right <= this.right)) {
      width = rect.right - x;
   }

   // Top
   if ((this.top >= rect.top) && (this.top < rect.bottom)) {
      y = this.top;
   } else if ((rect.top >= this.top) && (rect.top < this.bottom)) {
      y = rect.top;
   }

   // Bottom
   if ((this.bottom > rect.top) && (this.bottom <= rect.bottom)) {
     height = this.bottom - y;
   } else if ((rect.bottom > this.top) && (rect.bottom <= this.bottom)) {
     height = rect.bottom - y;
   }
   return new Rect(x, y, width, height);
};

/**
 * Join two rectangles
 *
 * @param {gamejs.Rect} union with this rectangle
 * @returns {gamejs.Rect} rectangle containing area of both rectangles
 */
Rect.prototype.union = function(rect) {
   var x, y, width, height;

   x = Math.min(this.left, rect.left);
   y = Math.min(this.top, rect.top);
   width = Math.max(this.right, rect.right) - x;
   height = Math.max(this.bottom, rect.bottom) - y;
   return new Rect(x, y, width, height);
};

/**
 * Grow or shrink the rectangle size
 *
 * @param {Number} amount to change in the width
 * @param {Number} amount to change in the height
 * @returns {gamejs.Rect} inflated rectangle centered on the original rectangle's center
 */
Rect.prototype.inflate = function(x, y) {
    var copy = this.clone();

    copy.inflateIp(x, y);

    return copy;
};

/**
 * Grow or shrink this Rect in place - not returning a new Rect like `inflate(x, y)` would.
 *
 * @param {Number} amount to change in the width
 * @param {Number} amount to change in the height
 */
Rect.prototype.inflateIp = function(x, y) {
    // Use Math.floor here to deal with rounding of negative numbers the
    // way this relies on.
    this.left -= Math.floor(x / 2);
    this.top -= Math.floor(y / 2);
    this.width += x;
    this.height += y;
};

/**
 * Check for collision with a point.
 *
 * `collidePoint(x,y)` or `collidePoint([x,y])` or `collidePoint(new Rect(x,y))`
 *
 * @param {Array|gamejs.Rect} point the x and y coordinates of the point to test for collision
 * @returns {Boolean} true if the point collides with this Rect
 */
Rect.prototype.collidePoint = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   return (this.left <= args.left && args.left <= this.right) &&
       (this.top <= args.top && args.top <= this.bottom);
};

/**
 * Check for collision with a Rect.
 * @param {gamejs.Rect} rect the Rect to test check for collision
 * @returns {Boolean} true if the given Rect collides with this Rect
 */
Rect.prototype.collideRect = function(rect) {
   return !(this.left > rect.right || this.right < rect.left ||
      this.top > rect.bottom || this.bottom < rect.top);
};

/**
 * @param {Array} pointA start point of the line
 * @param {Array} pointB end point of the line
 * @returns true if the line intersects with the rectangle
 * @see http://stackoverflow.com/questions/99353/how-to-test-if-a-line-segment-intersects-an-axis-aligned-rectange-in-2d/293052#293052
 *
 */
Rect.prototype.collideLine = function(p1, p2) {
   var x1 = p1[0];
   var y1 = p1[1];
   var x2 = p2[0];
   var y2 = p2[1];

   function linePosition(point) {
      var x = point[0];
      var y = point[1];
      return (y2 - y1) * x + (x1 - x2) * y + (x2 * y1 - x1 * y2);
   }

   var relPoses = [[this.left, this.top],
                   [this.left, this.bottom],
                   [this.right, this.top],
                   [this.right, this.bottom]
                  ].map(linePosition);

   var noNegative = true;
   var noPositive = true;
   var noZero = true;
   relPoses.forEach(function(relPos) {
      if (relPos > 0) {
         noPositive = false;
      } else if (relPos < 0) {
         noNegative = false;
      } else if (relPos === 0) {
         noZero = false;
      }
   }, this);

   if ( (noNegative || noPositive) && noZero) {
      return false;
   }
   return !((x1 > this.right && x2 > this.right) ||
            (x1 < this.left && x2 < this.left) ||
            (y1 < this.top && y2 < this.top) ||
            (y1 > this.bottom && y2 > this.bottom)
            );
};

/**
 * @returns {String} Like "[x, y][w, h]"
 */
Rect.prototype.toString = function() {
   return ["[", this.left, ",", this.top, "]"," [",this.width, ",", this.height, "]"].join("");
};

/**
 * @returns {gamejs.Rect} A new copy of this rect
 */
Rect.prototype.clone = function() {
   return new Rect(this);
};

/**
 * @ignore
 */
exports.event = require('./gamejs/event');
/**
 * @ignore
 */
exports.font = require('./gamejs/font');
/**
 * @ignore
 */
exports.http = require('./gamejs/http');
/**
 * @ignore
 */
exports.image = require('./gamejs/image');
/**
 * @ignore
 */
exports.audio = require('./gamejs/audio');
/**
 * @ignore
 */
exports.graphics = require('./gamejs/graphics');

/**
 * @ignore
 */
exports.logging = require('./gamejs/logging');

/**
 * @ignore
 */
exports.math = {
   matrix: require('./gamejs/math/matrix'),
   vectors: require('./gamejs/math/vectors'),
   angles: require('./gamejs/math/angles'),
   binaryheap: require('./gamejs/math/binaryheap'),
   random: require('./gamejs/math/random'),
   noise: require('./gamejs/math/noise'),
};

/**
 * @ignore
 */
exports.utils = {
   arrays: require('./gamejs/utils/arrays'),
   objects: require('./gamejs/utils/objects'),
   uri: require('./gamejs/utils/uri'),
   strings: require('./gamejs/utils/strings'),
   xml: require('./gamejs/utils/xml'),
   base64: require('./gamejs/utils/base64')
};
/**
 * @ignore
 */
exports.display = require('./gamejs/display');
/**
 * @ignore
 */
exports.pathfinding = require('./gamejs/pathfinding');


/**
 * @ignore
 */
exports.tiledmap = require('./gamejs/tiledmap');


/**
 * @ignore
 */
exports.time = require('./gamejs/time');

/**
 * @ignore
 */
exports.pixelcollision = require('./gamejs/pixelcollision');
},{"./gamejs/audio":42,"./gamejs/display":43,"./gamejs/event":44,"./gamejs/font":45,"./gamejs/graphics":46,"./gamejs/http":47,"./gamejs/image":48,"./gamejs/logging":49,"./gamejs/math/angles":50,"./gamejs/math/binaryheap":51,"./gamejs/math/matrix":52,"./gamejs/math/noise":53,"./gamejs/math/random":54,"./gamejs/math/vectors":55,"./gamejs/pathfinding":56,"./gamejs/pixelcollision":57,"./gamejs/thread":58,"./gamejs/tiledmap":59,"./gamejs/time":60,"./gamejs/utils/arrays":61,"./gamejs/utils/base64":62,"./gamejs/utils/callback":63,"./gamejs/utils/objects":64,"./gamejs/utils/strings":65,"./gamejs/utils/uri":66,"./gamejs/utils/xml":67}],"s2clientprotocol":[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.s2clientprotocol = {}));
}(this, (function (exports) { 'use strict';

    // var path = require('path');
    // var common_pb = require(path.resolve(__dirname, './common_pb.js'));
    // var data_pb = require(path.resolve(__dirname, './data_pb.js'));
    // var debug_pb = require(path.resolve(__dirname, './debug_pb.js'));
    // var error_pb = require(path.resolve(__dirname, './error_pb.js'));
    // var query_pb = require(path.resolve(__dirname, './query_pb.js'));
    // var raw_pb = require(path.resolve(__dirname,'./raw_pb.js'));
    // var sc2api_pb = require(path.resolve(__dirname,'./sc2api_pb.js'));
    // var score_pb = require(path.resolve(__dirname,'./score_pb.js'));
    // var spatial_pb = require(path.resolve(__dirname,'./spatial_pb.js'));
    // var ui_pb = require(path.resolve(__dirname,'./ui_pb.js'));
    var common_pb = require('./common_pb.js');
    var data_pb = require('./data_pb.js');
    var debug_pb = require('./debug_pb.js');
    var error_pb = require('./error_pb.js');
    var query_pb = require('./query_pb.js');
    var raw_pb = require('./raw_pb.js');
    var sc2api_pb = require('./sc2api_pb.js');
    var score_pb = require('./score_pb.js');
    var spatial_pb = require('./spatial_pb.js');
    var ui_pb = require('./ui_pb.js');
    var sc2clientprotocol = {
        common_pb,
        data_pb,
        debug_pb,
        error_pb,
        query_pb,
        raw_pb,
        sc2api_pb,
        score_pb,
        spatial_pb,
        ui_pb,
    };

    module.exports = sc2clientprotocol;

    exports.default = sc2clientprotocol;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"./common_pb.js":104,"./data_pb.js":105,"./debug_pb.js":106,"./error_pb.js":107,"./query_pb.js":108,"./raw_pb.js":109,"./sc2api_pb.js":110,"./score_pb.js":111,"./spatial_pb.js":112,"./ui_pb.js":113}]},{},[]);
